{"version":3,"file":"firefox-draw.bundle.js","mappings":";;;;;;;;;;AAAa,uBAAuB,MAAM,mEAAmE,sCAAsC,mJAAmJ,YAAY,0HAA0H,aAAa,0HAA0H,eAAe,gBAAgB,cAAc,iBAAiB,kBAAkB,sJAAsJ,aAAa,8BAA8B,iBAAiB,yIAAyI,eAAe,aAAa,mBAAmB,yBAAyB,iBAAiB,gBAAgB,gJAAgJ,YAAY,eAAe,cAAc,yBAAyB,uCAAuC,aAAa,sBAAsB,eAAe,uBAAuB,8EAA8E,oCAAoC,2EAA2E,mBAAmB,sDAAsD,eAAe,UAAU,WAAW,yBAAyB,0BAA0B,YAAY,yEAAyE,aAAa,wBAAwB,cAAc,mBAAmB,cAAc,2EAA2E,YAAY,iBAAiB,sBAAsB,iFAAiF,SAAS,wBAAwB,uBAAuB,uFAAuF,cAAc,qFAAqF,cAAc,yBAAyB,aAAa,mBAAmB,mBAAmB,sCAAsC,YAAY,gCAAgC,eAAe,gCAAgC,WAAW,wDAAwD,WAAW,eAAe,sCAAsC,0BAA0B,mFAAmF,aAAa,kHAAkH,aAAa,kCAAkC,aAAa,mBAAmB,wCAAwC,YAAY,8BAA8B,eAAe,mCAAmC,YAAY,aAAa,QAAQ,OAAO,kBAAkB,cAAc,eAAe,kCAAkC,UAAU,uBAAuB,oBAAoB,mBAAmB,sCAAsC,wBAAwB,8CAA8C,oBAAoB,kDAAkD,WAAW,YAAY,UAAU,oBAAoB,4CAA4C,aAAa,wBAAwB,0CAA0C,WAAW,6DAA6D,aAAa,cAAc,kBAAkB,iBAAiB,2CAA2C,mBAAmB,YAAY,UAAU,4BAA4B,uCAAuC,6DAA6D,iBAAiB,6CAA6C,mDAAmD,gDAAgD,oEAAoE,cAAc,WAAW,yBAAyB,yCAAyC,oFAAoF,yCAAyC,iBAAiB,gBAAgB,mBAAmB,gDAAgD,aAAa,yDAAyD,WAAW,iEAAiE,UAAU,QAAQ,uBAAuB,YAAY,SAAS,gBAAgB,UAAU,SAAS,sDAAsD,cAAc,YAAY,qBAAqB,mBAAmB,gDAAgD,kFAAkF,qEAAqE,iBAAiB,kBAAkB,uFAAuF,2CAA2C,gCAAgC,6CAA6C,aAAa,gBAAgB,aAAa,sBAAsB,mBAAmB,kBAAkB,uDAAuD,kCAAkC,4FAA4F,qBAAqB,8FAA8F,0BAA0B,eAAe,6FAA6F,qBAAqB,sBAAsB,kBAAkB,cAAc,2LAA2L,iDAAiD,mGAAmG,iBAAiB,uBAAuB,kBAAkB,2BAA2B,aAAa,mBAAmB,gBAAgB,eAAe,oBAAoB,sCAAsC,aAAa,8BAA8B,sBAAsB,eAAe,cAAc,WAAW,oDAAoD,4CAA4C,4CAA4C,UAAU,SAAS,4CAA4C,aAAa,sBAAsB,sBAAsB,yBAAyB,0BAA0B,gBAAgB,mBAAmB,uBAAuB,YAAY,iBAAiB,yBAAyB,4CAA4C,YAAY,cAAc,WAAW,8CAA8C,mDAAmD,wCAAwC,gDAAgD,2FAA2F,uBAAuB,kBAAkB,aAAa,mBAAmB,qGAAqG,aAAa,sBAAsB,gBAAgB,6BAA6B,YAAY,WAAW,YAAY,2GAA2G,YAAY,WAAW,cAAc,aAAa,uBAAuB,mBAAmB,wBAAwB,wBAAwB,sBAAsB,kGAAkG,aAAa,yGAAyG,gBAAgB,aAAa,sBAAsB,mBAAmB,gBAAgB,aAAa,sHAAsH,kBAAkB,iHAAiH,YAAY,WAAW,eAAe,OAAO,yBAAyB,0HAA0H,2CAA2C,kBAAkB,YAAY,yHAAyH,kBAAkB,SAAS,WAAW,cAAc,2CAA2C,wCAAwC,yCAAyC,eAAe,sBAAsB,WAAW,aAAa,mBAAmB,uBAAuB,iBAAiB,UAAU,+CAA+C,iCAAiC,eAAe,uLAAuL,gBAAgB,oCAAoC,gDAAgD,eAAe,WAAW,yBAAyB,kBAAkB,YAAY,aAAa,wCAAwC,eAAe,kBAAkB,kBAAkB,YAAY,2CAA2C,iBAAiB,yBAAyB,4EAA4E,iGAAiG,aAAa,sBAAsB,mBAAmB,uBAAuB,iBAAiB,kBAAkB,eAAe,gBAAgB,kBAAkB,cAAc,sBAAsB,eAAe,iBAAiB,yBAAyB,sEAAsE,gBAAgB,yGAAyG,UAAU,+EAA+E,2CAA2C,8BAA8B,eAAe,WAAW,4BAA4B,cAAc,iBAAiB,WAAW,eAAe,gBAAgB,gDAAgD,mDAAmD,wCAAwC,gDAAgD,2GAA2G,aAAa,qEAAqE,YAAY,+BAA+B,qFAAqF,yBAAyB,qHAAqH,aAAa,kBAAkB,kBAAkB,aAAa,gBAAgB,aAAa,eAAe,sBAAsB,gBAAgB,sBAAsB,UAAU,2CAA2C,2CAA2C,kCAAkC,GAAG,UAAU,sBAAsB,KAAK,UAAU,uBAAuB,mCAAmC,GAAG,UAAU,sBAAsB,KAAK,UAAU,uBAAuB,kBAAkB,0BAA0B,kDAAkD,mDAAmD,uCAAuC,kBAAkB,gCAAgC,gCAAgC,yBAAyB,aAAa,qEAAqE,gBAAgB,2CAA2C,iBAAiB,qBAAqB,aAAa,mBAAmB,uBAAuB,yCAAyC,gCAAgC,mBAAmB,4DAA4D,6CAA6C,wCAAwC,+CAA+C,WAAW,YAAY,aAAa,2CAA2C,sBAAsB,iCAAiC,aAAa,eAAe,MAAM,OAAO,SAAS,QAAQ,kBAAkB,2CAA2C,WAAW,UAAU,sBAAsB,mBAAmB,gBAAgB,sBAAsB,kBAAkB,aAAa,iBAAiB,cAAc,wBAAwB,GAAG,WAAW,IAAI,WAAW,KAAK,YAAY,8BAA8B,GAAG,UAAU,IAAI,UAAU,KAAK,YAAY,0BAA0B,GAAG,UAAU,GAAG,UAAU,KAAK,YAAY,6BAA6B,GAAG,UAAU,KAAK,WAAW,2CAA2C,KAAK,6BAA6B,GAAG,2BAA2B,yDAAyD,KAAK,UAAU,GAAG,WAAW,4CAA4C,GAAG,8BAA8B,0DAA0D,KAAK,UAAU,GAAG,WAAW,qDAAqD,KAAK,kBAAkB,GAAG,mBAAmB,sDAAsD,KAAK,kBAAkB,GAAG,mBAAmB,sBAAsB,yCAAyC,oDAAoD,qEAAqE,sBAAsB,mBAAmB,6BAA6B,8DAA8D,iCAAiC,qCAAqC,sBAAsB,iBAAiB,0CAA0C,eAAe,YAAY,eAAe,qCAAqC,oEAAoE,eAAe,oFAAoF,iCAAiC,0FAA0F,UAAU,oCAAoC,0BAA0B,KAAK,UAAU,GAAG,WAAW,2UAA2U,WAAW,qCAAqC,kHAAkH,WAAW,gNAAgN,iCAAiC,UAAU,8GAA8G,iCAAiC,UAAU,0FAA0F,UAAU,kBAAkB,8CAA8C,+CAA+C,UAAU,oBAAoB,2CAA2C,gCAAgC,mBAAmB,aAAa,iDAAiD,yEAAyE,0FAA0F,iBAAiB,qCAAqC,+GAA+G,cAAc,gBAAgB,0CAA0C,mBAAmB,aAAa,YAAY,uBAAuB,2CAA2C,gCAAgC,wCAAwC,gCAAgC,6DAA6D,UAAU,WAAW,mEAAmE,qCAAqC,2DAA2D,gBAAgB,kBAAkB,cAAc,6DAA6D,UAAU,2CAA2C,gCAAgC,wCAAwC,qDAAqD,sBAAsB,kBAAkB,iCAAiC,0EAA0E,mEAAmE,8DAA8D,sEAAsE,mDAAmD,wCAAwC,gDAAgD,sCAAsC,sBAAsB,+BAA+B,oEAAoE,gBAAgB,YAAY,6CAA6C,QAAQ,0DAA0D,YAAY,aAAa,6BAA6B,qEAAqE,oBAAoB,qCAAqC,UAAU,mGAAmG,gBAAgB,eAAe,sEAAsE,SAAS,0EAA0E,WAAW,4CAA4C,wFAAwF,YAAY,iBAAiB,cAAc,WAAW,8FAA8F,yEAAyE,kCAAkC,+VAA+V,WAAW,qCAAqC,4HAA4H,WAAW,oOAAoO,iCAAiC,UAAU,wHAAwH,iCAAiC,UAAU,oGAAoG,UAAU,kBAAkB,8CAA8C,+CAA+C,UAAU,oBAAoB,2CAA2C,gCAAgC,mBAAmB,aAAa,gDAAgD,uCAAuC,oGAAoG,iBAAiB,oHAAoH,WAAW,6EAA6E,qIAAqI,cAAc,kBAAkB,6DAA6D,SAAS,gBAAgB,YAAY,gBAAgB,0EAA0E,iBAAiB,kBAAkB,gBAAgB,mBAAmB,uFAAuF,SAAS,+BAA+B,WAAW,yGAAyG,kBAAkB,4BAA4B,qDAAqD,6FAA6F,kBAAkB,qCAAqC,uCAAuC,sBAAsB,aAAa,8BAA8B,mBAAmB,UAAU,uCAAuC,4BAA4B,sEAAsE,gDAAgD,kBAAkB,mCAAmC,gBAAgB,gBAAgB,YAAY,aAAa,+BAA+B,iBAAiB,6CAA6C,wDAAwD,yCAAyC,4CAA4C,WAAW,kBAAkB,aAAa,gCAAgC,kEAAkE,kDAAkD,6UAA6U,WAAW,qCAAqC,mHAAmH,WAAW,kNAAkN,iCAAiC,UAAU,+GAA+G,iCAAiC,UAAU,2FAA2F,UAAU,kBAAkB,8CAA8C,+CAA+C,UAAU,oBAAoB,2CAA2C,gCAAgC,mBAAmB,aAAa,gDAAgD,uCAAuC,2FAA2F,iBAAiB,yDAAyD,0BAA0B,8CAA8C,8BAA8B,kBAAkB,iBAAiB,yBAAyB,2CAA2C,gCAAgC,wCAAwC,2CAA2C,kBAAkB,mBAAmB,uBAAuB,sBAAsB,4BAA4B,6BAA6B,sDAAsD,2GAA2G,iBAAiB,yBAAyB,qEAAqE,qBAAqB,qDAAqD,+BAA+B,+DAA+D,YAAY,cAAc,iBAAiB,kBAAkB,iBAAiB,mBAAmB,WAAW,YAAY,gBAAgB,yBAAyB,uEAAuE,WAAW,mCAAmC,WAAW,cAAc,kBAAkB,SAAS,WAAW,kBAAkB,oBAAoB,iBAAiB,kBAAkB,qEAAqE,cAAc,qFAAqF,mBAAmB,gBAAgB,WAAW,sBAAsB,2BAA2B,gBAAgB,YAAY,mGAAmG,WAAW,YAAY,aAAa,kBAAkB,iMAAiM,cAAc,oFAAoF,kBAAkB,mBAAmB,kEAAkE,sBAAsB,0BAA0B,sEAAsE,aAAa,mBAAmB,eAAe,gBAAgB,kFAAkF,aAAa,4EAA4E,mBAAmB,kCAAkC,cAAc,sBAAsB,2FAA2F,WAAW,YAAY,cAAc,iGAAiG,YAAY,eAAe,cAAc,2EAA2E,2CAA2C,gCAAgC,wCAAwC,sEAAsE,2CAA2C,gCAAgC,wDAAwD,mBAAmB,eAAe,4CAA4C,WAAW,YAAY,QAAQ,OAAO,kBAAkB,qDAAqD,oBAAoB,uEAAuE,qBAAqB,sBAAsB,WAAW,YAAY,eAAe,gBAAgB,YAAY,SAAS,UAAU,UAAU,kBAAkB,gBAAgB,WAAW,oBAAoB,+BAA+B,aAAa,sBAAsB,8BAA8B,gCAAgC,gCAAgC,0BAA0B,kCAAkC,sDAAsD,kCAAkC,yBAAyB,GAAG,UAAU,KAAK,WAAW,0BAA0B,GAAG,UAAU,KAAK,WAAW,sEAAsE,mCAAmC,UAAU,gCAAgC,gBAAgB,uCAAuC,sBAAsB,iBAAiB,qCAAqC,0CAA0C,QAAQ,iBAAiB,uHAAuH,sCAAsC,mDAAmD,4CAA4C,eAAe,6BAA6B,yBAAyB,YAAY,qCAAqC,mBAAmB,oCAAoC,sBAAsB,WAAW,YAAY,UAAU,wCAAwC,WAAW,0CAA0C,YAAY,aAAa,2CAA2C,aAAa,mBAAmB,YAAY,kBAAkB,kDAAkD,YAAY,kBAAkB,iBAAiB,iBAAiB,kBAAkB,eAAe,UAAU,+BAA+B,qEAAqE,aAAa,mBAAmB,qEAAqE,gBAAgB,mBAAmB,qEAAqE,gBAAgB,mBAAmB,uCAAuC,kDAAkD,iBAAiB,qEAAqE,kBAAkB,UAAU,iBAAiB,yBAAyB,mBAAmB,YAAY,uCAAuC,gBAAgB,sDAAsD,uEAAuE,+BAA+B,uEAAuE,SAAS,uBAAuB,uCAAuC,wFAAwF,wBAAwB,iKAAiK,UAAU,kBAAkB,gFAAgF,eAAe,UAAU,wGAAwG,sBAAsB,qLAAqL,2CAA2C,6EAA6E,UAAU,2CAA2C,wCAAwC,+EAA+E,qBAAqB,0CAA0C,aAAa,mBAAmB,8BAA8B,cAAc,0DAA0D,WAAW,oGAAoG,cAAc,aAAa,8BAA8B,UAAU,uCAAuC,oGAAoG,iBAAiB,mFAAmF,wCAAwC,4BAA4B,GAAG,mBAAmB,IAAI,qBAAqB,IAAI,kCAAkC,IAAI,mCAAmC,KAAK,oBAAoB,uCAAuC,mFAAmF,gBAAgB,uDAAuD,iBAAiB,gBAAgB,4DAA4D,iBAAiB,iBAAiB,0DAA0D,gBAAgB,kEAAkE,gBAAgB,wIAAwI,iBAAiB,sCAAsC,gBAAgB,uCAAuC,eAAe,eAAe,8CAA8C,SAAS,kBAAkB,aAAa,oBAAoB,sDAAsD,SAAS,YAAY,cAAc,iBAAiB,gBAAgB,kBAAkB,WAAW,4DAA4D,aAAa,cAAc,2BAA2B,4IAA4I,oDAAoD,uBAAuB,QAAQ,SAAS,iBAAiB,WAAW,oBAAoB,0CAA0C,sBAAsB,uCAAuC,uBAAuB,uCAAuC,oBAAoB,KAAK,WAAW,GAAG,WAAW,0CAA0C,oCAAoC,UAAU,wFAAwF,4BAA4B,6BAA6B,gCAAgC,iCAAiC,2CAA2C,oCAAoC,kBAAkB,kIAAkI,oCAAoC,UAAU,gEAAgE,iFAAiF,iEAAiE,iFAAiF,wCAAwC,eAAe,sCAAsC,mBAAmB,iCAAiC,WAAW,sBAAsB,qCAAqC,mDAAmD,WAAW,iBAAiB,uBAAuB,kBAAkB,sBAAsB,aAAa,mBAAmB,uBAAuB,iBAAiB,+CAA+C,2CAA2C,qCAAqC,sBAAsB,0BAA0B,2BAA2B,WAAW,YAAY,aAAa,uBAAuB,mBAAmB,YAAY,qDAAqD,WAAW,YAAY,qEAAqE,mBAAmB,6CAA6C,iBAAiB,YAAY,+CAA+C,iBAAiB,+CAA+C,iBAAiB,gDAAgD,mBAAmB,0FAA0F,iBAAiB,0FAA0F,iBAAiB,2FAA2F,mBAAmB,sCAAsC,kCAAkC,2CAA2C,WAAW,YAAY,YAAY,eAAe,iBAAiB,yBAAyB,gCAAgC,4CAA4C,kBAAkB,WAAW,4BAA4B,gGAAgG,2CAA2C,gCAAgC,eAAe,UAAU,4CAA4C,WAAW,YAAY,uBAAuB,kBAAkB,cAAc,wFAAwF,SAAS,iBAAiB,iEAAiE,6CAA6C,+CAA+C,gBAAgB,oBAAoB,mEAAmE,mBAAmB,wEAAwE,UAAU,sGAAsG,aAAa,0CAA0C,GAAG,UAAU,IAAI,gBAAgB,KAAK,WAAW,uCAAuC,4CAA4C,mBAAmB,SAAS,kBAAkB,yBAAyB,UAAU,WAAW,gBAAgB,iBAAiB,yBAAyB,gCAAgC,eAAe,qFAAqF,iBAAiB,UAAU,8EAA8E,WAAW,qCAAqC,KAAK,UAAU,GAAG,WAAW,mBAAmB,WAAW,YAAY,+BAA+B,YAAY,4EAA4E,UAAU,2DAA2D,gBAAgB,yBAAyB,UAAU,4BAA4B,kBAAkB,qBAAqB,oBAAoB,aAAa,sBAAsB,cAAc,kBAAkB,2CAA2C,2CAA2C,6BAA6B,yBAAyB,0BAA0B,aAAa,sBAAsB,eAAe,YAAY,gBAAgB,mBAAmB,+BAA+B,gCAAgC,2BAA2B,YAAY,cAAc,wEAAwE,2CAA2C,gCAAgC,uCAAuC,UAAU,WAAW,cAAc,wBAAwB,wBAAwB,8BAA8B,qBAAqB,sBAAsB,8CAA8C,eAAe,+EAA+E,gBAAgB,gBAAgB,iBAAiB,mFAAmF,gCAAgC,0BAA0B,mBAAmB,KAAK,UAAU,GAAG,WAAW,iCAAiC,aAAa,0CAA0C,UAAU,oDAAoD,UAAU,4EAA4E,4BAA4B,2BAA2B,wBAAwB,aAAa,sBAAsB,YAAY,+BAA+B,cAAc,iBAAiB,kBAAkB,gCAAgC,YAAY,cAAc,gBAAgB,iBAAiB,kBAAkB,oBAAoB,yBAAyB,2CAA2C,gCAAgC,YAAY,aAAa,uCAAuC,kBAAkB,gBAAgB,sBAAsB,sBAAsB,mCAAmC,0BAA0B,kCAAkC,qDAAqD,YAAY,wBAAwB,iDAAiD,kBAAkB,uBAAuB,gBAAgB,mBAAmB,2DAA2D,6BAA6B,8BAA8B,+DAA+D,6BAA6B,8BAA8B,wEAAwE,8BAA8B,2DAA2D,8BAA8B,sBAAsB,4BAA4B,4BAA4B,8BAA8B,8BAA8B,8BAA8B,8BAA8B,sCAAsC,sCAAsC,yDAAyD,mCAAmC,wCAAwC,mCAAmC,sBAAsB,8BAA8B,4BAA4B,2BAA2B,8BAA8B,8BAA8B,2BAA2B,mCAAmC,oCAAoC,yCAAyC,sDAAsD,yCAAyC,sBAAsB,wCAAwC,sBAAsB,gCAAgC,+CAA+C,2CAA2C,WAAW,aAAa,iBAAiB,gBAAgB,2BAA2B,sBAAsB,aAAa,8BAA8B,4BAA4B,oDAAoD,6CAA6C,aAAa,0BAA0B,YAAY,cAAc,iBAAiB,YAAY,WAAW,YAAY,oDAAoD,aAAa,gBAAgB,kBAAkB,sBAAsB,WAAW,YAAY,YAAY,kBAAkB,eAAe,mBAAmB,iBAAiB,yBAAyB,uBAAuB,sCAAsC,eAAe,kBAAkB,cAAc,kDAAkD,SAAS,OAAO,QAAQ,iDAAiD,UAAU,QAAQ,SAAS,gBAAgB,oBAAoB,iBAAiB,yBAAyB,mDAAmD,aAAa,cAAc,gBAAgB,yBAAyB,iBAAiB,gEAAgE,iBAAiB,UAAU,gDAAgD,iBAAiB,SAAS,iEAAiE,6CAA6C,+CAA+C,gBAAgB,kBAAkB,oBAAoB,0EAA0E,kBAAkB,uBAAuB,sBAAsB,sDAAsD,0BAA0B,SAAS,mBAAmB,aAAa,sCAAsC,aAAa,oDAAoD,WAAW,gBAAgB,gCAAgC,IAAI,MAAM,mEAAmE,sCAAsC,2BAA2B,aAAa,eAAe,kBAAkB,YAAY,aAAa,mBAAmB,sBAAsB,yBAAyB,cAAc,qEAAqE,sBAAsB,yBAAyB,iBAAiB,mDAAmD,aAAa,8BAA8B,kBAAkB,cAAc,kBAAkB,WAAW,aAAa,mBAAmB,0BAA0B,oGAAoG,eAAe,YAAY,kBAAkB,WAAW,YAAY,qBAAqB,sBAAsB,kBAAkB,8BAA8B,eAAe,6DAA6D,WAAW,YAAY,oDAAoD,WAAW,YAAY,wBAAwB,gDAAgD,WAAW,YAAY,SAAS,gDAAgD,WAAW,YAAY,SAAS,SAAS,6HAA6H,oBAAoB,kBAAkB,wBAAwB,WAAW,gBAAgB,kBAAkB,gBAAgB,cAAc,YAAY,WAAW,sBAAsB,wEAAwE,gCAAgC,kBAAkB,wBAAwB,YAAY,WAAW,SAAS,SAAS,6BAA6B,UAAU,eAAe,gBAAgB,wBAAwB,4BAA4B,kBAAkB,WAAW,YAAY,OAAO,QAAQ,iBAAiB,2BAA2B,sBAAsB,kBAAkB,8BAA8B,wBAAwB,oBAAoB,sBAAsB,WAAW,kBAAkB,YAAY,WAAW,OAAO,MAAM,kBAAkB,8BAA8B,YAAY,aAAa,QAAQ,wBAAwB,mBAAmB,eAAe,aAAa,kBAAkB,WAAW,SAAS,UAAU,sBAAsB,mBAAmB,sBAAsB,WAAW,eAAe,2CAA2C,kBAAkB,WAAW,YAAY,SAAS,UAAU,SAAS,OAAO,MAAM,UAAU,oBAAoB,qBAAqB,YAAY,SAAS,cAAc,kBAAkB,mBAAmB,oBAAoB,kBAAkB,eAAe,mCAAmC,4BAA4B,kCAAkC,4BAA4B,mCAAmC,WAAW,sBAAsB,cAAc,QAAQ,wBAAwB,cAAc,kBAAkB,aAAa,eAAe,oBAAoB,uBAAuB,qBAAqB,kBAAkB,WAAW,YAAY,qBAAqB,UAAU,SAAS,kBAAkB,cAAc,oBAAoB,mBAAmB,gBAAgB,eAAe,2BAA2B,WAAW,cAAc,kBAAkB,WAAW,YAAY,OAAO,MAAM,sBAAsB,8BAA8B,8CAA8C,gBAAgB,QAAQ,wBAAwB,YAAY,2BAA2B,eAAe,sBAAsB,mBAAmB,WAAW,sBAAsB,uBAAuB,eAAe,kBAAkB,gBAAgB,sBAAsB,aAAa,yBAAyB,sBAAsB,aAAa,QAAQ,YAAY,mBAAmB,eAAe,SAAS,mBAAmB,WAAW,sBAAsB,oBAAoB,eAAe,gBAAgB,eAAe,WAAW,cAAc,wBAAwB,aAAa,kBAAkB,WAAW,YAAY,wBAAwB,kBAAkB,gBAAgB,uCAAuC,WAAW,kBAAkB,YAAY,WAAW,OAAO,MAAM,sBAAsB,kBAAkB,mBAAmB,SAAS,8BAA8B,8CAA8C,oBAAoB,kBAAkB,WAAW,YAAY,UAAU,SAAS,UAAU,SAAS,kBAAkB,oBAAoB,6BAA6B,oBAAoB,eAAe,gBAAgB,mDAAmD,sBAAsB,WAAW,qBAAqB,kBAAkB,kBAAkB,iBAAiB,SAAS,cAAc,yBAAyB,iBAAiB,kBAAkB,kBAAkB,WAAW,YAAY,QAAQ,QAAQ,2BAA2B,SAAS,UAAU,SAAS,cAAc,oBAAoB,mBAAmB,gBAAgB,oBAAoB,0BAA0B,WAAW,OAAO,wBAAwB,WAAW,cAAc,kBAAkB,WAAW,YAAY,OAAO,MAAM,sBAAsB,8BAA8B,4CAA4C,qFAAqF,6LAA6L,gCAAgC,wBAAwB,kBAAkB,aAAa,+KAA+K,aAAa,8CAA8C,yCAAyC,aAAa,+BAA+B,iBAAiB,qNAAqN,aAAa,UAAU,sBAAsB,yBAAyB,kBAAkB,qCAAqC,oDAAoD,0BAA0B,WAAW,kBAAkB,sBAAsB,gCAAgC,qBAAqB,6BAA6B,oDAAoD,2GAA2G,6LAA6L,yBAAyB,kBAAkB,oEAAoE,gCAAgC,WAAW,cAAc,kBAAkB,WAAW,YAAY,UAAU,UAAU,yBAAyB,4BAA4B,iCAAiC,sBAAsB,WAAW,kDAAkD,oBAAoB,yCAAyC,WAAW,yCAAyC,UAAU,WAAW,wCAAwC,SAAS,aAAa,0BAA0B,4BAA4B,wBAAwB,aAAa,YAAY,kBAAkB,gDAAgD,wBAAwB,YAAY,gBAAgB,kBAAkB,wDAAwD,sCAAsC,0BAA0B,wBAAwB,mBAAmB,4BAA4B,wBAAwB,aAAa,gCAAgC,oBAAoB,mCAAmC,WAAW,YAAY,8BAA8B,wBAAwB,2BAA2B,yBAAyB,wBAAwB,yBAAyB,wBAAwB,2BAA2B,wBAAwB,sBAAsB,YAAY,yBAAyB,aAAa,gCAAgC,WAAW,YAAY,qBAAqB,YAAY,mBAAmB,sBAAsB,wBAAwB,kBAAkB,YAAY,YAAY,OAAO,MAAM,gBAAgB,0BAA0B,mBAAmB,gBAAgB,gCAAgC,KAAK;;;;;;;;;;;;;;;;;ACAvnnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,yCAAyC,cAAc;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC5CO;AACP;AACA;AACA;AACA;AACA;AACA,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;;;;;;;;;;;;;;;;ACvDgC;AACzB;AACP;AACA;AACA;AACA,UAAU,iCAAiC;AAC3C;AACA;AACA,sCAAsC,0CAAK;AAC3C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,6BAA6B,iCAAiC;AAC9D,IAAI;;;;;;;;;;;;;;;ACjBG;AACP;AACA;AACA;AACA,UAAU,iCAAiC;AAC3C;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;ACTO,sBAAsB,WAAW;AACxC;AACA;AACA;AACA;AACA,cAAc,+BAA+B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;ACzBO,wBAAwB,WAAW;AAC1C;AACA;AACA;AACA;AACA,cAAc,iCAAiC;AAC/C;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;ACdO,6BAA6B,WAAW;AAC/C;AACA;AACA;AACA;AACA,cAAc,6CAA6C;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;;ACrBuC;AACE;AACA;AACY;AACd;AACI;AACY;AACvD;AACO;AACP;AACA,qDAAqD,gDAAW;AAChE;AACA;AACA,IAAI,uDAAQ;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,+BAA+B,sDAAW;AAC1C,+BAA+B,sDAAW;AAC1C,YAAY,gCAAgC,EAAE,kEAAiB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,YAAY,kBAAkB,EAAE,oDAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,YAAY,sBAAsB,EAAE,wDAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yDAAU;AAClB,KAAK;AACL;;;;;;;;;;;;;;;;;;ACjEmC;AACS;AAC5C,gBAAgB;AACT;AACP;AACA;AACA;AACA;AACA;AACA,sBAAsB,gDAAK,aAAa,+CAAI;AAC5C,6BAA6B,6CAAQ;AACrC;AACA;AACA,gBAAgB;AAChB;AACA;AACO;AACP;AACA;AACA;AACA,0BAA0B,gDAAK,aAAa,+CAAI,oBAAoB,gDAAK;AACzE,4BAA4B,6CAAQ;AACpC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;AC5BgC;AAChC;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA,0BAA0B,OAAO;AACjC;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa,KAAK,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,UAAU;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA,+CAA+C,UAAU;AACzD;AACA;AACA;AACA,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,mBAAmB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,KAAK,oCAAoC,sBAAsB;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS,UAAU,MAAM,OAAO,aAAa,MAAM,OAAO,aAAa,MAAM,OAAO,KAAK;AACvG;AACA;AACA;AACA,eAAe,iDAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iDAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,YAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,IAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,IAAI,EAAE,MAAM,EAAE,KAAK;AAC1C;AACA,6BAA6B,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,MAAM,EAAC;;;;;;;;;;;;;;;;;;AC1Zc;AACJ;AAChC;AACA;AACA;AACA;AACA;AACA,mCAAmC,YAAY,4BAA4B,WAAW,OAAO,WAAW;AACxG;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA,8DAA8D,YAAY;AAC1E,IAAI,0BAA0B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,qBAAqB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,YAAY,sBAAsB,GAAG,sBAAsB,GAAG,wBAAwB,OAAO,0BAA0B;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iDAAI,iBAAiB,iDAAI,iBAAiB,iDAAI;AACnE;AACA;AACA;AACA;AACA,cAAc;AACd,gBAAgB,MAAM,UAAU,MAAM,UAAU,KAAK;AACrD,gBAAgB,MAAM,UAAU,MAAM,UAAU,KAAK;AACrD,gBAAgB,MAAM,UAAU,MAAM,UAAU,KAAK;AACrD,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iDAAI,QAAQ,iDAAI,QAAQ,iDAAI;AACtD;AACA;AACA,6BAA6B,YAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qBAAqB,KAAK,oBAAoB;AAC/D;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAI;AAC/B;AACA;AACA,eAAe,2CAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iDAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC,iEAAiE,UAAU;AAC3E;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA,yCAAyC,sBAAsB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iDAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,kBAAkB,aAAa;AAC/B,kBAAkB,aAAa;AAC/B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA,mCAAmC;AACnC,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2CAAI;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,2CAAI;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,yBAAyB,QAAQ,GAAG,QAAQ,GAAG,QAAQ,GAAG,QAAQ,GAAG,QAAQ,GAAG,QAAQ;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG;AACpG;AACA;AACA,qBAAqB,EAAE;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gEAAgE,WAAW;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,UAAU;AAC1G;AACA,uCAAuC,2CAAI;AAC3C,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG,cAAc;AACtH;AACA,yCAAyC,2CAAI;AAC7C,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,OAAO;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK,EAAC;;;;;;;;;;;;;;;;;;AC9gBrB;AACA;AACA;AAC0C;AACpB;AACtB,iEAAe,2CAAI,EAAC;;;;;;;;;;;;;;;;;ACLpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,KAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO,IAAI,OAAO,IAAI,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,KAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO,IAAI,OAAO;AACxC;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,8BAA8B,cAAc;AAC5C,8BAA8B,iBAAiB;AAC/C;AACA;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oBAAoB;AACrB,gDAAgD,WAAW;AACpD;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oBAAoB;AACrB,iEAAe,IAAI,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9SpB;AACA;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2D;AACkF;AAChG;AAC8B;AACV;AACA;AAC3B;AACF;AACA;AACI;AACH;AACrC,gDAAgD,iBAAiB;AACjE;;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,cAAc,EAAC;;;;;;;;;;;;;;;;ACpC9B;AACO;AACP;AACA;AACA;AACA;AACA,kCAAkC,GAAG;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,aAAa,EAAC;;;;;;;;;;;;;;;AC9BtB;;;;;;;;;;;;;;;;;ACAyC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,wBAAwB,uDAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,kBAAkB,EAAC;;;;;;;;;;;;;;;;ACzBwB;;;;;;;;;;;;;;;;;ACAR;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACO;AACP;AACA;AACA,4CAA4C,GAAG,GAAG,GAAG,GAAG,IAAI;AAC5D,kDAAkD,GAAG,EAAE,GAAG,IAAI,IAAI;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+CAA+C,GAAG,eAAe;AACnF;AACA;AACA,WAAW,8DAAa;AACxB;AACA,iEAAe,eAAe,EAAC;;;;;;;;;;;;;;;;;;;;AC9CmB;AACF;AACY;AACN;AACtD;AACO;AACP;AACA,sBAAsB,uDAAW;AACjC;AACA;AACA;AACA;AACA;AACA,iCAAiC,mEAAkB;AACnD;AACA;AACA,eAAe,gEAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8DAAa,IAAI,aAAa,EAAE,WAAW,GAAG,YAAY;AACrE;AACA,iEAAe,uBAAuB,EAAC;;;;;;;;;;;;;;;;AClDvC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,0BAA0B;AAC3F;AACA,8BAA8B,2BAA2B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,eAAe,EAAC;;;;;;;;;;;;;;;;;;;;;ACvC/B,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACmC;AACE;AACW;AACd;AAC8B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B,iEAAoB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,6CAAM;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2CAAI;AACnB;AACA;AACA;AACA,eAAe,2CAAI;AACnB;AACA;AACA,eAAe,2CAAI;AACnB;AACA;AACA;AACA,eAAe,2CAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yDAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2CAAI;AAC9B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,2CAAI;AACzE,sEAAsE,2CAAI;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,WAAW;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,eAAe;AAC5F;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,eAAe,EAAC;;;;;;;;;;;;;;;;;ACvPuB;AACpB;AAClC;AACA;AACA;AACA,0BAA0B,4DAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kDAAK;AACpB;AACA;AACA,iEAAe,WAAW,EAAC;;;;;;;;;;;;;;;;;;;AC7BO;AACG;AAC2B;AAChE;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,iEAAoB;AACtD;AACA;AACA;AACA;AACA;AACA,oBAAoB,kDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2CAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2CAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mBAAmB,IAAI,mBAAmB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,YAAY,EAAC;;;;;;;;;;;;;;;;;ACpQ0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACO,mCAAmC,4DAAe;AACzD;AACA;AACA;AACA;AACA,iEAAe,oBAAoB,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACZY;AACd;AACG;AACS;AACQ;AACN;AACgB;AACgB;AACvB;AACzD,2EAA2E,WAAW;AAC/E;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA,WAAW,iCAAiC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,YAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kDAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wDAAW;AACjD;AACA;AACA;AACA,sCAAsC,4DAAe;AACrD;AACA;AACA;AACA,sCAAsC,yDAAY;AAClD;AACA;AACA;AACA,sCAAsC,yDAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kDAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sDAAsD;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sBAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6BAA6B;AAC3C,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iHAAiH,cAAc,aAAa,mBAAmB;AAC/J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2CAAI;AAC5C;AACA,kCAAkC,yDAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qBAAqB;AAC5D;AACA;AACA,kDAAkD,qBAAqB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,+BAA+B;AAC5C;AACA,wEAAwE;AACxE,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,2CAAI;AACpD;AACA;AACA;AACA,iCAAiC,yDAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2CAAI;AACrC,8BAA8B,kDAAK;AACnC,8BAA8B,kDAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,yEAAe;AAC5D,6CAA6C,yEAAe;AAC5D;AACA,mCAAmC,yEAAe;AAClD,mCAAmC,yEAAe;AAClD;AACA;AACA,+CAA+C,iFAAuB;AACtE,+CAA+C,iFAAuB;AACtE;AACA;AACA,qDAAqD,mBAAmB,EAAE,mBAAmB;AAC7F;AACA;AACA,qDAAqD,mBAAmB,GAAG,mBAAmB;AAC9F;AACA;AACA;AACA,iDAAiD,WAAW,GAAG,WAAW;AAC1E;AACA;AACA;AACA;AACA,mCAAmC,QAAQ,EAAE,+BAA+B;AAC5E;AACA;AACA,mCAAmC,sBAAsB,EAAE,+BAA+B;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2CAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,KAAK;AAC1E;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,2CAAI;AAClD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,0DAA0D,yBAAyB,mBAAmB,gBAAgB,IAAI,gBAAgB;AAC1I,kDAAkD,aAAa,wBAAwB,gBAAgB;AACvG,gCAAgC,WAAW;AAC3C;AACA;AACA,iCAAiC,yBAAyB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,YAAY;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,2CAAI;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oEAAa;AAClC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sBAAsB,2CAAI;AAC1B,iEAAe,IAAI,EAAC;;;;;;;;;;;;;;;;;;AC3yCiB;AAC2B;AAC9B;AAClC;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA,2BAA2B,iEAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2CAAI;AACnB;AACA;AACA,eAAe,2CAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,YAAY,EAAC;;;;;;;;;;;;;;;;;;;;AChDS;AAC2B;AACV;AACpB;AAClC;AACA;AACA;AACA;AACA;AACA,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B,4DAAe;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2CAAI;AACnB;AACA;AACA;AACA;AACA;AACA,eAAe,2CAAI;AACnB;AACA;AACA;AACA;AACA;AACA,eAAe,2CAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kDAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0EAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,eAAe,EAAC;;;;;;;;;;;;;;;;;;;;ACrJiB;AACb;AACE;AACiB;AACtD;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,oBAAoB,4DAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2CAAI;AAC3B,oBAAoB,2CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO,iBAAiB,OAAO,GAAG,MAAM,aAAa;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2CAAI;AACzC;AACA;AACA,iCAAiC,2CAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2CAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAY;AAC5B,gBAAgB,yDAAY;AAC5B,gBAAgB,yDAAY;AAC5B,gBAAgB,yDAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kDAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO,IAAI,OAAO,UAAU,OAAO,IAAI,OAAO;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2CAAI,mCAAmC,2CAAI;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK,EAAC;;;;;;;;;;;;;;;;AClUgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2CAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,aAAa,EAAC;;;;;;;;;;;;;;;;;;;;;;;AC1D7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,EAAE,eAAe,EAAE;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD,gBAAgB,MAAM,mBAAmB;;AAE1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sEAAsE,EAAE,iDAAiD,EAAE,kBAAkB,QAAQ,IAAI,OAAO;AAChK,eAAe;;AAEf,0EAA0E,kBAAkB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B,qBAAqB;AAClD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oDAAoD,eAAe;AACnE,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,KAAK;AACpC,8BAA8B,IAAI;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sDAAsD,eAAe;AACrE;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA,uDAAuD,eAAe;AACtE;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kDAAkD,eAAe;;AAEjE;AACA,yBAAyB,qBAAqB;AAC9C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kCAAkC,OAAO;AACzC,gCAAgC,mBAAmB;;AAEnD,kCAAkC,mCAAmC;AACrE,iCAAiC,2DAA2D;;AAE5F;AACA,kCAAkC,aAAa;AAC/C;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;AACA,qDAAqD,eAAe;AACpE;;AAEA;AACA;AACA;;AAEA,+DAA+D,UAAU,oBAAoB;AAC7F;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,EAAE;AAChC,8BAA8B,EAAE;AAChC;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,EAAE;AACpC,iCAAiC,EAAE;;AAEnC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,sCAAsC,sBAAsB,WAAW,sBAAsB;AAC7F;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oDAAoD,OAAO;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,IAAI;AACtC,gCAAgC,gBAAgB;;AAEhD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,YAAY;AAC9C,oBAAoB,UAAU;AAC9B;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B,6BAA6B;AAC7B,4BAA4B;AAC5B,mBAAmB;AACnB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,QAAQ;AACR,wDAAwD,EAAE;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,sBAAsB,OAAO,IAAI,OAAO,IAAI,OAAO;AACnD,QAAQ;AACR,uBAAuB,OAAO,IAAI,OAAO,IAAI,OAAO,IAAI,OAAO;AAC/D;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,sBAAsB,OAAO,IAAI,OAAO,KAAK,OAAO;AACpD,QAAQ;AACR,uBAAuB,OAAO,IAAI,OAAO,KAAK,OAAO,KAAK,OAAO;AACjE;AACA;;AAEA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,kIAAkI,oBAAoB;AACtJ,sFAAsF,0BAA0B;AAChH;AACA;AACA;AACA,8GAA8G,wBAAwB;AACtI;AACA;AACA;AACA,kHAAkH,0BAA0B;AAC5I;AACA;AACA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,oBAAoB,IAAI,oBAAoB;AACxH;AACA,4EAA4E,oBAAoB,IAAI,oBAAoB;AACxH;AACA,0CAA0C,mBAAmB;AAC7D,4CAA4C,qBAAqB;;AAEjE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;;AAEP;AACA,6DAA6D,gBAAgB;AAC7E,OAAO;;AAEP;AACA;AACA,OAAO;;AAEP;AACA,6DAA6D,gBAAgB;AAC7E,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA,2EAA2E,eAAe;AAC1F,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,mBAAmB;AAClC,eAAe,UAAU;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,eAAe;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,oCAAoC,oEAAoE,aAAa,SAAS;AAC9H;AACA;AACA;;AAEA;AACA;AACA,sDAAsD,0BAA0B;AAChF,sDAAsD,0BAA0B;AAChF,OAAO;;AAEP;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;;AC7uCvB;AACA;;AAEA;;AAEA;AACA;;AAEmC;AACW;;AAE9C;AACA,QAAQ,sCAAsC;AAC9C;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C,WAAW;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,4CAAK,iBAAiB,kCAAkC;AAC5E,uBAAuB,4CAAK;AAC5B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4CAAK;AAChB;AACA;;AAEA,kBAAkB,4CAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4BAA4B;AAC7C,aAAa,4BAA4B;AACzC;AACA,aAAa,kEAAkE;AAC/E,aAAa,sDAAsD;AACnE,cAAc,sDAAsD;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,4CAAK;AAChB;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,uDAAU;AACrB;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,4CAAK;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,UAAU;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,4CAAK;AACxB;AACA;;AAEA;AACA;AACA,kBAAkB,4CAAK;AACvB;AACA;;AAEA;AACA,WAAW,4CAAK;AAChB;;AAEA;AACA,cAAc,4CAAK;AACnB;AACA;AACA;AACA;AACA,OAAO;AACP,UAAU,4CAAK;AACf;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B,gBAAgB;AAC9C;AACA,UAAU,4CAAK;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,4CAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA,UAAU,4CAAK;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,4CAAK;AAClB;AACA,WAAW,4CAAK;AAChB;;AAEA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,4CAAK;AAChB;;AAEA;AACA,WAAW,4CAAK;AAChB;;AAEA;AACA;AACA,sBAAsB,4CAAK,YAAY,+BAA+B;AACtE;;AAEA;AACA,WAAW,4CAAK;AAChB;;AAEA;AACA,WAAW,4CAAK;AAChB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD,aAAa,4CAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,4CAAK;AAC3B,sBAAsB,4CAAK;AAC3B,uBAAuB,4CAAK;AAC5B,uBAAuB,4CAAK;;AAE5B;AACA;AACA;AACA;;AAEA;AACA,SAAS,4CAAK;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4CAAK;AAC3B;AACA;AACA,2CAA2C,4CAAK;AAChD;AACA;AACA;AACA,SAAS;AACT,8CAA8C,4CAAK;AACnD,OAAO;AACP;;AAEA,+BAA+B,4CAAK;AACpC;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAK;AACzB,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,4CAAK;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,iBAAiB,4CAAK;AACtB,iBAAiB,4CAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,oBAAoB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gBAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4CAAK;AAC/B,0BAA0B,4CAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4CAAK;AAC3B;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,4CAAK;;AAEnB;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,4CAAK;AACtC;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,oBAAoB,4CAAK;AACzB,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,YAAY;AACZ,YAAY;AACZ,cAAc;AACd;;AAEA,YAAY;AACZ,YAAY;AACZ,cAAc;AACd;;AAEA,iBAAiB,4CAAK;AACtB,iBAAiB,4CAAK;AACtB;AACA,iBAAiB,uDAAU;AAC3B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,4CAAK;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,4CAAK;AAChB,WAAW,4CAAK;AAChB;;AAEA,eAAe,uDAAU;AACzB;;AAEA;AACA;AACA;AACA;AACA,0CAA0C,aAAa;AACvD,oBAAoB,4CAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,4CAAK;AAChB;AACA,aAAa,4CAAK,yBAAyB,4CAAK;AAChD,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,qBAAqB,4CAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,4CAAK;AACjB,WAAW,4CAAK;AAChB,WAAW,4CAAK;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,cAAc,4CAAK;;AAEnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4CAAK,SAAS,oBAAoB;AACzD;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEkB;;;;;;;;;;;;;;;;ACl/BiB;;AAEnC;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4CAAK;AACtB,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC,MAAM,4CAAK;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEsB;;;;;;;;;;;;;;;;ACrEe;;AAErC;AACA,QAAQ,wCAAwC;;AAEhD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,kDAAkD,OAAO;AACzD;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA,eAAe,8CAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,WAAW,qDAAqD;AAChE,WAAW,qDAAqD;AAChE;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,qBAAqB,MAAM,YAAY,QAAQ;;AAE/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA,eAAe;AACf;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb,GAAG;;AAEH;AACA;;AAEA;;AAEA,oCAAoC,wCAAwC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;;AAEA,kCAAkC,SAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,iCAAiC;AAC3C,UAAU,kCAAkC;AAC5C,UAAU,mCAAmC;AAC7C,UAAU,kCAAkC;AAC5C;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;;AAEiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC54BmC;AACM;AACV;AACyD;AACnD;AACd;AACc;AACW;AACE;AACf;AACd;AACwC;AACtB;AACgB;AACG;AAChB;AACW;AAC3B;AACkD;AACrC;AACwB;AAC1B;AAC8B;AACjB;AACL;AACxB;AAC8D;AACnB;AACE;AACZ;AACV;AACuB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oFAAoB;AACnC;AACA;AACA;AACA;AACA;AACA,qDAAqD,iEAAa;AAClE;AACA;AACA;AACA,+EAA+E;AAC/E,uDAAuD,kEAAY;AACnE;AACA,0CAA0C,sBAAsB;AAChE;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0EAAoB;AAC5C;AACA,6BAA6B,+EAAuB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4DAAe;AAC3C,4BAA4B,qDAAQ;AACpC,mCAAmC,uDAAe;AAClD,sBAAsB,uDAAe;AACrC;AACA;AACA,aAAa;AACb,SAAS;AACT,2BAA2B,8DAAO;AAClC,yBAAyB,8DAAW;AACpC,2BAA2B,4DAAe;AAC1C,kCAAkC,iEAAc;AAChD;AACA,2CAA2C,qFAAqB;AAChE,+CAA+C,qFAAqB;AACpE;AACA,uCAAuC,+CAAI;AAC3C;AACA;AACA;AACA;AACA,yBAAyB,uDAAe;AACxC,6BAA6B,uDAAe;AAC5C;AACA,uDAAuD,+CAAI;AAC3D;AACA;AACA;AACA,qCAAqC,gDAAK;AAC1C;AACA;AACA;AACA;AACA;AACA,qCAAqC,gDAAK;AAC1C;AACA;AACA;AACA;AACA;AACA,iDAAiD,KAAK;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gDAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0BAA0B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iEAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA,2CAA2C,+CAAI;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gCAAgC,mEAAgB;AAChD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,yEAAyE,2BAA2B;AACpG,0EAA0E,4BAA4B;AACtG,iFAAiF,iCAAiC;AAClH,kFAAkF,kCAAkC;AACpH;AACA;AACA;AACA,oBAAoB,+CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+CAAI;AACxB;AACA;AACA;AACA,oBAAoB,+CAAI;AACxB;AACA,kBAAkB,0DAAY;AAC9B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qDAAO;AACnC;AACA;AACA;AACA,sBAAsB,0DAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qDAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAY;AACtC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qDAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAY;AAClC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mEAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa,+BAA+B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAAI;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,2FAA2F,eAAe;AAC1G,sBAAsB,4EAA0B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,eAAe;AACtG,sBAAsB,yEAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kFAA2B;AACnC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uDAAe;AAClD,sBAAsB,uDAAe;AACrC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA,4BAA4B,gDAAgD;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,cAAc,oCAAoC;AAClD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,MAAM,iDAAM;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kCAAkC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gDAAK;AAC5C,8BAA8B,gEAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,+CAAI;AAC/D;AACA;AACA;AACA,8DAA8D,+CAAI;AAClE,yDAAyD,cAAc;AACvE,yDAAyD,cAAc;AACvE,uDAAuD,iCAAiC;AACxF,oDAAoD,iCAAiC;AACrF;AACA;AACA;AACA;AACA;AACA,kDAAkD,uDAAe;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0EAAmB;AACrC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA,QAAQ,sEAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qDAAQ;AAC7B,wBAAwB,gDAAK,6DAA6D,gDAAK;AAC/F;AACA;AACA;AACA,0BAA0B,8DAAW;AACrC;AACA;AACA;AACA,4BAA4B,wEAAa,aAAa,gDAAgD;AACtG;AACA,6EAA6E,+EAAa;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B,EAAE,gFAAc,sDAAsD,wBAAwB;AAC1I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,eAAe,yFAAoB,0BAA0B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA,iCAAiC;AACjC;AACA,qBAAqB,0FAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8EAAuB;AAC7C;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,wDAAwD,gBAAgB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,4DAAK;AAChD;AACA,0CAA0C,8DAAW;AACrD,SAAS;AACT;AACA;AACA;AACA,uBAAuB,8EAAuB;AAC9C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,4EAAmB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE,YAAY,wCAAwC;AACpD;AACA,8BAA8B,0BAA0B;AACxD;AACA;AACA;AACA;AACA,gBAAgB,oDAAoD;AACpE;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,2CAA2C,sCAAsC;AACjF;AACA;AACA;AACA;AACA;AACA,8BAA8B,4DAAK;AACnC;AACA,0EAA0E,gFAAc;AACxF,wEAAwE,iDAAM;AAC9E;AACA,4DAA4D,gFAAc;AAC1E,cAAc,gFAAc;AAC5B;AACA;AACA;AACA;AACA,+BAA+B,gFAAc;AAC7C,sCAAsC,4EAAmB;AACzD,0BAA0B,8DAAW;AACrC;AACA;AACA;AACA;AACA;AACA,wGAAwG,+CAAI;AAC5G;AACA;AACA,eAAe,wEAAa;AAC5B;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,4CAA4C,iDAAM;AAClD,kBAAkB,gFAAc;AAChC,kBAAkB,gFAAc;AAChC,6BAA6B,4EAAmB;AAChD;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,4EAAmB;AACxD,oEAAoE,iDAAM;AAC1E;AACA;AACA,eAAe,iDAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gEAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,8BAA8B;AACxE;AACA;AACA;AACA;AACA;AACA,kDAAkD,qDAAO,QAAQ;AACjE;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,0BAA0B,qDAAO,QAAQ;AACzC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B,UAAU,mDAAmD;AACnH,uBAAuB,kCAAkC;AACzD,oCAAoC,2DAA2D;AAC/F,mCAAmC,6BAA6B,GAAG,6BAA6B;AAChG,oCAAoC,aAAa,GAAG,aAAa;AACjE,2CAA2C,mCAAmC;AAC9E;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,4DAA4D,qDAAO,QAAQ;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4EAAqB;AACrC;AACA;AACA;AACA,gBAAgB,4EAAqB;AACrC;AACA;AACA;AACA,gBAAgB,4EAAqB;AACrC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gCAAgC,yEAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,MAAM,EAAC;;;;;;;;;;;;;;;ACp0CtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrDqC;AAC9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+CAAI;AAClC,8BAA8B,+CAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0BAA0B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAAI;AAC5B;AACA;AACA,wCAAwC,+CAAI;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5HiE;AACkL;AACnL;AAChB;AACsC;AACD;AACjB;AACK;AACO;AAChB;AAChE;AACO,+BAA+B,gDAAK;AAC3C;AACO;AACP,SAAS,2BAA2B;AAC7B;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACO;AACP;AACA;AACA;AACA,CAAC,kDAAkD;AACnD;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iDAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iDAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,KAAK;AACpD,6BAA6B,+CAAI;AACjC,6BAA6B,mFAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8DAAM;AAC7B;AACA;AACA;AACA;AACA;AACA,2BAA2B,wEAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6FAA4B,CAAC,+EAAc;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iDAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,iGAAgC;AACzE,wDAAwD,iGAAgC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iDAAM;AAC1C,kCAAkC,iDAAM;AACxC;AACA,yCAAyC,sHAAqD;AAC9F;AACA;AACA,yBAAyB,2EAAmB;AAC5C;AACA;AACA;AACA;AACA,yBAAyB,iDAAM;AAC/B,6BAA6B,2EAAmB,CAAC,+EAAc;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gDAAK;AACjC;AACA;AACA;AACA,oEAAoE,iBAAiB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gDAAK;AACjC;AACA;AACA;AACA,4BAA4B,gDAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,gDAAK,aAAa,+CAAI;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,QAAQ;AAChF;AACA;AACA;AACA,iEAAiE,MAAM;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wEAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4EAAiB;AAC7C;AACA;AACA,4BAA4B,4EAAiB;AAC7C,2CAA2C,gDAAK,aAAa,+CAAI;AACjE;AACA;AACA;AACA;AACA,kCAAkC,4EAAiB;AACnD,gCAAgC,4EAAiB;AACjD;AACA;AACA,gCAAgC,4EAAiB;AACjD;AACA,2CAA2C,gDAAK,aAAa,+CAAI;AACjE;AACA;AACA,2BAA2B,qEAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sEAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wEAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2BAA2B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wEAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,MAAM,sCAAsC,YAAY,WAAW,WAAW;AAC/G;AACA;AACA;AACA,+BAA+B,gDAAK;AACpC,yDAAyD,YAAY;AACrE;AACA;AACA;AACA,4CAA4C,iFAAyB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,4FAA2B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,4FAA2B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,sFAAoB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,KAAK;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;ACzmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,iBAAiB,EAAC;;;;;;;;;;;;;;;;ACxBjC,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AAC+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,uDAAe;AACrD,kBAAkB,uDAAe;AACjC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qDAAa;AAC1C,sCAAsC,uDAAe;AACrD,kBAAkB,uDAAe;AACjC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qDAAa;AAC9C,0CAA0C,uDAAe;AACzD,sBAAsB,uDAAe;AACrC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qDAAa;AAC9C,0CAA0C,uDAAe;AACzD,sBAAsB,uDAAe;AACrC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,eAAe,EAAC;;;;;;;;;;;;;;;;;;;AC5F/B,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AAC+C;AACU;AAClD,gCAAgC,6DAAO;AAC9C;AACO;AACP;AACA;AACA;AACA,4BAA4B,gDAAK;AACjC,0BAA0B,gDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gDAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,+CAAI;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,iBAAiB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+CAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,iBAAiB;AACxF;AACA;AACA,4CAA4C,+CAAI;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gDAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gDAAK;AACrC;AACA;AACA,+BAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gDAAK;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gDAAK;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gDAAK;AAC9C;AACA;AACA;AACA;AACA;AACA,wBAAwB,gDAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,+CAAI;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,KAAK;AACL;AACA;AACA,iEAAe,QAAQ,EAAC;;;;;;;;;;;;;;;;AChRxB;AACA;AACA;AACA,QAAQ,sBAAsB;AAC9B;AACO;AACP;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa,IAAI,aAAa;AACxD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;;;ACrC4D;AACjD;AAC4B;AAC9D;AACA,kCAAkC,wBAAwB;AAC1D,yBAAyB,aAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,wBAAwB;AACjC;AACA,wBAAwB,gEAAmB;AAC3C;AACA;AACA;AACA;AACA,2BAA2B,kDAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,sFAAqB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gEAAmB;AACvB;AACA;AACA,KAAK;AACL,CAAC;AACD,iEAAe,SAAS,EAAC;;;;;;;;;;;;;;;;;;;AC1D6C;AACa;AAC9B;AACS;AAC9D;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA,YAAY,8EAA8E;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B,qBAAqB,QAAQ;AAC7B;AACA;AACA,+BAA+B,MAAM,GAAG,MAAM;AAC9C,aAAa,mCAAmC,qDAAqD;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8DAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sFAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gEAAmB;AACvB;AACA;AACA;AACA;AACA,6EAA6E,YAAY;AACzF,yEAAyE,yEAAiB;AAC1F;AACA,SAAS;AACT;AACA,KAAK;AACL,CAAC;AACD,iEAAe,KAAK,EAAC;;;;;;;;;;;;;;;;ACzGrB,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACsC;AACtC;AACA,0GAA0G;AAC1G,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA,kCAAkC,oDAAO;AACzC;AACA;AACA;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,YAAY;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,mBAAmB,EAAC;;;;;;;;;;;;;;;;AC3D2B;AAC9D;AACA;AACA;AACA;AACe,4CAA4C,gEAAmB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,iBAAiB;AACpF;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrBsC;AACwB;AAC9D;AACA;AACA;AACA,2BAA2B,gEAAmB;AAC9C;AACA,kCAAkC,gEAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0CAA0C,oDAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gEAAmB;AACnB,yBAAyB,gEAAmB;AAC5C,CAAC;AACD,iEAAe,aAAa,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;ACtDS;AACI;AACR;AACgB;AACY;AACZ;AACsC;;;;;;;;;;;;;;;ACNjF;AACP;AACA,uDAAuD,WAAW,SAAS,2BAA2B;AACtG,0DAA0D,UAAU,GAAG,UAAU;AACjF;AACA;AACA,yDAAyD,qBAAqB;AAC9E,+DAA+D,UAAU,EAAE,qBAAqB;AAChG,uEAAuE,UAAU,EAAE,qBAAqB;AACxG,2DAA2D,aAAa,EAAE,kBAAkB;AAC5F,oDAAoD,kBAAkB;AACtE;AACA;AACA;AACA,0CAA0C,mBAAmB,UAAU,gDAAgD;AACvH;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C,6CAA6C,OAAO,SAAS,uBAAuB;AACpF;;;;;;;;;;;;;;;;;;ACvBkD;AACZ;AACwB;AAC9D,mCAAmC,oDAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gEAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAkD;AAC9D,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,6BAA6B,QAAQ;AACrC,SAAS,oCAAoC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gEAAmB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gEAAmB;AACzC;AACA,qCAAqC,6BAA6B;AAClE,CAAC;AACD,iEAAe,aAAa,EAAC;;;;;;;;;;;;;;;;;;;;AClL7B,yBAAyB,SAAI,IAAI,SAAI;AACrC;AACA,8CAA8C,yEAAyE;AACvH;AACA;AACwE;AACnB;AACf;AAC0C;AACzE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD;AACnD;AACA,wDAAwD,kBAAkB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB,GAAG,cAAc;AAC3D;AACA,yCAAyC,eAAe;AACxD;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,cAAc;AACjE;AACA,QAAQ,mCAAmC;AAC3C;AACA,QAAQ,kBAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAiD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,gDAAK;AAClE;AACA;AACA,iBAAiB,mBAAmB,KAAK,iBAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,MAAM;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,uEAA6B;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8DAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,QAAQ,yEAAmB;AAC3B;AACA,kCAAkC,gDAAK;AACvC;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,iEAAe,iBAAiB,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;ACzUiC;AAC2B;AACV;AACN;AACpC;AACgC;AAClE;AACP;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AAClC;AACP;AACO;AACP;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACe,kCAAkC,8DAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qDAAQ;AAChC;AACA;AACA;AACA;AACA,2BAA2B,gDAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uFAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iDAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,wEAAoB;AAChF;AACA,SAAS;AACT,2DAA2D,wEAAoB;AAC/E;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+CAAI;AACvB;AACA,2BAA2B,+CAAI;AAC/B,6BAA6B,WAAW;AACxC;AACA,sBAAsB,0DAAe;AACrC,uBAAuB,+CAAI;AAC3B,aAAa;AACb;AACA,sBAAsB,0DAAe;AACrC,uBAAuB,+CAAI;AAC3B,aAAa;AACb;AACA,6BAA6B,WAAW;AACxC;AACA,sBAAsB,0DAAe;AACrC,uBAAuB,+CAAI;AAC3B,aAAa;AACb;AACA,sBAAsB,0DAAe;AACrC,uBAAuB,+CAAI;AAC3B,aAAa;AACb;AACA,mBAAmB,+CAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iDAAM;AAChC;AACA;AACA;AACA,4BAA4B,iDAAM;AAClC;AACA;AACA,sBAAsB,iDAAM;AAC5B,0BAA0B,+CAA+C;AACzE;AACA,4BAA4B,mFAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA,gCAAgC,8DAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uEAAmB,cAAc,uEAAmB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iDAAM;AAChC,qDAAqD,iDAAM;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAAiB;;;;;;;;;;;;;;;;;;;ACnU4B;AACkC;AACrB;AACQ;AAClE;AACA;AACA;AACA;AACA;AACA;AACe,6BAA6B,8DAAiB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wEAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,MAAM;AACrC;AACA,QAAQ,yEAAmB;AAC3B,QAAQ,oEAAc;AACtB,QAAQ,oEAAc;AACtB;AACA;AACA;AACA;AACA,8BAA8B,gDAAK;AACnC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,8DAAiB;;;;;;;;;;;;;;;;;;;;AC3JsB;AACiC;AACQ;AACY;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kFAAe;AAC1C;AACA;AACA;AACA;AACA,+BAA+B,iDAAM;AACrC,uCAAuC,oFAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,uEAA6B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,yEAAmB;AACvB;AACA;AACA;AACA;AACA,kDAAkD,eAAe;AACjE;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;;;;;;;AC/ED;AACA;AACA;AACA;AACA;AACA;AACsC;AAC6B;AACgB;AACnF;AACA;AACe,wCAAwC,8DAAiB;AACxE;AACA;AACA;AACA,2BAA2B,gDAAK;AAChC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gCAAgC,4EAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAAiB;;;;;;;;;;;;;;;;;;;;AC3DkF;AACpB;AACrB;AACmB;AACkD;AAC/H;AACA,kBAAkB,yBAAyB,wBAAwB,WAAW;AAC9E;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,qBAAqB,8DAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kBAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qFAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,6BAA6B,gDAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uFAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,0DAAe;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mFAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6DAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,8DAAe;AACnE;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gCAAgC,kCAAkC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kGAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA,uBAAuB,gDAAK;AAC5B;AACA;AACA,2BAA2B,gDAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,qBAAqB,yBAAyB;AAC9C;AACA;AACA;AACA,0BAA0B,WAAW,kBAAkB,wBAAwB;AAC/E,wDAAwD,gCAAgC;AACxF;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0EAAW;AAClC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,MAAM;AACrC;AACA;AACA,0BAA0B,4EAAa;AACvC,mBAAmB,mFAAgB,CAAC,+CAAI;AACxC,SAAS;AACT;AACA;AACA;AACA,8DAAiB;;;;;;;;;;;;;;;;;;;;ACzgB0C;AACiD;AAClD;AACmB;AAC7E;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA,sBAAsB,MAAM,iDAAM,SAAS;AAC3C;AACA;AACA;AACA;AACA,sEAAsE,oBAAoB;AAC1F;AACA;AACA;AACA;AACA,YAAY,iEAAiE;AAC7E;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,oBAAoB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8DAAiB;AAC7C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,wCAAwC;AAChG;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gDAAK;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gDAAK;AAC7D;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,eAAe,uFAA6B;AAC5C;AACA;AACA;AACA,yBAAyB,iFAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,eAAe,iFAAc;AAC7B;AACA;AACA,4CAA4C,+CAAI;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kFAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oFAAiB;AACvC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gEAAgE,eAAe;AAC/E;AACA;AACA,8BAA8B,gDAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+CAAI;AAC3B;AACA;AACA,yCAAyC,+CAAI;AAC7C;AACA,wDAAwD,gDAAK;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gDAAK;AACvC;AACA;AACA,yBAAyB,gDAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gDAAK;AACpC,oCAAoC,gDAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,kCAAkC,gDAAK,aAAa,+CAAI;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,aAAa,EAAC;AAC7B,8DAAiB;;;;;;;;;;;;;;;;;;ACpajB;AACA;AACA;AACA;AACA;AACsC;AAC6B;AACgB;AACnF;AACe,+BAA+B,8DAAiB;AAC/D;AACA;AACA;AACA,2BAA2B,gDAAK;AAChC;AACA;AACA,gCAAgC,4EAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8DAAiB;;;;;;;;;;;;;;;;;;;AClDqC;AACjB;AACiD;AACtF;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,sFAAyB;AACzD;AACA,CAAC;AACc;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAI;AAC7B;AACA;AACA,sBAAsB,0DAAe;AACrC;AACA,aAAa;AACb;AACA,sBAAsB,0DAAe;AACrC;AACA,aAAa;AACb;AACA,sBAAsB,0DAAe;AACrC;AACA,aAAa;AACb;AACA;AACA,sBAAsB,0DAAe;AACrC;AACA,aAAa;AACb;AACA,sBAAsB,0DAAe;AACrC;AACA,aAAa;AACb;AACA,sBAAsB,0DAAe;AACrC;AACA,aAAa;AACb;AACA,sBAAsB,0DAAe;AACrC;AACA,aAAa;AACb;AACA;AACA,4BAA4B,mDAAM;AAClC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5FoE;AACQ;AAChC;AACP;AACiD;AACtF;AACA;AACA;AACA;AACA;AACA;AACO,kCAAkC,sFAAyB;AAClE;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qDAAQ;AACpC;AACA;AACA;AACA,uCAAuC,+CAAI;AAC3C,+BAA+B,kBAAkB;AACjD,6BAA6B,+CAAI;AACjC;AACA;AACA;AACA,iCAAiC,+CAAI;AACrC;AACA;AACA;AACA,sBAAsB,0DAAe;AACrC;AACA;AACA,aAAa;AACb;AACA;AACA,kBAAkB,0DAAe;AACjC;AACA,SAAS;AACT,yBAAyB,+CAAI;AAC7B,4BAA4B,mDAAM;AAClC,YAAY,mFAAgB;AAC5B,sBAAsB,iDAAM;AAC5B;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC1EqE;AAChC;AACO;AACkB;AACoB;AAClF;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,oFAAuB;AAC9D;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oEAAc;AAC7C;AACA,wBAAwB,gDAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAM;AACxB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mDAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAQ;AACvB;AACA;AACA;AACA,eAAe,qDAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qDAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAe;AACzC,8CAA8C,+CAAI;AAClD;AACA;AACA;AACA;AACA;AACA,0CAA0C,+CAAI;AAC9C,iBAAiB;AACjB;AACA,0BAA0B,0DAAe;AACzC,8CAA8C,+CAAI;AAClD,0CAA0C,+CAAI;AAC9C,iBAAiB;AACjB;AACA,0BAA0B,0DAAe;AACzC,8CAA8C,+CAAI;AAClD,0CAA0C,+CAAI;AAC9C,iBAAiB;AACjB;AACA,0BAA0B,0DAAe;AACzC,8CAA8C,+CAAI;AAClD,0CAA0C,+CAAI;AAC9C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAe;AACrC;AACA,aAAa;AACb;AACA;AACA,kBAAkB,0DAAe;AACjC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxKsD;AACsB;AACvC;AACiD;AACtF;AACA;AACA;AACA;AACA;AACA;AACO,wBAAwB,sFAAyB;AACxD;AACA,CAAC;AACc;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAI;AAC7B;AACA,sBAAsB,0DAAe;AACrC;AACA,aAAa;AACb;AACA,sBAAsB,0DAAe;AACrC;AACA,aAAa;AACb;AACA,sBAAsB,0DAAe;AACrC;AACA,aAAa;AACb;AACA,sBAAsB,0DAAe;AACrC;AACA,aAAa;AACb;AACA,4BAA4B,mDAAM,EAAE,mFAAgB,SAAS,6BAA6B;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC/DoF;AAC/C;AACO;AACsC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,oFAAuB;AAC1D;AACA;AACA;AACA;AACA,CAAC;AACc;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gDAAK;AAC7B;AACA;AACA,sBAAsB,0DAAe;AACrC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAM;AACxB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAe;AACrC,uCAAuC,+CAAI;AAC3C,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAQ;AACvB;AACA;AACA;AACA,eAAe,qDAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAe;AACrC;AACA,aAAa;AACb;AACA,uCAAuC,uDAAY;AACnD;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACxH+E;AAC1C;AACO;AACkB;AACoB;AAC3E,iDAAiD,oFAAuB;AAC/E;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oEAAc;AAC7C;AACA,wBAAwB,gDAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qFAAqF;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,0DAAe;AACrD,sCAAsC,0DAAe;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qDAAQ;AAClC;AACA;AACA;AACA;AACA;AACA,wDAAwD,+CAAI;AAC5D;AACA;AACA,sBAAsB,0DAAe;AACrC,0CAA0C,+CAAI;AAC9C;AACA;AACA;AACA;AACA;AACA,sCAAsC,+CAAI;AAC1C,aAAa;AACb,sBAAsB,0DAAe;AACrC,0CAA0C,+CAAI;AAC9C,sCAAsC,+CAAI;AAC1C,aAAa;AACb,sBAAsB,0DAAe;AACrC,0CAA0C,+CAAI;AAC9C,sCAAsC,+CAAI;AAC1C,aAAa;AACb,sBAAsB,0DAAe;AACrC,0CAA0C,+CAAI;AAC9C,sCAAsC,+CAAI;AAC1C,aAAa;AACb;AACA,sBAAsB,0DAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uIAAuI;AACvJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0DAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0DAAe;AACjC;AACA;AACA;AACA;AACA;AACA,kBAAkB,0DAAe;AACjC;AACA;AACA;AACA;AACA,kBAAkB,0DAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAe;AACrC;AACA,aAAa;AACb;AACA,sBAAsB,0DAAe;AACrC;AACA,aAAa;AACb;AACA;AACA,kBAAkB,0DAAe;AACjC;AACA;AACA;AACA,+BAA+B,0DAAe;AAC9C,+BAA+B,0DAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC9UmD;AACyB;AACvC;AACiD;AACtF;AACA;AACA;AACA;AACA;AACA;AACO,mCAAmC,sFAAyB;AACnE;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACO,qCAAqC,sFAAyB;AACrE;AACA,CAAC;AACc;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gDAAK;AACjC;AACA;AACA;AACA;AACA,qBAAqB,gDAAK;AAC1B,qBAAqB,+CAAI;AACzB;AACA;AACA;AACA;AACA,4BAA4B,mDAAM;AAClC,YAAY,mFAAgB;AAC5B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/DoD;AACpD;AACA;AACA;AACA;AACA;AACA,iEAAe,uBAAuB,EAAC;AACvC;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gDAAK;AAC1B;AACA;AACA,4BAA4B,gDAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2BAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,mBAAmB;AACnE;AACA;AACA;AACA;AACA,kDAAkD,uDAAY;AAC9D,kDAAkD,uDAAY;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClKA;AACA;AACA;AACA;AACA;AACA,iEAAe,yBAAyB,EAAC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3CsE;AACR;AAC0C;AACtC;AACV;AACF;AAC8C;;;;;;;;;;;;ACN1F;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACA6B;AACF;AACmC;AAC9B;AAC+B;AACrC;AACc;AACE;AACgD;AAClB;AAG4D;;;;;;;;;;;;;;;ACZvI;AACP;AACA;AACA;AACA;AACA;AACA,gEAAgE,MAAM;AACtE,oCAAoC,KAAK;AACzC,0CAA0C,YAAY;AACtD,yDAAyD,mBAAmB;AAC5E;;;;;;;;;;;;;;;;;ACV2E;AAC3E;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAAI;AAC5B;AACA;AACA,wBAAwB,gDAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,+CAAI;AACrE;AACA;AACA,oCAAoC,0DAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uDAAY;AAC9C,gCAAgC,uDAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0DAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,cAAc,EAAC;;;;;;;;;;;;;;;AC7N9B;AACA;AACA,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;;;;ACbwD;AAC1D;AACA,mBAAmB,kEAAiB;AACpC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iEAAe,eAAe,EAAC;;;;;;;;;;;;;;;;ACjC2B;AAC1D;AACA;AACA,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,aAAa;AAC9D;AACA;AACA,cAAc,oEAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,iEAAe,eAAe,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;AClD/B,yBAAyB,SAAI,IAAI,SAAI;AACrC;AACA,8CAA8C,yEAAyE;AACvH;AACA;AACyC;AACsD;AACpC;AACa;AACjB;AACyC;AAChD;AAChD;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACA;AACA,oDAAoD,wBAAwB;AAC5E,aAAa,aAAa,IAAI,oBAAoB;AAClD;AACA;AACA;AACA,gCAAgC,kCAAkC;AAClE,OAAO,gDAAgD;AACvD,mDAAmD,yBAAyB;AAC5E,kCAAkC,6BAA6B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4DAAe;AAC3C,wCAAwC,qDAAQ;AAChD;AACA,SAAS;AACT;AACA,mDAAmD,+CAAI;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qCAAqC;AAC5D;AACA,uEAAuE,8BAA8B;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0BAA0B;AAClC;AACA;AACA;AACA;AACA,cAAc,4BAA4B;AAC1C;AACA;AACA;AACA;AACA;AACA,QAAQ,wBAAwB;AAChC;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gBAAgB;AACtE,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6DAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gDAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,yEAAmB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,QAAQ,yEAAmB;AAC3B;AACA;AACA,sCAAsC,yEAAiB;AACvD;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,6DAA6D,yEAAmB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,QAAQ,yEAAmB;AAC3B,YAAY,oEAAc;AAC1B,YAAY,oEAAc;AAC1B,YAAY,yEAAmB;AAC/B,YAAY,yEAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY,qEAAe;AAC3B,YAAY,qEAAe;AAC3B,iCAAiC,+CAAI;AACrC,0CAA0C,gDAAK;AAC/C,kCAAkC,gDAAK;AACvC;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,iEAAe,WAAW,EAAC;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,oBAAoB,gDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gDAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,sEAAsE,mBAAmB,IAAI,sBAAsB,oCAAoC,MAAM;AAC7J;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAmB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iDAAM,wBAAwB,iDAAM;AAClE;AACA,uEAAuE,MAAM;AAC7E;AACA;AACA;AACA;AACA;AACA,kCAAkC,MAAM,iDAAM,MAAM;AACpD;AACA,wCAAwC,MAAM,GAAG,gDAAK;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,MAAM;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,iBAAiB,MAAM,uBAAuB,wBAAwB,aAAa;AAC1I;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA,sDAAsD,cAAc,QAAQ,WAAW,UAAU,MAAM;AACvG;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,kFAAmB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kFAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kFAAmB;AAC9C;AACA;AACA,gCAAgC,kFAAmB;AACnD;AACA;AACA;AACA;AACA;AACA,gCAAgC,kFAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,WAAW;AAC/D;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACv+BgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8DAAe;AAC7C,+BAA+B,8DAAe;AAC9C;AACA,iEAAe,qBAAqB,EAAC;;;;;;;;;;;;;;;;;;;;ACnBC;AACgC;AACS;AACb;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gDAAK;AAC5B;AACA;AACA,uBAAuB,gDAAK;AAC5B;AACA;AACA;AACA;AACA;AACA,YAAY,4BAA4B,EAAE,4EAAW;AACrD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,iCAAiC,kFAA4B;AAC7D;AACA;AACA,oCAAoC,kFAA4B;AAChE;AACA;AACA,QAAQ,sEAAqB;AAC7B;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;ACtD6D;;;;;;;;;;;;;;;;;;ACAtD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN;AACA;AACA;AACoC;AACF;AACJ;AACM;AACqF;AACpF;AAC8B;AACZ;AACzB;AACS;AACF;AACH;AACE;AACE;AACF;AACE;AAC+B;AACD;AACC;AACpC;AACjC;AACgE;AACF;AAC3B;AACnC;AACA;AACA;AACA;AACA;AAC0C;AAC1C,iEAAe,mDAAM,EAAC;;;;;;;;;;;;;;;;;;;;AC9CqD;AACK;AACE;AACR;AACL;AAC9D;AACP,OAAO,iFAA0B;AACjC,OAAO,4EAAuB;AAC9B,OAAO,kFAA0B;AACjC,OAAO,sFAA4B;AACnC,OAAO,wFAA+B;AACtC;AACA;AACA;AACA;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;AACA,uDAAuD,mBAAmB;AAC1E,uDAAuD,mBAAmB;AAC1E;AACA;AACA;;;;;;;;;;;;;;;;ACvBkE;AAClE;AACA;AACA,OAAO,wEAAyB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,UAAU;AAChE,uDAAuD,UAAU;AACjE,gDAAgD,YAAY;AAC5D,qDAAqD,OAAO;AAC5D,+CAA+C,MAAM,EAAE,MAAM;AAC7D,kEAAkE,QAAQ;AAC1E;AACA,qCAAqC,UAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,UAAU,MAAM,cAAc;AAChG,8CAA8C,UAAU;AACxD,+CAA+C,UAAU;AACzD;AACA,2CAA2C,WAAW,SAAS,4BAA4B;AAC3F,uDAAuD,UAAU,GAAG,WAAW;AAC/E,mDAAmD,sBAAsB;AACzE,sDAAsD,aAAa,EAAE,iBAAiB;AACtF,0DAA0D,aAAa,EAAE,iBAAiB;AAC1F,yCAAyC,mBAAmB;AAC5D;AACA;AACA;AACA,+BAA+B,mBAAmB,OAAO,8DAA8D;AACvH;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO,SAAS,wBAAwB;AAC5E;AACA;AACA,oCAAoC,KAAK;AACzC,yCAAyC,OAAO;AAChD,yCAAyC,OAAO;AAChD,oCAAoC,QAAQ;AAC5C,8CAA8C,WAAW;AACzD,mCAAmC,MAAM;AACzC;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA,iDAAiD,oBAAoB;AACrE,iDAAiD,oBAAoB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,aAAa,EAAE,kBAAkB;AAClG;AACA,oEAAoE,MAAM;AAC1E,gDAAgD,oBAAoB;AACpE;AACA,iEAAe,YAAY,EAAC;;;;;;;;;;;;;;;;ACpHsC;AAClE;AACA;AACA,OAAO,wEAAyB;AAChC;AACA,iEAAe,YAAY,EAAC;;;;;;;;;;;;;;;;ACLsC;AAClE;AACA;AACA,OAAO,wEAAyB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D,6CAA6C,UAAU;AACvD;AACA,2BAA2B,UAAU;AACrC,KAAK;AACL,yCAAyC,YAAY;AACrD;AACA,uCAAuC,MAAM;AAC7C,KAAK;AACL,sDAAsD,MAAM,EAAE,MAAM;AACpE,2DAA2D,QAAQ;AACnE,iCAAiC,MAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,OAAO;AACjC,oDAAoD,OAAO;AAC3D,8CAA8C,UAAU;AACxD,+CAA+C,UAAU;AACzD,yEAAyE,UAAU,GAAG,UAAU;AAChG,iEAAiE,UAAU,EAAE,qBAAqB;AAClG;AACA,0CAA0C,WAAW;AACrD;AACA;AACA,iDAAiD,oBAAoB;AACrE,iDAAiD,oBAAoB;AACrE;AACA,iEAAe,YAAY,EAAC;;;;;;;;;;;;;;;;;;;;;ACnFsC;AACtC;AACA;AACA;AACrB;AACP,MAAM;AACN,MAAM;AACN,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,wEAAyB;AACvF;AACA,iEAAe,oBAAoB,EAAC;;;;;;;;;;;;;;;;;;;;;;AC3D0B;AACb;AACW;AACf;AACe;AACM;AAC3D;AACP;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,oEAAa;AACnD,sCAAsC,oEAAa;AACnD;AACA;AACA,uDAAuD,KAAK;AAC5D;AACA,gCAAgC,uEAAgB;AAChD;AACA,qCAAqC,+CAAI;AACzC,yBAAyB,mEAAc;AACvC;AACA;AACA,+BAA+B,oEAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qEAAc;AACzC,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gCAAgC,uDAAe;AAC/C,+BAA+B,uDAAe;AAC9C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,YAAY;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qEAAc;AAChD,kCAAkC,qEAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,uDAAe;AAC7D,0BAA0B,uDAAe;AACzC,6BAA6B,+CAAI;AACjC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iDAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC7P4E;AAC5E;AACO;AACP;AACA;AACA;AACA,eAAe,+CAAI;AACnB;AACA;AACA,wEAAwE,cAAc;AACtF,sBAAsB,gCAAgC;AACtD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,+CAAI;AAC/C;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,+CAAI;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,+CAAI,UAAU,MAAM,iDAAM,cAAc;AAC/E,2BAA2B,gDAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gDAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAI;AAC7B;AACA,0BAA0B,0DAAe,yBAAyB,0DAAe;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,0DAAe;AAC7D;AACA;AACA;AACA,sBAAsB,0DAAe;AACrC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,sBAAsB,0DAAe;AACrC;AACA,aAAa;AACb;AACA;AACA;AACA,wBAAwB,+CAAI;AAC5B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChKuC;AAChC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,mBAAmB,iDAAM;AACzB;AACA;AACA;AACA;AACA,cAAc,iDAAM;AACpB;AACA;AACA;;;;;;;;;;;;;;;;;;AC7CgF;AACzE;AACP;AACA;AACA,wBAAwB,+DAAU;AAClC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kEAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,wBAAwB,gEAAW;AACnC;AACA;;;;;;;;;;;;;;;;AC7BsC;AACtC;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAK,6EAA6E,gDAAK;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvD8C;AACvC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wDAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B,qBAAqB,iBAAiB;AAC/E,eAAe,cAAc;AAC7B,mDAAmD,+CAA+C;AAClG;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC3DsC;AACsB;AACI;AACjD;AACf;AACA,iCAAiC,uEAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+DAAkB,KAAK,gDAAK;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClDA;AAC8F;AAChD;AAC9C;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gDAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iDAAM;AAC5B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0EAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,wBAAwB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iDAAM;AAChD,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iFAAyB;AACpE,iDAAiD,mBAAmB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iDAAM;AAC5C,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gDAAK;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iDAAM;AACxC,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,iCAAiC;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrViF;AACN;AACJ;AACM;AACT;AACyD;;;;;;;;;;;;;;;ACLtH;AACP,2CAA2C,OAAO;AAClD,2CAA2C,OAAO;AAClD,gDAAgD,WAAW;AAC3D,oCAAoC,QAAQ;AAC5C,oCAAoC,MAAM;AAC1C;AACA;AACA;;;;;;;;;;;;;;;;;;ACR4D;AACN;AACS;AAC/D;AACA;AACA;AACA,SAAS;AACT;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8BAA8B;AAClD,+BAA+B,gEAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,0DAAe;AACpD;AACA;AACA,0CAA0C,0DAAe;AACzD;AACA;AACA,0CAA0C,0DAAe;AACzD;AACA;AACA,0CAA0C,0DAAe;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,kBAAkB;AAC9E,oDAAoD,iBAAiB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+CAAI;AACzB,sBAAsB,yEAAgB;AACtC;AACA;AACA;AACA,qBAAqB,+CAAI;AACzB,sBAAsB,yEAAgB,SAAS,MAAM;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,MAAM;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,+CAAI;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnLiE;AACpB;AACW;AACO;AAC/D;AACA;AACA;AACA;AACA;AACA;AACe,6BAA6B,6DAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO,0BAA0B,KAAK;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yEAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qEAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA,iCAAiC,iDAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,EAAE;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;;;;;;;;;;;;;;;;AC9PqC;AACmB;AACxD;AACe,4BAA4B,6DAAgB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+CAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,wBAAwB;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO,0BAA0B,KAAK;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC5G6D;AACqE;AAC5E;AACE;AACS;AACF;AACxD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACe,0BAA0B,6DAAgB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qBAAqB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,8DAAe;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2EAAkB;AACvC;AACA;AACA;AACA,aAAa,gEAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,+CAAI;AAC5D,sCAAsC,8DAAe,gBAAgB;AACrE,sCAAsC,8DAAe,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,0EAAoB;AAC7D,8CAA8C,+EAAyB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,mFAA6B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qEAAe;AAC/B;AACA;AACA;AACA;AACA,4EAA4E,YAAY;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C,uCAAuC,QAAQ;AAC/C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gDAAK;AACzC;AACA;AACA;AACA;AACA;AACA,uEAAuE,8DAAe;AACtF,qCAAqC,8DAAe;AACpD,sCAAsC,8DAAe;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;;;;;;;;;;;;;;;;AC3ZqC;AACmB;AACxD;AACe,+BAA+B,6DAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iBAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,4DAA4D,YAAY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,SAAS,gBAAgB,YAAY;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;AC3KwF;AAC5C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,YAAY;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uDAAU;AACjC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,YAAY;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kGAAyB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,uBAAuB,EAAC;;;;;;;;;;;;;;;;;;ACrI8C;AAC1B;;;;;;;;;;;;;;;ACD3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,kBAAkB,EAAC;;;;;;;;;;;;;;;;;;ACZ6B;AACI;;;;;;;;;;;;;;;;;;ACDT;AACN;AACQ;AAC5D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,0EAA0E,uDAAa;AACvF,eAAe,mEAAkB;AACjC,wBAAwB,oDAAO,oCAAoC,0DAAY;AAC/E;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iEAAe,YAAY,EAAC;;;;;;;;;;;;;;;;;;ACnB8B;AACN;AACQ;AAC5D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mEAAkB;AACpC,wBAAwB,oDAAO,wCAAwC,0DAAY,uCAAuC,uDAAa;AACvI;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iEAAe,cAAc,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpD9B,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACA;AACiD;AACwC;AACvB;AACK;AACtB;AACF;AACA;AACN;AACiB;AACE;AACU;AACV;AACA;AACE;AACM;AACgB;AACJ;AACzC;AACc;AACW;AACA;AACQ;AACxE;AACA;AACA;AACA,QAAQ,wBAAwB,GAAG,0BAA0B,OAAO,sBAAsB;AAC1F;AACA;AACA;AACA,4CAA4C,yEAA0B;AACtE;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA,YAAY,wDAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,6DAAgB,CAAC;AACrE;AACA;AACA;AACA;AACA,gBAAgB,yDAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAM;AAClB,YAAY,kDAAM;AAClB,YAAY,kDAAM;AAClB,YAAY,kDAAM;AAClB,YAAY,kDAAM;AAClB,YAAY,kDAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,IAAI,YAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,uDAAe;AAClH,+BAA+B,uDAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mGAAmG,uDAAe;AAClH,+BAA+B,uDAAe;AAC9C;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,yDAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qEAAc;AACtB,QAAQ,mEAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,UAAU;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wEAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8BAA8B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,2BAA2B,sEAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,2BAA2B,sEAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,sEAAgB;AAC/D;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA,+CAA+C,sEAAgB;AAC/D;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uDAAe;AAC/C,+BAA+B,uDAAe;AAC9C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sDAAO;AACvC,mCAAmC,kEAAa;AAChD;AACA;AACA,qCAAqC,yDAAU;AAC/C,mCAAmC,qEAAY;AAC/C;AACA,qCAAqC,8EAAa;AAClD,mCAAmC,yEAAmB;AACtD;AACA,qCAAqC,2DAAQ;AAC7C,mCAAmC,oEAAc;AACjD;AACA,qCAAqC,0DAAW;AAChD,mCAAmC,oEAAc;AACjD;AACA;AACA;AACA;AACA;AACA,sBAAsB,gCAAgC,KAAK,wBAAwB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gCAAgC,KAAK,wBAAwB;AAC/F;AACA;AACA,2BAA2B,8EAAwB;AACnD,2BAA2B,yFAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,eAAe,EAAC;;;;;;;;;;;;;;;;;;;;ACrdmC;AACN;AACN;AACD;AACrD;AACA;AACA;AACA;AACA,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,0BAA0B,sBAAsB;AAChD;AACA;AACA,MAAM;AACN,MAAM;AACN,MAAM;AACN;AACO;AACP;AACA;AACe,8BAA8B,4DAAe;AAC5D;AACA,oDAAoD,yEAA0B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,4DAAgB,CAAC;AACzD,wCAAwC,4DAAgB,CAAC;AACzD,wCAAwC,4DAAgB,CAAC;AACzD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,8CAA8C;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,gCAAgC,4DAAgB,CAAC;AACjD;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mEAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACjM8D;AACT;AACkC;AACL;AAC5B;AACkD;AAChD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0BAA0B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN,MAAM;AACN,MAAM;AACN;AACO;AACP;AACA;AACe,0BAA0B,4DAAe;AACxD;AACA;AACA;AACA;AACA;AACA,+CAA+C,4DAAgB,CAAC;AAChE,+CAA+C,4DAAgB,CAAC;AAChE,+CAA+C,4DAAgB,CAAC;AAChE;AACA;AACA;AACA;AACA;AACA,QAAQ,2FAAqC;AAC7C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kEAAa;AAC3C,wBAAwB,kEAAa;AACrC;AACA;AACA,4CAA4C,4DAAgB,CAAC;AAC7D;AACA,+CAA+C,4DAAgB,CAAC,cAAc,4DAAgB,CAAC;AAC/F,+CAA+C,4DAAgB,CAAC;AAChE;AACA;AACA;AACA;AACA;AACA,wEAAwE,EAAE;AAC1E;AACA;AACA;AACA;AACA;AACA,+DAA+D,GAAG;AAClE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yEAAoB;AAChD,iCAAiC,oFAAwB;AACzD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kBAAkB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,qBAAqB,EAAE,4DAAgB,CAAC,yBAAyB,aAAa;AACzI,wDAAwD,qBAAqB,EAAE,4DAAgB,CAAC,mCAAmC,aAAa;AAChJ;AACA;AACA;AACA;AACA,yCAAyC,qBAAqB;AAC9D;AACA;AACA;AACA;AACA,+DAA+D,qBAAqB,EAAE,4DAAgB,CAAC,0BAA0B,aAAa;AAC9I,4DAA4D,qBAAqB,EAAE,4DAAgB,CAAC,oCAAoC,aAAa;AACrJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,iBAAiB;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qEAAgB;AAC1C;AACA;AACA;AACA,0BAA0B,qEAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+BAA+B,oEAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oBAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACrWA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AAC6C;AACsB;AAC1B;AACkD;AACR;AAChC;AAC+C;AAClG;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD,2BAA2B,yEAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA,kBAAkB,0EAAiB;AACnC,cAAc,kDAAkD;AAChE,cAAc,+CAA+C;AAC7D,cAAc,+CAA+C;AAC7D;AACA,KAAK;AACL,+BAA+B,GAAG;AAClC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,gBAAgB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yEAAgB;AACrC;AACA;AACA,gBAAgB,yEAAgB;AAChC;AACA,wBAAwB,yEAAgB;AACxC;AACA,sCAAsC,0EAAiB;AACvD,kCAAkC,0CAA0C;AAC5E,kCAAkC,sCAAsC;AACxE,kCAAkC,0CAA0C;AAC5E;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB,gBAAgB,yEAAgB;AAChC,mCAAmC,yDAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB,UAAU;AAC7C,gBAAgB,mBAAmB,UAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB,yEAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,kBAAkB,GAAG;AAC5B,OAAO,kBAAkB,GAAG;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,wBAAwB,GAAG;AAClC;AACA,OAAO,wBAAwB,GAAG;AAClC,wBAAwB,mBAAmB,KAAK,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sBAAsB,GAAG,uBAAuB;AACtF,+BAA+B,iDAAM;AACrC;AACA;AACA;AACA,oBAAoB,uEAAc;AAClC;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,uBAAuB,uEAAc,GAAG,qDAAqD,IAAI,oDAAoD;AACrJ,qBAAqB,uEAAc,GAAG,yEAAyE;AAC/G;AACA,UAAU,sDAAsD,IAAI,sDAAsD;AAC1H;AACA,UAAU,0DAA0D,IAAI,uCAAuC;AAC/G;AACA;AACA,gCAAgC,yEAAgB;AAChD;AACA,SAAS;AACT,qBAAqB,yEAAgB;AACrC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+CAAI;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB,+CAAI;AACrB;AACA;AACA;AACA;AACA,6BAA6B,qDAAQ,UAAU;AAC/C;AACA;AACA;AACA;AACA,kCAAkC,+CAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,4EAAW;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,2BAA2B,4EAAW;AACtC;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,OAAO;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sBAAsB,sBAAsB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sCAAsC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB,0BAA0B;AAC5E;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iGAAuB,yBAAyB,yFAAmB;AACvG;AACA;AACA,oCAAoC,yFAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,YAAY,EAAC;;;;;;;;;;;;;;;ACp0BrB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACA6B;AACsB;AACK;AACD;AACR;;;;;;;;;;;;;;;;ACJuB;AACtE;AACP,OAAO,oFAA+B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,QAAQ;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,GAAG;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D,6CAA6C,UAAU;AACvD,8CAA8C,UAAU;AACxD,yCAAyC,YAAY;AACrD,6DAA6D,MAAM;AACnE,+CAA+C,MAAM,EAAE,MAAM;AAC7D,yDAAyD,QAAQ;AACjE;;;;;;;;;;;;;;;;;;;;AClGA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACsC;AACY;AACoB;AACO;AACc;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,mBAAmB,gDAAK;AACxB;AACA,8EAA8E,gDAAK;AACnF,eAAe,gDAAK;AACpB;AACA;AACA;AACA;AACA;AACA,4BAA4B,wCAAwC;AACpE,yBAAyB,iCAAiC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAK;AAC/B;AACA;AACA,kCAAkC,gDAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gDAAK;AACpC;AACA,gCAAgC,8BAA8B;AAC9D;AACA;AACA;AACA,iCAAiC,gDAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4EAAsB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,qBAAqB;AAC5E,sDAAsD,qBAAqB;AAC3E;AACA,gBAAgB,mFAA6B,2BAA2B,YAAY;AACpF,2CAA2C,qDAAqD;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,8BAA8B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yEAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8DAAa;AAC1C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,+CAA+C;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,WAAW,EAAC;;;;;;;;;;;;;;;ACtbpB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI,eAAe;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+CAAI;AAC9B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+CAAI;AACvC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iEAAe,aAAa,EAAC;;;;;;;;;;;;;;;;AC5H7B,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AAC4C;AAC5C,iCAAiC,uDAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,kBAAkB,EAAC;;;;;;;;;;;;;;;;;ACvDU;AACU;AACtD;AACA;AACA;AACA,+DAA+D,4DAAgB,CAAC;AAChF;AACe,6BAA6B,uDAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACzDA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AAC8E;AACiB;AACzC;AACmB;AACkB;AACtC;AACQ;AAC7D;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA,2FAA2F,gCAAgC;AAC3H;AACA;AACA;AACA;AACA,+BAA+B,uCAAuC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yEAAqB;AAC9D;AACA;AACA;AACA;AACA,wCAAwC,4DAAgB,CAAC,mBAAmB,4DAAgB,CAAC,yBAAyB,4DAAgB,CAAC,oBAAoB,kCAAkC;AAC7L;AACA;AACA;AACA,qCAAqC,4DAAgB,CAAC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mFAA6B;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,IAAI;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAwD;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,4EAA0B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yEAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6BAA6B,oBAAoB,8BAA8B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8DAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4DAAgB,CAAC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4DAAgB,CAAC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,yEAAsB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iEAAe,UAAU,EAAC;;;;;;;;;;;;;;;;;;;;;;;;AC/eqB;AACgB;AACkC;AAC5B;AAC/B;AACc;AACE;AACS;AACnB;AAC5C,uCAAuC,uDAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uDAAe;AAC/C;AACA,SAAS;AACT,sCAAsC,wEAAoB;AAC1D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2EAAmB;AACxD;AACA;AACA;AACA,mBAAmB,2DAAK;AACxB;AACA;AACA;AACA;AACA,kCAAkC,2EAAmB;AACrD;AACA,eAAe,uEAAa;AAC5B;AACA;AACA;AACA;AACA,sDAAsD,QAAQ;AAC9D;AACA,qCAAqC,2EAAmB;AACxD;AACA;AACA;AACA,eAAe,+EAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gDAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4DAAgB,CAAC,gBAAgB,4DAAgB,CAAC,kCAAkC,4DAAgB,CAAC;AACxI;AACA;AACA;AACA;AACA;AACA,oBAAoB,mJAAmJ,EAAE,0EAAc;AACvL;AACA;AACA;AACA,aAAa;AACb,+BAA+B,4DAAgB,CAAC,0BAA0B,qCAAqC;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,gBAAgB,6FAA6F;AAC7G;AACA;AACA;AACA;AACA,oCAAoC,4DAAgB,CAAC,wBAAwB,qCAAqC;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,gBAAgB,mDAAmD;AACnE;AACA,mDAAmD,+EAAc;AACjE;AACA;AACA;AACA;AACA,oCAAoC,+EAAc;AAClD;AACA,oCAAoC,+EAAc;AAClD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAAgB,CAAC,4BAA4B,qCAAqC;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,SAAS;AACT;AACA,8CAA8C,eAAe;AAC7D,SAAS;AACT;AACA,gBAAgB,yDAAyD;AACzE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,+EAAc;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,wBAAwB,EAAC;;;;;;;;;;;;;;;;;;;;ACvPc;AACF;AACE;AACF;AACqB;AACzE,+BAA+B,2DAAc;AAC7C;AACA;AACA;AACA;AACA,gCAAgC,uDAAe;AAC/C,iCAAiC,uDAAe;AAChD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4DAAgB,CAAC,mBAAmB,6BAA6B;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,yDAAU,cAAc,yDAAU;AACjF;AACA;AACA,yEAAyE,yDAAU;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,mCAAmC,4DAAgB,CAAC,gBAAgB,4DAAgB,CAAC;AACrF,gCAAgC,+EAAmB;AACnD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,iBAAiB;AAC3E;AACA;AACA;AACA;AACA;AACA,8BAA8B,yDAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,gBAAgB,EAAC;;;;;;;;;;;;;;;;;;AClG4B;AACN;AACK;AAC3D,+BAA+B,+DAAkB;AACjD,sEAAsE;AACtE;AACA;AACA;AACA;AACA,SAAS;AACT,sBAAsB,6DAAgB;AACtC;AACA;AACA;AACA;AACA;AACA,kDAAkD,kEAAoB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,gBAAgB,EAAC;;;;;;;;;;;;;;;;;;;;;;;AC1BM;AAC2B;AACb;AACR;AACU;AACF;AACR;AACiB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,4DAAgB,CAAC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uDAAe;AACtC,2BAA2B,uDAAe;AAC1C;AACA;AACA,6DAA6D,gDAAK;AAClE;AACA,KAAK;AACL;AACA;AACA,gCAAgC,gDAAK;AACrC,wBAAwB,qDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAU;AACvC;AACA,kCAAkC,KAAK;AACvC;AACA;AACA;AACA;AACA;AACA,2BAA2B,uDAAe;AAC1C,iCAAiC,uDAAe;AAChD,uDAAuD,2DAAW;AAClE;AACA;AACA;AACA,wDAAwD,2DAAW;AACnE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,eAAe;AACzD,6BAA6B,2DAAc;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,2DAAW;AACnG,wFAAwF,2DAAW;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,0DAAO;AACrD;AACA;AACA;AACA;AACA,gEAAgE,0DAAO;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,4DAAgB,CAAC;AACnE,QAAQ,yEAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2DAAW;AAChD,uCAAuC,2DAAW;AAClD;AACA;AACA;AACA;AACA,oDAAoD,2DAAW;AAC/D;AACA;AACA,oDAAoD,2DAAW;AAC/D;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtMA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5DsE;AACpB;AACS;AACO;AACW;AACjC;AACC;AACU;AACE;AACK;AACW;AACH;AAClB;AACc;AAClB;AAChD;AACA;AACA;AACA,2EAA2E,2BAA2B;AACtG;AACA;AACA;AACA,YAAY,6CAA6C;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uDAAU;AAC1C;AACA;AACA;AACA;AACA;AACA,2BAA2B,uDAAe;AAC1C,+BAA+B,uDAAe;AAC9C;AACA;AACA,SAAS;AACT,sBAAsB,0EAAoB;AAC1C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,4DAAgB,CAAC,gBAAgB,4DAAgB,CAAC;AAC7H,gBAAgB,2CAA2C,EAAE,yEAAa;AAC1E;AACA;AACA;AACA,SAAS;AACT;AACA,6BAA6B,4EAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,gCAAgC;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,8DAAY;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB,EAAE,4DAAY;AAC7D;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc,EAAE,wEAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,8EAAa;AACxF;AACA;AACA;AACA,0EAA0E,sEAAc;AACxF;AACA;AACA,iCAAiC,4DAAY;AAC7C;AACA,+BAA+B,oCAAoC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gDAAK;AACjC;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sEAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+CAAI;AAClC,+CAA+C,gDAAK;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,2DAAK;AAClD;AACA;AACA;AACA;AACA;AACA,iDAAiD,gDAAK;AACtD;AACA;AACA,sCAAsC,8DAAW;AACjD;AACA,yCAAyC,uEAAa;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,iBAAiB,EAAC;;;;;;;;;;;;;;;;;AC7RiC;AAC5B;AACtC;AACA;AACA;AACA,4BAA4B,qEAAe;AAC3C;AACA;AACA;AACA;AACA,uBAAuB,gDAAK;AAC5B,SAAS;AACT;AACA;AACA;AACA,iEAAe,YAAY,EAAC;;;;;;;;;;;;;;;;ACfgB;AAC7B,6BAA6B,uDAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvEgF;AACc;AACkC;AAClD;AAC+C;AACnC;AACtC;AACW;AACX;AACb;AACmC;AACpB;AACmB;AACN;AACmB;AACtF;AACA,0DAA0D,WAAW;AACrE;AACA,aAAa,4CAA4C;AACzD;AACA,4BAA4B,2DAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mIAAwC;AACjE,aAAa;AACb;AACA;AACA;AACA,yBAAyB,iGAAuB;AAChD,aAAa;AACb;AACA;AACA;AACA,yBAAyB,0FAAmB;AAC5C,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mFAAgB;AACzC,aAAa;AACb;AACA;AACA;AACA;AACA,yBAAyB,iFAAe;AACxC,aAAa;AACb;AACA;AACA;AACA;AACA,yBAAyB,iGAA0B;AACnD,aAAa;AACb;AACA;AACA;AACA;AACA,yBAAyB,mGAA4B;AACrD,aAAa;AACb;AACA;AACA;AACA;AACA,yBAAyB,6FAAyB;AAClD,aAAa;AACb;AACA;AACA,gCAAgC,uDAAe;AAC/C,iCAAiC,uDAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iGAAuB;AACrD,8BAA8B,mIAAwC;AACtE,8BAA8B,0FAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,4BAA4B,6EAAgB;AAC5C;AACA,8BAA8B,6EAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,wDAAwD,6DAAgB,CAAC;AACzE;AACA;AACA,oCAAoC,6DAAgB,CAAC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,QAAQ;AACnE;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6DAAgB,CAAC,gBAAgB,6DAAgB,CAAC;AACrF;AACA,gBAAgB,kDAAkD,EAAE,gFAAmB;AACvF;AACA,SAAS;AACT;AACA;AACA,kCAAkC,0EAAc;AAChD;AACA,SAAS;AACT,gBAAgB,oDAAoD;AACpE,2BAA2B,6DAAgB,CAAC,YAAY,0BAA0B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,IAAI,kFAAmC,SAAS;AACxE,6BAA6B,kFAAmC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,aAAa,2BAA2B,aAAa;AAC/G,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA,+BAA+B,iDAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,aAAa,EAAC;;;;;;;;;;;;;;;;;;AC1V+B;AACN;AACK;AAC3D,+BAA+B,+DAAkB;AACjD,sEAAsE;AACtE;AACA;AACA;AACA;AACA,SAAS;AACT,sBAAsB,6DAAgB;AACtC;AACA;AACA;AACA;AACA;AACA,kDAAkD,kEAAoB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,gBAAgB,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;AC3BO;AAC4C;AACpB;AACX;AACW;AACH;AACR;AACyB;AAChB;AACP;AACtD;AACA;AACA,wDAAwD,4DAAgB,CAAC,gBAAgB,4DAAgB,CAAC;AAC1G;AACA;AACA,8BAA8B,0EAAc;AAC5C;AACA;AACA;AACA;AACA,oBAAoB,0FAAqB;AACzC,gEAAgE,OAAO;AACvE;AACA;AACA,kCAAkC,uEAAa;AAC/C;AACA;AACA,KAAK;AACL,YAAY,oDAAoD;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0FAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iDAAM;AAC7C;AACA;AACA;AACA;AACA,uCAAuC,iDAAM;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACe,kCAAkC,2DAAc;AAC/D;AACA;AACA;AACA;AACA,iCAAiC,+DAAkB;AACnD;AACA,SAAS;AACT;AACA,iCAAiC,+DAAkB;AACnD;AACA;AACA;AACA,SAAS;AACT;AACA,oCAAoC,+DAAkB;AACtD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uDAAe;AAC/C,iCAAiC,uDAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,oFAAsC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,4DAAgB,CAAC;AAC5D;AACA,QAAQ,yEAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxJuC;AACa;AACE;AACS;AACX;AACpD,6BAA6B,2DAAc;AAC3C;AACA;AACA;AACA;AACA,2BAA2B,uDAAe;AAC1C,6BAA6B,uDAAe;AAC5C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4DAAgB,CAAC,gBAAgB,4DAAgB,CAAC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mFAAmF,EAAE,0EAAc;AACnH;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4DAAgB,CAAC,oBAAoB,2BAA2B;AAC3F;AACA,0BAA0B,4DAAgB,CAAC,mBAAmB,2BAA2B;AACzF;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAAgB,CAAC,mBAAmB,2BAA2B;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,cAAc,EAAC;;;;;;;;;;;;;;;;;;;ACnHS;AACoB;AACJ;AACvD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uBAAuB,iDAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uDAAe;AACpD,sBAAsB,uDAAe;AACrC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAe;AAChD,kBAAkB,uDAAe;AACjC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iCAAiC,uDAAe;AAChD,kBAAkB,uDAAe;AACjC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,eAAe;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,8DAAW;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,iEAAe,cAAc,EAAC;;;;;;;;;;;;;;;;ACtJgC;AAC9D;AACA;AACA;AACA;AACA;AACA,6CAA6C,8DAA8D,IAAI;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+DAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,eAAe;AACjE;AACA;AACA;AACA;AACA;AACA,2CAA2C,EAAE,EAAE,MAAM,EAAE,EAAE;AACzD;AACA,4BAA4B,qBAAqB;AACjD,8BAA8B,sBAAsB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iEAAe,aAAa,EAAC;;;;;;;;;;;;;;;;;;;AC7K4C;AACqC;AAChB;AACrC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,4DAAgB,CAAC;AACrD,0BAA0B,yEAAoB;AAC9C;AACA;AACA,0BAA0B,4DAAgB,CAAC,kBAAkB,YAAY;AACzE,IAAI,2FAAqC;AACzC;AACA;AACA;AACA;AACA;AACA,4BAA4B,4DAAgB,CAAC,iBAAiB,YAAY;AAC1E;AACA;AACA;AACA;AACA;AACA,uBAAuB,4DAAgB,CAAC,sBAAsB,YAAY;AAC1E;AACA;AACA,QAAQ,mFAA6B;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iEAAe,gBAAgB,EAAC;;;;;;;;;;;;;;;AC9IhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iEAAe,aAAa,EAAC;;;;;;;;;;;;;;;;;ACbiF;AACtB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yEAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kEAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,sCAAsC;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,kBAAkB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kEAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,MAAM;AAC7D;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,wBAAwB,kEAAa;AACrC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI,2FAAqC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,eAAe,EAAC;;;;;;;;;;;;;;;;;ACtKiB;AACS;AACzD;AACA;AACA;AACA;AACA;AACA,+BAA+B,4DAAgB,CAAC;AAChD;AACA,2BAA2B,4DAAgB,CAAC,gBAAgB,YAAY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,UAAU;AAC1C,gCAAgC,UAAU;AAC1C,iCAAiC,8DAAe,+BAA+B;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iEAAe,mBAAmB,EAAC;;;;;;;;;;;;;;;;;;;AC5CiD;AACpF;AACO;AACP,8EAAuB;AACvB;AACO,yHAAyH,GAAG;AACnI,gBAAgB,gDAAgD;AAChE;AACA,IAAI,8EAAuB,yDAAyD,MAAM;AAC1F;AACA;AACO;AACP,8EAAuB;AACvB;AACO;AACP,8EAAuB;;;;;;;;;;;;;;;;;;;ACfgC;AACM;AACJ;AACS;AAClE;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kEAAa;AACpC;AACA,gDAAgD,4DAAgB,CAAC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+BAA+B;AAChE;AACA;AACA;AACA;AACA;AACA,kCAAkC,wBAAwB;AAC1D;AACA;AACA;AACA;AACA,wDAAwD,mBAAmB,EAAE,kBAAkB;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gDAAgD,0BAA0B;AAC1E,oDAAoD,kBAAkB,UAAU,cAAc;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA,4BAA4B,4DAAe;AAC3C,6DAA6D,gCAAgC;AAC7F;AACA;AACA;AACA;AACA;AACA,kCAAkC,uDAAe;AACjD,0BAA0B,uDAAe;AACzC;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT,8DAA8D,UAAU;AACxE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uDAAe;AAClD,qCAAqC,uDAAe;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;;;;;;;;;;;;;;;;AChMkE;AACnD;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kEAAa;AACjD;AACA;AACA;AACA;AACA;AACA,wBAAwB,kEAAa;AACrC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxD2E;AACR;AACU;AACZ;AACE;AACA;AACU;AACN;AACoB;AACJ;;;;;;;;;;;;;;;;;;ACTvF,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACiD;AACI;AACO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,kEAAa;AACrE;AACA;AACA;AACA;AACA,uCAAuC,uDAAe;AACtD,0BAA0B,uDAAe;AACzC;AACA,iBAAiB;AACjB;AACA;AACA,uCAAuC,uDAAe;AACtD,0BAA0B,uDAAe;AACzC;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0DAAY;AAC7B;AACA,iBAAiB,0DAAY;AAC7B;AACA;AACA,iBAAiB,0DAAY;AAC7B;AACA,iBAAiB,0DAAY;AAC7B;AACA;AACA,iBAAiB,0DAAY;AAC7B;AACA,iBAAiB,0DAAY;AAC7B;AACA,iBAAiB,0DAAY;AAC7B;AACA,iBAAiB,0DAAY;AAC7B;AACA,iBAAiB,0DAAY;AAC7B;AACA,iBAAiB,0DAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,QAAQ,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;AClLyB;AACT;AACgC;AAC5B;AACK;AACoD;AACzC;AACP;AACO;AACa;AAClE;AACP;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA,6BAA6B,qDAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,uDAAa;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,qBAAqB,qDAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kEAAa;AAC3C;AACA;AACA,0CAA0C,uDAAe;AACzD,sBAAsB,uDAAe;AACrC;AACA,aAAa;AACb,SAAS;AACT,yBAAyB,kEAAa;AACtC;AACA,0CAA0C,uDAAe;AACzD,sBAAsB,uDAAe;AACrC;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAM;AACxB,sBAAsB,yBAAyB,iDAAM,OAAO;AAC5D;AACA,0BAA0B,mFAAgB,CAAC,+CAAI;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAI;AAC7B,eAAe,gDAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uDAAY;AACrC,uBAAuB,gDAAK;AAC5B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,2DAAK;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+CAAI;AACtC;AACA;AACA;AACA;AACA;AACA,qCAAqC,2DAAK;AAC1C,uDAAuD,8DAAW;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2DAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,uDAAa;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,8DAAW;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2DAAK;AACrC;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,iCAAiC,uEAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4EAA8B;AACpE;AACA;AACA,2CAA2C,4EAA8B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4BAA4B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxSA;AACA;AACA;AAC8D;AACE;AACxB;AAC0B;AAClE;AACe,uBAAuB,qDAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,UAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qEAAa;AAClD;AACA;AACA,0CAA0C,sEAAc;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,UAAU,eAAe,cAAc;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,yEAA2B;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,yEAA2B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClIqE;AACvB;AACiE;AAC3D;AACrC,oCAAoC,wDAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uDAAa;AAC7C;AACA;AACA;AACA;AACA,iBAAiB,8DAAY;AAC7B;AACA;AACA;AACA,0BAA0B,0DAAY;AACtC;AACA;AACA,iBAAiB;AACjB;AACA;AACA,8BAA8B,0DAAY;AAC1C,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,2BAA2B,0DAAY;AACvC;AACA;AACA;AACA;AACA;AACA,kDAAkD,uEAAqB,gBAAgB,6FAAgC;AACvH;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0DAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0DAAY;AAC5C;AACA;AACA,0DAA0D,uDAAa;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzEA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,WAAW,EAAC;;;;;;;;;;;;;;;;ACnC3B,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACA;AAC8C;AAC9C;AACA;AACA;AACA,4BAA4B,wDAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,aAAa,EAAC;;;;;;;;;;;;;;;;;;;AChDyC;AACxB;AACT;AAC0C;AAC/E;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAAI;AAC5B;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6EAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,gCAAgC,WAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,8BAA8B,wDAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAY,0BAA0B,0DAAY;AAC9D;AACA;AACA;AACA,2BAA2B,0DAAY;AACvC;AACA;AACA;AACA;AACA;AACA,2BAA2B,0DAAY;AACvC;AACA;AACA,gCAAgC,0DAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0DAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAY,0BAA0B,0DAAY;AAC9D,+BAA+B,0DAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0DAAY;AAC3C,+BAA+B,0DAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACrLuD;AACT;AACkD;AAChG;AACA;AACA;AACA;AACe,oCAAoC,wDAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0DAAY;AACvC,2BAA2B,0DAAY;AACvC,2BAA2B,0DAAY;AACvC,+BAA+B,0DAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0DAAY;AACnC;AACA;AACA,wCAAwC,0DAAY;AACpD,8CAA8C,0DAAY;AAC1D,0CAA0C,0EAA4B;AACtE;AACA;AACA;AACA,0CAA0C,wEAA0B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AChFkD;AACD;AACA;AAC2B;AAC/B;AACL;AAC+O;AAChR;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6EAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACe,sBAAsB,qDAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,iDAAiD;AACjD,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,oBAAoB,iDAAiD;AACrE;AACA,wFAAwF,+CAAI;AAC5F;AACA;AACA;AACA,gEAAgE,uDAAa;AAC7E,iEAAiE,uDAAa;AAC9E;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mDAAQ,aAAa,gDAAK;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0CAA0C;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gDAAK;AACrC,sBAAsB,gDAAK;AAC3B,sBAAsB,gDAAK;AAC3B;AACA,yBAAyB,mDAAQ;AACjC;AACA;AACA;AACA;AACA,gCAAgC,gDAAK;AACrC,yBAAyB,mDAAQ;AACjC;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC,2BAA2B,mDAAQ,aAAa,gDAAK;AACrD,8BAA8B,gDAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+CAAI;AAChC;AACA;AACA,8DAA8D,uDAAa;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mDAAQ,+CAA+C,gDAAK;AAC7F;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA;AACA,yBAAyB,mDAAQ,aAAa,gDAAK;AACnD;AACA;AACA;AACA,mDAAmD,+CAAI;AACvD;AACA;AACA;AACA;AACA,gCAAgC,gDAAK,yGAAyG,gDAAK;AACnJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mDAAQ,aAAa,gDAAK;AACnD,0BAA0B,+CAAI;AAC9B;AACA;AACA;AACA;AACA,uCAAuC,wEAA0B;AACjE,0BAA0B,+CAAI;AAC9B;AACA,4CAA4C,yEAA2B;AACvE,0BAA0B,+CAAI;AAC9B;AACA,4CAA4C,sEAAwB;AACpE,0BAA0B,+CAAI;AAC9B;AACA,4CAA4C,wEAA0B;AACtE,0BAA0B,+CAAI;AAC9B;AACA,4CAA4C,sEAAwB;AACpE;AACA;AACA,4CAA4C,uEAAyB;AACrE;AACA;AACA,4CAA4C,+EAAiC;AAC7E;AACA;AACA,4CAA4C,sFAAwC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gDAAK;AACrC,sBAAsB,gDAAK;AAC3B,sBAAsB,gDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;AACA;AACA,gBAAgB,mCAAmC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,uDAAe;AACzD,sBAAsB,uDAAe;AACrC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AClgB8D;AACT;AACP;AACN;AACA;AACwB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,2BAA2B,qDAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,MAAM,WAAW,OAAO,OAAO;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gEAAS;AACpC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,qDAAQ;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8BAA8B,MAAM,iDAAM,MAAM;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qEAAa,kBAAkB,gDAAK;AAChD;AACA;AACA;AACA;AACA;AACA,gCAAgC,sEAAc,kBAAkB,gDAAK;AACrE;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACpHuC;AACc;AACJ;AAC0C;AAC1C;AACT;AACqB;AACwC;AACnC;AACN;AACkD;AAC9G;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACe,kBAAkB,qDAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kEAAa;AACvC,qBAAqB,iGAAuB;AAC5C,mBAAmB,iDAAM;AACzB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC,4CAA4C,uDAAa;AACzD,yCAAyC,uDAAa;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,uEAAqB,UAAU,6FAAgC;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,uDAAa;AACpE,sDAAsD,uDAAa;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8DAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,uDAAe;AACrD,kBAAkB,uDAAe;AACjC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,+BAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,wEAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,oEAAsB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4EAA8B;AACpE;AACA;AACA,2CAA2C,4EAA8B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtUA;AACwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,0BAA0B,qDAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9DsC;AACW;AACT;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACe,4BAA4B,qDAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,uDAAe;AACrE;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+BAA+B,gDAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,eAAe;AACjE,iDAAiD,gBAAgB;AACjE,uDAAuD,WAAW;AAClE,oDAAoD,WAAW;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;AC/EyC;AACwB;AACf;AAClD;AACe,uCAAuC,qDAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,uEAAyB;AAC3E,+EAA+E,0DAAa;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AAC2E;AACxB;AACiC;AAClC;AACN;AACG;AACQ;AACuC;AACnD;AACa;AACO;AACG;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gDAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gDAAK;AACvC;AACA,sBAAsB,+DAAe;AACrC,wBAAwB,iEAAiB;AACzC,wBAAwB,iEAAiB;AACzC;AACA;AACA;AACA;AACA;AACA,6CAA6C,yDAAS,CAAC;AACvD;AACA,6CAA6C,yDAAS,CAAC;AACvD;AACA,6CAA6C,yDAAS,CAAC;AACvD;AACA;AACA;AACA;AACA,iBAAiB,kDAAU,QAAQ,8DAAY;AAC/C,iBAAiB,kDAAU,kBAAkB,8DAAY;AACzD,iBAAiB,kDAAU,gBAAgB,8DAAY;AACvD;AACA,uBAAuB,4DAAe;AACtC;AACA;AACA,aAAa;AACb;AACA;AACA,6BAA6B,kDAAU,iBAAiB,+CAAI;AAC5D,6BAA6B,kDAAU,iBAAiB,+CAAI;AAC5D;AACA,sDAAsD,kDAAU,eAAe,+CAAI;AACnF,kDAAkD,kDAAU,OAAO,+CAAI;AACvE,mCAAmC,4DAAe;AAClD,oBAAoB,8DAAY;AAChC,kBAAkB,+CAAI;AACtB;AACA,SAAS;AACT,qCAAqC,mEAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gDAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,uBAAuB,gDAAK;AAC5B;AACA;AACA,4CAA4C,+CAAI;AAChD;AACA;AACA;AACA,eAAe,gDAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gDAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,mBAAmB,wEAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gDAAK;AAC9B;AACA;AACA;AACA,kCAAkC,gDAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gDAAK;AACvC;AACA;AACA;AACA;AACA,iCAAiC,4DAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,uBAAuB;AACzE,iDAAiD,uBAAuB;AACxE,6CAA6C,mBAAmB;AAChE,8CAA8C,oBAAoB;AAClE;AACA,wDAAwD,YAAY;AACpE;AACA;AACA,0CAA0C,yDAAS,CAAC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8DAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gDAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,qDAAQ,aAAa,gDAAK;AACrE;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAK;AACxB;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,iDAAiD,kBAAkB;AACnE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wEAAa;AACnC,uBAAuB,8DAAW;AAClC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+DAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gDAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,yEAAmB;AACvB;AACA,kCAAkC,gDAAK;AACvC;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD,qDAAqD,yEAAmB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,GAAG;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gDAAK;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gDAAK;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,SAAS,EAAC;;;;;;;;;;;;;;;;;;;;ACtmBuC;AACpB;AACM;AAClD;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AAC5B;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACO;AACQ;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yDAAS,CAAC,YAAY,yDAAS,CAAC,EAAE,oBAAoB;AAC5F;AACA;AACA,wCAAwC,yDAAS,CAAC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,yDAAS,CAAC;AACxD;AACA;AACA,8CAA8C,yDAAS,CAAC;AACxD;AACA;AACA,gBAAgB,uEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+CAAI;AACzB;AACA;AACA;AACA;AACA,mBAAmB,gDAAK;AACxB;AACA;AACA;AACA;AACA,qBAAqB,+CAAI;AACzB;AACA,mBAAmB,gDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,eAAe;AAC1D,0CAA0C,eAAe;AACzD,sCAAsC,OAAO;AAC7C,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3I4C;AACM;AAClD;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yDAAS,CAAC,YAAY,yDAAS,CAAC;AACtE,+DAA+D,eAAe;AAC9E;AACA,iCAAiC,qBAAqB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAI;AACnB;AACA;AACA;AACA,wBAAwB,+CAAI;AAC5B;AACA,mBAAmB,gDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAAI;AAC5B,wBAAwB,+CAAI;AAC5B,mBAAmB,gDAAK;AACxB;AACA;AACA;AACA;AACA,2CAA2C,eAAe;AAC1D,0CAA0C,eAAe;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7F4C;AACQ;AACR;AACH;AACmC;AACN;AAC5B;AACuB;AAC2d;AAC1d;AACW;AACtE;AACP;AACA;AACe,4BAA4B,qDAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,kBAAkB,+EAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kEAAqB;AACrD,4BAA4B,qDAAQ,aAAa,gDAAK;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2BAA2B,uDAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gCAAgC,sDAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,gDAAK;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,uDAAe;AACzD,sBAAsB,uDAAe;AACrC;AACA,aAAa;AACb;AACA,0CAA0C,uDAAe;AACzD,sBAAsB,uDAAe;AACrC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0EAA4B;AACnE;AACA;AACA;AACA;AACA,wCAAwC,wEAA0B;AAClE,2CAA2C,yEAA2B;AACtE;AACA;AACA;AACA;AACA,4CAA4C,uEAAyB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,8EAAgC;AACvE;AACA;AACA,4CAA4C,+EAAiC;AAC7E;AACA;AACA,4CAA4C,4EAA8B;AAC1E;AACA;AACA,4CAA4C,8EAAgC;AAC5E;AACA;AACA,4CAA4C,gFAAkC;AAC9E;AACA;AACA,4CAA4C,uFAAyC;AACrF;AACA;AACA,4CAA4C,wEAA0B;AACtE;AACA;AACA,4CAA4C,yEAA2B;AACvE;AACA;AACA,4CAA4C,wEAA0B;AACtE;AACA;AACA,4CAA4C,yEAA2B;AACvE;AACA;AACA,4CAA4C,yEAA2B;AACvE;AACA;AACA;AACA,4CAA4C,0EAA4B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+CAAI;AACpC,gCAAgC,gDAAK;AACrC,gFAAgF,qDAAQ;AACxF;AACA,8BAA8B,gDAAK;AACnC,0BAA0B,gDAAK;AAC/B;AACA,0BAA0B,gDAAK;AAC/B,0BAA0B,gDAAK,6CAA6C,+CAAI;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0EAA4B;AACnE;AACA;AACA;AACA,uCAAuC,uEAAyB;AAChE;AACA;AACA;AACA,4DAA4D,wEAA0B;AACtF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,4DAA4D,yEAA2B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qDAAQ,UAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gDAAK;AAC3C;AACA,sBAAsB,gDAAK;AAC3B,gBAAgB,gDAAgD,EAAE,4EAAW,gCAAgC,gDAAgD;AAC7J,gBAAgB,4CAA4C,EAAE,+EAAc,gCAAgC,sBAAsB;AAClI;AACA;AACA;AACA;AACA,gCAAgC,qEAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrf4C;AACmC;AAC/E;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,+BAA+B,gDAAK;AACpC;AACA;AACA;AACA;AACA,mBAAmB,+CAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,+CAAI;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,6EAAuB;AAC7C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5E4C;AACA;AACD;AACpC;AACP;AACA;AACA;AACA;AACA;AACA,oCAAoC,gDAAK;AACzC;AACA;AACA;AACA;AACA,oCAAoC,gDAAK;AACzC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB,kDAAU;AAC9B;AACA;AACA,oCAAoC,gDAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAI;AAC7B;AACA;AACA;AACA;AACA;AACA,oBAAoB,+CAAI;AACxB,0BAA0B,kDAAU;AACpC;AACA,oBAAoB,+CAAI;AACxB;AACA,0BAA0B,kDAAU;AACpC;AACA,oBAAoB,+CAAI;AACxB;AACA,0BAA0B,kDAAU;AACpC;AACA;AACA,oBAAoB,+CAAI;AACxB;AACA;AACA;AACA,yCAAyC,qDAAQ;AACjD;AACA;AACA,wCAAwC,gDAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gDAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAK;AAC/B,yEAAyE,qDAAQ;AACjF,qCAAqC,gDAAK;AAC1C;AACA,sBAAsB,gDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChJoF;AACpF;AACO;AACP,8EAAuB;AAChB;AACP,8EAAuB;AAChB;AACP,8EAAuB;AAChB;AACP,8EAAuB;AAChB;AACP,8EAAuB;AAChB;AACP,8EAAuB;AAChB;AACP,8EAAuB;AAChB;AACP,8EAAuB;AAChB;AACP,8EAAuB;AAChB;AACP,8EAAuB;AAChB;AACP,8EAAuB;AAChB;AACP,8EAAuB;AAChB;AACP,8EAAuB;AAChB;AACP,8EAAuB;AAChB;AACP,8EAAuB;;;;;;;;;;;;;;;;AC/BhB;AACP;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA;AACA,CAAC,sCAAsC;;;;;;;;;;;;;;;;;ACVkC;AACL;AACpE;AACA;AACA,uBAAuB,0EAAiB;AACxC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0EAA0E,MAAM;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kEAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kEAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iEAAe,0BAA0B,EAAC;;;;;;;;;;;;;;;;;;ACjEyB;AACC;AACQ;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kEAAgB,SAAS,2EAA0B;AAChG;AACA,aAAa;AACb,SAAS;AACT;AACA,8BAA8B,uEAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,iDAAiD,kEAAgB,SAAS,2EAA0B;AACpG;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iEAAe,wBAAwB,EAAC;;;;;;;;;;;;;;;;;AC9Ca;AACb;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,0BAA0B,qDAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,iDAAM;AAChG;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B,0FAA0F,iDAAM;AAChG,sCAAsC,uDAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACtK8D;AACT;AACM;AACV;AACA;AACT;AACI;AACgB;AACA;AAC5D;AACA;AACe,uBAAuB,qDAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kEAAa;AAC3C;AACA;AACA;AACA,sBAAsB,iDAAM;AAC5B,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,0CAA0C,uDAAe;AACzD,sBAAsB,uDAAe;AACrC;AACA,aAAa;AACb,SAAS;AACT,gCAAgC,kEAAa,kBAAkB,gDAAK;AACpE;AACA;AACA;AACA,MAAM,iBAAiB;AACvB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qEAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+CAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gDAAK;AACzC,kCAAkC,qEAAa;AAC/C,2BAA2B,8DAAW;AACtC;AACA;AACA;AACA,qCAAqC,uEAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,oBAAoB;AACnE;AACA;AACA,4CAA4C,+BAA+B;AAC3E,6CAA6C,gCAAgC;AAC7E;AACA;AACA;AACA;AACA;AACA,6DAA6D,YAAY;AACzE;AACA;AACA;AACA,iDAAiD,WAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+CAAI;AAC9B;AACA;AACA,QAAQ,gDAAK;AACb,sBAAsB,gDAAK;AAC3B,sBAAsB,gDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA,oDAAoD,+BAA+B;AACnF,qDAAqD,gCAAgC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C,+BAA+B,uDAAa;AAC5C;AACA;AACA;AACA;AACA;AACA,uCAAuC,+CAAI;AAC3C,+BAA+B,gDAAK;AACpC;AACA,+EAA+E,qEAAa;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,2DAAK;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzRiD;AACV;AACgB;AACzB;AAC0B;AACpB;AAC4B;AACR;AAChB;AACM;AACkB;AAChB;AACoB;AACyD;AACrF;AAC8C;AACxC;AACM;AACU;AACI;AAChB;AACnC;AACf;AACA;AACA;AACA;AACA,iCAAiC,uEAAa;AAC9C;AACA,qCAAqC,6DAAgB;AACrD;AACA,gCAAgC,oDAAO,SAAS,qDAAW,0BAA0B,qDAAW;AAChG,wCAAwC,oDAAO,SAAS,qDAAW;AACnE,mCAAmC,gDAAG;AACtC,mBAAmB,iDAAM;AACzB;AACA,SAAS;AACT,qCAAqC,gDAAG;AACxC,mBAAmB,iDAAM;AACzB;AACA,SAAS;AACT;AACA,4CAA4C,yEAAe;AAC3D,2BAA2B,mDAAM;AACjC;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAG;AACnB,uBAAuB,iDAAM;AAC7B;AACA,yBAAyB,oIAAwC;AACjE,aAAa;AACb;AACA,gBAAgB,wEAAa;AAC7B,gBAAgB,qDAAQ;AACxB,gBAAgB,oDAAO,SAAS,qDAAW;AAC3C;AACA;AACA,kCAAkC,yDAAW;AAC7C;AACA;AACA,gBAAgB,2DAAa;AAC7B,gBAAgB,wDAAW;AAC3B;AACA;AACA;AACA;AACA,gBAAgB,6DAAgB;AAChC,gBAAgB,oEAAsB;AACtC,gBAAgB,kEAAoB;AACpC;AACA,gBAAgB,sDAAQ;AACxB,gBAAgB,0DAAY;AAC5B,gBAAgB,oFAAwB;AACxC;AACA;AACA;AACA;AACA,2BAA2B,uDAAe;AAC1C,+BAA+B,uDAAe;AAC9C;AACA;AACA,SAAS;AACT,2BAA2B,uDAAe;AAC1C,+BAA+B,uDAAe;AAC9C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,6DAAgB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wBAAwB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,MAAM,2DAAY,mBAAmB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2DAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2DAAY;AAC5C;AACA;AACA;AACA;AACA;AACA,gCAAgC,2DAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxRA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACTwC;AACxC;AACA;AACA;AACA;AACA,kCAAkC,sBAAsB;AACxD;AACA;AACe,mCAAmC,qDAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjCA;AACA;AACwC;AACzB,qCAAqC,qDAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,MAAM;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3BwC;AAC6C;AACrF;AACe,+BAA+B,qDAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,oEAAsB;AACxE;AACA;AACA;AACA,uDAAuD,oEAAsB;AAC7E;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpBiF;AACjF;AACA;AACO;AACA;AACP,8EAAuB;AACvB,8EAAuB;AACvB;AACO;AACP,8EAAuB;AAChB;AACP,8EAAuB;AAChB;AACP,8EAAuB;AAChB;AACP,8EAAuB;AACvB;AACO;AACP,8EAAuB;AACvB;AACO;AACP,8EAAuB;AAChB;AACP,8EAAuB;AAChB;AACP,8EAAuB;AAChB;AACP,8EAAuB;AAChB;AACP,8EAAuB;AAChB;AACP,8EAAuB;AAChB;AACP,8EAAuB;AAChB;AACP,8EAAuB;AACvB;AACkD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrCuB;AAClB;AACY;AACI;AACA;AACQ;AACT;AACrB;AACM;AACwB;AACsB;AAClC;AACJ;AACF;AACsB;;;;;;;;;;;;;;;ACd5E;AACP,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,kBAAkB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,UAAU,KAAK,aAAa;AAC/F;AACA,iCAAiC,OAAO;AACxC,iCAAiC,OAAO;AACxC,8CAA8C,UAAU;AACxD,+CAA+C,UAAU;AACzD;;;;;;;;;;;;;;;;;AC3CqC;AAC9B;AACP;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAAI;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA,gFAAgF;AAChF,8FAA8F;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;;;;;;;;;;;;;;;;ACtG6D;AACT;AACpD;AACA;AACA;AACA,YAAY,wBAAwB;AACpC;AACA;AACA;AACA,oEAAoE,gBAAgB;AACpF;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D,qDAAqD,SAAS;AAC9D;AACA;AACA,sDAAsD,uDAAe;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oEAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sDAAsD,YAAY;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kBAAkB;AAC1D,KAAK;AACL;AACA,iEAAe,iBAAiB,EAAC;;;;;;;;;;;;;;;;ACxHjC;AACA,UAAU,sBAAsB;AACzB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,sCAAsC;;;;;;;;;;;;;;;;;AC5BvC;AACA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACA;AACoD;AACE;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAY;AACtC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,MAAM;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,gEAAe,SAAS,YAAY;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0DAAY;AAC9B;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,8BAA8B,OAAO,OAAO;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,WAAW;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,gBAAgB,EAAC;;;;;;;;;;;;;;;;;ACzRhC,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,4BAA4B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,MAAK;AAC/B,cAAc,CAA0B;AACxC,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,aAAa,EAAC;;;;;;;;;;;;;;;;ACtL6C;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB,EAAE,0EAAyB;AACzD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iEAAe,6BAA6B,EAAC;;;;;;;;;;;;;;;;AC7BA;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uCAAuC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iDAAM;AACpB;AACA;AACA,cAAc,iDAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iDAAM;AACpC;AACA;AACA;AACA,yBAAyB,+CAAI;AAC7B;AACA,8BAA8B,iDAAM;AACpC,6BAA6B,iDAAM;AACnC;AACA,yBAAyB,iDAAM;AAC/B;AACA;AACA,8BAA8B,iDAAM;AACpC,6BAA6B,iDAAM;AACnC;AACA,yBAAyB,iDAAM;AAC/B;AACA,8BAA8B,iDAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,4BAA4B,EAAC;;;;;;;;;;;;;;;;;;;;;AClI5C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,mDAAmD,IAAI;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACO;AACP;AACA,iFAAiF,aAAa;AAC9F;AACA;;;;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,iEAAe,iBAAiB,EAAC;;;;;;;;;;;;;;;ACvBjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sCAAsC;AAClE;AACA;AACA;AACA;AACA,wBAAwB,qCAAqC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,sBAAsB,EAAC;;;;;;;;;;;;;;;;;;;AC7B/B;AACP;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,YAAY;AAC5D;AACA;AACA;AACA;AACA;AACA,sDAAsD,aAAa;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA,iEAAe,aAAa,EAAC;;;;;;;;;;;;;;;AC9C7B;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB,SAAS,gBAAgB;AACxE;AACA;AACA,iEAAe,eAAe,EAAC;;;;;;;;;;;;;;;ACpC/B;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA,uBAAuB,IAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,mBAAmB,EAAC;;;;;;;;;;;;;;;;;;;AC7B4D;AACnB;;;;;;;;;;;;;;;ACD5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,eAAe,EAAC;;;;;;;;;;;;;;;ACd/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,iEAAe,2BAA2B,EAAC;;;;;;;;;;;;;;;ACjJ3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iEAAe,yBAAyB,EAAC;;;;;;;;;;;;;;;AC7EzC;AACA;AACA;AACA;;AAEA,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,qBAAqB,EAAC;;;;;;;;;;;;;;;ACzBrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,qCAAqC,EAAC;;;;;;;;;;;;;;;AClBrD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iEAAe,uBAAuB,EAAC;;;;;;;;;;;;;;;ACNvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,iEAAe,UAAU,EAAC;;;;;;;;;;;;;;;AChB1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iEAAe,gBAAgB,EAAC;;;;;;;;;;;;;;;ACZhC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iEAAe,cAAc,EAAC;;;;;;;;;;;;;;;ACN9B;AACA;AACA;AACA;AACA;AACA,iEAAe;AACf;AACA,CAAC,EAAC;;;;;;;UCPF;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;ACNmD;AACpB;AACQ;AACO;AACA;AACE;AAChD;AACA,uBAAuB,2CAAM;AAC7B;AACA;AACA;AACA,KAAK;AACL,oBAAoB,6DAAW;AAC/B;AACA,eAAe,iDAAM;AACrB;AACA;AACA,KAAK;AACL,uBAAuB,oDAAe;AACtC,QAAQ,mDAAS;AACjB,KAAK;AACL,uBAAuB,oDAAe;AACtC,QAAQ,mDAAS;AACjB,KAAK;AACL,IAAI,gDAAM;AACV;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd;AACA,CAAC;AACD;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,QAAQ,mDAAU;AAClB;AACA;AACA,CAAC","sources":["webpack://notetheweb/./node_modules/js-draw/dist/bundledStyles.js","webpack://notetheweb/./src/data/browser.ts","webpack://notetheweb/./src/data/db.ts","webpack://notetheweb/./src/toolbar/btnClear.ts","webpack://notetheweb/./src/toolbar/btnClose.ts","webpack://notetheweb/./src/toolbar/btnHide.ts","webpack://notetheweb/./src/toolbar/btnNormal.ts","webpack://notetheweb/./src/toolbar/btnTransparent.ts","webpack://notetheweb/./src/toolbar/toolbar.ts","webpack://notetheweb/./src/update.ts","webpack://notetheweb/./node_modules/@js-draw/math/dist/mjs/Color4.mjs","webpack://notetheweb/./node_modules/@js-draw/math/dist/mjs/Mat33.mjs","webpack://notetheweb/./node_modules/@js-draw/math/dist/mjs/Vec2.mjs","webpack://notetheweb/./node_modules/@js-draw/math/dist/mjs/Vec3.mjs","webpack://notetheweb/./node_modules/@js-draw/math/dist/mjs/lib.mjs","webpack://notetheweb/./node_modules/@js-draw/math/dist/mjs/polynomial/solveQuadratic.mjs","webpack://notetheweb/./node_modules/@js-draw/math/dist/mjs/rounding/cleanUpNumber.mjs","webpack://notetheweb/./node_modules/@js-draw/math/dist/mjs/rounding/constants.mjs","webpack://notetheweb/./node_modules/@js-draw/math/dist/mjs/rounding/getLenAfterDecimal.mjs","webpack://notetheweb/./node_modules/@js-draw/math/dist/mjs/rounding/lib.mjs","webpack://notetheweb/./node_modules/@js-draw/math/dist/mjs/rounding/toRoundedString.mjs","webpack://notetheweb/./node_modules/@js-draw/math/dist/mjs/rounding/toStringOfSamePrecision.mjs","webpack://notetheweb/./node_modules/@js-draw/math/dist/mjs/shapes/Abstract2DShape.mjs","webpack://notetheweb/./node_modules/@js-draw/math/dist/mjs/shapes/BezierJSWrapper.mjs","webpack://notetheweb/./node_modules/@js-draw/math/dist/mjs/shapes/CubicBezier.mjs","webpack://notetheweb/./node_modules/@js-draw/math/dist/mjs/shapes/LineSegment2.mjs","webpack://notetheweb/./node_modules/@js-draw/math/dist/mjs/shapes/Parameterized2DShape.mjs","webpack://notetheweb/./node_modules/@js-draw/math/dist/mjs/shapes/Path.mjs","webpack://notetheweb/./node_modules/@js-draw/math/dist/mjs/shapes/PointShape2D.mjs","webpack://notetheweb/./node_modules/@js-draw/math/dist/mjs/shapes/QuadraticBezier.mjs","webpack://notetheweb/./node_modules/@js-draw/math/dist/mjs/shapes/Rect2.mjs","webpack://notetheweb/./node_modules/@js-draw/math/dist/mjs/utils/convexHull2Of.mjs","webpack://notetheweb/./node_modules/@melloware/coloris/dist/esm/coloris.js","webpack://notetheweb/./node_modules/bezier-js/src/bezier.js","webpack://notetheweb/./node_modules/bezier-js/src/poly-bezier.js","webpack://notetheweb/./node_modules/bezier-js/src/utils.js","webpack://notetheweb/./node_modules/js-draw/dist/mjs/Editor.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/EventDispatcher.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/Pointer.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/SVGLoader/SVGLoader.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/SVGLoader/utils/determineFontSize.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/UndoRedoHistory.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/Viewport.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/commands/Command.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/commands/Duplicate.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/commands/Erase.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/commands/SerializableCommand.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/commands/UnresolvedCommand.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/commands/invertCommand.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/commands/lib.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/commands/localization.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/commands/uniteCommands.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/components/AbstractComponent.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/components/BackgroundComponent.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/components/ImageComponent.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/components/RestylableComponent.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/components/SVGGlobalAttributesObject.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/components/Stroke.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/components/TextComponent.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/components/UnknownSVGObject.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/components/builders/ArrowBuilder.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/components/builders/CircleBuilder.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/components/builders/FreehandLineBuilder.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/components/builders/LineBuilder.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/components/builders/PolylineBuilder.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/components/builders/PressureSensitiveFreehandLineBuilder.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/components/builders/RectangleBuilder.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/components/builders/autocorrect/makeShapeFitAutocorrect.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/components/builders/autocorrect/makeSnapToGridAutocorrect.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/components/builders/lib.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/components/builders/types.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/components/lib.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/components/localization.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/components/util/StrokeSmoother.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/components/util/describeComponentList.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/dialogs/makeAboutDialog.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/dialogs/makeMessageDialog.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/image/EditorImage.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/image/export/adjustExportedSVGSize.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/image/export/editorImageToSVG.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/image/lib.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/inputEvents.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/lib.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/localization.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/localizations/de.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/localizations/en.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/localizations/es.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/localizations/getLocalizationTable.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/rendering/Display.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/rendering/RenderablePathSpec.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/rendering/RenderingStyle.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/rendering/TextRenderingStyle.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/rendering/caching/CacheRecord.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/rendering/caching/CacheRecordManager.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/rendering/caching/RenderingCache.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/rendering/caching/RenderingCacheNode.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/rendering/lib.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/rendering/localization.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/rendering/renderers/AbstractRenderer.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/rendering/renderers/CanvasRenderer.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/rendering/renderers/DummyRenderer.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/rendering/renderers/SVGRenderer.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/rendering/renderers/TextOnlyRenderer.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/shortcuts/KeyBinding.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/shortcuts/KeyboardShortcutManager.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/shortcuts/lib.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/testing/getUniquePointerId.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/testing/lib.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/testing/sendPenEvent.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/testing/sendTouchEvent.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/AbstractToolbar.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/DropdownToolbar.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/EdgeToolbar.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/IconProvider.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/constants.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/lib.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/localization.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/utils/HelpDisplay.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/utils/localization.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/utils/makeDraggable.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/widgets/ActionButtonWidget.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/widgets/BaseToolWidget.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/widgets/BaseWidget.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/widgets/DocumentPropertiesWidget.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/widgets/EraserToolWidget.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/widgets/ExitActionWidget.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/widgets/HandToolWidget.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/widgets/InsertImageWidget/ImageWrapper.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/widgets/InsertImageWidget/InsertImageWidget.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/widgets/InsertImageWidget/fileToImages.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/widgets/OverflowWidget.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/widgets/PenToolWidget.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/widgets/SaveActionWidget.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/widgets/SelectionToolWidget.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/widgets/TextToolWidget.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeColorInput.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeFileInput.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeGridSelector.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeSeparator.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeSnappedList.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeThicknessSlider.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/widgets/keybindings.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/widgets/layout/DropdownLayoutManager.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/widgets/layout/EdgeToolbarLayoutManager.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/toolbar/widgets/lib.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/BaseTool.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/Eraser.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/FindTool.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/InputFilter/ContextMenuRecognizer.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/InputFilter/InputMapper.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/InputFilter/InputPipeline.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/InputFilter/InputStabilizer.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/InputFilter/StrokeKeyboardControl.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/PanZoom.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/PasteHandler.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/Pen.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/PipetteTool.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/ScrollbarTool.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectAllShortcutHandler.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/SelectionTool/Selection.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionHandle.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionMenuShortcut.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionTool.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/SelectionTool/ToPointerAutoscroller.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/SelectionTool/TransformMode.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/SelectionTool/keybindings.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/SelectionTool/types.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/SelectionTool/util/makeClipboardErrorHandlers.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/SelectionTool/util/showSelectionContextMenu.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/SoundUITool.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/TextTool.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/ToolController.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/ToolEnabledGroup.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/ToolSwitcherShortcut.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/ToolbarShortcutHandler.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/UndoRedoShortcut.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/keybindings.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/lib.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/localization.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/util/StationaryPenDetector.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/tools/util/createMenuOverlay.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/types.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/util/ClipboardHandler.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/util/ReactiveValue.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/util/addLongPressOrHoverCssClasses.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/util/adjustEditorThemeForContrast.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/util/assertions.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/util/bytesToSizeString.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/util/cloneElementWithStyles.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/util/createElement.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/util/fileToBase64Url.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/util/guessKeyCodeFromKey.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/util/lib.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/util/listPrefixMatch.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/util/listenForKeyboardEventsFrom.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/util/listenForLongPressOrHover.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/util/mitLicenseAttribution.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/util/stopPropagationOfScrollingWheelEvents.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/util/untilNextAnimationFrame.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/util/waitForAll.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/util/waitForImageLoaded.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/util/waitForTimeout.mjs","webpack://notetheweb/./node_modules/js-draw/dist/mjs/version.mjs","webpack://notetheweb/webpack/bootstrap","webpack://notetheweb/webpack/runtime/compat get default export","webpack://notetheweb/webpack/runtime/define property getters","webpack://notetheweb/webpack/runtime/hasOwnProperty shorthand","webpack://notetheweb/webpack/runtime/make namespace object","webpack://notetheweb/./src/firefox-draw.ts"],"sourcesContent":["\"use strict\";var jsdrawStyles=(()=>{(()=>{if(typeof document<\"u\"&&typeof document.createElement==\"function\"){let o=document.createElement(\"style\");o.textContent='\\uFEFF:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content>div>div{padding:5px}:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content>div{min-height:0}:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content img{max-width:100%;max-height:100%;display:block;margin-left:auto;margin-right:auto}:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content .insert-image-image-status-view{display:flex;justify-content:space-between;padding-bottom:0}:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content .action-button-row{margin-top:4px;display:flex;flex-direction:row;justify-content:flex-end;padding-bottom:0;margin-bottom:0}:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content .action-button-row>button{flex-grow:1;text-align:end;max-width:50%;min-width:min(100%,40px)}.toolbar-overflow-widget-overflow-list{display:flex;flex-direction:column;flex-wrap:wrap;justify-content:center}.toolbar-overflow-widget-overflow-list>.toolbar-toolContainer>.toolbar-button{height:var(--toolbar-button-height)}.toolbar-overflow-widget.horizontal .toolbar-overflow-widget-overflow-list{flex-direction:row}.toolbar-overflow-widget.horizontal>.toolbar-dropdown{max-width:100%;left:15px;right:15px;margin-left:0 !important;translate:none !important;padding:4px}:root .toolbar--pen-tool-toggle-buttons.toolbar--pen-tool-toggle-buttons{display:flex;justify-content:stretch;padding-top:0;padding-bottom:5px;direction:ltr}:root .toolbar--pen-tool-toggle-buttons.toolbar--pen-tool-toggle-buttons>*{flex-grow:1;text-align:start;margin-inline-end:5px}:root .toolbar--pen-tool-toggle-buttons.toolbar--pen-tool-toggle-buttons>* .icon{margin:0;margin-inline-start:4px;margin-inline-end:10px}:root .toolbar--pen-tool-toggle-buttons.toolbar--pen-tool-toggle-buttons>:nth-child(1){direction:ltr}:root .toolbar--pen-tool-toggle-buttons.toolbar--pen-tool-toggle-buttons>:last-child{direction:rtl}.toolbar-zoomLevelEditor{display:flex;flex-direction:row;align-items:center}.toolbar-zoomLevelEditor .zoomDisplay{flex-grow:1}.toolbar-zoomLevelEditor button{min-width:48px}.selection-format-menu.disabled{opacity:.5}.toolbar-document-properties-widget button.about-button{width:100%;text-align:end}.toolbar-document-properties-widget>*{--align-items-to-x: 120px}.toolbar-document-properties-widget .js-draw-size-input-row.js-draw-size-input-row{display:flex}.toolbar-document-properties-widget .js-draw-size-input-row.js-draw-size-input-row.size-input-row--automatic-size{display:none}.toolbar-thicknessSliderContainer{display:flex;flex-direction:row}.toolbar-thicknessSliderContainer input{flex-grow:1}.toolbar-element .clr-field *{cursor:pointer}.toolbar-element .clr-field button{width:1.2em;height:1.2em;top:50%;left:0;border-radius:50%;margin-left:0;margin-right:0}.toolbar-element .clr-field input{opacity:0}.color-input-container{display:inline-flex;flex-direction:row}.color-input-container .coloris_input{height:calc(100% - 6px)}.color-input-container.picker-open .clr-field{pointer-events:none}:root .color-input-container>button.pipetteButton{width:30px;height:30px;padding:0;display:inline-flex}.color-input-container>.color-input-wrapper{display:flex;justify-content:stretch}.color-input-container .pipetteButton>svg{width:100%}.color-input-container .pipetteButton .pickColorInstructions{display:none;font-size:1em;position:absolute;margin-left:30px;background-color:var(--background-color-1);border-radius:30px;padding:4px;opacity:0;transition:.2s ease opacity}@media(prefers-reduced-motion: reduce){.color-input-container .pipetteButton .pickColorInstructions{transition:none}}.color-input-container .pipetteButton.active{background-color:var(--selection-background-color);--icon-color: var(--selection-foreground-color)}.color-input-container .pipetteButton.active .pickColorInstructions{display:block;opacity:.8}.tool-dropdown-separator{--border-color: rgba(100, 100, 100, 0.2);--border-color: color-mix(in srgb, var(--foreground-color-1), rgba(0, 0, 0, 0) 80%);border-top:1px solid var(--border-color);padding-left:2px;margin-top:10px;margin-bottom:10px}.toolbar-element .toolbar--file-input-container{display:flex}.toolbar-element .toolbar--file-input-container.-loading{opacity:.8}.toolbar-element .toolbar--file-input-container>input.file-input{opacity:0;width:0;min-width:0 !important;max-width:0;height:0;overflow:hidden;padding:0;margin:0}.toolbar-element .toolbar--file-input-container>label{display:block;flex-grow:1;padding:0 !important;padding-bottom:5px;--active-border-color: rgba(100, 100, 100, 0.5);--active-border-color: color-mix(in srgb, var(--foreground-color-1), transparent)}.toolbar-element .toolbar--file-input-container>label .cancel-button{padding-left:3px;padding-right:3px}.toolbar-element .toolbar--file-input-container>label>.toolbar--file-input-description{background-color:var(--background-color-3);color:var(--foreground-color-3);border:1px dashed var(--active-border-color);padding:10px;margin-top:10px;display:flex;flex-direction:column;align-items:center;text-align:center;--action-color: var(--primary-action-foreground-color);--icon-color: var(--action-color)}.toolbar-element .toolbar--file-input-container>label>.toolbar--file-input-description>span{white-space:pre-wrap}.toolbar-element .toolbar--file-input-container>label>.toolbar--file-input-description>span>b{color:var(--action-color);cursor:pointer}.toolbar-element .toolbar--file-input-container>label>.toolbar--file-input-description>.icon{width:min(50vw,42px);height:min(50vw,42px);margin-bottom:8px;display:block}.toolbar-element .toolbar--file-input-container>label:active,.toolbar-element .toolbar--file-input-container>label:hover,.toolbar-element .toolbar--file-input-container>label.drag-target{--active-border-color: var(--foreground-color-1)}.toolbar-element .toolbar--file-input-container>label.drag-target>.toolbar--file-input-description{border-width:2px}.toolbar-grid-selector{position:relative}.toolbar-grid-selector>div{display:flex;flex-direction:row;max-width:350px;flex-wrap:wrap;--button-size: 48px}.toolbar-grid-selector .choice-button{display:flex;flex-direction:column-reverse;box-sizing:border-box;cursor:pointer;flex-shrink:1;margin:2px}.toolbar-grid-selector .choice-button.focus-visible{outline:2px solid var(--foreground-color-1)}.toolbar-grid-selector .choice-button input{opacity:0;height:0}.toolbar-grid-selector .choice-button label{display:flex;flex-direction:column;box-sizing:border-box;width:var(--button-size);height:var(--button-size);font-size:.7rem;align-items:center;justify-content:center;padding:4px;user-select:none;-webkit-user-select:none}.toolbar-grid-selector .choice-button .icon{flex-grow:1;flex-shrink:1;width:100%}.toolbar-grid-selector .choice-button.checked{background-color:var(--selection-background-color);color:var(--selection-foreground-color);--icon-color: var(--selection-foreground-color)}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list{height:min(200px,50vh);position:relative;display:flex;align-items:center}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.scroller{display:flex;flex-direction:column;overflow-y:auto;scroll-snap-type:y mandatory;height:100%;width:100%;flex-grow:1}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.scroller>.item{height:100%;width:100%;flex-shrink:0;display:flex;justify-content:center;align-items:center;scroll-snap-align:start;scroll-snap-stop:always;box-sizing:border-box}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.-empty{display:none}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.page-markers{overflow:hidden;display:flex;flex-direction:column;align-items:center;max-height:100%;min-height:0}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.page-markers.-one-element{visibility:hidden}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.page-markers>.marker{padding:2px;opacity:.1;cursor:pointer;left:0;transition:left .2s ease}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.page-markers>.marker>.content{background-color:var(--foreground-color-1);border-radius:2px;padding:2px}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.page-markers>.marker.-active{position:relative;left:2px;opacity:.2}.toolbar-root{background-color:var(--background-color-1);--icon-color: var(--foreground-color-1);--toolbar-button-height: min(20vh, 60px);flex-wrap:wrap;box-sizing:border-box;width:100%;display:flex;flex-direction:row;justify-content:center}.toolbar-element{z-index:1;font-family:system-ui,-apple-system,sans-serif}.toolbar-element details>summary{cursor:pointer}.toolbar-element>.toolbar-toolContainer>.toolbar-button,.toolbar-element>.toolbar-toolContainer>*>button,.toolbar-element>.toolbar-buttonGroup>button,.toolbar-element>.toolbar-button{white-space:pre;height:var(--toolbar-button-height)}.toolbar-dropdown .toolbar-button>.toolbar-icon{max-width:50px;width:100%}.toolbar-button.disabled{filter:sepia(0.2);opacity:.45;cursor:unset}.toolbar-button,.toolbar-element button{cursor:pointer;text-align:center;border-radius:6px;border:none;box-shadow:0px 0px 2px var(--shadow-color);user-select:none;-webkit-user-select:none;transition:background-color .15s ease,box-shadow .25s ease,opacity .2s ease}.toolbar-button,.toolbar-buttonGroup>button,.toolbar-toolContainer>*>button,.toolbar-root>button{display:flex;flex-direction:column;align-items:center;justify-content:center;padding-left:3px;padding-right:3px;min-width:40px;max-width:105px;width:min-content;font-size:1em}.toolbar-button>label{cursor:inherit;user-select:none;-webkit-user-select:none}.toolbar-root>.toolbar-toolContainer>.toolbar-button>label.long-label{font-size:.75em}.toolbar-dropdown>.toolbar-toolContainer>button,.toolbar-dropdown>.toolbar-toolContainer>.toolbar-button{width:6em}.toolbar-button:not(.disabled):hover,.toolbar-root button:not(:disabled):hover{box-shadow:0px 2px 4px var(--shadow-color)}.toolbar-root button:disabled{cursor:inherit;opacity:.5}.toolbar-root .toolbar-icon{flex-shrink:1;user-select:none;width:100%;min-width:20px;min-height:20px}.toolbar-toolContainer.selected>.toolbar-button{background-color:var(--selection-background-color);color:var(--selection-foreground-color);--icon-color: var(--selection-foreground-color)}.toolbar-toolContainer:not(.selected):not(.dropdownShowable)>.toolbar-button>.toolbar-showHideDropdownIcon{display:none}.toolbar-toolContainer>.toolbar-button>.toolbar-showHideDropdownIcon{height:15px;transition:transform .25s ease}.toolbar-toolContainer.dropdownVisible>.toolbar-button>.toolbar-showHideDropdownIcon{transform:rotate(180deg)}.toolbar-dropdown.hidden,.toolbar-toolContainer:not(.selected):not(.dropdownShowable)>.toolbar-dropdown:not(.hiding){display:none}.toolbar-dropdown{position:absolute;padding:15px;padding-top:5px;display:flex;flex-wrap:wrap;flex-direction:column;max-height:80vh;max-width:fit-content;z-index:2;background-color:var(--background-color-1);box-shadow:0px 3px 3px var(--shadow-color)}@keyframes dropdown-transition-in{0%{opacity:0;transform:scale(1, 0)}100%{opacity:1;transform:scale(1, 1)}}@keyframes dropdown-transition-out{0%{opacity:1;transform:scale(1, 1)}100%{opacity:0;transform:scale(1, 0)}}.toolbar-dropdown{transform-origin:top left;--dropdown-show-animation: dropdown-transition-in;--dropdown-hide-animation: dropdown-transition-out}@media(prefers-reduced-motion: reduce){.toolbar-dropdown{--dropdown-show-animation: none;--dropdown-hide-animation: none}.toolbar-dropdown.hiding{display:none}.toolbar-toolContainer>.toolbar-button>.toolbar-showHideDropdownIcon{transition:none}:root .toolbar-button,.toolbar-root button{transition:none}}.toolbar-buttonGroup{display:flex;flex-direction:row;justify-content:center}.toolbar-element .toolbar--toggle-button{color:var(--foreground-color-1);font-weight:normal}.toolbar-element .toolbar--toggle-button[aria-checked=true]{background:var(--selection-background-color);color:var(--selection-foreground-color)}.toolbar-element .toolbar--toggle-button>.icon{width:25px;height:25px;margin:0 5px}.toolbar-element .toolbar--toggle-button>*{vertical-align:middle}.toolbar-closeColorPickerOverlay{display:none;position:fixed;top:0;left:0;bottom:0;right:0;touch-action:none;background-color:var(--background-color-1);opacity:.3;z-index:2}.toolbar-spacedList>*{padding-bottom:5px;padding-top:5px}.toolbar-indentedList{padding-left:10px}@media print{.toolbar-element{display:none}}@keyframes rehide-label{0%{opacity:.8}80%{opacity:.8}100%{opacity:.1}}@keyframes show-label-delayed{0%{opacity:0}80%{opacity:0}100%{opacity:.8}}@keyframes show-label-now{0%{opacity:0}5%{opacity:0}100%{opacity:.8}}@keyframes keep-label-hidden{0%{opacity:0}100%{opacity:0}}@keyframes toolbar--edgemenu-transition-in{from{transform:translate(0, 100%)}to{transform:translate(0, 0)}}@keyframes toolbar--edgemenu-transition-in-reduce-motion{from{opacity:0}to{opacity:1}}@keyframes toolbar--edgemenu-transition-out{to{transform:translate(0, 100%)}}@keyframes toolbar--edgemenu-transition-out-reduce-motion{from{opacity:1}to{opacity:0}}@keyframes toolbar--edgemenu-container-transition-in{from{overflow-y:hidden}to{overflow-y:hidden}}@keyframes toolbar--edgemenu-container-transition-out{from{overflow-y:hidden}to{overflow-y:hidden}}.toolbar-edge-toolbar{--toolbar-button-height: min(20vh, 48px);--toolbar-button-size: var(--toolbar-button-height);--label-hover-offset-size: calc(14px + var(--toolbar-button-height));box-sizing:border-box;flex-direction:row;justify-content:space-around;--button-label-hover-offset-y: var(--label-hover-offset-size);--button-label-hover-offset-x: 0}@media screen and (min-width: 540px){.toolbar-edge-toolbar{flex-wrap:nowrap}.toolbar-edge-toolbar>.toolbar-action-row{max-width:50vw;flex-grow:0;flex-shrink:0}}@media screen and (max-width: 700px){.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline{font-size:.9em}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button{width:var(--toolbar-button-size)}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button label{opacity:0;animation:.2s linear hide-initially}@keyframes hide-initially{from{opacity:0}to{opacity:0}}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):hover:not(:focus-visible)>label,.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):active>label{opacity:.8;animation:1s ease show-label-delayed}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button.has-long-press-or-hover>label{opacity:.8}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button:focus-visible>label,.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button.focus-visible>label{animation:1.5s ease rehide-label;opacity:0}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button:has(:focus-visible)>label{animation:1.5s ease rehide-label;opacity:0}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button>label{opacity:0;position:absolute;margin-top:var(--button-label-hover-offset-y);margin-left:var(--button-label-hover-offset-x);z-index:1;pointer-events:none;background-color:var(--background-color-1);color:var(--foreground-color-1);border-radius:25px;padding:10px;transition:.3s ease opacity,.2s ease margin-top}}@media screen and (max-width: 700px)and (prefers-reduced-motion: reduce){.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button>label{transition:none}}@media screen and (max-width: 700px){.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button>.toolbar-icon.toolbar-icon{margin-left:0;margin-right:0}}.toolbar-edge-toolbar>div.toolbar-element{flex-direction:row;display:flex;flex-grow:1;justify-content:center;background-color:var(--background-color-2);color:var(--foreground-color-2);--icon-color: var(--foreground-color-2);--extra-left-right-padding: 0px}.toolbar-edge-toolbar>div.toolbar-element::-webkit-scrollbar{width:3px;height:3px}.toolbar-edge-toolbar>div.toolbar-element::-webkit-scrollbar-thumb{background-color:var(--shadow-color)}.toolbar-edge-toolbar>div.toolbar-element.toolbar-tool-row{overflow-x:auto;overflow-y:hidden;flex-grow:100}.toolbar-edge-toolbar>div.toolbar-element.toolbar-action-row{z-index:2;background-color:var(--background-color-3);color:var(--foreground-color-3);--icon-color: var(--foreground-color-3)}.toolbar-edge-toolbar>div.toolbar-element.has-scroll{justify-content:start;position:relative;--button-label-hover-offset-y: 0;--button-label-hover-offset-x: calc(0px - var(--label-hover-offset-size))}.toolbar-edge-toolbar>div.toolbar-element.has-scroll>:nth-child(1){--button-label-hover-offset-x: var(--label-hover-offset-size)}.toolbar-edge-toolbar .toolbar-toolContainer.selected>.toolbar-button{background-color:var(--selection-background-color);color:var(--selection-foreground-color);--icon-color: var(--selection-foreground-color)}.toolbar-edge-toolbar .toolbar-button{box-sizing:border-box;background-color:rgba(0,0,0,0)}.toolbar-edge-toolbar .toolbar-button .toolbar-showHideDropdownIcon{flex-shrink:.01;height:12px}.toolbar-edge-toolbar .toolbar-toolContainer{order:1}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline{flex-grow:1;display:flex;--button-flex-direction: row}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline.label-left{justify-content:end;--button-flex-direction: row-reverse;order:100}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline.label-left>.toolbar-button>.toolbar-icon{margin-left:7px;margin-right:0}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline.label-right{order:-1}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline>.toolbar-button{width:auto;flex-direction:var(--button-flex-direction)}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline>.toolbar-button>.toolbar-icon{height:100%;margin-right:7px;margin-left:0;width:22px}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button{width:calc(var(--toolbar-button-size) + var(--extra-left-right-padding));height:var(--toolbar-button-size)}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):hover:not(:focus-visible)>label,.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):active>label{opacity:.8;animation:1s ease show-label-delayed}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button.has-long-press-or-hover>label{opacity:.8}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button:focus-visible>label,.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button.focus-visible>label{animation:1.5s ease rehide-label;opacity:0}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button:has(:focus-visible)>label{animation:1.5s ease rehide-label;opacity:0}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button>label{opacity:0;position:absolute;margin-top:var(--button-label-hover-offset-y);margin-left:var(--button-label-hover-offset-x);z-index:1;pointer-events:none;background-color:var(--background-color-1);color:var(--foreground-color-1);border-radius:25px;padding:10px;transition:.3s ease opacity,.2s ease margin-top}@media(prefers-reduced-motion: reduce){.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button>label{transition:none}}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline).dropdownVisible>.toolbar-button>label{opacity:.8;animation:1.5s ease rehide-label .3s,1s ease keep-label-hidden 1.8s infinite}.toolbar-edge-toolbar>div>.toolbar-toolContainer:not(.selected):not(.dropdownShowable)>.toolbar-button>.toolbar-showHideDropdownIcon{display:block;visibility:hidden}.toolbar-edge-toolbar .toolbar-toolContainer>.toolbar-button{margin:0;border-radius:0;padding:8px;box-shadow:none}.toolbar-edge-toolbar .toolbar-toolContainer>.toolbar-button.has-dropdown{padding-left:8px;padding-right:8px;padding-top:8px;padding-bottom:0px}.imageEditorContainer.pipette--color-selection-in-progress .toolbar-edgemenu-container{height:0;background-color:rgba(0,0,0,0);opacity:.9}.imageEditorContainer.pipette--color-selection-in-progress .toolbar-edgemenu-container .toolbar-edgemenu{position:absolute}.toolbar-edgemenu-container{background-color:var(--background-color-transparent);transition:.15s ease-in-out height,.15s ease-in-out background-color,.2s ease-in-out opacity;position:absolute;width:var(--editor-current-width-px);height:var(--editor-current-height-px);box-sizing:border-box;display:flex;flex-direction:column-reverse;align-items:center;z-index:2}@media(prefers-reduced-motion: reduce){.toolbar-edgemenu-container{transition:.15s ease-in-out background-color,.2s ease-in-out opacity}}.toolbar-edgemenu-container.dropdown-below-edge{overflow-y:hidden}.toolbar-edgemenu-container button{font-size:1.2em;box-shadow:none;border:none;padding:10px;transition:.2s ease box-shadow;font-weight:bold;color:var(--primary-action-foreground-color)}.toolbar-edgemenu-container button:not(:disabled):hover{box-shadow:0 1px 2px var(--shadow-color)}.toolbar-edgemenu-container button:disabled{opacity:.5;font-weight:unset;cursor:unset;color:var(--foreground-color-1)}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button{--button-label-hover-offset-y: var(--button-size)}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):hover:not(:focus-visible)>label>.button-label-text,.toolbar-edgemenu-container .toolbar-grid-selector .choice-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):active>label>.button-label-text{opacity:.8;animation:1s ease show-label-delayed}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button.has-long-press-or-hover>label>.button-label-text{opacity:.8}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button:focus-visible>label>.button-label-text,.toolbar-edgemenu-container .toolbar-grid-selector .choice-button.focus-visible>label>.button-label-text{animation:1.5s ease rehide-label;opacity:0}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button:has(:focus-visible)>label>.button-label-text{animation:1.5s ease rehide-label;opacity:0}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button>label>.button-label-text{opacity:0;position:absolute;margin-top:var(--button-label-hover-offset-y);margin-left:var(--button-label-hover-offset-x);z-index:1;pointer-events:none;background-color:var(--background-color-1);color:var(--foreground-color-1);border-radius:25px;padding:10px;transition:.3s ease opacity,.2s ease margin-top}@media(prefers-reduced-motion: reduce){.toolbar-edgemenu-container .toolbar-grid-selector .choice-button>label>.button-label-text{transition:none}}.toolbar-edgemenu-container .toolbar-help-overlay-button{align-items:last baseline}.toolbar-edgemenu-container .toolbar-edgemenu{--toolbar-button-height: 48px;touch-action:none;user-select:none;-webkit-user-select:none;background-color:var(--background-color-2);color:var(--foreground-color-2);--icon-color: var(--foreground-color-2);box-shadow:0px 0px 1px var(--shadow-color);padding-left:10px;padding-right:10px;width:min(400px,100vw);box-sizing:border-box;border-top-left-radius:30px;border-top-right-radius:30px;transition:transform .1s ease,padding-bottom .1s ease}.toolbar-edgemenu-container .toolbar-edgemenu input,.toolbar-edgemenu-container .toolbar-edgemenu textarea{user-select:auto;-webkit-user-select:auto}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer{display:inline-block}.toolbar-edgemenu-container .toolbar-edgemenu button{background-color:rgba(0,0,0,0)}.toolbar-edgemenu-container .toolbar-edgemenu>button.drag-elem{height:40px;display:block;cursor:ns-resize;position:relative;margin-top:-15px;margin-bottom:10px;width:100%;border:none;box-shadow:none;background:rgba(0,0,0,0)}.toolbar-edgemenu-container .toolbar-edgemenu>button.drag-elem::before{content:\"\";background-color:var(--icon-color);opacity:.2;display:block;position:relative;top:10px;height:5px;border-radius:5px;width:min(80%,40px);margin-left:auto;margin-right:auto}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer{display:block}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer .toolbar-button{flex-direction:row;max-width:unset;width:100%;box-sizing:border-box;justify-content:flex-start;box-shadow:none;padding:2px}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer .toolbar-button>.toolbar-icon{width:25px;height:25px;padding:13px;margin-right:15px}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer .toolbar-button label,.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer .toolbar-button>label.long-label{font-size:1em}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-nonbutton-controls-main-list{padding-left:10px;padding-right:10px}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList{box-sizing:border-box;--align-items-to-x: 105px}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList>div{display:flex;align-items:center;margin-top:5px;min-height:35px}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList>div:first-child{margin-top:0}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList>div>label{padding-right:35px;min-width:var(--align-items-to-x);flex-shrink:1;box-sizing:border-box}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList>div>input[type=checkbox]{width:20px;height:20px;margin-left:0}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList>div>input:not([type=checkbox]){flex-grow:1;min-width:48px;flex-shrink:1}.toolbar-dropdown-toolbar button,.toolbar-dropdown-toolbar .toolbar-button{background-color:var(--background-color-2);color:var(--foreground-color-2);--icon-color: var(--foreground-color-2)}.toolbar-dropdown-toolbar,.toolbar-dropdown-toolbar .toolbar-dropdown{background-color:var(--background-color-3);color:var(--foreground-color-3)}.toolbar-dropdown-toolbar .toolbar-spacedList>div>label{padding-right:10px;min-width:50px}.toolbar-dropdown-toolbar .clr-field button{width:100%;height:100%;top:50%;left:0;border-radius:5px}.toolbar-dropdown-toolbar .toolbar-grid-selector>div{--button-size: 57px}.toolbar-dropdown-toolbar .toolbar-dropdown>div>.toolbar-toolContainer{display:inline-block}.toolbar-help-overlay{width:100%;height:100%;max-width:none;max-height:none;border:none;margin:0;padding:0;z-index:5;touch-action:none;overflow:hidden;color:#fff;--icon-color: white;background-color:rgba(0,0,0,0);display:flex;flex-direction:column;transition:.3s ease transform}.toolbar-help-overlay::backdrop{background-color:rgba(0,0,0,.8);backdrop-filter:blur(1px);-webkit-backdrop-filter:blur(1px)}.toolbar-help-overlay,.toolbar-help-overlay::backdrop{animation:.25s ease transition-in}@keyframes transition-in{0%{opacity:0}100%{opacity:1}}@keyframes transition-out{0%{opacity:1}100%{opacity:0}}.toolbar-help-overlay.-hiding,.toolbar-help-overlay.-hiding::backdrop{animation:.25s ease transition-out;opacity:0}.toolbar-help-overlay.-dragging{transition:none}@media(prefers-reduced-motion: reduce){.toolbar-help-overlay{transition:none}}@media screen and (min-width: 800px){.toolbar-help-overlay>.navigation-buttons{order:1;margin-top:auto}}.toolbar-help-overlay .with-text-shadow,.toolbar-help-overlay .help-page-container>.label,.toolbar-help-overlay button{text-shadow:0 0 3px rgba(20,20,20,.9);filter:drop-shadow(0px 0px 2px rgba(0, 0, 0, 0.5))}.toolbar-help-overlay button:not(:disabled){cursor:pointer}.toolbar-help-overlay button{background:rgba(0,0,0,0);border:none;color:var(--help-overlay-foreground);border-radius:15px}.toolbar-help-overlay .close-button{align-self:flex-start;width:48px;height:48px;z-index:1}.toolbar-help-overlay .close-button>svg{width:100%}.toolbar-help-overlay .navigation-content{flex-grow:1;display:flex}.toolbar-help-overlay .help-page-container{display:flex;align-items:center;flex-grow:1;touch-action:none}.toolbar-help-overlay .help-page-container>.label{flex-grow:1;text-align:center;font-size:18.5pt;margin-left:15px;margin-right:15px;margin-top:0px;z-index:1;transition:.5s ease margin-top}.toolbar-help-overlay .help-page-container>.label.-large-space-below{margin-top:0;margin-bottom:auto}.toolbar-help-overlay .help-page-container>.label.-small-space-above{margin-top:40px;margin-bottom:auto}.toolbar-help-overlay .help-page-container>.label.-large-space-above{margin-top:auto;margin-bottom:10px}@media(prefers-reduced-motion: reduce){.toolbar-help-overlay .help-page-container>.label{transition:none}}.toolbar-help-overlay .help-page-container>.cloned-element-container{position:absolute;z-index:0;user-select:none;-webkit-user-select:none;border-radius:10px;opacity:.01;background-color:rgba(100,100,100,.01);box-shadow:none;transition:.5s ease opacity,.5s ease background-color}.toolbar-help-overlay .help-page-container>.cloned-element-container *{pointer-events:none !important}.toolbar-help-overlay .help-page-container>.cloned-element-container>*{margin:0;opacity:.01 !important;transition:.3s ease opacity !important}.toolbar-help-overlay .help-page-container>.cloned-element-container:not(.-clickable) *{cursor:unset !important}.toolbar-help-overlay .help-page-container>.cloned-element-container.-clickable,.toolbar-help-overlay .help-page-container>.cloned-element-container.-background{z-index:1;touch-action:none}.toolbar-help-overlay .help-page-container>.cloned-element-container.-clickable{cursor:pointer;z-index:2}.toolbar-help-overlay .help-page-container>.cloned-element-container.-clickable.has-long-press-or-hover{opacity:.5 !important}.toolbar-help-overlay .help-page-container>.cloned-element-container.-clickable.has-long-press-or-hover,.toolbar-help-overlay .help-page-container>.cloned-element-container.-active{background-color:var(--background-color-1)}.toolbar-help-overlay .help-page-container>.cloned-element-container.-active{opacity:1;background-color:var(--background-color-1);box-shadow:0 0 3px rgba(100,100,100,.5)}.toolbar-help-overlay .help-page-container>.cloned-element-container.-active>*{opacity:1 !important}.toolbar-help-overlay .navigation-buttons{display:flex;flex-direction:row;justify-content:space-between;direction:ltr}.toolbar-help-overlay .navigation-buttons>button:disabled{opacity:.5}.toolbar-help-overlay .navigation-buttons>.next,.toolbar-help-overlay .navigation-buttons>.previous{font-size:1em;padding:10px;transition:.2s ease font-size;z-index:3}@media(prefers-reduced-motion: reduce){.toolbar-help-overlay .navigation-buttons>.next,.toolbar-help-overlay .navigation-buttons>.previous{transition:none}}.toolbar-help-overlay .navigation-buttons:not(.-has-previous)>.next:not(:disabled){animation:.5s ease highlight-button .5s}@keyframes highlight-button{0%{transform:scale(1)}50%{transform:scale(1.2)}55%{transform:scale(1.2) rotate(2deg)}65%{transform:scale(1.2) rotate(-2deg)}100%{transform:scale(1)}}@media(prefers-reduced-motion: reduce){.toolbar-help-overlay .navigation-buttons:not(.-has-previous)>.next:not(:disabled){animation:none}}.toolbar-help-overlay .navigation-buttons>.next::after{content:\"\\u276F\";margin-left:3px}.toolbar-help-overlay .navigation-buttons>.previous::before{content:\"\\u276E\";margin-right:3px}.toolbar-help-overlay .navigation-buttons.-has-next>.next{font-size:1.4em}.toolbar-help-overlay .navigation-buttons.-has-previous>.previous{font-size:1.4em}.toolbar-help-overlay .navigation-buttons.-highlight-next>.next,.toolbar-help-overlay .navigation-buttons.-highlight-previous>.previous{font-weight:bold;background-color:rgba(200,200,200,.1);font-size:1.4em}.toolbar-help-overlay .navigation-help{margin-top:1em;font-size:.7em}.toolbar-element .toolbar-help-overlay-button{height:0;position:relative;display:flex;justify-content:end}.toolbar-element .toolbar-help-overlay-button>.button{margin:0;padding:5px;padding-top:0;padding-bottom:0;box-shadow:none;text-align:center;opacity:.5}.toolbar-element .toolbar-help-overlay-button>.button>.icon{width:1.18em;height:1.18em;transition:.2s ease filter}.toolbar-element .toolbar-help-overlay-button>.button:focus-visible>.icon,.toolbar-element .toolbar-help-overlay-button>.button:hover>.icon{filter:drop-shadow(0px 0px 1px var(--shadow-color))}.ScrollbarTool-overlay{width:0;height:0;overflow:visible;opacity:.2;pointer-events:none;--fade-out-animation: 1s ease 0s fade-out;--scrollbar-size: 3px}@media(prefers-reduced-motion: reduce){.ScrollbarTool-overlay{--fade-out-animation: none !important}}@keyframes fade-out{from{opacity:.2}to{opacity:0}}.ScrollbarTool-overlay:not(.just-updated){animation:var(--fade-out-animation);opacity:0}.ScrollbarTool-overlay .vertical-scrollbar,.ScrollbarTool-overlay .horizontal-scrollbar{width:var(--scrollbar-size);height:var(--scrollbar-size);min-width:var(--scrollbar-size);min-height:var(--scrollbar-size);background-color:var(--foreground-color-1);border-radius:var(--scrollbar-size);position:absolute}.ScrollbarTool-overlay .vertical-scrollbar.represents-no-scroll,.ScrollbarTool-overlay .horizontal-scrollbar.represents-no-scroll{animation:var(--fade-out-animation);opacity:0}.ScrollbarTool-overlay:not(.scrollbar-left) .vertical-scrollbar{margin-left:calc(var(--editor-current-display-width-px) - var(--scrollbar-size))}.ScrollbarTool-overlay:not(.scrollbar-top) .horizontal-scrollbar{margin-top:calc(var(--editor-current-display-height-px) - var(--scrollbar-size))}.clipboard-error-dialog details>summary{cursor:pointer}.clipboard-error-dialog details[open]{margin-bottom:12px}.clipboard-error-dialog textarea{width:100%;box-sizing:border-box}.selection-tool-selection-background{background-color:var(--selection-background-color);opacity:.5;overflow:visible}.selection-tool-handle{position:absolute;box-sizing:border-box;display:flex;align-items:center;justify-content:center;--max-size: 17px}.selection-tool-handle .selection-tool-content{border:1px solid var(--foreground-color-1);background:var(--background-color-1);box-sizing:border-box;max-width:var(--max-size);max-height:var(--max-size);width:100%;height:100%;display:flex;justify-content:center;align-items:center;padding:3px}.selection-tool-handle .selection-tool-content .icon{width:100%;height:100%}.selection-tool-handle.selection-tool-circle .selection-tool-content{border-radius:100%}.selection-tool-handle.selection-tool-rotate{--max-size: 28px;cursor:grab}.selection-tool-handle.selection-tool-resize-x{cursor:ew-resize}.selection-tool-handle.selection-tool-resize-y{cursor:ns-resize}.selection-tool-handle.selection-tool-resize-xy{cursor:nwse-resize}.selection-tool-rotated-near-perpendicular .selection-tool-handle.selection-tool-resize-x{cursor:ns-resize}.selection-tool-rotated-near-perpendicular .selection-tool-handle.selection-tool-resize-y{cursor:ew-resize}.selection-tool-rotated-near-perpendicular .selection-tool-handle.selection-tool-resize-xy{cursor:nesw-resize}.selection-tool-selection-menu>button{max-height:var(--vertical-offset);background-color:var(--background-color-1);width:24px;height:24px;padding:6px;font-size:14px;user-select:none;-webkit-user-select:none;color:var(--foreground-color-1);border:.5px solid var(--foreground-color-1);border-radius:3px;opacity:.8;transition:.2s ease opacity}.selection-tool-selection-menu>button:hover,.selection-tool-selection-menu>button:focus-visible{background-color:var(--background-color-2);color:var(--foreground-color-2);cursor:pointer;opacity:1}.selection-tool-selection-menu>button>.icon{width:100%;height:100%}.overlay.handleOverlay{touch-action:none;direction:ltr}.overlay.handleOverlay,.overlay.handleOverlay .selection-tool-selection-outer-container{height:0;overflow:visible}.overlay.handleOverlay .selection-tool-selection-inner-container{width:var(--editor-current-display-width-px);height:var(--editor-current-display-height-px);overflow:hidden;pointer-events:none}.overlay.handleOverlay .selection-tool-selection-inner-container>*{pointer-events:all}.overlay.handleOverlay .selection-tool-selection-inner-container.-empty{opacity:0}.overlay.handleOverlay .selection-tool-selection-inner-container.-hide-handles .selection-tool-handle{display:none}@keyframes selection-duplicated-animation{0%{scale:1 1}50%{scale:1.02 1.02}100%{scale:1 1}}@media(prefers-reduced-motion: reduce){@keyframes selection-duplicated-animation{}}.find-tool-overlay{order:-1;position:absolute}.js-draw-sound-ui-toggle{width:0px;height:0px;overflow:hidden;user-select:none;-webkit-user-select:none}.js-draw-sound-ui-toggle button{margin-top:1px}.js-draw-sound-ui-toggle:focus-within,.js-draw-sound-ui-toggle.sound-ui-tool-enabled{overflow:visible;z-index:5}.js-draw-sound-ui-toggle:not(:focus-within):not(:hover).sound-ui-tool-enabled{opacity:.5}@keyframes show-popup-menu-animation{from{opacity:0}to{opacity:1}}.editor-popup-menu{width:100%;height:100%;background-color:rgba(0,0,0,0);border:none;animation:var(--hide-menu-animation-timeout) ease show-popup-menu-animation;opacity:1;transition:var(--hide-menu-animation-timeout) ease opacity;overflow:hidden}.editor-popup-menu.-hide{opacity:0}.editor-popup-menu>.content{position:absolute;left:var(--anchor-x);top:var(--anchor-y);display:flex;flex-direction:column;overflow:clip;border-radius:6px;box-shadow:0px 1px 2px var(--shadow-color);background-color:var(--background-color-1)}.editor-popup-menu::backdrop{background:rgba(0,0,0,0)}.editor-popup-menu-option{display:flex;justify-content:start;cursor:pointer;padding:5px;padding-top:6px;padding-bottom:6px;background-color:rgba(0,0,0,0);color:var(--foreground-color-1);--icon-color: currentColor;border:none;font-size:1em}.editor-popup-menu-option:hover,.editor-popup-menu-option:focus-visible{background-color:var(--background-color-2);color:var(--foreground-color-2)}.editor-popup-menu-option>:first-child{width:1em;height:1em;flex-shrink:0;margin-inline-start:0em;margin-inline-end:.25em}.about-dialog-content>.scroll{white-space:pre-wrap;font-family:monospace}.about-dialog-content>.scroll>details>summary{cursor:pointer}.about-dialog-content>.scroll>h2,.about-dialog-content>.scroll>details>summary{margin-top:15px;font-size:1.2em;font-weight:bold}.about-dialog-content>.scroll>h2 a,.about-dialog-content>.scroll>details>summary a{color:var(--foreground-color-1);text-decoration:underline}@keyframes fade-in{from{opacity:0}to{opacity:1}}.message-dialog-container dialog{display:flex}.message-dialog-container dialog.-closing{opacity:0}.message-dialog-container dialog.-closing::backdrop{opacity:0}.message-dialog-container dialog,.message-dialog-container dialog::backdrop{transition:opacity .2s ease;animation:fade-in .2s ease}.message-dialog-content{display:flex;flex-direction:column;flex-grow:1}.message-dialog-content>.close{display:block;margin-left:auto;margin-right:auto}.message-dialog-content>.scroll{flex-grow:1;flex-shrink:1;overflow-y:auto;margin-left:20px;margin-right:20px;padding-bottom:20px}.dialog-container>dialog{background-color:var(--background-color-1);color:var(--foreground-color-1);border:none;outline:none;box-shadow:0 0 2px var(--shadow-color);border-radius:8px;max-height:90vh;width:min(100%,500px);box-sizing:border-box}.dialog-container>dialog::backdrop{backdrop-filter:blur(5px);-webkit-backdrop-filter:blur(5px);background-color:var(--background-color-transparent)}#clr-picker{--clr-slider-size: 30px}#clr-picker #clr-color-area,#clr-picker .clr_hue{touch-action:none}#clr-picker .clr-alpha{margin-top:15px;margin-bottom:15px}#clr-picker.clr-picker input[type=range]::-moz-range-thumb{width:var(--clr-slider-size);height:var(--clr-slider-size)}#clr-picker.clr-picker input[type=range]::-webkit-slider-thumb{width:var(--clr-slider-size);height:var(--clr-slider-size)}#clr-picker.clr-picker input[type=range]::-webkit-slider-runnable-track{height:var(--clr-slider-size)}#clr-picker.clr-picker input[type=range]::-moz-range-track{height:var(--clr-slider-size)}.imageEditorContainer{--background-color-1: white;--foreground-color-1: black;--background-color-2: #f5f5f5;--foreground-color-2: #2c303a;--background-color-3: #e5e5e5;--foreground-color-3: #1c202a;--selection-background-color: #cbdaf1;--selection-foreground-color: #2c303a;--background-color-transparent: rgba(105, 100, 100, 0.5);--shadow-color: rgba(0, 0, 0, 0.5);--primary-action-foreground-color: #15b}@media(prefers-color-scheme: dark){.imageEditorContainer{--background-color-1: #151515;--foreground-color-1: white;--background-color-2: #222;--foreground-color-2: #efefef;--background-color-3: #272627;--foreground-color-3: #eee;--selection-background-color: #607;--selection-foreground-color: white;--shadow-color: rgba(250, 250, 250, 0.5);--background-color-transparent: rgba(50, 50, 50, 0.5);--primary-action-foreground-color: #7ae}}.imageEditorContainer{--icon-color: var(--foreground-color-1)}.imageEditorContainer{color:var(--foreground-color-1);font-family:system-ui,-apple-system,sans-serif;background-color:var(--background-color-1);width:100%;height:400px;min-height:220px;min-width:100px;writing-mode:horizontal-tb;box-sizing:border-box;display:flex;flex-direction:column-reverse}.imageEditorContainer input{accent-color:var(--primary-action-foreground-color)}.imageEditorContainer .imageEditorRenderArea{display:grid;grid-template-columns:1fr;flex-grow:2;flex-shrink:1;min-height:100px;min-width:0;width:100%;height:100%}.imageEditorContainer .imageEditorRenderArea canvas{grid-row:1/1;grid-column:1/1;touch-action:none;box-sizing:border-box;width:100%;height:100%;min-width:0;max-width:inherit;min-height:0px;max-height:inherit;user-select:none;-webkit-user-select:none;-webkit-user-drag:none}.imageEditorContainer .loadingMessage{position:fixed;text-align:center;font-size:2em;text-shadow:0px 0px 1px var(--background-color-1);bottom:0;left:0;right:0}.imageEditorContainer .accessibilityAnnouncement{opacity:0;width:0;height:0;overflow:hidden;pointer-events:none;user-select:none;-webkit-user-select:none}.imageEditorContainer .textRendererOutputContainer{width:.001px;height:.001px;overflow:hidden;-webkit-user-select:none;user-select:none}.imageEditorContainer .textRendererOutputContainer:focus-within{overflow:visible;z-index:5}.imageEditorContainer .anchored-element-overlay{overflow:visible;height:0}.imageEditorContainer .anchored-element-overlay>.content-wrapper{width:var(--editor-current-display-width-px);height:var(--editor-current-display-height-px);overflow:hidden;position:relative;pointer-events:none}.imageEditorContainer .anchored-element-overlay>.content-wrapper>.content{position:absolute;left:var(--position-x);top:var(--position-y);transform:scale(var(--scale)) rotate(var(--rotation));transform-origin:left top;margin:0;pointer-events:all}@media print{.imageEditorContainer .loadingMessage{display:none}.imageEditorContainer .imageEditorRenderArea canvas{width:100%;height:initial}}',document.head.appendChild(o)}})();(()=>{if(typeof document<\"u\"&&typeof document.createElement==\"function\"){let o=document.createElement(\"style\");o.textContent='.clr-picker{display:none;flex-wrap:wrap;position:absolute;width:200px;z-index:1000;border-radius:10px;background-color:#fff;justify-content:flex-end;direction:ltr;box-shadow:0 0 5px rgba(0, 0, 0, 0.05),0 5px 20px rgba(0, 0, 0, 0.1);-moz-user-select:none;-webkit-user-select:none;user-select:none}.clr-picker.clr-open,.clr-picker[data-inline=true]{display:flex}.clr-picker[data-inline=true]{position:relative}.clr-gradient{position:relative;width:100%;height:100px;margin-bottom:15px;border-radius:3px 3px 0 0;background-image:linear-gradient(rgba(0, 0, 0, 0), #000),linear-gradient(90deg, #fff, currentColor);cursor:pointer}.clr-marker{position:absolute;width:12px;height:12px;margin:-6px 0 0 -6px;border:1px solid #fff;border-radius:50%;background-color:currentColor;cursor:pointer}.clr-picker input[type=range]::-webkit-slider-runnable-track{width:100%;height:16px}.clr-picker input[type=range]::-webkit-slider-thumb{width:16px;height:16px;-webkit-appearance:none}.clr-picker input[type=range]::-moz-range-track{width:100%;height:16px;border:0}.clr-picker input[type=range]::-moz-range-thumb{width:16px;height:16px;border:0}.clr-hue{background-image:linear-gradient(to right, #f00 0%, #ff0 16.66%, #0f0 33.33%, #0ff 50%, #00f 66.66%, #f0f 83.33%, #f00 100%)}.clr-hue,.clr-alpha{position:relative;width:calc(100% - 40px);height:8px;margin:5px 20px;border-radius:4px}.clr-alpha span{display:block;height:100%;width:100%;border-radius:inherit;background-image:linear-gradient(90deg, rgba(0, 0, 0, 0), currentColor)}.clr-hue input,.clr-alpha input{position:absolute;width:calc(100% + 32px);height:16px;left:-16px;top:-4px;margin:0;background-color:transparent;opacity:0;cursor:pointer;appearance:none;-webkit-appearance:none}.clr-hue div,.clr-alpha div{position:absolute;width:16px;height:16px;left:0;top:50%;margin-left:-8px;transform:translateY(-50%);border:2px solid #fff;border-radius:50%;background-color:currentColor;box-shadow:0 0 1px #888;pointer-events:none}.clr-alpha div:before{content:\"\";position:absolute;height:100%;width:100%;left:0;top:0;border-radius:50%;background-color:currentColor}.clr-format{display:none;order:1;width:calc(100% - 40px);margin:0 20px 20px}.clr-segmented{display:flex;position:relative;width:100%;margin:0;padding:0;border:1px solid #ddd;border-radius:15px;box-sizing:border-box;color:#999;font-size:12px}.clr-segmented input,.clr-segmented legend{position:absolute;width:100%;height:100%;margin:0;padding:0;border:0;left:0;top:0;opacity:0;pointer-events:none}.clr-segmented label{flex-grow:1;margin:0;padding:4px 0;font-size:inherit;font-weight:normal;line-height:initial;text-align:center;cursor:pointer}.clr-segmented label:first-of-type{border-radius:10px 0 0 10px}.clr-segmented label:last-of-type{border-radius:0 10px 10px 0}.clr-segmented input:checked+label{color:#fff;background-color:#666}.clr-swatches{order:2;width:calc(100% - 32px);margin:0 16px}.clr-swatches div{display:flex;flex-wrap:wrap;padding-bottom:12px;justify-content:center}.clr-swatches button{position:relative;width:20px;height:20px;margin:0 4px 6px 4px;padding:0;border:0;border-radius:50%;color:inherit;text-indent:-1000px;white-space:nowrap;overflow:hidden;cursor:pointer}.clr-swatches button:after{content:\"\";display:block;position:absolute;width:100%;height:100%;left:0;top:0;border-radius:inherit;background-color:currentColor;box-shadow:inset 0 0 0 1px rgba(0, 0, 0, 0.1)}input.clr-color{order:1;width:calc(100% - 80px);height:32px;margin:15px 20px 20px auto;padding:0 10px;border:1px solid #ddd;border-radius:16px;color:#444;background-color:#fff;font-family:sans-serif;font-size:14px;text-align:center;box-shadow:none}input.clr-color:focus{outline:none;border:1px solid #1e90ff}.clr-close,.clr-clear{display:none;order:2;height:24px;margin:0 20px 20px;padding:0 20px;border:0;border-radius:12px;color:#fff;background-color:#666;font-family:inherit;font-size:12px;font-weight:400;cursor:pointer}.clr-close{display:block;margin:0 20px 20px auto}.clr-preview{position:relative;width:32px;height:32px;margin:15px 0 20px 20px;border-radius:50%;overflow:hidden}.clr-preview:before,.clr-preview:after{content:\"\";position:absolute;height:100%;width:100%;left:0;top:0;border:1px solid #fff;border-radius:50%}.clr-preview:after{border:0;background-color:currentColor;box-shadow:inset 0 0 0 1px rgba(0, 0, 0, 0.1)}.clr-preview button{position:absolute;width:100%;height:100%;z-index:1;margin:0;padding:0;border:0;border-radius:50%;outline-offset:-2px;background-color:transparent;text-indent:-9999px;cursor:pointer;overflow:hidden}.clr-marker,.clr-hue div,.clr-alpha div,.clr-color{box-sizing:border-box}.clr-field{display:inline-block;position:relative;color:transparent}.clr-field input{margin:0;direction:ltr}.clr-field.clr-rtl input{text-align:right}.clr-field button{position:absolute;width:30px;height:100%;right:0;top:50%;transform:translateY(-50%);margin:0;padding:0;border:0;color:inherit;text-indent:-1000px;white-space:nowrap;overflow:hidden;pointer-events:none}.clr-field.clr-rtl button{right:auto;left:0}.clr-field button:after{content:\"\";display:block;position:absolute;width:100%;height:100%;left:0;top:0;border-radius:inherit;background-color:currentColor;box-shadow:inset 0 0 1px rgba(0, 0, 0, 0.5)}.clr-alpha,.clr-alpha div,.clr-swatches button,.clr-preview:before,.clr-field button{background-image:repeating-linear-gradient(45deg, #aaa 25%, transparent 25%, transparent 75%, #aaa 75%, #aaa),repeating-linear-gradient(45deg, #aaa 25%, #fff 25%, #fff 75%, #aaa 75%, #aaa);background-position:0 0,4px 4px;background-size:8px 8px}.clr-marker:focus{outline:none}.clr-keyboard-nav .clr-marker:focus,.clr-keyboard-nav .clr-hue input:focus+div,.clr-keyboard-nav .clr-alpha input:focus+div,.clr-keyboard-nav .clr-segmented input:focus+label{outline:none;box-shadow:0 0 0 2px #1e90ff,0 0 2px 2px #fff}.clr-picker[data-alpha=false] .clr-alpha{display:none}.clr-picker[data-minimal=true]{padding-top:16px}.clr-picker[data-minimal=true] .clr-gradient,.clr-picker[data-minimal=true] .clr-hue,.clr-picker[data-minimal=true] .clr-alpha,.clr-picker[data-minimal=true] .clr-color,.clr-picker[data-minimal=true] .clr-preview{display:none}.clr-dark{background-color:#444}.clr-dark .clr-segmented{border-color:#777}.clr-dark .clr-swatches button:after{box-shadow:inset 0 0 0 1px rgba(255, 255, 255, 0.3)}.clr-dark input.clr-color{color:#fff;border-color:#777;background-color:#555}.clr-dark input.clr-color:focus{border-color:#1e90ff}.clr-dark .clr-preview:after{box-shadow:inset 0 0 0 1px rgba(255, 255, 255, 0.5)}.clr-dark .clr-alpha,.clr-dark .clr-alpha div,.clr-dark .clr-swatches button,.clr-dark .clr-preview:before{background-image:repeating-linear-gradient(45deg, #666 25%, transparent 25%, transparent 75%, #888 75%, #888),repeating-linear-gradient(45deg, #888 25%, #444 25%, #444 75%, #888 75%, #888)}.clr-picker.clr-polaroid{border-radius:6px;box-shadow:0 0 5px rgba(0, 0, 0, 0.1),0 5px 30px rgba(0, 0, 0, 0.2)}.clr-picker.clr-polaroid:before{content:\"\";display:block;position:absolute;width:16px;height:10px;left:20px;top:-10px;border:solid transparent;border-width:0 8px 10px 8px;border-bottom-color:currentColor;box-sizing:border-box;color:#fff;filter:drop-shadow(0 -4px 3px rgba(0, 0, 0, 0.1));pointer-events:none}.clr-picker.clr-polaroid.clr-dark:before{color:#444}.clr-picker.clr-polaroid.clr-left:before{left:auto;right:20px}.clr-picker.clr-polaroid.clr-top:before{top:auto;bottom:-10px;transform:rotateZ(180deg)}.clr-polaroid .clr-gradient{width:calc(100% - 20px);height:120px;margin:10px;border-radius:3px}.clr-polaroid .clr-hue,.clr-polaroid .clr-alpha{width:calc(100% - 30px);height:10px;margin:6px 15px;border-radius:5px}.clr-polaroid .clr-hue div,.clr-polaroid .clr-alpha div{box-shadow:0 0 5px rgba(0, 0, 0, 0.2)}.clr-polaroid .clr-format{width:calc(100% - 20px);margin:0 10px 15px}.clr-polaroid .clr-swatches{width:calc(100% - 12px);margin:0 6px}.clr-polaroid .clr-swatches div{padding-bottom:10px}.clr-polaroid .clr-swatches button{width:22px;height:22px}.clr-polaroid input.clr-color{width:calc(100% - 60px);margin:10px 10px 15px auto}.clr-polaroid .clr-clear{margin:0 10px 15px 10px}.clr-polaroid .clr-close{margin:0 10px 15px auto}.clr-polaroid .clr-preview{margin:10px 0 15px 10px}.clr-picker.clr-large{width:275px}.clr-large .clr-gradient{height:150px}.clr-large .clr-swatches button{width:22px;height:22px}.clr-picker.clr-pill{width:380px;padding-left:180px;box-sizing:border-box}.clr-pill .clr-gradient{position:absolute;width:180px;height:100%;left:0;top:0;margin-bottom:0;border-radius:3px 0 0 3px}.clr-pill .clr-hue{margin-top:20px}',document.head.appendChild(o)}})();})();\n","/**\n * Browser storage utility functions for Firefox extension\n */\n/**\n * Store a key-value pair in browser storage\n * @param key Storage key\n * @param value String value to store\n */\nexport async function storeValue(key, value) {\n    try {\n        await browser.storage.sync.set({ [key]: value });\n    }\n    catch (error) {\n        console.error(\"Failed to store value:\", error);\n        return;\n    }\n}\n/**\n * Retrieve a value from browser storage\n * @param key Storage key\n * @returns The stored string value, or null if not found\n */\nexport async function getValue(key) {\n    try {\n        const result = await browser.storage.sync.get(key);\n        return result[key] || null;\n    }\n    catch (error) {\n        console.error(\"Failed to retrieve value:\", error);\n        return null;\n    }\n}\n/**\n * Remove a key-value pair from browser storage\n * @param key Storage key to remove\n */\nexport async function removeValue(key) {\n    try {\n        await browser.storage.sync.remove(key);\n    }\n    catch (error) {\n        console.error(\"Failed to remove value:\", error);\n        return;\n    }\n}\n","export async function openDatabase() {\n    return new Promise((resolve, reject) => {\n        const request = indexedDB.open(\"SVGStorageDB\", 1);\n        request.onupgradeneeded = (event) => {\n            const db = event.target.result;\n            if (!db.objectStoreNames.contains(\"SVGs\")) {\n                db.createObjectStore(\"SVGs\", { keyPath: \"id\" });\n            }\n        };\n        request.onsuccess = (event) => {\n            resolve(event.target.result);\n        };\n        request.onerror = (event) => {\n            reject(event.target.error);\n        };\n    });\n}\nexport async function saveSVG(id, svgData) {\n    const db = await openDatabase();\n    return new Promise((resolve, reject) => {\n        const transaction = db.transaction(\"SVGs\", \"readwrite\");\n        const store = transaction.objectStore(\"SVGs\");\n        const data = { id, svgData };\n        const request = store.put(data);\n        request.onsuccess = () => {\n            resolve(\"SVG saved successfully!\");\n        };\n        request.onerror = (event) => {\n            reject(event.target.error);\n        };\n    });\n}\nexport async function getSVG(id) {\n    const db = await openDatabase();\n    return new Promise((resolve, reject) => {\n        const transaction = db.transaction(\"SVGs\", \"readonly\");\n        const store = transaction.objectStore(\"SVGs\");\n        const request = store.get(id);\n        request.onsuccess = (event) => {\n            resolve(event.target.result?.svgData || null);\n        };\n        request.onerror = (event) => {\n            reject(event.target.error);\n        };\n    });\n}\nlet debounce = null;\nexport const queueSave = (editor) => {\n    if (debounce && Date.now() - debounce < 2000) {\n        return;\n    }\n    debounce = Date.now();\n    const maxDimension = Math.max(editor.viewport.visibleRect.width, editor.viewport.visibleRect.height);\n    const svg = editor.toSVG({ minDimension: maxDimension });\n    saveSVG(document.location.href, svg.outerHTML).catch(console.error);\n};\n","import { Erase } from \"js-draw\";\nexport const ClearButton = (editor) => {\n    const clearIcon = document.createElement(\"div\");\n    clearIcon.textContent = \"🧹\";\n    return [\n        { icon: clearIcon, label: \"Clear\" },\n        () => {\n            const allComponents = editor.image.getAllElements();\n            const deleteCommand = new Erase(allComponents);\n            editor.dispatch(deleteCommand);\n        },\n    ];\n};\n// Clear icon clears the canvas\n// const clearIcon = document.createElement(\"div\");\n// clearIcon.textContent = \"🧹\";\n// toolbar.addActionButton({ icon: clearIcon, label: \"Clear\" }, () => {\n// });\n","export const CloseButton = () => {\n    const closeIcon = document.createElement(\"div\");\n    closeIcon.textContent = \"❌\";\n    return [\n        { icon: closeIcon, label: \"Close\" },\n        () => {\n            document.querySelector(\".js-draw\")?.classList.add(\"display-none\");\n        },\n    ];\n};\n","export const HideButton = ({ onSelect, }) => {\n    const hideIcon = document.createElement(\"div\");\n    hideIcon.textContent = \"👁️\";\n    return {\n        hide: [\n            { icon: hideIcon, label: \"Hide\" },\n            () => {\n                onSelect();\n                const element = document.querySelector(\".imageEditorRenderArea\");\n                const drawElement = document.querySelector(\".js-draw\");\n                if (!element || !drawElement)\n                    return;\n                element.classList.add(\"visibility-hidden\");\n                drawElement.classList.add(\"pointer-events-none\");\n            },\n        ],\n        resetHide: () => {\n            const element = document.querySelector(\".imageEditorRenderArea\");\n            const drawElement = document.querySelector(\".js-draw\");\n            if (!element || !drawElement)\n                return;\n            element.classList.remove(\"visibility-hidden\");\n            drawElement.classList.remove(\"pointer-events-none\");\n        },\n    };\n};\n","export const NormalButton = ({ onSelect, }) => {\n    const normalIcon = document.createElement(\"div\");\n    normalIcon.textContent = \"📝\";\n    return {\n        normal: [\n            { icon: normalIcon, label: \"Draw\" },\n            () => {\n                onSelect();\n            },\n        ],\n        resetNormal: () => {\n            //\n        },\n    };\n};\n","export const TransparentButton = ({ onSelect, }) => {\n    const transparentIcon = document.createElement(\"div\");\n    transparentIcon.textContent = \"🪟\";\n    return {\n        transparent: [\n            { icon: transparentIcon, label: \"Transparent\" },\n            () => {\n                onSelect();\n                const element = document.querySelector(\".js-draw\");\n                if (!element)\n                    return;\n                element.classList.add(\"pointer-events-none\");\n            },\n        ],\n        resetTransparent: () => {\n            const element = document.querySelector(\".js-draw\");\n            if (!element)\n                return;\n            element.classList.remove(\"pointer-events-none\");\n        },\n    };\n};\n","import { PanZoomTool, } from \"js-draw\";\nimport { CloseButton } from \"./btnClose\";\nimport { ClearButton } from \"./btnClear\";\nimport { TransparentButton } from \"./btnTransparent\";\nimport { HideButton } from \"./btnHide\";\nimport { NormalButton } from \"./btnNormal\";\nimport { getValue, storeValue } from \"../data/browser\";\nlet mode = \"draw\";\nexport const initToolbar = (editor) => {\n    const toolController = editor.toolController;\n    const panTools = toolController.getMatchingTools(PanZoomTool);\n    toolController.removeAndDestroyTools(panTools);\n    const toolbar = editor.addToolbar();\n    getValue(\"toolbarState\").then((state) => {\n        if (state) {\n            try {\n                toolbar.deserializeState(state);\n            }\n            catch (e) {\n                console.warn(\"Error deserializing toolbar state: \", e);\n            }\n        }\n    });\n    toolbar.addActionButton(...CloseButton());\n    toolbar.addActionButton(...ClearButton(editor));\n    const { transparent, resetTransparent } = TransparentButton({\n        onSelect: () => {\n            resetHide();\n            mode = \"transparent\";\n            transparentButton.addCSSClassToContainer(\"toggle-on\");\n            hideButton.removeCSSClassFromContainer(\"toggle-on\");\n            normalButton.removeCSSClassFromContainer(\"toggle-on\");\n        },\n    });\n    const transparentButton = toolbar.addActionButton(...transparent);\n    transparentButton.addCSSClassToContainer(\"margin-left-48\");\n    const { hide, resetHide } = HideButton({\n        onSelect: () => {\n            resetTransparent();\n            mode = \"hide\";\n            hideButton.addCSSClassToContainer(\"toggle-on\");\n            transparentButton.removeCSSClassFromContainer(\"toggle-on\");\n            normalButton.removeCSSClassFromContainer(\"toggle-on\");\n        },\n    });\n    const hideButton = toolbar.addActionButton(...hide);\n    const { normal, resetNormal } = NormalButton({\n        onSelect: () => {\n            resetHide();\n            resetTransparent();\n            mode = \"draw\";\n            normalButton.addCSSClassToContainer(\"toggle-on\");\n            hideButton.removeCSSClassFromContainer(\"toggle-on\");\n            transparentButton.removeCSSClassFromContainer(\"toggle-on\");\n        },\n    });\n    const normalButton = toolbar.addActionButton(...normal);\n    normalButton.addCSSClassToContainer(\"toggle-on\");\n    timedSave(toolbar);\n    return toolbar;\n};\nconst timedSave = (toolbar) => {\n    const timedSaveInterval = setInterval(() => {\n        storeValue(\"toolbarState\", toolbar.serializeState());\n    }, 10000);\n};\n","import { Viewport } from \"js-draw\";\nimport { Mat33, Vec2 } from \"@js-draw/math\";\nlet lastPos = { x: 0, y: 0 };\nexport function update(edtr, wndw) {\n    const scrollX = wndw.scrollX;\n    const scrollY = wndw.scrollY;\n    const deltaX = scrollX - lastPos.x;\n    const deltaY = lastPos.y - scrollY;\n    if (deltaX !== 0 || deltaY !== 0) {\n        const delta = Mat33.translation(Vec2.of(deltaX, deltaY));\n        const deltaCommand = Viewport.transformBy(delta);\n        deltaCommand.apply(edtr);\n    }\n    lastPos = { x: scrollX, y: scrollY };\n}\nlet lastZoom = 1;\nexport function updateZoom(edtr, wndw) {\n    const zoom = wndw.devicePixelRatio;\n    if (zoom !== lastZoom) {\n        const zoomFactor = zoom / lastZoom;\n        const deltaZoom = Mat33.translation(Vec2.of(0, 0)).rightMul(Mat33.scaling2D(zoomFactor));\n        const zoomCommand = Viewport.transformBy(deltaZoom);\n        zoomCommand.apply(edtr);\n        lastZoom = zoom;\n    }\n    requestAnimationFrame(() => {\n        updateZoom(edtr, wndw);\n    });\n}\n","import  Vec3  from './Vec3.mjs';\n/**\n * Represents a color.\n *\n * @example\n * ```ts,runnable,console\n * import { Color4 } from '@js-draw/math';\n *\n * console.log('Red:', Color4.fromString('#f00'));\n * console.log('Also red:', Color4.ofRGB(1, 0, 0), Color4.red);\n * console.log('Mixing red and blue:', Color4.red.mix(Color4.blue, 0.5));\n * console.log('To string:', Color4.orange.toHexString());\n * ```\n */\nexport class Color4 {\n    constructor(\n    /** Red component. Should be in the range [0, 1]. */\n    r, \n    /** Green component. ${\\tt g} \\in [0, 1]$ */\n    g, \n    /** Blue component. ${\\tt b} \\in [0, 1]$ */\n    b, \n    /** Alpha/transparent component. ${\\tt a} \\in [0, 1]$. 0 = transparent */\n    a) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n        this.hexString = null;\n    }\n    /**\n     * Create a color from red, green, blue components. The color is fully opaque (`a = 1.0`).\n     *\n     * Each component should be in the range [0, 1].\n     */\n    static ofRGB(red, green, blue) {\n        return Color4.ofRGBA(red, green, blue, 1.0);\n    }\n    /**\n     * Creates a color from red, green, blue, and transparency components. Each component should\n     * be in the range $[0, 1]$.\n     */\n    static ofRGBA(red, green, blue, alpha) {\n        red = Math.max(0, Math.min(red, 1));\n        green = Math.max(0, Math.min(green, 1));\n        blue = Math.max(0, Math.min(blue, 1));\n        alpha = Math.max(0, Math.min(alpha, 1));\n        return new Color4(red, green, blue, alpha);\n    }\n    /**\n     * Creates a color from an RGB (or RGBA) array.\n     *\n     * This is similar to {@link ofRGB} and {@link ofRGBA}, but, by default, takes values\n     * that range from 0 to 255.\n     *\n     * If the array values instead range from 0-1, pass `maxValue` as `1`.\n     */\n    static fromRGBArray(array, maxValue = 255) {\n        const red = array[0];\n        const green = array[1] ?? red;\n        const blue = array[2] ?? red;\n        let alpha = 255;\n        if (3 < array.length) {\n            alpha = array[3];\n        }\n        return Color4.ofRGBA(red / maxValue, green / maxValue, blue / maxValue, alpha / maxValue);\n    }\n    /**\n     * Creates a `Color4` from a three or four-component hexadecimal\n     * [color string](https://en.wikipedia.org/wiki/Web_colors#Hex_triplet).\n     *\n     * Example:\n     * ```ts,runnable,console\n     * import { Color4 } from '@js-draw/math';\n     * console.log(Color4.fromHex('#ff0'));\n     * ```\n     */\n    static fromHex(hexString) {\n        // Remove starting '#' (if present)\n        hexString = (hexString.match(/^[#]?(.*)$/) ?? [])[1];\n        hexString = hexString.toUpperCase();\n        if (!hexString.match(/^[0-9A-F]+$/)) {\n            throw new Error(`${hexString} is not in a valid format.`);\n        }\n        // RGBA or RGB\n        if (hexString.length === 3 || hexString.length === 4) {\n            // Each character is a component\n            const components = hexString.split('');\n            // Convert to RRGGBBAA or RRGGBB format\n            hexString = components.map((component) => `${component}0`).join('');\n        }\n        if (hexString.length === 6) {\n            // Alpha component\n            hexString += 'FF';\n        }\n        const components = [];\n        for (let i = 2; i <= hexString.length; i += 2) {\n            const chunk = hexString.substring(i - 2, i);\n            components.push(parseInt(chunk, 16) / 255);\n        }\n        if (components.length !== 4) {\n            throw new Error(`Unable to parse ${hexString}: Wrong number of components.`);\n        }\n        return Color4.ofRGBA(components[0], components[1], components[2], components[3]);\n    }\n    /** Like {@link fromHex}, but can handle additional colors if an `HTMLCanvasElement` is available. */\n    static fromString(text) {\n        if (text.startsWith('#')) {\n            return Color4.fromHex(text);\n        }\n        if (text === 'none' || text === 'transparent') {\n            return Color4.transparent;\n        }\n        if (text === '') {\n            return Color4.black;\n        }\n        // rgba?: Match both rgb and rgba strings.\n        // ([,0-9.]+): Match any string of only numeric, '.' and ',' characters.\n        const rgbRegex = /^rgba?\\(([,0-9.]+)\\)$/i;\n        const rgbMatch = text.replace(/\\s*/g, '').match(rgbRegex);\n        if (rgbMatch) {\n            const componentsListStr = rgbMatch[1];\n            const componentsList = JSON.parse(`[ ${componentsListStr} ]`);\n            if (componentsList.length === 3) {\n                return Color4.ofRGB(componentsList[0] / 255, componentsList[1] / 255, componentsList[2] / 255);\n            }\n            else if (componentsList.length === 4) {\n                return Color4.ofRGBA(componentsList[0] / 255, componentsList[1] / 255, componentsList[2] / 255, componentsList[3]);\n            }\n            else {\n                throw new Error(`RGB string, ${text}, has wrong number of components: ${componentsList.length}`);\n            }\n        }\n        // Otherwise, try to use an HTMLCanvasElement to determine the color.\n        // Note: We may be unable to create an HTMLCanvasElement if running as a unit test.\n        const canvas = document.createElement('canvas');\n        canvas.width = 1;\n        canvas.height = 1;\n        const ctx = canvas.getContext('2d');\n        // Default to black if no canvas is available.\n        if (!ctx) {\n            return Color4.black;\n        }\n        ctx.fillStyle = text;\n        ctx.fillRect(0, 0, 1, 1);\n        const data = ctx.getImageData(0, 0, 1, 1);\n        const red = data.data[0] / 255;\n        const green = data.data[1] / 255;\n        const blue = data.data[2] / 255;\n        const alpha = data.data[3] / 255;\n        return Color4.ofRGBA(red, green, blue, alpha);\n    }\n    /** @returns true if `this` and `other` are approximately equal. */\n    eq(other) {\n        if (other == null) {\n            return false;\n        }\n        // If both completely transparent,\n        if (this.a === 0 && other.a === 0) {\n            return true;\n        }\n        return this.toHexString() === other.toHexString();\n    }\n    /**\n     * If `fractionTo` is not in the range $[0, 1]$, it will be clamped to the nearest number\n     * in that range. For example, `a.mix(b, -1)` is equivalent to `a.mix(b, 0)`.\n     *\n     * @returns a color `fractionTo` of the way from this color to `other`.\n     *\n     * @example\n     * ```ts\n     * Color4.ofRGB(1, 0, 0).mix(Color4.ofRGB(0, 1, 0), 0.1) // -> Color4(0.9, 0.1, 0)\n     * ```\n     */\n    mix(other, fractionTo) {\n        fractionTo = Math.min(Math.max(fractionTo, 0), 1);\n        const fractionOfThis = 1 - fractionTo;\n        return new Color4(this.r * fractionOfThis + other.r * fractionTo, this.g * fractionOfThis + other.g * fractionTo, this.b * fractionOfThis + other.b * fractionTo, this.a * fractionOfThis + other.a * fractionTo);\n    }\n    /**\n     * Ignoring this color's alpha component, returns a vector with components,\n     * $$\n     * \\begin{pmatrix} \\colorbox{#F44}{\\tt r} \\\\ \\colorbox{#4F4}{\\tt g} \\\\ \\colorbox{#44F}{\\tt b} \\end{pmatrix}\n     * $$\n     */\n    get rgb() {\n        return Vec3.of(this.r, this.g, this.b);\n    }\n    /**\n     * Returns the [relative luminance](https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef)\n     * of this color in the sRGB color space.\n     *\n     * Ignores the alpha component.\n     */\n    relativeLuminance() {\n        // References:\n        // - https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\n        // - https://stackoverflow.com/a/9733420\n        // Normalize the components, as per above\n        const components = [this.r, this.g, this.b].map((component) => {\n            if (component < 0.03928) {\n                return component / 12.92;\n            }\n            else {\n                return Math.pow((component + 0.055) / 1.055, 2.4);\n            }\n        });\n        // From w3.org,\n        // > For the sRGB colorspace, the relative luminance of a color is\n        // > defined as L = 0.2126 * R + 0.7152 * G + 0.0722 * B\n        // where R, G, B are defined in components above.\n        return 0.2126 * components[0] + 0.7152 * components[1] + 0.0722 * components[2];\n    }\n    /**\n     * Returns the [contrast ratio](https://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef)\n     * between `colorA` and `colorB`.\n     */\n    static contrastRatio(colorA, colorB) {\n        const L1 = colorA.relativeLuminance();\n        const L2 = colorB.relativeLuminance();\n        return (Math.max(L1, L2) + 0.05) / (Math.min(L1, L2) + 0.05);\n    }\n    /**\n     * @returns the component-wise average of `colors`, or `Color4.transparent` if `colors` is empty.\n     */\n    static average(colors) {\n        let averageA = 0;\n        let averageR = 0;\n        let averageG = 0;\n        let averageB = 0;\n        for (const color of colors) {\n            averageA += color.a;\n            averageR += color.r;\n            averageG += color.g;\n            averageB += color.b;\n        }\n        if (colors.length > 0) {\n            averageA /= colors.length;\n            averageR /= colors.length;\n            averageG /= colors.length;\n            averageB /= colors.length;\n        }\n        return new Color4(averageR, averageG, averageB, averageA);\n    }\n    /**\n     * Converts to (hue, saturation, value).\n     * See also https://en.wikipedia.org/wiki/HSL_and_HSV#General_approach\n     *\n     * The resultant hue is represented in radians and is thus in $[0, 2\\pi]$.\n     */\n    asHSV() {\n        // Ref: https://en.wikipedia.org/wiki/HSL_and_HSV#General_approach\n        //\n        // HUE:\n        // First, consider the unit cube. Rotate it such that one vertex is at the origin\n        // of a plane and its three neighboring vertices are equidistant from that plane:\n        //\n        //         /\\\n        //       /  | \\\n        //   2 /    3   \\ 1\n        //     \\    |   /\n        //       \\  | /\n        //   .     \\/      .\n        //\n        //        .\n        //\n        // Let z be up and (x, y, 0) be in the plane.\n        //\n        // Label vectors 1,2,3 with R, G, and B, respectively. Let R's projection into the plane\n        // lie along the x axis.\n        //\n        // Because R is a unit vector and R, G, B are equidistant from the plane, they must\n        // form 30-60-90 triangles, which have side lengths proportional to (1, √3, 2)\n        //\n        //       /|\n        //    1/  | (√3)/2\n        //    /   |\n        //      1/2\n        //\n        const minComponent = Math.min(this.r, this.g, this.b);\n        const maxComponent = Math.max(this.r, this.g, this.b);\n        const chroma = maxComponent - minComponent;\n        let hue;\n        // See https://en.wikipedia.org/wiki/HSL_and_HSV#General_approach\n        if (chroma === 0) {\n            hue = 0;\n        }\n        else if (this.r >= this.g && this.r >= this.b) {\n            hue = ((this.g - this.b) / chroma) % 6;\n        }\n        else if (this.g >= this.r && this.g >= this.b) {\n            hue = (this.b - this.r) / chroma + 2;\n        }\n        else {\n            hue = (this.r - this.g) / chroma + 4;\n        }\n        // Convert to degree representation, then to radians.\n        hue *= 60;\n        hue *= Math.PI / 180;\n        // Ensure positivity.\n        if (hue < 0) {\n            hue += Math.PI * 2;\n        }\n        const value = maxComponent;\n        const saturation = value > 0 ? chroma / value : 0;\n        return Vec3.of(hue, saturation, value);\n    }\n    /**\n     * Creates a new `Color4` from a representation [in $HSV$](https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB).\n     *\n     * [Algorithm](https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB).\n     *\n     * Note that hue must be given **in radians**. While non-standard, this is consistent with\n     * {@link asHSV}.\n     *\n     * `hue` and `value` should range from 0 to 1.\n     *\n     * @param hue $H \\in [0, 2\\pi]$\n     * @param saturation $S_V \\in [0, 1]$\n     * @param value $V \\in [0, 1]$\n     */\n    static fromHSV(hue, saturation, value) {\n        if (hue < 0) {\n            hue += Math.PI * 2;\n        }\n        hue %= Math.PI * 2;\n        // Clamp value and saturation to [0, 1]\n        value = Math.max(0, Math.min(1, value));\n        saturation = Math.max(0, Math.min(1, saturation));\n        // Formula from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB\n        // Saturation can be thought of as scaled chroma. Unapply the scaling.\n        // See https://en.wikipedia.org/wiki/HSL_and_HSV#Saturation\n        const chroma = value * saturation;\n        // Determines which edge of the projected color cube\n        const huePrime = hue / (Math.PI / 3);\n        const secondLargestComponent = chroma * (1 - Math.abs((huePrime % 2) - 1));\n        let rgb;\n        if (huePrime < 1) {\n            rgb = [chroma, secondLargestComponent, 0];\n        }\n        else if (huePrime < 2) {\n            rgb = [secondLargestComponent, chroma, 0];\n        }\n        else if (huePrime < 3) {\n            rgb = [0, chroma, secondLargestComponent];\n        }\n        else if (huePrime < 4) {\n            rgb = [0, secondLargestComponent, chroma];\n        }\n        else if (huePrime < 5) {\n            rgb = [secondLargestComponent, 0, chroma];\n        }\n        else {\n            rgb = [chroma, 0, secondLargestComponent];\n        }\n        const adjustment = value - chroma;\n        return Color4.ofRGB(rgb[0] + adjustment, rgb[1] + adjustment, rgb[2] + adjustment);\n    }\n    /**\n     * Equivalent to `ofRGB(rgb.x, rgb.y, rgb.z)`.\n     *\n     * All components should be in the range `[0, 1]` (0 to 1 inclusive).\n     */\n    static fromRGBVector(rgb, alpha) {\n        return Color4.ofRGBA(rgb.x, rgb.y, rgb.z, alpha ?? 1);\n    }\n    /**\n     * @returns a hexadecimal color string representation of `this`, in the form `#rrggbbaa`.\n     *\n     * @example\n     * ```\n     * Color4.red.toHexString(); // -> #ff0000ff\n     * ```\n     */\n    toHexString() {\n        if (this.hexString) {\n            return this.hexString;\n        }\n        const componentToHex = (component) => {\n            const res = Math.round(255 * component).toString(16);\n            if (res.length === 1) {\n                return `0${res}`;\n            }\n            return res;\n        };\n        const alpha = componentToHex(this.a);\n        const red = componentToHex(this.r);\n        const green = componentToHex(this.g);\n        const blue = componentToHex(this.b);\n        if (alpha === 'ff') {\n            return `#${red}${green}${blue}`;\n        }\n        this.hexString = `#${red}${green}${blue}${alpha}`;\n        return this.hexString;\n    }\n    toString() {\n        return this.toHexString();\n    }\n}\nColor4.transparent = Color4.ofRGBA(0, 0, 0, 0);\nColor4.red = Color4.ofRGB(1.0, 0.0, 0.0);\nColor4.orange = Color4.ofRGB(1.0, 0.65, 0.0);\nColor4.green = Color4.ofRGB(0.0, 1.0, 0.0);\nColor4.blue = Color4.ofRGB(0.0, 0.0, 1.0);\nColor4.purple = Color4.ofRGB(0.5, 0.2, 0.5);\nColor4.yellow = Color4.ofRGB(1, 1, 0.1);\nColor4.clay = Color4.ofRGB(0.8, 0.4, 0.2);\nColor4.black = Color4.ofRGB(0, 0, 0);\nColor4.gray = Color4.ofRGB(0.5, 0.5, 0.5);\nColor4.white = Color4.ofRGB(1, 1, 1);\nexport default Color4;\n","import  { Vec2 }  from './Vec2.mjs';\nimport  Vec3  from './Vec3.mjs';\n/**\n * Represents a three dimensional linear transformation or\n * a two-dimensional affine transformation. (An affine transformation scales/rotates/shears\n * **and** translates while a linear transformation just scales/rotates/shears).\n *\n * In addition to other matrices, {@link Mat33}s can be used to transform {@link Vec3}s and {@link Vec2}s.\n *\n * For example, to move the point $(1, 1)$ by 5 units to the left and 6 units up,\n * ```ts,runnable,console\n * import {Mat33, Vec2} from '@js-draw/math';\n *\n * const moveLeftAndUp = Mat33.translation(Vec2.of(5, 6));\n * console.log(moveLeftAndUp);\n * ```\n *\n * This `moveLeftAndUp` matrix could then translate (move) a {@link Vec2} using\n * {@link Mat33.transformVec2}:\n *\n * ```ts,runnable,console\n * ---use-previous---\n * ---visible---\n * console.log(moveLeftAndUp.transformVec2(Vec2.of(1, 1)));\n * console.log(moveLeftAndUp.transformVec2(Vec2.of(-1, 2)));\n * ```\n *\n * It's also possible to create transformation matrices that scale and rotate.\n * A single transform matrix can be created from multiple using matrix multiplication\n * (see {@link Mat33.rightMul}):\n *\n * ```ts,runnable,console\n * ---use-previous---\n * ---visible---\n * // Create a matrix by right multiplying.\n * const scaleThenRotate =\n *   // The resultant matrix first scales by a factor of two\n *   Mat33.scaling2D(2).rightMul(\n *     // ...then rotates by pi/2 radians = 90 degrees.\n *     Mat33.zRotation(Math.PI / 2)\n *   );\n * console.log(scaleThenRotate);\n *\n * // Use scaleThenRotate to scale then rotate a vector.\n * console.log(scaleThenRotate.transformVec2(Vec2.unitX));\n * ```\n */\nexport class Mat33 {\n    /**\n     * Creates a matrix from inputs in the form,\n     * $$\n     * \\begin{bmatrix}\n     *   a1 & a2 & a3 \\\\\n     *   b1 & b2 & b3 \\\\\n     *   c1 & c2 & c3\n     * \\end{bmatrix}\n     * $$\n     *\n     * Static constructor methods are also available.\n     * See {@link Mat33.scaling2D}, {@link Mat33.zRotation}, {@link Mat33.translation}, and {@link Mat33.fromCSSMatrix}.\n     */\n    constructor(a1, a2, a3, b1, b2, b3, c1, c2, c3) {\n        this.a1 = a1;\n        this.a2 = a2;\n        this.a3 = a3;\n        this.b1 = b1;\n        this.b2 = b2;\n        this.b3 = b3;\n        this.c1 = c1;\n        this.c2 = c2;\n        this.c3 = c3;\n        this.cachedInverse = undefined;\n        this.rows = [Vec3.of(a1, a2, a3), Vec3.of(b1, b2, b3), Vec3.of(c1, c2, c3)];\n    }\n    /**\n     * Creates a matrix from the given rows:\n     * $$\n     * \\begin{bmatrix}\n     *  \\texttt{r1.x} & \\texttt{r1.y} & \\texttt{r1.z}\\\\\n     *  \\texttt{r2.x} & \\texttt{r2.y} & \\texttt{r2.z}\\\\\n     *  \\texttt{r3.x} & \\texttt{r3.y} & \\texttt{r3.z}\\\\\n     * \\end{bmatrix}\n     * $$\n     */\n    static ofRows(r1, r2, r3) {\n        return new Mat33(r1.x, r1.y, r1.z, r2.x, r2.y, r2.z, r3.x, r3.y, r3.z);\n    }\n    /**\n     * Either returns the inverse of this, or, if this matrix is singular/uninvertable,\n     * returns Mat33.identity.\n     *\n     * This may cache the computed inverse and return the cached version instead of recomputing\n     * it.\n     */\n    inverse() {\n        return this.computeInverse() ?? Mat33.identity;\n    }\n    invertable() {\n        return this.computeInverse() !== null;\n    }\n    computeInverse() {\n        if (this.cachedInverse !== undefined) {\n            return this.cachedInverse;\n        }\n        const toIdentity = [this.rows[0], this.rows[1], this.rows[2]];\n        const toResult = [Vec3.unitX, Vec3.unitY, Vec3.unitZ];\n        // Convert toIdentity to the identity matrix and\n        // toResult to the inverse through elementary row operations\n        for (let cursor = 0; cursor < 3; cursor++) {\n            // Select the [cursor]th diagonal entry\n            let pivot = toIdentity[cursor].at(cursor);\n            // Don't divide by zero (treat very small numbers as zero).\n            const minDivideBy = 1e-10;\n            if (Math.abs(pivot) < minDivideBy) {\n                let swapIndex = -1;\n                // For all other rows,\n                for (let i = 1; i <= 2; i++) {\n                    const otherRowIdx = (cursor + i) % 3;\n                    if (Math.abs(toIdentity[otherRowIdx].at(cursor)) >= minDivideBy) {\n                        swapIndex = otherRowIdx;\n                        break;\n                    }\n                }\n                // Can't swap with another row?\n                if (swapIndex === -1) {\n                    this.cachedInverse = null;\n                    return null;\n                }\n                const tmpIdentityRow = toIdentity[cursor];\n                const tmpResultRow = toResult[cursor];\n                // Swap!\n                toIdentity[cursor] = toIdentity[swapIndex];\n                toResult[cursor] = toResult[swapIndex];\n                toIdentity[swapIndex] = tmpIdentityRow;\n                toResult[swapIndex] = tmpResultRow;\n                pivot = toIdentity[cursor].at(cursor);\n            }\n            // Make toIdentity[k = cursor] = 1\n            let scale = 1.0 / pivot;\n            toIdentity[cursor] = toIdentity[cursor].times(scale);\n            toResult[cursor] = toResult[cursor].times(scale);\n            const cursorToIdentityRow = toIdentity[cursor];\n            const cursorToResultRow = toResult[cursor];\n            // Make toIdentity[k ≠ cursor] = 0\n            for (let i = 1; i <= 2; i++) {\n                const otherRowIdx = (cursor + i) % 3;\n                scale = -toIdentity[otherRowIdx].at(cursor);\n                toIdentity[otherRowIdx] = toIdentity[otherRowIdx].plus(cursorToIdentityRow.times(scale));\n                toResult[otherRowIdx] = toResult[otherRowIdx].plus(cursorToResultRow.times(scale));\n            }\n        }\n        const inverse = Mat33.ofRows(toResult[0], toResult[1], toResult[2]);\n        this.cachedInverse = inverse;\n        return inverse;\n    }\n    transposed() {\n        return new Mat33(this.a1, this.b1, this.c1, this.a2, this.b2, this.c2, this.a3, this.b3, this.c3);\n    }\n    /**\n     * [Right-multiplies](https://en.wikipedia.org/wiki/Matrix_multiplication) this by `other`.\n     *\n     * See also {@link transformVec3} and {@link transformVec2}.\n     *\n     * Example:\n     * ```ts,runnable,console\n     * import {Mat33, Vec2} from '@js-draw/math';\n     * console.log(Mat33.identity.rightMul(Mat33.identity));\n     *\n     * // Create a matrix by right multiplying.\n     * const scaleThenRotate =\n     *   // The resultant matrix first scales by a factor of two\n     *   Mat33.scaling2D(2).rightMul(\n     *     // ...then rotates by pi/4 radians = 45 degrees.\n     *     Mat33.zRotation(Math.PI / 4)\n     *   );\n     * console.log(scaleThenRotate);\n     *\n     * // Use scaleThenRotate to scale then rotate a vector.\n     * console.log(scaleThenRotate.transformVec2(Vec2.unitX));\n     * ```\n     */\n    rightMul(other) {\n        other = other.transposed();\n        const at = (row, col) => {\n            return this.rows[row].dot(other.rows[col]);\n        };\n        return new Mat33(at(0, 0), at(0, 1), at(0, 2), at(1, 0), at(1, 1), at(1, 2), at(2, 0), at(2, 1), at(2, 2));\n    }\n    /**\n     * Applies this as an **affine** transformation to the given vector.\n     * Returns a transformed version of `other`.\n     *\n     * Unlike {@link transformVec3}, this **does** translate the given vector.\n     */\n    transformVec2(other) {\n        // When transforming a Vec2, we want to use the z transformation\n        // components of this for translation:\n        //  ⎡ . . tX ⎤\n        //  ⎢ . . tY ⎥\n        //  ⎣ 0 0 1  ⎦\n        // For this, we need other's z component to be 1 (so that tX and tY\n        // are scaled by 1):\n        let intermediate = Vec3.of(other.x, other.y, 1);\n        intermediate = this.transformVec3(intermediate);\n        // Drop the z=1 to allow magnitude to work as expected\n        return Vec2.of(intermediate.x, intermediate.y);\n    }\n    /**\n     * Applies this as a linear transformation to the given vector (doesn't translate).\n     * This is the standard way of transforming vectors in ℝ³.\n     */\n    transformVec3(other) {\n        return Vec3.of(this.rows[0].dot(other), this.rows[1].dot(other), this.rows[2].dot(other));\n    }\n    /** @returns true iff this is the identity matrix. */\n    isIdentity() {\n        if (this === Mat33.identity) {\n            return true;\n        }\n        return this.eq(Mat33.identity);\n    }\n    /** Returns true iff this = other ± fuzz */\n    eq(other, fuzz = 0) {\n        for (let i = 0; i < 3; i++) {\n            if (!this.rows[i].eq(other.rows[i], fuzz)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Creates a human-readable representation of the matrix.\n     *\n     * Example:\n     * ```ts,runnable,console\n     * import { Mat33 } from '@js-draw/math';\n     * console.log(Mat33.identity.toString());\n     * ```\n     */\n    toString() {\n        let result = '';\n        const maxColumnLens = [0, 0, 0];\n        // Determine the longest item in each column so we can pad the others to that\n        // length.\n        for (const row of this.rows) {\n            for (let i = 0; i < 3; i++) {\n                maxColumnLens[i] = Math.max(maxColumnLens[0], `${row.at(i)}`.length);\n            }\n        }\n        for (let i = 0; i < 3; i++) {\n            if (i === 0) {\n                result += '⎡ ';\n            }\n            else if (i === 1) {\n                result += '⎢ ';\n            }\n            else {\n                result += '⎣ ';\n            }\n            // Add each component of the ith row (after padding it)\n            for (let j = 0; j < 3; j++) {\n                const val = this.rows[i].at(j).toString();\n                let padding = '';\n                for (let i = val.length; i < maxColumnLens[j]; i++) {\n                    padding += ' ';\n                }\n                result += val + ', ' + padding;\n            }\n            if (i === 0) {\n                result += ' ⎤';\n            }\n            else if (i === 1) {\n                result += ' ⎥';\n            }\n            else {\n                result += ' ⎦';\n            }\n            result += '\\n';\n        }\n        return result.trimEnd();\n    }\n    /**\n     * ```\n     * result[0] = top left element\n     * result[1] = element at row zero, column 1\n     * ...\n     * ```\n     *\n     * Example:\n     * ```ts,runnable,console\n     * import { Mat33 } from '@js-draw/math';\n     * console.log(\n     *   new Mat33(\n     *     1, 2, 3,\n     *     4, 5, 6,\n     *     7, 8, 9,\n     *   )\n     * );\n     * ```\n     */\n    toArray() {\n        return [this.a1, this.a2, this.a3, this.b1, this.b2, this.b3, this.c1, this.c2, this.c3];\n    }\n    /**\n     * Returns a new `Mat33` where each entry is the output of the function\n     * `mapping`.\n     *\n     * @example\n     * ```\n     * new Mat33(\n     *  1, 2, 3,\n     *  4, 5, 6,\n     *  7, 8, 9,\n     * ).mapEntries(component => component - 1);\n     * // → ⎡ 0, 1, 2 ⎤\n     * //   ⎢ 3, 4, 5 ⎥\n     * //   ⎣ 6, 7, 8 ⎦\n     * ```\n     */\n    mapEntries(mapping) {\n        return new Mat33(mapping(this.a1, [0, 0]), mapping(this.a2, [0, 1]), mapping(this.a3, [0, 2]), mapping(this.b1, [1, 0]), mapping(this.b2, [1, 1]), mapping(this.b3, [1, 2]), mapping(this.c1, [2, 0]), mapping(this.c2, [2, 1]), mapping(this.c3, [2, 2]));\n    }\n    /** Estimate the scale factor of this matrix (based on the first row). */\n    getScaleFactor() {\n        return Math.hypot(this.a1, this.a2);\n    }\n    /** Returns the `idx`-th column (`idx` is 0-indexed). */\n    getColumn(idx) {\n        return Vec3.of(this.rows[0].at(idx), this.rows[1].at(idx), this.rows[2].at(idx));\n    }\n    /** Returns the magnitude of the entry with the largest entry */\n    maximumEntryMagnitude() {\n        let greatestSoFar = Math.abs(this.a1);\n        for (const entry of this.toArray()) {\n            greatestSoFar = Math.max(greatestSoFar, Math.abs(entry));\n        }\n        return greatestSoFar;\n    }\n    /**\n     * Constructs a 3x3 translation matrix (for translating `Vec2`s) using\n     * **transformVec2**.\n     *\n     * Creates a matrix in the form\n     * $$\n     * \t\\begin{pmatrix}\n     * \t\t1 & 0 & {\\tt amount.x}\\\\\n     * \t\t0 & 1 & {\\tt amount.y}\\\\\n     * \t\t0 & 0 & 1\n     * \t\\end{pmatrix}\n     * $$\n     */\n    static translation(amount) {\n        // When transforming Vec2s by a 3x3 matrix, we give the input\n        // Vec2s z = 1. As such,\n        //   outVec2.x = inVec2.x * 1 + inVec2.y * 0 + 1 * amount.x\n        //   ...\n        return new Mat33(1, 0, amount.x, 0, 1, amount.y, 0, 0, 1);\n    }\n    /**\n     * Creates a matrix for rotating `Vec2`s about `center` by some number of `radians`.\n     *\n     * For this function, {@link Vec2}s are considered to be points in 2D space.\n     *\n     * For example,\n     * ```ts,runnable,console\n     * import { Mat33, Vec2 } from '@js-draw/math';\n     *\n     * const halfCircle = Math.PI; // PI radians = 180 degrees = 1/2 circle\n     * const center = Vec2.of(1, 1); // The point (1,1)\n     * const rotationMatrix = Mat33.zRotation(halfCircle, center);\n     *\n     * console.log(\n     *   'Rotating (0,0) 180deg about', center, 'results in',\n     *   // Rotates (0,0)\n     *   rotationMatrix.transformVec2(Vec2.zero),\n     * );\n     * ```\n     */\n    static zRotation(radians, center = Vec2.zero) {\n        if (radians === 0) {\n            return Mat33.identity;\n        }\n        const cos = Math.cos(radians);\n        const sin = Math.sin(radians);\n        // Translate everything so that rotation is about the origin\n        let result = Mat33.translation(center);\n        result = result.rightMul(new Mat33(cos, -sin, 0, sin, cos, 0, 0, 0, 1));\n        return result.rightMul(Mat33.translation(center.times(-1)));\n    }\n    static scaling2D(amount, center = Vec2.zero) {\n        let result = Mat33.translation(center);\n        let xAmount, yAmount;\n        if (typeof amount === 'number') {\n            xAmount = amount;\n            yAmount = amount;\n        }\n        else {\n            xAmount = amount.x;\n            yAmount = amount.y;\n        }\n        result = result.rightMul(new Mat33(xAmount, 0, 0, 0, yAmount, 0, 0, 0, 1));\n        // Translate such that [center] goes to (0, 0)\n        return result.rightMul(Mat33.translation(center.times(-1)));\n    }\n    /**\n     * **Note**: Assumes `this.c1 = this.c2 = 0` and `this.c3 = 1`.\n     *\n     * @see {@link fromCSSMatrix}\n     */\n    toCSSMatrix() {\n        return `matrix(${this.a1},${this.b1},${this.a2},${this.b2},${this.a3},${this.b3})`;\n    }\n    /**\n     * Converts a CSS-form `matrix(a, b, c, d, e, f)` to a Mat33.\n     *\n     * Note that such a matrix has the form,\n     * ```\n     * ⎡ a c e ⎤\n     * ⎢ b d f ⎥\n     * ⎣ 0 0 1 ⎦\n     * ```\n     */\n    static fromCSSMatrix(cssString) {\n        if (cssString === '' || cssString === 'none') {\n            return Mat33.identity;\n        }\n        // Normalize spacing\n        cssString = cssString.trim().replace(/\\s+/g, ' ');\n        const parseArguments = (argumentString) => {\n            const parsed = argumentString.split(/[, \\t\\n]+/g).map((argString) => {\n                // Handle trailing spaces/commands\n                if (argString.trim() === '') {\n                    return null;\n                }\n                let isPercentage = false;\n                if (argString.endsWith('%')) {\n                    isPercentage = true;\n                    argString = argString.substring(0, argString.length - 1);\n                }\n                // Remove trailing px units.\n                argString = argString.replace(/px$/gi, '');\n                const numberExp = /^[-]?\\d*(?:\\.\\d*)?(?:[eE][-+]?\\d+)?$/i;\n                if (!numberExp.exec(argString)) {\n                    throw new Error(`All arguments to transform functions must be numeric (state: ${JSON.stringify({\n                        currentArgument: argString,\n                        allArguments: argumentString,\n                    })})`);\n                }\n                let argNumber = parseFloat(argString);\n                if (isPercentage) {\n                    argNumber /= 100;\n                }\n                return argNumber;\n            });\n            return parsed.filter((n) => n !== null);\n        };\n        const keywordToAction = {\n            matrix: (matrixData) => {\n                if (matrixData.length !== 6) {\n                    throw new Error(`Invalid matrix argument: ${matrixData}. Must have length 6`);\n                }\n                const a = matrixData[0];\n                const b = matrixData[1];\n                const c = matrixData[2];\n                const d = matrixData[3];\n                const e = matrixData[4];\n                const f = matrixData[5];\n                const transform = new Mat33(a, c, e, b, d, f, 0, 0, 1);\n                return transform;\n            },\n            scale: (scaleArgs) => {\n                let scaleX, scaleY;\n                if (scaleArgs.length === 1) {\n                    scaleX = scaleArgs[0];\n                    scaleY = scaleArgs[0];\n                }\n                else if (scaleArgs.length === 2) {\n                    scaleX = scaleArgs[0];\n                    scaleY = scaleArgs[1];\n                }\n                else {\n                    throw new Error(`The scale() function only supports two arguments. Given: ${scaleArgs}`);\n                }\n                return Mat33.scaling2D(Vec2.of(scaleX, scaleY));\n            },\n            translate: (translateArgs) => {\n                let translateX = 0;\n                let translateY = 0;\n                if (translateArgs.length === 1) {\n                    // If no y translation is given, assume 0.\n                    translateX = translateArgs[0];\n                }\n                else if (translateArgs.length === 2) {\n                    translateX = translateArgs[0];\n                    translateY = translateArgs[1];\n                }\n                else {\n                    throw new Error(`The translate() function requires either 1 or 2 arguments. Given ${translateArgs}`);\n                }\n                return Mat33.translation(Vec2.of(translateX, translateY));\n            },\n        };\n        // A command (\\w+)\n        // followed by a set of arguments ([^)]*)\n        const partRegex = /(?:^|\\W)(\\w+)\\s?\\(([^)]*)\\)/gi;\n        let match;\n        let matrix = null;\n        while ((match = partRegex.exec(cssString)) !== null) {\n            const action = match[1].toLowerCase();\n            if (!(action in keywordToAction)) {\n                throw new Error(`Unsupported CSS transform action: ${action}`);\n            }\n            const args = parseArguments(match[2]);\n            const currentMatrix = keywordToAction[action](args);\n            if (!matrix) {\n                matrix = currentMatrix;\n            }\n            else {\n                matrix = matrix.rightMul(currentMatrix);\n            }\n        }\n        return matrix ?? Mat33.identity;\n    }\n}\n/** The 3x3 [identity matrix](https://en.wikipedia.org/wiki/Identity_matrix). */\nMat33.identity = new Mat33(1, 0, 0, 0, 1, 0, 0, 0, 1);\nexport default Mat33;\n","// Internally, we define Vec2 as a namespace within Vec3 --\n// this allows referencing Vec2s from Vec3 constructors without\n// cyclic references.\nimport  { Vec3, Vec2 }  from './Vec3.mjs';\nexport { Vec3, Vec2 };\nexport default Vec2;\n","const defaultEqlTolerance = 1e-10;\nclass Vec3Impl {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    get xy() {\n        // Useful for APIs that behave differently if .z is present.\n        return {\n            x: this.x,\n            y: this.y,\n        };\n    }\n    /** Returns this' `idx`th component. For example, `Vec3.of(1, 2, 3).at(1) → 2`. */\n    at(idx) {\n        if (idx === 0)\n            return this.x;\n        if (idx === 1)\n            return this.y;\n        if (idx === 2)\n            return this.z;\n        throw new Error(`${idx} out of bounds!`);\n    }\n    length() {\n        return this.magnitude();\n    }\n    magnitude() {\n        return Math.sqrt(this.magnitudeSquared());\n    }\n    magnitudeSquared() {\n        return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n    squareDistanceTo(p) {\n        const dx = this.x - p.x;\n        const dy = this.y - p.y;\n        const dz = this.z - p.z;\n        return dx * dx + dy * dy + dz * dz;\n    }\n    distanceTo(p) {\n        return Math.sqrt(this.squareDistanceTo(p));\n    }\n    maximumEntryMagnitude() {\n        return Math.max(Math.abs(this.x), Math.max(Math.abs(this.y), Math.abs(this.z)));\n    }\n    angle() {\n        return Math.atan2(this.y, this.x);\n    }\n    normalized() {\n        const norm = this.magnitude();\n        return Vec3.of(this.x / norm, this.y / norm, this.z / norm);\n    }\n    normalizedOrZero() {\n        if (this.eq(Vec3.zero)) {\n            return Vec3.zero;\n        }\n        return this.normalized();\n    }\n    times(c) {\n        return Vec3.of(this.x * c, this.y * c, this.z * c);\n    }\n    plus(v) {\n        return Vec3.of(this.x + v.x, this.y + v.y, this.z + v.z);\n    }\n    minus(v) {\n        return Vec3.of(this.x - v.x, this.y - v.y, this.z - v.z);\n    }\n    dot(other) {\n        return this.x * other.x + this.y * other.y + this.z * other.z;\n    }\n    cross(other) {\n        // | i  j  k |\n        // | x1 y1 z1| = (i)(y1z2 - y2z1) - (j)(x1z2 - x2z1) + (k)(x1y2 - x2y1)\n        // | x2 y2 z2|\n        return Vec3.of(this.y * other.z - other.y * this.z, other.x * this.z - this.x * other.z, this.x * other.y - other.x * this.y);\n    }\n    scale(other) {\n        if (typeof other === 'number') {\n            return this.times(other);\n        }\n        return Vec3.of(this.x * other.x, this.y * other.y, this.z * other.z);\n    }\n    orthog() {\n        // If parallel to the z-axis\n        if (this.dot(Vec3.unitX) === 0 && this.dot(Vec3.unitY) === 0) {\n            return this.dot(Vec3.unitX) === 0 ? Vec3.unitX : this.cross(Vec3.unitX).normalized();\n        }\n        return this.cross(Vec3.unitZ.times(-1)).normalized();\n    }\n    extend(distance, direction) {\n        return this.plus(direction.normalized().times(distance));\n    }\n    lerp(target, fractionTo) {\n        return this.times(1 - fractionTo).plus(target.times(fractionTo));\n    }\n    zip(other, zip) {\n        return Vec3.of(zip(other.x, this.x), zip(other.y, this.y), zip(other.z, this.z));\n    }\n    map(fn) {\n        return Vec3.of(fn(this.x, 0), fn(this.y, 1), fn(this.z, 2));\n    }\n    asArray() {\n        return [this.x, this.y, this.z];\n    }\n    eq(other, fuzz = defaultEqlTolerance) {\n        return (Math.abs(other.x - this.x) <= fuzz &&\n            Math.abs(other.y - this.y) <= fuzz &&\n            Math.abs(other.z - this.z) <= fuzz);\n    }\n    toString() {\n        return `Vec(${this.x}, ${this.y}, ${this.z})`;\n    }\n}\nclass Vec2Impl {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    get z() {\n        return 0;\n    }\n    get xy() {\n        // Useful for APIs that behave differently if .z is present.\n        return {\n            x: this.x,\n            y: this.y,\n        };\n    }\n    at(idx) {\n        if (idx === 0)\n            return this.x;\n        if (idx === 1)\n            return this.y;\n        if (idx === 2)\n            return 0;\n        throw new Error(`${idx} out of bounds!`);\n    }\n    length() {\n        return this.magnitude();\n    }\n    magnitude() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    magnitudeSquared() {\n        return this.x * this.x + this.y * this.y;\n    }\n    squareDistanceTo(p) {\n        const dx = this.x - p.x;\n        const dy = this.y - p.y;\n        return dx * dx + dy * dy + p.z * p.z;\n    }\n    distanceTo(p) {\n        return Math.sqrt(this.squareDistanceTo(p));\n    }\n    maximumEntryMagnitude() {\n        return Math.max(Math.abs(this.x), Math.abs(this.y));\n    }\n    angle() {\n        return Math.atan2(this.y, this.x);\n    }\n    normalized() {\n        const norm = this.magnitude();\n        return Vec2.of(this.x / norm, this.y / norm);\n    }\n    normalizedOrZero() {\n        if (this.eq(Vec3.zero)) {\n            return Vec3.zero;\n        }\n        return this.normalized();\n    }\n    times(c) {\n        return Vec2.of(this.x * c, this.y * c);\n    }\n    plus(v) {\n        return Vec3.of(this.x + v.x, this.y + v.y, v.z);\n    }\n    minus(v) {\n        return Vec3.of(this.x - v.x, this.y - v.y, -v.z);\n    }\n    dot(other) {\n        return this.x * other.x + this.y * other.y;\n    }\n    cross(other) {\n        // | i  j  k |\n        // | x1 y1 z1| = (i)(y1z2 - y2z1) - (j)(x1z2 - x2z1) + (k)(x1y2 - x2y1)\n        // | x2 y2 z2|\n        return Vec3.of(this.y * other.z, -this.x * other.z, this.x * other.y - other.x * this.y);\n    }\n    scale(other) {\n        if (typeof other === 'number') {\n            return this.times(other);\n        }\n        return Vec2.of(this.x * other.x, this.y * other.y);\n    }\n    orthog() {\n        // If parallel to the z-axis\n        if (this.dot(Vec3.unitX) === 0 && this.dot(Vec3.unitY) === 0) {\n            return this.dot(Vec3.unitX) === 0 ? Vec3.unitX : this.cross(Vec3.unitX).normalized();\n        }\n        return this.cross(Vec3.unitZ.times(-1)).normalized();\n    }\n    extend(distance, direction) {\n        return this.plus(direction.normalized().times(distance));\n    }\n    lerp(target, fractionTo) {\n        return this.times(1 - fractionTo).plus(target.times(fractionTo));\n    }\n    zip(other, zip) {\n        return Vec3.of(zip(other.x, this.x), zip(other.y, this.y), zip(other.z, 0));\n    }\n    map(fn) {\n        return Vec3.of(fn(this.x, 0), fn(this.y, 1), fn(0, 2));\n    }\n    asArray() {\n        return [this.x, this.y, 0];\n    }\n    eq(other, fuzz = defaultEqlTolerance) {\n        return (Math.abs(other.x - this.x) <= fuzz &&\n            Math.abs(other.y - this.y) <= fuzz &&\n            Math.abs(other.z) <= fuzz);\n    }\n    toString() {\n        return `Vec(${this.x}, ${this.y})`;\n    }\n}\n/**\n * A `Vec2` is a {@link Vec3} optimized for working in a plane. `Vec2`s have an\n * always-zero `z` component.\n *\n * ```ts,runnable,console\n * import { Vec2 } from '@js-draw/math';\n *\n * const v = Vec2.of(1, 2);\n * console.log('a Vec2:', v);\n * console.log('x component:', v.x);\n * console.log('z component:', v.z);\n * ```\n */\nexport var Vec2;\n(function (Vec2) {\n    /**\n     * Creates a `Vec2` from an x and y coordinate.\n     *\n     * @example\n     * ```ts,runnable,console\n     * import { Vec2 } from '@js-draw/math';\n     * const v = Vec2.of(3, 4); // x=3, y=4.\n     * ```\n     */\n    Vec2.of = (x, y) => {\n        return new Vec2Impl(x, y);\n    };\n    /**\n     * Creates a `Vec2` from an object containing `x` and `y` coordinates.\n     *\n     * @example\n     * ```ts,runnable,console\n     * import { Vec2 } from '@js-draw/math';\n     * const v1 = Vec2.ofXY({ x: 3, y: 4.5 });\n     * const v2 = Vec2.ofXY({ x: -123.4, y: 1 });\n     * ```\n     */\n    Vec2.ofXY = ({ x, y }) => {\n        return Vec2.of(x, y);\n    };\n    /** A vector of length 1 in the X direction (→). */\n    Vec2.unitX = Vec2.of(1, 0);\n    /** A vector of length 1 in the Y direction (↑). */\n    Vec2.unitY = Vec2.of(0, 1);\n    /** The zero vector: A vector with x=0, y=0. */\n    Vec2.zero = Vec2.of(0, 0);\n})(Vec2 || (Vec2 = {}));\n/** Contains static methods for constructing a {@link Vec3}. */\nexport var Vec3;\n(function (Vec3) {\n    /**\n     * Construct a vector from three components.\n     *\n     * @example\n     * ```ts,runnable,console\n     * import { Vec3 } from '@js-draw/math';\n     * const v1 = Vec3.of(1, 2, 3);\n     * console.log(v1.plus(Vec3.of(0, 100, 0)));\n     * ```\n     */\n    Vec3.of = (x, y, z) => {\n        if (z === 0) {\n            return Vec2.of(x, y);\n        }\n        else {\n            return new Vec3Impl(x, y, z);\n        }\n    };\n    /** A unit vector in the x direction (`[1, 0, 0]`). */\n    Vec3.unitX = Vec2.unitX;\n    /** A unit vector in the y direction (`[0, 1, 0]`). */\n    Vec3.unitY = Vec2.unitY;\n    /** The zero vector (`[0, 0, 0]`). */\n    Vec3.zero = Vec2.zero;\n    /** A vector of length 1 in the z direction. */\n    Vec3.unitZ = Vec3.of(0, 0, 1);\n})(Vec3 || (Vec3 = {}));\nexport default Vec3;\n","/**\n * This package contains general math utilities used by `js-draw`.\n * These include 2D and 3D vectors, 2D paths, and 3x3 matrices.\n *\n * ```ts,runnable,console\n * import { Vec2, Mat33, Rect2 } from '@js-draw/math';\n *\n * // Example: Rotate a vector 90 degrees about the z-axis\n * const rotate90Degrees = Mat33.zRotation(Math.PI/2); // π/2 radians = 90 deg\n * const moveUp = Mat33.translation(Vec2.of(1, 0));\n * const moveUpThenRotate = rotate90Degrees.rightMul(moveUp);\n * console.log(moveUpThenRotate.transformVec2(Vec2.of(1, 2)));\n *\n * // Example: Bounding box of some points\n * console.log(Rect2.bboxOf([\n *   Vec2.of(1, 2), Vec2.of(3, 4), Vec2.of(-100, 1000),\n * ]));\n * ```\n *\n * @packageDocumentation\n */\nexport  { LineSegment2 }  from './shapes/LineSegment2.mjs';\nexport  { Path, stepCurveIndexBy as stepPathIndexBy, compareCurveIndices as comparePathIndices, PathCommandType, }  from './shapes/Path.mjs';\nexport  { Rect2 }  from './shapes/Rect2.mjs';\nexport  { Parameterized2DShape }  from './shapes/Parameterized2DShape.mjs';\nexport  { QuadraticBezier }  from './shapes/QuadraticBezier.mjs';\nexport  { Abstract2DShape }  from './shapes/Abstract2DShape.mjs';\nexport  { Mat33 }  from './Mat33.mjs';\nexport  { Vec2 }  from './Vec2.mjs';\nexport  { Vec3 }  from './Vec3.mjs';\nexport  { Color4 }  from './Color4.mjs';\nexport  *  from './rounding/lib.mjs';\n// Note: All above exports cannot use `export { default as ... } from \"...\"` because this\n// breaks TypeDoc -- TypeDoc otherwise labels any imports of these classes as `default`.\n","/**\n * Solves an equation of the form ax² + bx + c = 0.\n * The larger solution is returned first.\n *\n * If there are no solutions, returns `[NaN, NaN]`. If there is one solution,\n * repeats the solution twice in the result.\n */\nconst solveQuadratic = (a, b, c) => {\n    // See also https://en.wikipedia.org/wiki/Quadratic_formula\n    if (a === 0) {\n        let solution;\n        if (b === 0) {\n            solution = c === 0 ? 0 : NaN;\n        }\n        else {\n            // Then we have bx + c = 0\n            // which implies bx = -c.\n            // Thus, x = -c/b\n            solution = -c / b;\n        }\n        return [solution, solution];\n    }\n    const discriminant = b * b - 4 * a * c;\n    if (discriminant < 0) {\n        return [NaN, NaN];\n    }\n    const rootDiscriminant = Math.sqrt(discriminant);\n    const solution1 = (-b + rootDiscriminant) / (2 * a);\n    const solution2 = (-b - rootDiscriminant) / (2 * a);\n    if (solution1 > solution2) {\n        return [solution1, solution2];\n    }\n    else {\n        return [solution2, solution1];\n    }\n};\nexport default solveQuadratic;\n","/** Cleans up stringified numbers */\nexport const cleanUpNumber = (text) => {\n    // Regular expression substitions can be somewhat expensive. Only do them\n    // if necessary.\n    if (text.indexOf('e') > 0) {\n        // Round to zero.\n        if (text.match(/[eE][-]\\d{2,}$/)) {\n            return '0';\n        }\n    }\n    const lastChar = text.charAt(text.length - 1);\n    if (lastChar === '0' || lastChar === '.') {\n        // Remove trailing zeroes\n        text = text.replace(/([.]\\d*[^0])0+$/, '$1');\n        text = text.replace(/[.]0+$/, '.');\n        // Remove trailing period\n        text = text.replace(/[.]$/, '');\n    }\n    const firstChar = text.charAt(0);\n    if (firstChar === '0' || firstChar === '-') {\n        // Remove unnecessary leading zeroes.\n        text = text.replace(/^(0+)[.]/, '.');\n        text = text.replace(/^-(0+)[.]/, '-.');\n        text = text.replace(/^(-?)0+$/, '$10');\n    }\n    if (text === '-0') {\n        return '0';\n    }\n    return text;\n};\nexport default cleanUpNumber;\n","export const numberRegex = /^([-]?)(\\d*)[.](\\d+)$/;\n","import  { numberRegex }  from './constants.mjs';\n/**\n * Returns the length of `numberAsString` after a decimal point.\n *\n * For example,\n * ```ts\n * getLenAfterDecimal('1.001') // -> 3\n * ```\n */\nexport const getLenAfterDecimal = (numberAsString) => {\n    const numberMatch = numberRegex.exec(numberAsString);\n    if (!numberMatch) {\n        // If not a match, either the number is exponential notation (or is something\n        // like NaN or Infinity)\n        if (numberAsString.search(/[eE]/) !== -1 || /^[a-zA-Z]+$/.exec(numberAsString)) {\n            return -1;\n            // Or it has no decimal point\n        }\n        else {\n            return 0;\n        }\n    }\n    const afterDecimalLen = numberMatch[3].length;\n    return afterDecimalLen;\n};\nexport default getLenAfterDecimal;\n","export  { toRoundedString }  from './toRoundedString.mjs';\n","import  cleanUpNumber  from './cleanUpNumber.mjs';\n/**\n * Converts `num` to a string, removing trailing digits that were likely caused by\n * precision errors.\n *\n * @example\n * ```ts,runnable,console\n * import { toRoundedString } from '@js-draw/math';\n *\n * console.log('Rounded: ', toRoundedString(1.000000011));\n * ```\n */\nexport const toRoundedString = (num) => {\n    // Try to remove rounding errors. If the number ends in at least three/four zeroes\n    // (or nines) just one or two digits, it's probably a rounding error.\n    const fixRoundingUpExp = /^([-]?\\d*\\.\\d{3,})0{4,}\\d{1,4}$/;\n    const hasRoundingDownExp = /^([-]?)(\\d*)\\.(\\d{3,}9{4,})\\d{1,4}$/;\n    let text = num.toString(10);\n    if (text.indexOf('.') === -1) {\n        return text;\n    }\n    const roundingDownMatch = hasRoundingDownExp.exec(text);\n    if (roundingDownMatch) {\n        const negativeSign = roundingDownMatch[1];\n        const postDecimalString = roundingDownMatch[3];\n        const lastDigit = parseInt(postDecimalString.charAt(postDecimalString.length - 1), 10);\n        const postDecimal = parseInt(postDecimalString, 10);\n        const preDecimal = parseInt(roundingDownMatch[2], 10);\n        const origPostDecimalString = roundingDownMatch[3];\n        let newPostDecimal = (postDecimal + 10 - lastDigit).toString();\n        let carry = 0;\n        if (newPostDecimal.length > postDecimal.toString().length) {\n            // Left-shift\n            newPostDecimal = newPostDecimal.substring(1);\n            carry = 1;\n        }\n        // parseInt(...).toString() removes leading zeroes. Add them back.\n        while (newPostDecimal.length < origPostDecimalString.length) {\n            newPostDecimal = carry.toString(10) + newPostDecimal;\n            carry = 0;\n        }\n        text = `${negativeSign + (preDecimal + carry).toString()}.${newPostDecimal}`;\n    }\n    text = text.replace(fixRoundingUpExp, '$1');\n    return cleanUpNumber(text);\n};\nexport default toRoundedString;\n","import  cleanUpNumber  from './cleanUpNumber.mjs';\nimport  { numberRegex }  from './constants.mjs';\nimport  getLenAfterDecimal  from './getLenAfterDecimal.mjs';\nimport  toRoundedString  from './toRoundedString.mjs';\n// [reference] should be a string representation of a base-10 number (no exponential (e.g. 10e10))\nexport const toStringOfSamePrecision = (num, ...references) => {\n    const text = num.toString(10);\n    const textMatch = numberRegex.exec(text);\n    if (!textMatch) {\n        return text;\n    }\n    let decimalPlaces = -1;\n    for (const reference of references) {\n        decimalPlaces = Math.max(getLenAfterDecimal(reference), decimalPlaces);\n    }\n    if (decimalPlaces === -1) {\n        return toRoundedString(num);\n    }\n    // Make text's after decimal length match [afterDecimalLen].\n    let postDecimal = textMatch[3].substring(0, decimalPlaces);\n    let preDecimal = textMatch[2];\n    const nextDigit = textMatch[3].charAt(decimalPlaces);\n    if (nextDigit !== '') {\n        const asNumber = parseInt(nextDigit, 10);\n        if (asNumber >= 5) {\n            // Don't attempt to parseInt() an empty string.\n            if (postDecimal.length > 0) {\n                const leadingZeroMatch = /^(0+)(\\d*)$/.exec(postDecimal);\n                let leadingZeroes = '';\n                let postLeading = postDecimal;\n                if (leadingZeroMatch) {\n                    leadingZeroes = leadingZeroMatch[1];\n                    postLeading = leadingZeroMatch[2];\n                }\n                postDecimal = (parseInt(postDecimal) + 1).toString();\n                // If postDecimal got longer, remove leading zeroes if possible\n                if (postDecimal.length > postLeading.length && leadingZeroes.length > 0) {\n                    leadingZeroes = leadingZeroes.substring(1);\n                }\n                postDecimal = leadingZeroes + postDecimal;\n            }\n            if (postDecimal.length === 0 || postDecimal.length > decimalPlaces) {\n                preDecimal = (parseInt(preDecimal) + 1).toString();\n                postDecimal = postDecimal.substring(1);\n            }\n        }\n    }\n    const negativeSign = textMatch[1];\n    return cleanUpNumber(`${negativeSign}${preDecimal}.${postDecimal}`);\n};\nexport default toStringOfSamePrecision;\n","/**\n * An abstract base class for 2D shapes.\n */\nexport class Abstract2DShape {\n    /**\n     * @returns the distance from `point` to this shape. If `point` is within this shape,\n     * this returns the distance from `point` to the edge of this shape.\n     *\n     * @see {@link signedDistance}\n     */\n    distance(point) {\n        return Math.abs(this.signedDistance(point));\n    }\n    /**\n     * Returns `true` if and only if the given `point` is contained within this shape.\n     *\n     * `epsilon` is a small number used to counteract floating point error. Thus, if\n     * `point` is within `epsilon` of the inside of this shape, `containsPoint` may also\n     * return `true`.\n     *\n     * The default implementation relies on `signedDistance`.\n     * Subclasses may override this method to provide a more efficient implementation.\n     */\n    containsPoint(point, epsilon = Abstract2DShape.smallValue) {\n        return this.signedDistance(point) < epsilon;\n    }\n    /**\n     * Returns a bounding box that **loosely** fits the content of this shape.\n     *\n     * The result of this call can be larger than the result of {@link getTightBoundingBox},\n     * **but should not be smaller**. Thus, a call to `getLooseBoundingBox` can be significantly\n     * faster than a call to {@link getTightBoundingBox} for some shapes.\n     */\n    getLooseBoundingBox() {\n        return this.getTightBoundingBox();\n    }\n}\n// @internal\nAbstract2DShape.smallValue = 1e-12;\nexport default Abstract2DShape;\n","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _BezierJSWrapper_bezierJs;\nimport { Bezier } from 'bezier-js';\nimport  { Vec2 }  from '../Vec2.mjs';\nimport  LineSegment2  from './LineSegment2.mjs';\nimport  Rect2  from './Rect2.mjs';\nimport  Parameterized2DShape  from './Parameterized2DShape.mjs';\n/**\n * A lazy-initializing wrapper around Bezier-js.\n *\n * Subclasses may override `at`, `derivativeAt`, and `normal` with functions\n * that do not initialize a `bezier-js` `Bezier`.\n *\n * **Do not use this class directly.** It may be removed/replaced in a future release.\n * @internal\n */\nexport class BezierJSWrapper extends Parameterized2DShape {\n    constructor(bezierJsBezier) {\n        super();\n        _BezierJSWrapper_bezierJs.set(this, null);\n        if (bezierJsBezier) {\n            __classPrivateFieldSet(this, _BezierJSWrapper_bezierJs, bezierJsBezier, \"f\");\n        }\n    }\n    getBezier() {\n        if (!__classPrivateFieldGet(this, _BezierJSWrapper_bezierJs, \"f\")) {\n            __classPrivateFieldSet(this, _BezierJSWrapper_bezierJs, new Bezier(this.getPoints().map((p) => p.xy)), \"f\");\n        }\n        return __classPrivateFieldGet(this, _BezierJSWrapper_bezierJs, \"f\");\n    }\n    signedDistance(point) {\n        // .d: Distance\n        return this.nearestPointTo(point).point.distanceTo(point);\n    }\n    /**\n     * @returns the (more) exact distance from `point` to this.\n     *\n     * @see {@link approximateDistance}\n     */\n    distance(point) {\n        // A Bézier curve has no interior, thus, signed distance is the same as distance.\n        return this.signedDistance(point);\n    }\n    /**\n     * @returns the curve evaluated at `t`.\n     */\n    at(t) {\n        return Vec2.ofXY(this.getBezier().get(t));\n    }\n    /** @returns the curve's directional derivative at `t`. */\n    derivativeAt(t) {\n        return Vec2.ofXY(this.getBezier().derivative(t));\n    }\n    secondDerivativeAt(t) {\n        return Vec2.ofXY(this.getBezier().dderivative(t));\n    }\n    /** @returns the [normal vector](https://en.wikipedia.org/wiki/Normal_(geometry)) to this curve at `t`. */\n    normal(t) {\n        return Vec2.ofXY(this.getBezier().normal(t));\n    }\n    normalAt(t) {\n        return this.normal(t);\n    }\n    tangentAt(t) {\n        return this.derivativeAt(t).normalized();\n    }\n    getTightBoundingBox() {\n        const bbox = this.getBezier().bbox();\n        const width = bbox.x.max - bbox.x.min;\n        const height = bbox.y.max - bbox.y.min;\n        return new Rect2(bbox.x.min, bbox.y.min, width, height);\n    }\n    argIntersectsLineSegment(line) {\n        // Bezier-js has a bug when all control points of a Bezier curve lie on\n        // a line. Our solution involves converting the Bezier into a line, then\n        // finding the parameter value that produced the intersection.\n        //\n        // TODO: This is unnecessarily slow. A better solution would be to fix\n        // the bug upstream.\n        const asLine = LineSegment2.ofSmallestContainingPoints(this.getPoints());\n        if (asLine) {\n            const intersection = asLine.intersectsLineSegment(line);\n            return intersection.map((p) => this.nearestPointTo(p).parameterValue);\n        }\n        const bezier = this.getBezier();\n        return bezier\n            .intersects(line)\n            .map((t) => {\n            // We're using the .intersects(line) function, which is documented\n            // to always return numbers. However, to satisfy the type checker (and\n            // possibly improperly-defined types),\n            if (typeof t === 'string') {\n                t = parseFloat(t);\n            }\n            const point = Vec2.ofXY(this.at(t));\n            // Ensure that the intersection is on the line segment\n            if (point.distanceTo(line.p1) > line.length || point.distanceTo(line.p2) > line.length) {\n                return null;\n            }\n            return t;\n        })\n            .filter((entry) => entry !== null);\n    }\n    splitAt(t) {\n        if (t <= 0 || t >= 1) {\n            return [this];\n        }\n        const bezier = this.getBezier();\n        const split = bezier.split(t);\n        return [\n            new BezierJSWrapperImpl(split.left.points.map((point) => Vec2.ofXY(point)), split.left),\n            new BezierJSWrapperImpl(split.right.points.map((point) => Vec2.ofXY(point)), split.right),\n        ];\n    }\n    nearestPointTo(point) {\n        // One implementation could be similar to this:\n        //   const projection = this.getBezier().project(point);\n        //   return {\n        //    point: Vec2.ofXY(projection),\n        //    parameterValue: projection.t!,\n        //   };\n        // However, Bezier-js is rather impercise (and relies on a lookup table).\n        // Thus, we instead use Newton's Method:\n        // We want to find t such that f(t) = |B(t) - p|² is minimized.\n        // Expanding,\n        //   f(t)  = (Bₓ(t) - pₓ)² + (Bᵧ(t) - pᵧ)²\n        // ⇒ f'(t) = Dₜ(Bₓ(t) - pₓ)² + Dₜ(Bᵧ(t) - pᵧ)²\n        // ⇒ f'(t) = 2(Bₓ(t) - pₓ)(Bₓ'(t)) + 2(Bᵧ(t) - pᵧ)(Bᵧ'(t))\n        //         = 2Bₓ(t)Bₓ'(t) - 2pₓBₓ'(t) + 2Bᵧ(t)Bᵧ'(t) - 2pᵧBᵧ'(t)\n        // ⇒ f''(t)= 2Bₓ'(t)Bₓ'(t) + 2Bₓ(t)Bₓ''(t) - 2pₓBₓ''(t) + 2Bᵧ'(t)Bᵧ'(t)\n        //         + 2Bᵧ(t)Bᵧ''(t) - 2pᵧBᵧ''(t)\n        // Because f'(t) = 0 at relative extrema, we can use Newton's Method\n        // to improve on an initial guess.\n        const sqrDistAt = (t) => point.squareDistanceTo(this.at(t));\n        const yIntercept = sqrDistAt(0);\n        let t = 0;\n        let minSqrDist = yIntercept;\n        // Start by testing a few points:\n        const pointsToTest = 4;\n        for (let i = 0; i < pointsToTest; i++) {\n            const testT = i / (pointsToTest - 1);\n            const testMinSqrDist = sqrDistAt(testT);\n            if (testMinSqrDist < minSqrDist) {\n                t = testT;\n                minSqrDist = testMinSqrDist;\n            }\n        }\n        // To use Newton's Method, we need to evaluate the second derivative of the distance\n        // function:\n        const secondDerivativeAt = (t) => {\n            // f''(t) = 2Bₓ'(t)Bₓ'(t) + 2Bₓ(t)Bₓ''(t) - 2pₓBₓ''(t)\n            //        + 2Bᵧ'(t)Bᵧ'(t) + 2Bᵧ(t)Bᵧ''(t) - 2pᵧBᵧ''(t)\n            const b = this.at(t);\n            const bPrime = this.derivativeAt(t);\n            const bPrimePrime = this.secondDerivativeAt(t);\n            return (2 * bPrime.x * bPrime.x +\n                2 * b.x * bPrimePrime.x -\n                2 * point.x * bPrimePrime.x +\n                2 * bPrime.y * bPrime.y +\n                2 * b.y * bPrimePrime.y -\n                2 * point.y * bPrimePrime.y);\n        };\n        // Because we're zeroing f'(t), we also need to be able to compute it:\n        const derivativeAt = (t) => {\n            // f'(t) = 2Bₓ(t)Bₓ'(t) - 2pₓBₓ'(t) + 2Bᵧ(t)Bᵧ'(t) - 2pᵧBᵧ'(t)\n            const b = this.at(t);\n            const bPrime = this.derivativeAt(t);\n            return (2 * b.x * bPrime.x - 2 * point.x * bPrime.x + 2 * b.y * bPrime.y - 2 * point.y * bPrime.y);\n        };\n        const iterate = () => {\n            const slope = secondDerivativeAt(t);\n            if (slope === 0)\n                return;\n            // We intersect a line through the point on f'(t) at t with the x-axis:\n            //    y = m(x - x₀) + y₀\n            // ⇒  x - x₀ = (y - y₀) / m\n            // ⇒  x = (y - y₀) / m + x₀\n            //\n            // Thus, when zeroed,\n            //   tN = (0 - f'(t)) / m + t\n            const newT = (0 - derivativeAt(t)) / slope + t;\n            //const distDiff = sqrDistAt(newT) - sqrDistAt(t);\n            //console.assert(distDiff <= 0, `${-distDiff} >= 0`);\n            t = newT;\n            if (t > 1) {\n                t = 1;\n            }\n            else if (t < 0) {\n                t = 0;\n            }\n        };\n        for (let i = 0; i < 12; i++) {\n            iterate();\n        }\n        return { parameterValue: t, point: this.at(t) };\n    }\n    intersectsBezier(other) {\n        const intersections = this.getBezier().intersects(other.getBezier());\n        if (!intersections || intersections.length === 0) {\n            return [];\n        }\n        const result = [];\n        for (const intersection of intersections) {\n            // From http://pomax.github.io/bezierjs/#intersect-curve,\n            // .intersects returns an array of 't1/t2' pairs, where curve1.at(t1) gives the point.\n            const match = /^([-0-9.eE]+)\\/([-0-9.eE]+)$/.exec(intersection);\n            if (!match) {\n                throw new Error(`Incorrect format returned by .intersects: ${intersections} should be array of \"number/number\"!`);\n            }\n            const t = parseFloat(match[1]);\n            result.push({\n                parameterValue: t,\n                point: this.at(t),\n            });\n        }\n        return result;\n    }\n    toString() {\n        return `Bézier(${this.getPoints()\n            .map((point) => point.toString())\n            .join(', ')})`;\n    }\n}\n_BezierJSWrapper_bezierJs = new WeakMap();\n/**\n * Private concrete implementation of `BezierJSWrapper`, used by methods above that need to return a wrapper\n * around a `Bezier`.\n */\nclass BezierJSWrapperImpl extends BezierJSWrapper {\n    constructor(controlPoints, curve) {\n        super(curve);\n        this.controlPoints = controlPoints;\n    }\n    getPoints() {\n        return this.controlPoints;\n    }\n}\nexport default BezierJSWrapper;\n","import  BezierJSWrapper  from './BezierJSWrapper.mjs';\nimport  Rect2  from './Rect2.mjs';\n/**\n * A wrapper around [`bezier-js`](https://github.com/Pomax/bezierjs)'s cubic Bezier.\n */\nclass CubicBezier extends BezierJSWrapper {\n    constructor(\n    // Start point\n    p0, \n    // Control point 1\n    p1, \n    // Control point 2\n    p2, \n    // End point\n    p3) {\n        super();\n        this.p0 = p0;\n        this.p1 = p1;\n        this.p2 = p2;\n        this.p3 = p3;\n    }\n    getPoints() {\n        return [this.p0, this.p1, this.p2, this.p3];\n    }\n    /** Returns an overestimate of this shape's bounding box. */\n    getLooseBoundingBox() {\n        return Rect2.bboxOf([this.p0, this.p1, this.p2, this.p3]);\n    }\n}\nexport default CubicBezier;\n","import  Rect2  from './Rect2.mjs';\nimport  { Vec2 }  from '../Vec2.mjs';\nimport  Parameterized2DShape  from './Parameterized2DShape.mjs';\n/**\n * Represents a line segment. A `LineSegment2` is immutable.\n *\n * @example\n * ```ts,runnable,console\n * import {LineSegment2, Vec2} from '@js-draw/math';\n * const l = new LineSegment2(Vec2.of(1, 1), Vec2.of(2, 2));\n * console.log('length: ', l.length);\n * console.log('direction: ', l.direction);\n * console.log('bounding box: ', l.bbox);\n * ```\n */\nexport class LineSegment2 extends Parameterized2DShape {\n    /** Creates a new `LineSegment2` from its endpoints. */\n    constructor(point1, point2) {\n        super();\n        this.point1 = point1;\n        this.point2 = point2;\n        this.bbox = Rect2.bboxOf([point1, point2]);\n        this.direction = point2.minus(point1);\n        this.length = this.direction.magnitude();\n        // Normalize\n        if (this.length > 0) {\n            this.direction = this.direction.times(1 / this.length);\n        }\n    }\n    /**\n     * Returns the smallest line segment that contains all points in `points`, or `null`\n     * if no such line segment exists.\n     *\n     * @example\n     * ```ts,runnable,console\n     * import {LineSegment2, Vec2} from '@js-draw/math';\n     * console.log(LineSegment2.ofSmallestContainingPoints([Vec2.of(1, 0), Vec2.of(0, 1)]));\n     * ```\n     */\n    static ofSmallestContainingPoints(points) {\n        if (points.length <= 1)\n            return null;\n        const sorted = [...points].sort((a, b) => (a.x !== b.x ? a.x - b.x : a.y - b.y));\n        const line = new LineSegment2(sorted[0], sorted[sorted.length - 1]);\n        for (const point of sorted) {\n            if (!line.containsPoint(point)) {\n                return null;\n            }\n        }\n        return line;\n    }\n    // Accessors to make LineSegment2 compatible with bezier-js's\n    // interface\n    /** Alias for `point1`. */\n    get p1() {\n        return this.point1;\n    }\n    /** Alias for `point2`. */\n    get p2() {\n        return this.point2;\n    }\n    get center() {\n        return this.point1.lerp(this.point2, 0.5);\n    }\n    /**\n     * Gets a point a **distance** `t` along this line.\n     *\n     * @deprecated\n     */\n    get(t) {\n        return this.point1.plus(this.direction.times(t));\n    }\n    /**\n     * Returns a point a fraction, `t`, along this line segment.\n     * Thus, `segment.at(0)` returns `segment.p1` and `segment.at(1)` returns\n     * `segment.p2`.\n     *\n     * `t` should be in `[0, 1]`.\n     */\n    at(t) {\n        return this.get(t * this.length);\n    }\n    normalAt(_t) {\n        return this.direction.orthog();\n    }\n    tangentAt(_t) {\n        return this.direction;\n    }\n    splitAt(t) {\n        if (t <= 0 || t >= 1) {\n            return [this];\n        }\n        return [new LineSegment2(this.point1, this.at(t)), new LineSegment2(this.at(t), this.point2)];\n    }\n    /**\n     * Returns the intersection of this with another line segment.\n     *\n     * **WARNING**: The parameter value returned by this method does not range from 0 to 1 and\n     *              is currently a length.\n     *              This will change in a future release.\n     * @deprecated\n     */\n    intersection(other) {\n        // TODO(v2.0.0): Make this return a `t` value from `0` to `1`.\n        // We want x₁(t) = x₂(t) and y₁(t) = y₂(t)\n        // Observe that\n        // x = this.point1.x + this.direction.x · t₁\n        //   = other.point1.x + other.direction.x · t₂\n        // Thus,\n        //  t₁ = (x - this.point1.x) / this.direction.x\n        //     = (y - this.point1.y) / this.direction.y\n        // and\n        //  t₂ = (x - other.point1.x) / other.direction.x\n        // (and similarly for y)\n        //\n        // Letting o₁ₓ = this.point1.x, o₂ₓ = other.point1.x,\n        //         d₁ᵧ = this.direction.y, ...\n        //\n        // We can substitute these into the equations for y:\n        // y = o₁ᵧ + d₁ᵧ · (x - o₁ₓ) / d₁ₓ\n        //   = o₂ᵧ + d₂ᵧ · (x - o₂ₓ) / d₂ₓ\n        // ⇒ o₁ᵧ - o₂ᵧ = d₂ᵧ · (x - o₂ₓ) / d₂ₓ - d₁ᵧ · (x - o₁ₓ) / d₁ₓ\n        //            = (d₂ᵧ/d₂ₓ)(x) - (d₂ᵧ/d₂ₓ)(o₂ₓ) - (d₁ᵧ/d₁ₓ)(x) + (d₁ᵧ/d₁ₓ)(o₁ₓ)\n        //            = (x)(d₂ᵧ/d₂ₓ - d₁ᵧ/d₁ₓ) - (d₂ᵧ/d₂ₓ)(o₂ₓ) + (d₁ᵧ/d₁ₓ)(o₁ₓ)\n        // ⇒ (x)(d₂ᵧ/d₂ₓ - d₁ᵧ/d₁ₓ) = o₁ᵧ - o₂ᵧ + (d₂ᵧ/d₂ₓ)(o₂ₓ) - (d₁ᵧ/d₁ₓ)(o₁ₓ)\n        // ⇒ x = (o₁ᵧ - o₂ᵧ + (d₂ᵧ/d₂ₓ)(o₂ₓ) - (d₁ᵧ/d₁ₓ)(o₁ₓ))/(d₂ᵧ/d₂ₓ - d₁ᵧ/d₁ₓ)\n        //     = (d₁ₓd₂ₓ)(o₁ᵧ - o₂ᵧ + (d₂ᵧ/d₂ₓ)(o₂ₓ) - (d₁ᵧ/d₁ₓ)(o₁ₓ))/(d₂ᵧd₁ₓ - d₁ᵧd₂ₓ)\n        //     = ((o₁ᵧ - o₂ᵧ)((d₁ₓd₂ₓ)) + (d₂ᵧd₁ₓ)(o₂ₓ) - (d₁ᵧd₂ₓ)(o₁ₓ))/(d₂ᵧd₁ₓ - d₁ᵧd₂ₓ)\n        // ⇒ y = o₁ᵧ + d₁ᵧ · (x - o₁ₓ) / d₁ₓ = ...\n        let resultPoint, resultT;\n        // Consider very-near-vertical lines to be vertical --- not doing so can lead to\n        // precision error when dividing by this.direction.x.\n        const small = 4e-13;\n        if (Math.abs(this.direction.x) < small) {\n            // Vertical line: Where does the other have x = this.point1.x?\n            // x = o₁ₓ = o₂ₓ + d₂ₓ · (y - o₂ᵧ) / d₂ᵧ\n            // ⇒ (o₁ₓ - o₂ₓ)(d₂ᵧ/d₂ₓ) + o₂ᵧ = y\n            // Avoid division by zero\n            if (other.direction.x === 0 || this.direction.y === 0) {\n                return null;\n            }\n            const xIntersect = this.point1.x;\n            const yIntersect = ((this.point1.x - other.point1.x) * other.direction.y) / other.direction.x + other.point1.y;\n            resultPoint = Vec2.of(xIntersect, yIntersect);\n            resultT = (yIntersect - this.point1.y) / this.direction.y;\n        }\n        else {\n            // From above,\n            // x = ((o₁ᵧ - o₂ᵧ)(d₁ₓd₂ₓ) + (d₂ᵧd₁ₓ)(o₂ₓ) - (d₁ᵧd₂ₓ)(o₁ₓ))/(d₂ᵧd₁ₓ - d₁ᵧd₂ₓ)\n            const numerator = (this.point1.y - other.point1.y) * this.direction.x * other.direction.x +\n                this.direction.x * other.direction.y * other.point1.x -\n                this.direction.y * other.direction.x * this.point1.x;\n            const denominator = other.direction.y * this.direction.x - this.direction.y * other.direction.x;\n            // Avoid dividing by zero. It means there is no intersection\n            if (denominator === 0) {\n                return null;\n            }\n            const xIntersect = numerator / denominator;\n            const t1 = (xIntersect - this.point1.x) / this.direction.x;\n            const yIntersect = this.point1.y + this.direction.y * t1;\n            resultPoint = Vec2.of(xIntersect, yIntersect);\n            resultT = (xIntersect - this.point1.x) / this.direction.x;\n        }\n        // Ensure the result is in this/the other segment.\n        const resultToP1 = resultPoint.distanceTo(this.point1);\n        const resultToP2 = resultPoint.distanceTo(this.point2);\n        const resultToP3 = resultPoint.distanceTo(other.point1);\n        const resultToP4 = resultPoint.distanceTo(other.point2);\n        if (resultToP1 > this.length ||\n            resultToP2 > this.length ||\n            resultToP3 > other.length ||\n            resultToP4 > other.length) {\n            return null;\n        }\n        return {\n            point: resultPoint,\n            t: resultT,\n        };\n    }\n    intersects(other) {\n        return this.intersection(other) !== null;\n    }\n    argIntersectsLineSegment(lineSegment) {\n        const intersection = this.intersection(lineSegment);\n        if (intersection) {\n            return [intersection.t / this.length];\n        }\n        return [];\n    }\n    /**\n     * Returns the points at which this line segment intersects the\n     * given line segment.\n     *\n     * Note that {@link intersects} returns *whether* this line segment intersects another\n     * line segment. This method, by contrast, returns **the point** at which the intersection\n     * occurs, if such a point exists.\n     */\n    intersectsLineSegment(lineSegment) {\n        const intersection = this.intersection(lineSegment);\n        if (intersection) {\n            return [intersection.point];\n        }\n        return [];\n    }\n    // Returns the closest point on this to [target]\n    closestPointTo(target) {\n        return this.nearestPointTo(target).point;\n    }\n    nearestPointTo(target) {\n        // Distance from P1 along this' direction.\n        const projectedDistFromP1 = target.minus(this.p1).dot(this.direction);\n        const projectedDistFromP2 = this.length - projectedDistFromP1;\n        const projection = this.p1.plus(this.direction.times(projectedDistFromP1));\n        if (projectedDistFromP1 > 0 && projectedDistFromP1 < this.length) {\n            return { point: projection, parameterValue: projectedDistFromP1 / this.length };\n        }\n        if (Math.abs(projectedDistFromP2) < Math.abs(projectedDistFromP1)) {\n            return { point: this.p2, parameterValue: 1 };\n        }\n        else {\n            return { point: this.p1, parameterValue: 0 };\n        }\n    }\n    /**\n     * Returns the distance from this line segment to `target`.\n     *\n     * Because a line segment has no interior, this signed distance is equivalent to\n     * the full distance between `target` and this line segment.\n     */\n    signedDistance(target) {\n        return this.closestPointTo(target).minus(target).magnitude();\n    }\n    /** Returns a copy of this line segment transformed by the given `affineTransfm`. */\n    transformedBy(affineTransfm) {\n        return new LineSegment2(affineTransfm.transformVec2(this.p1), affineTransfm.transformVec2(this.p2));\n    }\n    /** @inheritdoc */\n    getTightBoundingBox() {\n        return this.bbox;\n    }\n    toString() {\n        return `LineSegment(${this.p1.toString()}, ${this.p2.toString()})`;\n    }\n    /**\n     * Returns `true` iff this is equivalent to `other`.\n     *\n     * **Options**:\n     * - `tolerance`: The maximum difference between endpoints. (Default: 0)\n     * - `ignoreDirection`: Allow matching a version of `this` with opposite direction. (Default: `true`)\n     */\n    eq(other, options) {\n        if (!(other instanceof LineSegment2)) {\n            return false;\n        }\n        const tolerance = options?.tolerance;\n        const ignoreDirection = options?.ignoreDirection ?? true;\n        return ((other.p1.eq(this.p1, tolerance) && other.p2.eq(this.p2, tolerance)) ||\n            (ignoreDirection && other.p1.eq(this.p2, tolerance) && other.p2.eq(this.p1, tolerance)));\n    }\n}\nexport default LineSegment2;\n","import  Abstract2DShape  from './Abstract2DShape.mjs';\n/**\n * A 2-dimensional path with parameter interval $t \\in [0, 1]$.\n *\n * **Note:** Avoid extending this class outside of `js-draw` --- new abstract methods\n * may be added between minor versions.\n */\nexport class Parameterized2DShape extends Abstract2DShape {\n    intersectsLineSegment(line) {\n        return this.argIntersectsLineSegment(line).map((t) => this.at(t));\n    }\n}\nexport default Parameterized2DShape;\n","import  LineSegment2  from './LineSegment2.mjs';\nimport  Rect2  from './Rect2.mjs';\nimport  { Vec2 }  from '../Vec2.mjs';\nimport  CubicBezier  from './CubicBezier.mjs';\nimport  QuadraticBezier  from './QuadraticBezier.mjs';\nimport  PointShape2D  from './PointShape2D.mjs';\nimport  toRoundedString  from '../rounding/toRoundedString.mjs';\nimport  toStringOfSamePrecision  from '../rounding/toStringOfSamePrecision.mjs';\nimport  convexHull2Of  from '../utils/convexHull2Of.mjs';\n/** Identifiers for different path commands. These commands can make up a {@link Path}. */\nexport var PathCommandType;\n(function (PathCommandType) {\n    PathCommandType[PathCommandType[\"LineTo\"] = 0] = \"LineTo\";\n    PathCommandType[PathCommandType[\"MoveTo\"] = 1] = \"MoveTo\";\n    PathCommandType[PathCommandType[\"CubicBezierTo\"] = 2] = \"CubicBezierTo\";\n    PathCommandType[PathCommandType[\"QuadraticBezierTo\"] = 3] = \"QuadraticBezierTo\";\n})(PathCommandType || (PathCommandType = {}));\n/** Returns a positive number if `a` comes after `b`, 0 if equal, and negative otherwise. */\nexport const compareCurveIndices = (a, b) => {\n    const indexCompare = a.curveIndex - b.curveIndex;\n    if (indexCompare === 0) {\n        return a.parameterValue - b.parameterValue;\n    }\n    else {\n        return indexCompare;\n    }\n};\n/**\n * Returns a version of `index` with its parameter value incremented by `stepBy`\n * (which can be either positive or negative).\n */\nexport const stepCurveIndexBy = (index, stepBy) => {\n    if (index.parameterValue + stepBy > 1) {\n        return { curveIndex: index.curveIndex + 1, parameterValue: index.parameterValue + stepBy - 1 };\n    }\n    if (index.parameterValue + stepBy < 0) {\n        if (index.curveIndex === 0) {\n            return { curveIndex: 0, parameterValue: 0 };\n        }\n        return { curveIndex: index.curveIndex - 1, parameterValue: index.parameterValue + stepBy + 1 };\n    }\n    return { curveIndex: index.curveIndex, parameterValue: index.parameterValue + stepBy };\n};\n/**\n * Represents a union of lines and curves.\n *\n * To create a path from a string, see {@link fromString}.\n *\n * @example\n * ```ts,runnable,console\n * import {Path, Mat33, Vec2, LineSegment2} from '@js-draw/math';\n *\n * // Creates a path from an SVG path string.\n * // In this case,\n * // 1. Move to (0,0)\n * // 2. Line to (100,0)\n * const path = Path.fromString('M0,0 L100,0');\n *\n * // Logs the distance from (10,0) to the curve 1 unit\n * // away from path. This curve forms a stroke with the path at\n * // its center.\n * const strokeRadius = 1;\n * console.log(path.signedDistance(Vec2.of(10,0), strokeRadius));\n *\n * // Log a version of the path that's scaled by a factor of 4.\n * console.log(path.transformedBy(Mat33.scaling2D(4)).toString());\n *\n * // Log all intersections of a stroked version of the path with\n * // a vertical line segment.\n * // (Try removing the `strokeRadius` parameter).\n * const segment = new LineSegment2(Vec2.of(5, -100), Vec2.of(5, 100));\n * console.log(path.intersection(segment, strokeRadius).map(i => i.point));\n * ```\n */\nexport class Path {\n    /**\n     * Creates a new `Path` that starts at `startPoint` and is made up of the path commands,\n     * `parts`.\n     *\n     * See also {@link fromString}\n     */\n    constructor(startPoint, parts) {\n        this.startPoint = startPoint;\n        this.cachedGeometry = null;\n        this.cachedPolylineApproximation = null;\n        this.cachedStringVersion = null;\n        this.parts = parts;\n        // Initial bounding box contains one point: the start point.\n        this.bbox = Rect2.bboxOf([startPoint]);\n        // Convert into a representation of the geometry (cache for faster intersection\n        // calculation)\n        for (const part of this.parts) {\n            this.bbox = this.bbox.union(Path.computeBBoxForSegment(startPoint, part));\n        }\n    }\n    /**\n     * Computes and returns the full bounding box for this path.\n     *\n     * If a slight over-estimate of a path's bounding box is sufficient, use\n     * {@link bbox} instead.\n     */\n    getExactBBox() {\n        const bboxes = [];\n        for (const part of this.geometry) {\n            bboxes.push(part.getTightBoundingBox());\n        }\n        return Rect2.union(...bboxes);\n    }\n    // Lazy-loads and returns this path's geometry\n    get geometry() {\n        if (this.cachedGeometry) {\n            return this.cachedGeometry;\n        }\n        let startPoint = this.startPoint;\n        const geometry = [];\n        for (const part of this.parts) {\n            let exhaustivenessCheck;\n            switch (part.kind) {\n                case PathCommandType.CubicBezierTo:\n                    geometry.push(new CubicBezier(startPoint, part.controlPoint1, part.controlPoint2, part.endPoint));\n                    startPoint = part.endPoint;\n                    break;\n                case PathCommandType.QuadraticBezierTo:\n                    geometry.push(new QuadraticBezier(startPoint, part.controlPoint, part.endPoint));\n                    startPoint = part.endPoint;\n                    break;\n                case PathCommandType.LineTo:\n                    geometry.push(new LineSegment2(startPoint, part.point));\n                    startPoint = part.point;\n                    break;\n                case PathCommandType.MoveTo:\n                    geometry.push(new PointShape2D(part.point));\n                    startPoint = part.point;\n                    break;\n                default:\n                    exhaustivenessCheck = part;\n                    return exhaustivenessCheck;\n            }\n        }\n        this.cachedGeometry = geometry;\n        return this.cachedGeometry;\n    }\n    /**\n     * Iterates through the start/end points of each component in this path.\n     *\n     * If a start point is equivalent to the end point of the previous segment,\n     * the point is **not** emitted twice.\n     */\n    *startEndPoints() {\n        yield this.startPoint;\n        for (const part of this.parts) {\n            let exhaustivenessCheck;\n            switch (part.kind) {\n                case PathCommandType.CubicBezierTo:\n                    yield part.endPoint;\n                    break;\n                case PathCommandType.QuadraticBezierTo:\n                    yield part.endPoint;\n                    break;\n                case PathCommandType.LineTo:\n                    yield part.point;\n                    break;\n                case PathCommandType.MoveTo:\n                    yield part.point;\n                    break;\n                default:\n                    exhaustivenessCheck = part;\n                    return exhaustivenessCheck;\n            }\n        }\n    }\n    // Approximates this path with a group of line segments.\n    polylineApproximation() {\n        if (this.cachedPolylineApproximation) {\n            return this.cachedPolylineApproximation;\n        }\n        const points = [];\n        for (const part of this.parts) {\n            switch (part.kind) {\n                case PathCommandType.CubicBezierTo:\n                    points.push(part.controlPoint1, part.controlPoint2, part.endPoint);\n                    break;\n                case PathCommandType.QuadraticBezierTo:\n                    points.push(part.controlPoint, part.endPoint);\n                    break;\n                case PathCommandType.MoveTo:\n                case PathCommandType.LineTo:\n                    points.push(part.point);\n                    break;\n            }\n        }\n        const result = [];\n        let prevPoint = this.startPoint;\n        for (const point of points) {\n            result.push(new LineSegment2(prevPoint, point));\n            prevPoint = point;\n        }\n        return result;\n    }\n    static computeBBoxForSegment(startPoint, part) {\n        const points = [startPoint];\n        let exhaustivenessCheck;\n        switch (part.kind) {\n            case PathCommandType.MoveTo:\n            case PathCommandType.LineTo:\n                points.push(part.point);\n                break;\n            case PathCommandType.CubicBezierTo:\n                points.push(part.controlPoint1, part.controlPoint2, part.endPoint);\n                break;\n            case PathCommandType.QuadraticBezierTo:\n                points.push(part.controlPoint, part.endPoint);\n                break;\n            default:\n                exhaustivenessCheck = part;\n                return exhaustivenessCheck;\n        }\n        return Rect2.bboxOf(points);\n    }\n    /**\n     * Returns the signed distance between `point` and a curve `strokeRadius` units\n     * away from this path.\n     *\n     * This returns the **signed distance**, which means that points inside this shape\n     * have their distance negated. For example,\n     * ```ts,runnable,console\n     * import {Path, Vec2} from '@js-draw/math';\n     * console.log(Path.fromString('m0,0 L100,0').signedDistance(Vec2.zero, 1));\n     * ```\n     * would print `-1` because (0,0) is on `m0,0 L100,0` and thus one unit away from its boundary.\n     *\n     * **Note**: `strokeRadius = strokeWidth / 2`\n     */\n    signedDistance(point, strokeRadius) {\n        let minDist = Infinity;\n        for (const part of this.geometry) {\n            const currentDist = part.signedDistance(point) - strokeRadius;\n            if (currentDist < minDist) {\n                minDist = currentDist;\n            }\n        }\n        return minDist;\n    }\n    /**\n     * Let `S` be a closed path a distance `strokeRadius` from this path.\n     *\n     * @returns Approximate intersections of `line` with `S` using ray marching, starting from\n     * \t        both end points of `line` and each point in `additionalRaymarchStartPoints`.\n     */\n    raymarchIntersectionWith(line, strokeRadius, additionalRaymarchStartPoints = []) {\n        // No intersection between bounding boxes: No possible intersection\n        // of the interior.\n        if (!line.bbox.intersects(this.bbox.grownBy(strokeRadius))) {\n            return [];\n        }\n        const lineLength = line.length;\n        const partDistFunctionRecords = [];\n        // Determine distance functions for all parts that the given line could possibly intersect with\n        for (const part of this.geometry) {\n            const bbox = part.getTightBoundingBox().grownBy(strokeRadius);\n            if (!bbox.intersects(line.bbox)) {\n                continue;\n            }\n            // Signed distance function\n            const partDist = (point) => part.signedDistance(point);\n            // Part signed distance function (negative result implies `point` is\n            // inside the shape).\n            const partSdf = (point) => partDist(point) - strokeRadius;\n            // If the line can't possibly intersect the part,\n            if (partSdf(line.p1) > lineLength && partSdf(line.p2) > lineLength) {\n                continue;\n            }\n            partDistFunctionRecords.push({\n                part,\n                distFn: partDist,\n                bbox,\n            });\n        }\n        // If no distance functions, there are no intersections.\n        if (partDistFunctionRecords.length === 0) {\n            return [];\n        }\n        // Returns the minimum distance to a part in this stroke, where only parts that the given\n        // line could intersect are considered.\n        const sdf = (point) => {\n            let minDist = Infinity;\n            let minDistPart = null;\n            const uncheckedDistFunctions = [];\n            // First pass: only curves for which the current point is inside\n            // the bounding box.\n            for (const distFnRecord of partDistFunctionRecords) {\n                const { part, distFn, bbox } = distFnRecord;\n                // Check later if the current point isn't in the bounding box.\n                if (!bbox.containsPoint(point)) {\n                    uncheckedDistFunctions.push(distFnRecord);\n                    continue;\n                }\n                const currentDist = distFn(point);\n                if (currentDist <= minDist) {\n                    minDist = currentDist;\n                    minDistPart = part;\n                }\n            }\n            // Second pass: Everything else\n            for (const { part, distFn, bbox } of uncheckedDistFunctions) {\n                // Skip if impossible for the distance to the target to be lesser than\n                // the current minimum.\n                if (isFinite(minDist) && !bbox.grownBy(minDist).containsPoint(point)) {\n                    continue;\n                }\n                const currentDist = distFn(point);\n                if (currentDist <= minDist) {\n                    minDist = currentDist;\n                    minDistPart = part;\n                }\n            }\n            return [minDistPart, minDist - strokeRadius];\n        };\n        // Raymarch:\n        const maxRaymarchSteps = 8;\n        // Start raymarching from each of these points. This allows detection of multiple\n        // intersections.\n        const startPoints = [line.p1, ...additionalRaymarchStartPoints, line.p2];\n        // Converts a point ON THE LINE to a parameter\n        const pointToParameter = (point) => {\n            // Because line.direction is a unit vector, this computes the length\n            // of the projection of the vector(line.p1->point) onto line.direction.\n            //\n            // Note that this can be negative if the given point is outside of the given\n            // line segment.\n            return point.minus(line.p1).dot(line.direction);\n        };\n        // Sort start points by parameter on the line.\n        // This allows us to determine whether the current value of a parameter\n        // drops down to a value already tested.\n        startPoints.sort((a, b) => {\n            const t_a = pointToParameter(a);\n            const t_b = pointToParameter(b);\n            // Sort in increasing order\n            return t_a - t_b;\n        });\n        const result = [];\n        const stoppingThreshold = strokeRadius / 1000;\n        // Returns the maximum parameter value explored\n        const raymarchFrom = (startPoint, \n        // Direction to march in (multiplies line.direction)\n        directionMultiplier, \n        // Terminate if the current point corresponds to a parameter\n        // below this.\n        minimumLineParameter) => {\n            let currentPoint = startPoint;\n            let [lastPart, lastDist] = sdf(currentPoint);\n            let lastParameter = pointToParameter(currentPoint);\n            if (lastDist > lineLength) {\n                return lastParameter;\n            }\n            const direction = line.direction.times(directionMultiplier);\n            for (let i = 0; i < maxRaymarchSteps; i++) {\n                // Step in the direction of the edge of the shape.\n                const step = lastDist;\n                currentPoint = currentPoint.plus(direction.times(step));\n                lastParameter = pointToParameter(currentPoint);\n                // If we're below the minimum parameter, stop. We've already tried\n                // this.\n                if (lastParameter <= minimumLineParameter) {\n                    return lastParameter;\n                }\n                const [currentPart, signedDist] = sdf(currentPoint);\n                // Ensure we're stepping in the correct direction.\n                // Note that because we could start with a negative distance and work towards a\n                // positive distance, we need absolute values here.\n                if (Math.abs(signedDist) > Math.abs(lastDist)) {\n                    // If not, stop.\n                    return null;\n                }\n                lastDist = signedDist;\n                lastPart = currentPart;\n                // Is the distance close enough that we can stop early?\n                if (Math.abs(lastDist) < stoppingThreshold) {\n                    break;\n                }\n            }\n            // Ensure that the point we ended with is on the line.\n            const isOnLineSegment = lastParameter >= 0 && lastParameter <= lineLength;\n            if (lastPart && isOnLineSegment && Math.abs(lastDist) < stoppingThreshold) {\n                result.push({\n                    point: currentPoint,\n                    parameterValue: lastPart.nearestPointTo(currentPoint).parameterValue,\n                    curve: lastPart,\n                    curveIndex: this.geometry.indexOf(lastPart),\n                });\n                // Slightly increase the parameter value to prevent the same point from being\n                // added to the results twice.\n                const parameterIncrease = strokeRadius / 20 / line.length;\n                lastParameter += isFinite(parameterIncrease) ? parameterIncrease : 0;\n            }\n            return lastParameter;\n        };\n        // The maximum value of the line's parameter explored so far (0 corresponds to\n        // line.p1)\n        let maxLineT = 0;\n        // Raymarch for each start point.\n        //\n        // Use a for (i from 0 to length) loop because startPoints may be added\n        // during iteration.\n        for (let i = 0; i < startPoints.length; i++) {\n            const startPoint = startPoints[i];\n            // Try raymarching in both directions.\n            maxLineT = Math.max(maxLineT, raymarchFrom(startPoint, 1, maxLineT) ?? maxLineT);\n            maxLineT = Math.max(maxLineT, raymarchFrom(startPoint, -1, maxLineT) ?? maxLineT);\n        }\n        return result;\n    }\n    /**\n     * Returns a list of intersections with this path. If `strokeRadius` is given,\n     * intersections are approximated with the surface `strokeRadius` away from this.\n     *\n     * If `strokeRadius > 0`, the resultant `parameterValue` has no defined value.\n     *\n     * **Note**: `strokeRadius` is half of a stroke's width.\n     */\n    intersection(line, strokeRadius) {\n        let result = [];\n        // Is any intersection between shapes within the bounding boxes impossible?\n        if (!line.bbox.intersects(this.bbox.grownBy(strokeRadius ?? 0))) {\n            return [];\n        }\n        if (this.parts.length === 0) {\n            return new Path(this.startPoint, [\n                { kind: PathCommandType.MoveTo, point: this.startPoint },\n            ]).intersection(line, strokeRadius);\n        }\n        let index = 0;\n        for (const part of this.geometry) {\n            const intersections = part.argIntersectsLineSegment(line);\n            for (const intersection of intersections) {\n                result.push({\n                    curve: part,\n                    curveIndex: index,\n                    point: part.at(intersection),\n                    parameterValue: intersection,\n                });\n            }\n            index++;\n        }\n        // If given a non-zero strokeWidth, attempt to raymarch.\n        // Even if raymarching, we need to collect starting points.\n        // We use the above-calculated intersections for this.\n        const doRaymarching = strokeRadius && strokeRadius > 1e-8;\n        if (doRaymarching) {\n            // Starting points for raymarching (in addition to the end points of the line).\n            const startPoints = result.map((intersection) => intersection.point);\n            result = this.raymarchIntersectionWith(line, strokeRadius, startPoints);\n        }\n        return result;\n    }\n    /**\n     * @returns the nearest point on this path to the given `point`.\n     */\n    nearestPointTo(point) {\n        // Find the closest point on this\n        let closestSquareDist = Infinity;\n        let closestPartIndex = 0;\n        let closestParameterValue = 0;\n        let closestPoint = this.startPoint;\n        for (let i = 0; i < this.geometry.length; i++) {\n            const current = this.geometry[i];\n            const nearestPoint = current.nearestPointTo(point);\n            const sqareDist = nearestPoint.point.squareDistanceTo(point);\n            if (i === 0 || sqareDist < closestSquareDist) {\n                closestPartIndex = i;\n                closestSquareDist = sqareDist;\n                closestParameterValue = nearestPoint.parameterValue;\n                closestPoint = nearestPoint.point;\n            }\n        }\n        return {\n            curve: this.geometry[closestPartIndex],\n            curveIndex: closestPartIndex,\n            parameterValue: closestParameterValue,\n            point: closestPoint,\n        };\n    }\n    at(index) {\n        if (index.curveIndex === 0 && index.parameterValue === 0) {\n            return this.startPoint;\n        }\n        return this.geometry[index.curveIndex].at(index.parameterValue);\n    }\n    tangentAt(index) {\n        return this.geometry[index.curveIndex].tangentAt(index.parameterValue);\n    }\n    /** Splits this path in two near the given `point`. */\n    splitNear(point, options) {\n        const nearest = this.nearestPointTo(point);\n        return this.splitAt(nearest, options);\n    }\n    /**\n     * Returns a copy of this path with `deleteFrom` until `deleteUntil` replaced with `insert`.\n     *\n     * This method is analogous to {@link Array.toSpliced}.\n     */\n    spliced(deleteFrom, deleteTo, insert, options) {\n        const isBeforeOrEqual = (a, b) => {\n            return (a.curveIndex < b.curveIndex ||\n                (a.curveIndex === b.curveIndex && a.parameterValue <= b.parameterValue));\n        };\n        if (isBeforeOrEqual(deleteFrom, deleteTo)) {\n            //          deleteFrom        deleteTo\n            //      <---------|             |-------------->\n            //      x                                      x\n            //  startPoint                             endPoint\n            const firstSplit = this.splitAt(deleteFrom, options);\n            const secondSplit = this.splitAt(deleteTo, options);\n            const before = firstSplit[0];\n            const after = secondSplit[secondSplit.length - 1];\n            return insert ? before.union(insert).union(after) : before.union(after);\n        }\n        else {\n            // In this case, we need to handle wrapping at the start/end.\n            //          deleteTo        deleteFrom\n            //      <---------|    keep     |-------------->\n            //      x                                      x\n            //  startPoint                             endPoint\n            const splitAtFrom = this.splitAt([deleteFrom], options);\n            const beforeFrom = splitAtFrom[0];\n            // We need splitNear, rather than splitAt, because beforeFrom does not have\n            // the same indexing as this.\n            const splitAtTo = beforeFrom.splitNear(this.at(deleteTo), options);\n            const betweenBoth = splitAtTo[splitAtTo.length - 1];\n            return insert ? betweenBoth.union(insert) : betweenBoth;\n        }\n    }\n    // @internal\n    splitAt(splitAt, options) {\n        if (!Array.isArray(splitAt)) {\n            splitAt = [splitAt];\n        }\n        splitAt = [...splitAt];\n        splitAt.sort(compareCurveIndices);\n        //\n        // Bounds checking & reversal.\n        //\n        while (splitAt.length > 0 &&\n            splitAt[splitAt.length - 1].curveIndex >= this.parts.length - 1 &&\n            splitAt[splitAt.length - 1].parameterValue >= 1) {\n            splitAt.pop();\n        }\n        splitAt.reverse(); // .reverse() <-- We're `.pop`ing from the end\n        while (splitAt.length > 0 &&\n            splitAt[splitAt.length - 1].curveIndex <= 0 &&\n            splitAt[splitAt.length - 1].parameterValue <= 0) {\n            splitAt.pop();\n        }\n        if (splitAt.length === 0 || this.parts.length === 0) {\n            return [this];\n        }\n        const expectedSplitCount = splitAt.length + 1;\n        const mapNewPoint = options?.mapNewPoint ?? ((p) => p);\n        const result = [];\n        let currentStartPoint = this.startPoint;\n        let currentPath = [];\n        //\n        // Splitting\n        //\n        let { curveIndex, parameterValue } = splitAt.pop();\n        for (let i = 0; i < this.parts.length; i++) {\n            if (i !== curveIndex) {\n                currentPath.push(this.parts[i]);\n            }\n            else {\n                let part = this.parts[i];\n                let geom = this.geometry[i];\n                while (i === curveIndex) {\n                    let newPathStart;\n                    const newPath = [];\n                    switch (part.kind) {\n                        case PathCommandType.MoveTo:\n                            currentPath.push({\n                                kind: part.kind,\n                                point: part.point,\n                            });\n                            newPathStart = part.point;\n                            break;\n                        case PathCommandType.LineTo:\n                            {\n                                const split = geom.splitAt(parameterValue);\n                                currentPath.push({\n                                    kind: part.kind,\n                                    point: mapNewPoint(split[0].p2),\n                                });\n                                newPathStart = split[0].p2;\n                                if (split.length > 1) {\n                                    console.assert(split.length === 2);\n                                    newPath.push({\n                                        kind: part.kind,\n                                        // Don't map: For lines, the end point of the split is\n                                        // the same as the end point of the original:\n                                        point: split[1].p2,\n                                    });\n                                    geom = split[1];\n                                }\n                            }\n                            break;\n                        case PathCommandType.QuadraticBezierTo:\n                        case PathCommandType.CubicBezierTo:\n                            {\n                                const split = geom.splitAt(parameterValue);\n                                let isFirstPart = split.length === 2;\n                                for (const segment of split) {\n                                    geom = segment;\n                                    const targetArray = isFirstPart ? currentPath : newPath;\n                                    const controlPoints = segment.getPoints();\n                                    if (part.kind === PathCommandType.CubicBezierTo) {\n                                        targetArray.push({\n                                            kind: part.kind,\n                                            controlPoint1: mapNewPoint(controlPoints[1]),\n                                            controlPoint2: mapNewPoint(controlPoints[2]),\n                                            endPoint: mapNewPoint(controlPoints[3]),\n                                        });\n                                    }\n                                    else {\n                                        targetArray.push({\n                                            kind: part.kind,\n                                            controlPoint: mapNewPoint(controlPoints[1]),\n                                            endPoint: mapNewPoint(controlPoints[2]),\n                                        });\n                                    }\n                                    // We want the start of the new path to match the start of the\n                                    // FIRST Bézier in the NEW path.\n                                    if (!isFirstPart) {\n                                        newPathStart = controlPoints[0];\n                                    }\n                                    isFirstPart = false;\n                                }\n                            }\n                            break;\n                        default: {\n                            const exhaustivenessCheck = part;\n                            return exhaustivenessCheck;\n                        }\n                    }\n                    result.push(new Path(currentStartPoint, [...currentPath]));\n                    currentStartPoint = mapNewPoint(newPathStart);\n                    console.assert(!!currentStartPoint, 'should have a start point');\n                    currentPath = newPath;\n                    part = newPath[newPath.length - 1] ?? part;\n                    const nextSplit = splitAt.pop();\n                    if (!nextSplit) {\n                        break;\n                    }\n                    else {\n                        curveIndex = nextSplit.curveIndex;\n                        if (i === curveIndex) {\n                            const originalPoint = this.at(nextSplit);\n                            parameterValue = geom.nearestPointTo(originalPoint).parameterValue;\n                            currentPath = [];\n                        }\n                        else {\n                            parameterValue = nextSplit.parameterValue;\n                        }\n                    }\n                }\n            }\n        }\n        result.push(new Path(currentStartPoint, currentPath));\n        console.assert(result.length === expectedSplitCount, `should split into splitAt.length + 1 splits (was ${result.length}, expected ${expectedSplitCount})`);\n        return result;\n    }\n    /**\n     * Replaces all `MoveTo` commands with `LineTo` commands and connects the end point of this\n     * path to the start point.\n     */\n    asClosed() {\n        const newParts = [];\n        let hasChanges = false;\n        for (const part of this.parts) {\n            if (part.kind === PathCommandType.MoveTo) {\n                newParts.push({\n                    kind: PathCommandType.LineTo,\n                    point: part.point,\n                });\n                hasChanges = true;\n            }\n            else {\n                newParts.push(part);\n            }\n        }\n        if (!this.getEndPoint().eq(this.startPoint)) {\n            newParts.push({\n                kind: PathCommandType.LineTo,\n                point: this.startPoint,\n            });\n            hasChanges = true;\n        }\n        if (!hasChanges) {\n            return this;\n        }\n        const result = new Path(this.startPoint, newParts);\n        console.assert(result.getEndPoint().eq(result.startPoint));\n        return result;\n    }\n    static mapPathCommand(part, mapping) {\n        switch (part.kind) {\n            case PathCommandType.MoveTo:\n            case PathCommandType.LineTo:\n                return {\n                    kind: part.kind,\n                    point: mapping(part.point),\n                };\n                break;\n            case PathCommandType.CubicBezierTo:\n                return {\n                    kind: part.kind,\n                    controlPoint1: mapping(part.controlPoint1),\n                    controlPoint2: mapping(part.controlPoint2),\n                    endPoint: mapping(part.endPoint),\n                };\n                break;\n            case PathCommandType.QuadraticBezierTo:\n                return {\n                    kind: part.kind,\n                    controlPoint: mapping(part.controlPoint),\n                    endPoint: mapping(part.endPoint),\n                };\n                break;\n        }\n        const exhaustivenessCheck = part;\n        return exhaustivenessCheck;\n    }\n    mapPoints(mapping) {\n        const startPoint = mapping(this.startPoint);\n        const newParts = [];\n        for (const part of this.parts) {\n            newParts.push(Path.mapPathCommand(part, mapping));\n        }\n        return new Path(startPoint, newParts);\n    }\n    transformedBy(affineTransfm) {\n        if (affineTransfm.isIdentity()) {\n            return this;\n        }\n        return this.mapPoints((point) => affineTransfm.transformVec2(point));\n    }\n    /**\n     * @internal\n     */\n    closedContainsPoint(point) {\n        const bbox = this.getExactBBox();\n        if (!bbox.containsPoint(point)) {\n            return false;\n        }\n        const pointOutside = point.plus(Vec2.of(bbox.width, 0));\n        const asClosed = this.asClosed();\n        const lineToOutside = new LineSegment2(point, pointOutside);\n        return asClosed.intersection(lineToOutside).length % 2 === 1;\n    }\n    // Creates a new path by joining [other] to the end of this path\n    union(other, \n    // allowReverse: true iff reversing other or this is permitted if it means\n    //               no moveTo command is necessary when unioning the paths.\n    options = { allowReverse: true }) {\n        if (!other) {\n            return this;\n        }\n        if (Array.isArray(other)) {\n            return new Path(this.startPoint, [...this.parts, ...other]);\n        }\n        const thisEnd = this.getEndPoint();\n        let newParts = [];\n        if (thisEnd.eq(other.startPoint)) {\n            newParts = this.parts.concat(other.parts);\n        }\n        else if (options.allowReverse && this.startPoint.eq(other.getEndPoint())) {\n            return other.union(this, { allowReverse: false });\n        }\n        else if (options.allowReverse && this.startPoint.eq(other.startPoint)) {\n            return this.union(other.reversed(), { allowReverse: false });\n        }\n        else {\n            newParts = [\n                ...this.parts,\n                {\n                    kind: PathCommandType.MoveTo,\n                    point: other.startPoint,\n                },\n                ...other.parts,\n            ];\n        }\n        return new Path(this.startPoint, newParts);\n    }\n    /**\n     * @returns a version of this path with the direction reversed.\n     *\n     * Example:\n     * ```ts,runnable,console\n     * import {Path} from '@js-draw/math';\n     * console.log(Path.fromString('m0,0l1,1').reversed()); // -> M1,1 L0,0\n     * ```\n     */\n    reversed() {\n        const newStart = this.getEndPoint();\n        const newParts = [];\n        let lastPoint = this.startPoint;\n        for (const part of this.parts) {\n            switch (part.kind) {\n                case PathCommandType.LineTo:\n                case PathCommandType.MoveTo:\n                    newParts.push({\n                        kind: part.kind,\n                        point: lastPoint,\n                    });\n                    lastPoint = part.point;\n                    break;\n                case PathCommandType.CubicBezierTo:\n                    newParts.push({\n                        kind: part.kind,\n                        controlPoint1: part.controlPoint2,\n                        controlPoint2: part.controlPoint1,\n                        endPoint: lastPoint,\n                    });\n                    lastPoint = part.endPoint;\n                    break;\n                case PathCommandType.QuadraticBezierTo:\n                    newParts.push({\n                        kind: part.kind,\n                        controlPoint: part.controlPoint,\n                        endPoint: lastPoint,\n                    });\n                    lastPoint = part.endPoint;\n                    break;\n                default: {\n                    const exhaustivenessCheck = part;\n                    return exhaustivenessCheck;\n                }\n            }\n        }\n        newParts.reverse();\n        return new Path(newStart, newParts);\n    }\n    /** Computes and returns the end point of this path */\n    getEndPoint() {\n        if (this.parts.length === 0) {\n            return this.startPoint;\n        }\n        const lastPart = this.parts[this.parts.length - 1];\n        if (lastPart.kind === PathCommandType.QuadraticBezierTo ||\n            lastPart.kind === PathCommandType.CubicBezierTo) {\n            return lastPart.endPoint;\n        }\n        else {\n            return lastPart.point;\n        }\n    }\n    /**\n     * Like {@link closedRoughlyIntersects} except takes stroke width into account.\n     *\n     * This is intended to be a very fast and rough approximation. Use {@link intersection}\n     * and {@link signedDistance} for more accurate (but much slower) intersection calculations.\n     *\n     * **Note**: Unlike other methods, this accepts `strokeWidth` (and not `strokeRadius`).\n     *\n     * `strokeRadius` is half of `strokeWidth`.\n     */\n    roughlyIntersects(rect, strokeWidth = 0) {\n        if (this.parts.length === 0) {\n            return rect.containsPoint(this.startPoint);\n        }\n        const isClosed = this.startPoint.eq(this.getEndPoint());\n        if (isClosed && strokeWidth === 0) {\n            return this.closedRoughlyIntersects(rect);\n        }\n        if (rect.containsRect(this.bbox)) {\n            return true;\n        }\n        // Does the rectangle intersect the bounding boxes of any of this' parts?\n        let startPoint = this.startPoint;\n        for (const part of this.parts) {\n            const bbox = Path.computeBBoxForSegment(startPoint, part).grownBy(strokeWidth);\n            if (part.kind === PathCommandType.LineTo || part.kind === PathCommandType.MoveTo) {\n                startPoint = part.point;\n            }\n            else {\n                startPoint = part.endPoint;\n            }\n            if (rect.intersects(bbox)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Treats this as a closed path and returns true if part of `rect` is *roughly* within\n     * this path's interior.\n     *\n     * **Note**: Assumes that this is a closed, non-self-intersecting path.\n     */\n    closedRoughlyIntersects(rect) {\n        if (rect.containsRect(this.bbox)) {\n            return true;\n        }\n        // Choose a point outside of the path.\n        const startPt = this.bbox.topLeft.minus(Vec2.of(1, 1));\n        const testPts = rect.corners;\n        const polygon = this.polylineApproximation();\n        for (const point of testPts) {\n            const testLine = new LineSegment2(point, startPt);\n            let intersectionCount = 0;\n            for (const line of polygon) {\n                if (line.intersects(testLine)) {\n                    intersectionCount++;\n                }\n            }\n            // Odd? The point is within the polygon!\n            if (intersectionCount % 2 === 1) {\n                return true;\n            }\n        }\n        // Grow the rectangle for possible additional precision.\n        const grownRect = rect.grownBy(Math.min(rect.size.x, rect.size.y));\n        const edges = [];\n        for (const subrect of grownRect.divideIntoGrid(4, 4)) {\n            edges.push(...subrect.getEdges());\n        }\n        for (const edge of edges) {\n            for (const line of polygon) {\n                if (edge.intersects(line)) {\n                    return true;\n                }\n            }\n        }\n        // Even? Probably no intersection.\n        return false;\n    }\n    /** @returns true if all points on this are equivalent to the points on `other` */\n    eq(other, tolerance) {\n        if (other.parts.length !== this.parts.length) {\n            return false;\n        }\n        for (let i = 0; i < this.parts.length; i++) {\n            const part1 = this.parts[i];\n            const part2 = other.parts[i];\n            switch (part1.kind) {\n                case PathCommandType.LineTo:\n                case PathCommandType.MoveTo:\n                    if (part1.kind !== part2.kind) {\n                        return false;\n                    }\n                    else if (!part1.point.eq(part2.point, tolerance)) {\n                        return false;\n                    }\n                    break;\n                case PathCommandType.CubicBezierTo:\n                    if (part1.kind !== part2.kind) {\n                        return false;\n                    }\n                    else if (!part1.controlPoint1.eq(part2.controlPoint1, tolerance) ||\n                        !part1.controlPoint2.eq(part2.controlPoint2, tolerance) ||\n                        !part1.endPoint.eq(part2.endPoint, tolerance)) {\n                        return false;\n                    }\n                    break;\n                case PathCommandType.QuadraticBezierTo:\n                    if (part1.kind !== part2.kind) {\n                        return false;\n                    }\n                    else if (!part1.controlPoint.eq(part2.controlPoint, tolerance) ||\n                        !part1.endPoint.eq(part2.endPoint, tolerance)) {\n                        return false;\n                    }\n                    break;\n                default: {\n                    const exhaustivenessCheck = part1;\n                    return exhaustivenessCheck;\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Returns a path that outlines `rect`.\n     *\n     * If `lineWidth` is given, the resultant path traces a `lineWidth` thick\n     * border around `rect`. Otherwise, the resultant path is just the border\n     * of `rect`.\n     */\n    static fromRect(rect, lineWidth = null) {\n        const commands = [];\n        let corners;\n        let startPoint;\n        if (lineWidth !== null) {\n            // Vector from the top left corner or bottom right corner to the edge of the\n            // stroked region.\n            const cornerToEdge = Vec2.of(lineWidth, lineWidth).times(0.5);\n            const innerRect = Rect2.fromCorners(rect.topLeft.plus(cornerToEdge), rect.bottomRight.minus(cornerToEdge));\n            const outerRect = Rect2.fromCorners(rect.topLeft.minus(cornerToEdge), rect.bottomRight.plus(cornerToEdge));\n            corners = [innerRect.corners[3], ...innerRect.corners, ...outerRect.corners.reverse()];\n            startPoint = outerRect.corners[3];\n        }\n        else {\n            corners = rect.corners.slice(1);\n            startPoint = rect.corners[0];\n        }\n        for (const corner of corners) {\n            commands.push({\n                kind: PathCommandType.LineTo,\n                point: corner,\n            });\n        }\n        // Close the shape\n        commands.push({\n            kind: PathCommandType.LineTo,\n            point: startPoint,\n        });\n        return new Path(startPoint, commands);\n    }\n    /**\n     * Convert to an [SVG path representation](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths).\n     *\n     * If `useNonAbsCommands` is given, relative path commands (e.g. `l10,0`) are to be used instead of\n     * absolute commands (e.g. `L10,0`).\n     *\n     * See also {@link fromString}.\n     */\n    toString(useNonAbsCommands, ignoreCache = false) {\n        if (this.cachedStringVersion && !ignoreCache) {\n            return this.cachedStringVersion;\n        }\n        if (useNonAbsCommands === undefined) {\n            // Hueristic: Try to determine whether converting absolute to relative commands is worth it.\n            useNonAbsCommands = Math.abs(this.bbox.topLeft.x) > 10 && Math.abs(this.bbox.topLeft.y) > 10;\n        }\n        const result = Path.toString(this.startPoint, this.parts, !useNonAbsCommands);\n        this.cachedStringVersion = result;\n        return result;\n    }\n    serialize() {\n        return this.toString();\n    }\n    // @param onlyAbsCommands - True if we should avoid converting absolute coordinates to relative offsets -- such\n    //   conversions can lead to smaller output strings, but also take time.\n    static toString(startPoint, parts, onlyAbsCommands) {\n        const result = [];\n        let prevPoint;\n        const addCommand = (command, ...points) => {\n            const absoluteCommandParts = [];\n            const relativeCommandParts = [];\n            const makeAbsCommand = !prevPoint || onlyAbsCommands;\n            const roundedPrevX = prevPoint ? toRoundedString(prevPoint.x) : '';\n            const roundedPrevY = prevPoint ? toRoundedString(prevPoint.y) : '';\n            for (const point of points) {\n                const xComponent = toRoundedString(point.x);\n                const yComponent = toRoundedString(point.y);\n                // Relative commands are often shorter as strings than absolute commands.\n                if (!makeAbsCommand) {\n                    const xComponentRelative = toStringOfSamePrecision(point.x - prevPoint.x, xComponent, roundedPrevX, roundedPrevY);\n                    const yComponentRelative = toStringOfSamePrecision(point.y - prevPoint.y, yComponent, roundedPrevX, roundedPrevY);\n                    // No need for an additional separator if it starts with a '-'\n                    if (yComponentRelative.charAt(0) === '-') {\n                        relativeCommandParts.push(`${xComponentRelative}${yComponentRelative}`);\n                    }\n                    else {\n                        relativeCommandParts.push(`${xComponentRelative},${yComponentRelative}`);\n                    }\n                }\n                else {\n                    absoluteCommandParts.push(`${xComponent},${yComponent}`);\n                }\n            }\n            let commandString;\n            if (makeAbsCommand) {\n                commandString = `${command}${absoluteCommandParts.join(' ')}`;\n            }\n            else {\n                commandString = `${command.toLowerCase()}${relativeCommandParts.join(' ')}`;\n            }\n            // Don't add no-ops.\n            if (commandString === 'l0,0' || commandString === 'm0,0') {\n                return;\n            }\n            result.push(commandString);\n            if (points.length > 0) {\n                prevPoint = points[points.length - 1];\n            }\n        };\n        // Don't add two moveTos in a row (this can happen if\n        // the start point corresponds to a moveTo _and_ the first command is\n        // also a moveTo)\n        if (parts[0]?.kind !== PathCommandType.MoveTo) {\n            addCommand('M', startPoint);\n        }\n        let exhaustivenessCheck;\n        for (let i = 0; i < parts.length; i++) {\n            const part = parts[i];\n            switch (part.kind) {\n                case PathCommandType.MoveTo:\n                    addCommand('M', part.point);\n                    break;\n                case PathCommandType.LineTo:\n                    addCommand('L', part.point);\n                    break;\n                case PathCommandType.CubicBezierTo:\n                    addCommand('C', part.controlPoint1, part.controlPoint2, part.endPoint);\n                    break;\n                case PathCommandType.QuadraticBezierTo:\n                    addCommand('Q', part.controlPoint, part.endPoint);\n                    break;\n                default:\n                    exhaustivenessCheck = part;\n                    return exhaustivenessCheck;\n            }\n        }\n        return result.join('');\n    }\n    /**\n     * Create a `Path` from a subset of the SVG path specification.\n     *\n     * Currently, this does not support elliptical arcs or `s` and `t` command\n     * shorthands. See https://github.com/personalizedrefrigerator/js-draw/pull/19.\n     *\n     * @example\n     * ```ts,runnable,console\n     * import { Path } from '@js-draw/math';\n     *\n     * const path = Path.fromString('m0,0l100,100');\n     * console.log(path.toString(true)); // true: Prefer relative to absolute path commands\n     * ```\n     */\n    static fromString(pathString) {\n        // TODO: Support elliptical arcs, and the `s`, `t` command shorthands.\n        //\n        // See the MDN reference:\n        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d\n        // and\n        // https://www.w3.org/TR/SVG2/paths.html\n        // Remove linebreaks\n        pathString = pathString.split('\\n').join(' ');\n        let lastPos = Vec2.zero;\n        let firstPos = null;\n        let startPos = null;\n        let isFirstCommand = true;\n        const commands = [];\n        const moveTo = (point) => {\n            // The first moveTo/lineTo is already handled by the [startPoint] parameter of the Path constructor.\n            if (isFirstCommand) {\n                isFirstCommand = false;\n                return;\n            }\n            commands.push({\n                kind: PathCommandType.MoveTo,\n                point,\n            });\n        };\n        const lineTo = (point) => {\n            if (isFirstCommand) {\n                isFirstCommand = false;\n                return;\n            }\n            commands.push({\n                kind: PathCommandType.LineTo,\n                point,\n            });\n        };\n        const cubicBezierTo = (cp1, cp2, end) => {\n            commands.push({\n                kind: PathCommandType.CubicBezierTo,\n                controlPoint1: cp1,\n                controlPoint2: cp2,\n                endPoint: end,\n            });\n        };\n        const quadraticBeierTo = (controlPoint, endPoint) => {\n            commands.push({\n                kind: PathCommandType.QuadraticBezierTo,\n                controlPoint,\n                endPoint,\n            });\n        };\n        const commandArgCounts = {\n            m: 1,\n            l: 1,\n            c: 3,\n            q: 2,\n            z: 0,\n            h: 1,\n            v: 1,\n        };\n        // Each command: Command character followed by anything that isn't a command character\n        const commandExp = /([MZLHVCSQTA])\\s*([^MZLHVCSQTA]*)/gi;\n        let current;\n        while ((current = commandExp.exec(pathString)) !== null) {\n            const argParts = current[2]\n                .trim()\n                .split(/[^0-9Ee.-]/)\n                .filter((part) => part.length > 0)\n                .reduce((accumualtor, current) => {\n                // As of 09/2022, iOS Safari doesn't support support lookbehind in regular\n                // expressions. As such, we need an alternative.\n                // Because '-' can be used as a path separator, unless preceeded by an 'e' (as in 1e-5),\n                // we need special cases:\n                current = current.replace(/([^eE])[-]/g, '$1 -');\n                const parts = current.split(' -');\n                if (parts[0] !== '') {\n                    accumualtor.push(parts[0]);\n                }\n                accumualtor.push(...parts.slice(1).map((part) => `-${part}`));\n                return accumualtor;\n            }, []);\n            let numericArgs = argParts.map((arg) => parseFloat(arg));\n            let commandChar = current[1].toLowerCase();\n            let uppercaseCommand = current[1] !== commandChar;\n            // Convert commands that don't take points into commands that do.\n            if (commandChar === 'v' || commandChar === 'h') {\n                numericArgs = numericArgs.reduce((accumulator, current) => {\n                    if (commandChar === 'v') {\n                        return accumulator.concat(uppercaseCommand ? lastPos.x : 0, current);\n                    }\n                    else {\n                        return accumulator.concat(current, uppercaseCommand ? lastPos.y : 0);\n                    }\n                }, []);\n                commandChar = 'l';\n            }\n            else if (commandChar === 'z') {\n                if (firstPos) {\n                    numericArgs = [firstPos.x, firstPos.y];\n                    firstPos = lastPos;\n                }\n                else {\n                    continue;\n                }\n                // 'z' always acts like an uppercase lineTo(startPos)\n                uppercaseCommand = true;\n                commandChar = 'l';\n            }\n            const commandArgCount = commandArgCounts[commandChar] ?? 0;\n            const allArgs = numericArgs\n                .reduce((accumulator, current, index, parts) => {\n                if (index % 2 !== 0) {\n                    const currentAsFloat = current;\n                    const prevAsFloat = parts[index - 1];\n                    return accumulator.concat(Vec2.of(prevAsFloat, currentAsFloat));\n                }\n                else {\n                    return accumulator;\n                }\n            }, [])\n                .map((coordinate, index) => {\n                // Lowercase commands are relative, uppercase commands use absolute\n                // positioning\n                let newPos;\n                if (uppercaseCommand) {\n                    newPos = coordinate;\n                }\n                else {\n                    newPos = lastPos.plus(coordinate);\n                }\n                if ((index + 1) % commandArgCount === 0) {\n                    lastPos = newPos;\n                }\n                return newPos;\n            });\n            if (allArgs.length % commandArgCount !== 0) {\n                throw new Error([\n                    `Incorrect number of arguments: got ${JSON.stringify(allArgs)} with a length of ${allArgs.length} ≠ ${commandArgCount}k, k ∈ ℤ.`,\n                    `The number of arguments to ${commandChar} must be a multiple of ${commandArgCount}!`,\n                    `Command: ${current[0]}`,\n                ].join('\\n'));\n            }\n            for (let argPos = 0; argPos < allArgs.length; argPos += commandArgCount) {\n                const args = allArgs.slice(argPos, argPos + commandArgCount);\n                switch (commandChar.toLowerCase()) {\n                    case 'm':\n                        if (argPos === 0) {\n                            moveTo(args[0]);\n                        }\n                        else {\n                            lineTo(args[0]);\n                        }\n                        break;\n                    case 'l':\n                        lineTo(args[0]);\n                        break;\n                    case 'c':\n                        cubicBezierTo(args[0], args[1], args[2]);\n                        break;\n                    case 'q':\n                        quadraticBeierTo(args[0], args[1]);\n                        break;\n                    default:\n                        throw new Error(`Unknown path command ${commandChar}`);\n                }\n                isFirstCommand = false;\n            }\n            if (allArgs.length > 0) {\n                firstPos ??= allArgs[0];\n                startPos ??= firstPos;\n                lastPos = allArgs[allArgs.length - 1];\n            }\n        }\n        const result = new Path(startPos ?? Vec2.zero, commands);\n        result.cachedStringVersion = pathString;\n        return result;\n    }\n    static fromConvexHullOf(points) {\n        if (points.length === 0) {\n            return Path.empty;\n        }\n        const hull = convexHull2Of(points);\n        const commands = hull.slice(1).map((p) => ({\n            kind: PathCommandType.LineTo,\n            point: p,\n        }));\n        // Close -- connect back to the start\n        commands.push({\n            kind: PathCommandType.LineTo,\n            point: hull[0],\n        });\n        return new Path(hull[0], commands);\n    }\n}\n// @internal TODO: At present, this isn't really an empty path.\nPath.empty = new Path(Vec2.zero, []);\nexport default Path;\n","import  { Vec2 }  from '../Vec2.mjs';\nimport  Parameterized2DShape  from './Parameterized2DShape.mjs';\nimport  Rect2  from './Rect2.mjs';\n/**\n * Like a {@link Point2}, but with additional functionality (e.g. SDF).\n *\n * Access the internal `Point2` using the `p` property.\n */\nclass PointShape2D extends Parameterized2DShape {\n    constructor(p) {\n        super();\n        this.p = p;\n    }\n    signedDistance(point) {\n        return this.p.distanceTo(point);\n    }\n    argIntersectsLineSegment(lineSegment, epsilon) {\n        if (lineSegment.containsPoint(this.p, epsilon)) {\n            return [0];\n        }\n        return [];\n    }\n    getTightBoundingBox() {\n        return new Rect2(this.p.x, this.p.y, 0, 0);\n    }\n    at(_t) {\n        return this.p;\n    }\n    /**\n     * Returns an arbitrary unit-length vector.\n     */\n    normalAt(_t) {\n        // Return a vector that makes sense.\n        return Vec2.unitY;\n    }\n    tangentAt(_t) {\n        return Vec2.unitX;\n    }\n    splitAt(_t) {\n        return [this];\n    }\n    nearestPointTo(_point) {\n        return {\n            point: this.p,\n            parameterValue: 0,\n        };\n    }\n}\nexport default PointShape2D;\n","import  { Vec2 }  from '../Vec2.mjs';\nimport  solveQuadratic  from '../polynomial/solveQuadratic.mjs';\nimport  BezierJSWrapper  from './BezierJSWrapper.mjs';\nimport  Rect2  from './Rect2.mjs';\n/**\n * Represents a 2D [Bézier curve](https://en.wikipedia.org/wiki/B%C3%A9zier_curve).\n *\n * Example:\n * ```ts,runnable,console\n * import { QuadraticBezier, Vec2 } from '@js-draw/math';\n *\n * const startPoint = Vec2.of(4, 3);\n * const controlPoint = Vec2.of(1, 1);\n * const endPoint = Vec2.of(1, 3);\n *\n * const curve = new QuadraticBezier(\n *   startPoint,\n *   controlPoint,\n *   endPoint,\n * );\n *\n * console.log('Curve:', curve);\n * ```\n *\n * **Note**: Some Bézier operations internally use the `bezier-js` library.\n */\nexport class QuadraticBezier extends BezierJSWrapper {\n    constructor(\n    // Start point\n    p0, \n    // Control point\n    p1, \n    // End point\n    p2) {\n        super();\n        this.p0 = p0;\n        this.p1 = p1;\n        this.p2 = p2;\n    }\n    /**\n     * Returns a component of a quadratic Bézier curve at t, where p0,p1,p2 are either all x or\n     * all y components of the target curve.\n     */\n    static componentAt(t, p0, p1, p2) {\n        return p0 + t * (-2 * p0 + 2 * p1) + t * t * (p0 - 2 * p1 + p2);\n    }\n    static derivativeComponentAt(t, p0, p1, p2) {\n        return -2 * p0 + 2 * p1 + 2 * t * (p0 - 2 * p1 + p2);\n    }\n    static secondDerivativeComponentAt(t, p0, p1, p2) {\n        return 2 * (p0 - 2 * p1 + p2);\n    }\n    /**\n     * @returns the curve evaluated at `t`.\n     *\n     * `t` should be a number in `[0, 1]`.\n     */\n    at(t) {\n        if (t === 0)\n            return this.p0;\n        if (t === 1)\n            return this.p2;\n        const p0 = this.p0;\n        const p1 = this.p1;\n        const p2 = this.p2;\n        return Vec2.of(QuadraticBezier.componentAt(t, p0.x, p1.x, p2.x), QuadraticBezier.componentAt(t, p0.y, p1.y, p2.y));\n    }\n    derivativeAt(t) {\n        const p0 = this.p0;\n        const p1 = this.p1;\n        const p2 = this.p2;\n        return Vec2.of(QuadraticBezier.derivativeComponentAt(t, p0.x, p1.x, p2.x), QuadraticBezier.derivativeComponentAt(t, p0.y, p1.y, p2.y));\n    }\n    secondDerivativeAt(t) {\n        const p0 = this.p0;\n        const p1 = this.p1;\n        const p2 = this.p2;\n        return Vec2.of(QuadraticBezier.secondDerivativeComponentAt(t, p0.x, p1.x, p2.x), QuadraticBezier.secondDerivativeComponentAt(t, p0.y, p1.y, p2.y));\n    }\n    normal(t) {\n        const tangent = this.derivativeAt(t);\n        return tangent.orthog().normalized();\n    }\n    /** @returns an overestimate of this shape's bounding box. */\n    getLooseBoundingBox() {\n        return Rect2.bboxOf([this.p0, this.p1, this.p2]);\n    }\n    /**\n     * @returns the *approximate* distance from `point` to this curve.\n     */\n    approximateDistance(point) {\n        // We want to minimize f(t) = |B(t) - p|².\n        // Expanding,\n        //   f(t)  = (Bₓ(t) - pₓ)² + (Bᵧ(t) - pᵧ)²\n        // ⇒ f'(t) = Dₜ(Bₓ(t) - pₓ)² + Dₜ(Bᵧ(t) - pᵧ)²\n        //\n        // Considering just one component,\n        //  Dₜ(Bₓ(t) - pₓ)² = 2(Bₓ(t) - pₓ)(DₜBₓ(t))\n        //                  = 2(Bₓ(t)DₜBₓ(t) - pₓBₓ(t))\n        //   = 2(p0ₓ + (t)(-2p0ₓ + 2p1ₓ) + (t²)(p0ₓ - 2p1ₓ + p2ₓ) - pₓ)((-2p0ₓ + 2p1ₓ) + 2(t)(p0ₓ - 2p1ₓ + p2ₓ))\n        //     - (pₓ)((-2p0ₓ + 2p1ₓ) + (t)(p0ₓ - 2p1ₓ + p2ₓ))\n        const A = this.p0.x - point.x;\n        const B = -2 * this.p0.x + 2 * this.p1.x;\n        const C = this.p0.x - 2 * this.p1.x + this.p2.x;\n        // Let A = p0ₓ - pₓ, B = -2p0ₓ + 2p1ₓ, C = p0ₓ - 2p1ₓ + p2ₓ. We then have,\n        //  Dₜ(Bₓ(t) - pₓ)²\n        //    = 2(A + tB + t²C)(B + 2tC) - (pₓ)(B + 2tC)\n        //    = 2(AB + tB² + t²BC + 2tCA + 2tCtB + 2tCt²C) - pₓB - pₓ2tC\n        //    = 2(AB + tB² + 2tCA + t²BC + 2t²CB + 2C²t³) - pₓB - pₓ2tC\n        //    = 2AB + 2t(B² + 2CA) + 2t²(BC + 2CB) + 4C²t³ - pₓB - pₓ2tC\n        //    = 2AB + 2t(B² + 2CA - pₓC) + 2t²(BC + 2CB) + 4C²t³ - pₓB\n        //\n        const D = this.p0.y - point.y;\n        const E = -2 * this.p0.y + 2 * this.p1.y;\n        const F = this.p0.y - 2 * this.p1.y + this.p2.y;\n        // Using D = p0ᵧ - pᵧ, E = -2p0ᵧ + 2p1ᵧ, F = p0ᵧ - 2p1ᵧ + p2ᵧ, we thus have,\n        //  f'(t) = 2AB + 2t(B² + 2CA - pₓC) + 2t²(BC + 2CB) + 4C²t³ - pₓB\n        //        + 2DE + 2t(E² + 2FD - pᵧF) + 2t²(EF + 2FE) + 4F²t³ - pᵧE\n        const a = 2 * A * B + 2 * D * E - point.x * B - point.y * E;\n        const b = 2 * B * B + 2 * E * E + 2 * C * A + 2 * F * D - point.x * C - point.y * F;\n        const c = 2 * E * F + 2 * B * C + 2 * C * B + 2 * F * E;\n        //const d = 4 * C * C + 4 * F * F;\n        // Thus,\n        // f'(t) = a + bt + ct² + dt³\n        const fDerivAtZero = a;\n        const f2ndDerivAtZero = b;\n        const f3rdDerivAtZero = 2 * c;\n        // Using the first few terms of a Maclaurin series to approximate f'(t),\n        // f'(t) ≈ f'(0) + t f''(0) + t² f'''(0) / 2\n        let [min1, min2] = solveQuadratic(f3rdDerivAtZero / 2, f2ndDerivAtZero, fDerivAtZero);\n        // If the quadratic has no solutions, approximate.\n        if (isNaN(min1)) {\n            min1 = 0.25;\n        }\n        if (isNaN(min2)) {\n            min2 = 0.75;\n        }\n        const at1 = this.at(min1);\n        const at2 = this.at(min2);\n        const sqrDist1 = at1.squareDistanceTo(point);\n        const sqrDist2 = at2.squareDistanceTo(point);\n        const sqrDist3 = this.at(0).squareDistanceTo(point);\n        const sqrDist4 = this.at(1).squareDistanceTo(point);\n        return Math.sqrt(Math.min(sqrDist1, sqrDist2, sqrDist3, sqrDist4));\n    }\n    getPoints() {\n        return [this.p0, this.p1, this.p2];\n    }\n}\nexport default QuadraticBezier;\n","import  LineSegment2  from './LineSegment2.mjs';\nimport  Mat33  from '../Mat33.mjs';\nimport  { Vec2 }  from '../Vec2.mjs';\nimport  Abstract2DShape  from './Abstract2DShape.mjs';\n/**\n * Represents a rectangle in 2D space, parallel to the XY axes.\n *\n * **Example**:\n * ```ts,runnable,console\n * import { Rect2, Vec2 } from '@js-draw/math';\n *\n * const rect = Rect2.fromCorners(\n *   Vec2.of(0, 0),\n *   Vec2.of(10, 10),\n * );\n * console.log('area', rect.area);\n * console.log('topLeft', rect.topLeft);\n * ```\n *\n * `invariant: w ≥ 0, h ≥ 0, immutable`\n */\nexport class Rect2 extends Abstract2DShape {\n    constructor(\n    // Top left x coordinate\n    x, \n    // Top left y coordinate\n    y, \n    // Width\n    w, \n    // Height\n    h) {\n        super();\n        this.x = x;\n        this.y = y;\n        this.w = w;\n        this.h = h;\n        if (w < 0) {\n            this.x += w;\n            this.w = Math.abs(w);\n        }\n        if (h < 0) {\n            this.y += h;\n            this.h = Math.abs(h);\n        }\n        // Precompute/store vector forms.\n        this.topLeft = Vec2.of(this.x, this.y);\n        this.size = Vec2.of(this.w, this.h);\n        this.area = this.w * this.h;\n    }\n    translatedBy(vec) {\n        return new Rect2(vec.x + this.x, vec.y + this.y, this.w, this.h);\n    }\n    // Returns a copy of this with the given size (but same top-left).\n    resizedTo(size) {\n        return new Rect2(this.x, this.y, size.x, size.y);\n    }\n    containsPoint(other) {\n        return (this.x <= other.x &&\n            this.y <= other.y &&\n            this.x + this.w >= other.x &&\n            this.y + this.h >= other.y);\n    }\n    /** @returns true iff `other` is completely within this `Rect2`. */\n    containsRect(other) {\n        return (this.x <= other.x &&\n            this.y <= other.y &&\n            this.x + this.w >= other.x + other.w &&\n            this.y + this.h >= other.y + other.h);\n    }\n    /**\n     * @returns true iff this and `other` overlap\n     */\n    intersects(other) {\n        // Project along x/y axes.\n        const thisMinX = this.x;\n        const thisMaxX = thisMinX + this.w;\n        const otherMinX = other.x;\n        const otherMaxX = other.x + other.w;\n        if (thisMaxX < otherMinX || thisMinX > otherMaxX) {\n            return false;\n        }\n        const thisMinY = this.y;\n        const thisMaxY = thisMinY + this.h;\n        const otherMinY = other.y;\n        const otherMaxY = other.y + other.h;\n        if (thisMaxY < otherMinY || thisMinY > otherMaxY) {\n            return false;\n        }\n        return true;\n    }\n    // Returns the overlap of this and [other], or null, if no such\n    //          overlap exists\n    intersection(other) {\n        if (!this.intersects(other)) {\n            return null;\n        }\n        const topLeft = this.topLeft.zip(other.topLeft, Math.max);\n        const bottomRight = this.bottomRight.zip(other.bottomRight, Math.min);\n        return Rect2.fromCorners(topLeft, bottomRight);\n    }\n    // Returns a new rectangle containing both [this] and [other].\n    union(other) {\n        return Rect2.union(this, other);\n    }\n    // Returns a the subdivision of this into [columns] columns\n    // and [rows] rows. For example,\n    //\t Rect2.unitSquare.divideIntoGrid(2, 2)\n    //\t\t-> [ Rect2(0, 0, 0.5, 0.5), Rect2(0.5, 0, 0.5, 0.5), Rect2(0, 0.5, 0.5, 0.5), Rect2(0.5, 0.5, 0.5, 0.5) ]\n    // The rectangles are ordered in row-major order.\n    divideIntoGrid(columns, rows) {\n        const result = [];\n        if (columns <= 0 || rows <= 0) {\n            return result;\n        }\n        const eachRectWidth = this.w / columns;\n        const eachRectHeight = this.h / rows;\n        if (eachRectWidth === 0) {\n            columns = 1;\n        }\n        if (eachRectHeight === 0) {\n            rows = 1;\n        }\n        for (let j = 0; j < rows; j++) {\n            for (let i = 0; i < columns; i++) {\n                const x = eachRectWidth * i + this.x;\n                const y = eachRectHeight * j + this.y;\n                result.push(new Rect2(x, y, eachRectWidth, eachRectHeight));\n            }\n        }\n        return result;\n    }\n    // Returns a rectangle containing this and [point].\n    // [margin] is the minimum distance between the new point and the edge\n    // of the resultant rectangle.\n    grownToPoint(point, margin = 0) {\n        const otherRect = new Rect2(point.x - margin, point.y - margin, margin * 2, margin * 2);\n        return this.union(otherRect);\n    }\n    // Returns this grown by [margin] in both the x and y directions.\n    grownBy(margin) {\n        if (margin === 0) {\n            return this;\n        }\n        // Prevent width/height from being negative\n        if (margin < 0) {\n            const xMargin = -Math.min(-margin, this.w / 2);\n            const yMargin = -Math.min(-margin, this.h / 2);\n            return new Rect2(this.x - xMargin, this.y - yMargin, this.w + xMargin * 2, this.h + yMargin * 2);\n        }\n        return new Rect2(this.x - margin, this.y - margin, this.w + margin * 2, this.h + margin * 2);\n    }\n    /**\n     * If this rectangle is smaller than `minSize`, returns a copy of this\n     * with a larger width/height.\n     *\n     * If smaller than `minSize`, padding is applied on both sides.\n     */\n    grownToSize(minSize) {\n        if (this.width >= minSize.x && this.height >= minSize.y) {\n            return this;\n        }\n        const deltaWidth = Math.max(0, minSize.x - this.width);\n        const deltaHeight = Math.max(0, minSize.y - this.height);\n        return new Rect2(this.x - deltaWidth / 2, this.y - deltaHeight / 2, this.width + deltaWidth, this.height + deltaHeight);\n    }\n    getClosestPointOnBoundaryTo(target) {\n        const closestEdgePoints = this.getEdges().map((edge) => {\n            return edge.closestPointTo(target);\n        });\n        let closest = null;\n        let closestDist = null;\n        for (const point of closestEdgePoints) {\n            const dist = point.distanceTo(target);\n            if (closestDist === null || dist < closestDist) {\n                closest = point;\n                closestDist = dist;\n            }\n        }\n        return closest;\n    }\n    /**\n     * Returns `true` iff all points in this rectangle are within `distance` from `point`:\n     *\n     * If $R$ is the set of points in this rectangle, returns `true` iff\n     * $$\n     * \t\\forall {\\bf a} \\in R, \\|\\texttt{point} - {\\bf a}\\| < \\texttt{radius}\n     * $$\n     */\n    isWithinRadiusOf(radius, point) {\n        if (this.maxDimension > radius) {\n            return false;\n        }\n        const squareRadius = radius * radius;\n        return this.corners.every((corner) => corner.minus(point).magnitudeSquared() < squareRadius);\n    }\n    get corners() {\n        return [this.bottomRight, this.topRight, this.topLeft, this.bottomLeft];\n    }\n    get maxDimension() {\n        return Math.max(this.w, this.h);\n    }\n    get minDimension() {\n        return Math.min(this.w, this.h);\n    }\n    get bottomRight() {\n        return this.topLeft.plus(this.size);\n    }\n    get topRight() {\n        return this.bottomRight.plus(Vec2.of(0, -this.h));\n    }\n    get bottomLeft() {\n        return this.topLeft.plus(Vec2.of(0, this.h));\n    }\n    get width() {\n        return this.w;\n    }\n    get height() {\n        return this.h;\n    }\n    get center() {\n        return Vec2.of(this.x + this.w / 2, this.y + this.h / 2);\n    }\n    // Returns edges in the order\n    // [ rightEdge, topEdge, leftEdge, bottomEdge ]\n    getEdges() {\n        const corners = this.corners;\n        return [\n            new LineSegment2(corners[0], corners[1]),\n            new LineSegment2(corners[1], corners[2]),\n            new LineSegment2(corners[2], corners[3]),\n            new LineSegment2(corners[3], corners[0]),\n        ];\n    }\n    intersectsLineSegment(lineSegment) {\n        const result = [];\n        for (const edge of this.getEdges()) {\n            const intersection = edge.intersectsLineSegment(lineSegment);\n            intersection.forEach((point) => result.push(point));\n        }\n        return result;\n    }\n    signedDistance(point) {\n        const closestBoundaryPoint = this.getClosestPointOnBoundaryTo(point);\n        const dist = point.minus(closestBoundaryPoint).magnitude();\n        if (this.containsPoint(point)) {\n            return -dist;\n        }\n        return dist;\n    }\n    getTightBoundingBox() {\n        return this;\n    }\n    // [affineTransform] is a transformation matrix that both scales and **translates**.\n    // the bounding box of this' four corners after transformed by the given affine transformation.\n    transformedBoundingBox(affineTransform) {\n        // Optimize transforming by the identity matrix (a common case).\n        if (affineTransform === Mat33.identity) {\n            return this;\n        }\n        return Rect2.bboxOf(this.corners.map((corner) => affineTransform.transformVec2(corner)));\n    }\n    /** @return true iff this is equal to `other ± tolerance` */\n    eq(other, tolerance = 0) {\n        return this.topLeft.eq(other.topLeft, tolerance) && this.size.eq(other.size, tolerance);\n    }\n    toString() {\n        return `Rect(point(${this.x}, ${this.y}), size(${this.w}, ${this.h}))`;\n    }\n    static fromCorners(corner1, corner2) {\n        return new Rect2(Math.min(corner1.x, corner2.x), Math.min(corner1.y, corner2.y), Math.abs(corner1.x - corner2.x), Math.abs(corner1.y - corner2.y));\n    }\n    // Returns a box that contains all points in [points] with at least [margin]\n    // between each point and the edge of the box.\n    static bboxOf(points, margin = 0) {\n        let minX = 0;\n        let minY = 0;\n        let maxX = 0;\n        let maxY = 0;\n        let isFirst = true;\n        for (const point of points) {\n            if (isFirst) {\n                minX = point.x;\n                minY = point.y;\n                maxX = point.x;\n                maxY = point.y;\n                isFirst = false;\n            }\n            minX = Math.min(minX, point.x);\n            minY = Math.min(minY, point.y);\n            maxX = Math.max(maxX, point.x);\n            maxY = Math.max(maxY, point.y);\n        }\n        return Rect2.fromCorners(Vec2.of(minX - margin, minY - margin), Vec2.of(maxX + margin, maxY + margin));\n    }\n    // @returns a rectangle that contains all of the given rectangles, the bounding box\n    //     of the given rectangles.\n    static union(...rects) {\n        if (rects.length === 0) {\n            return Rect2.empty;\n        }\n        const firstRect = rects[0];\n        let minX = firstRect.x;\n        let minY = firstRect.y;\n        let maxX = firstRect.x + firstRect.w;\n        let maxY = firstRect.y + firstRect.h;\n        for (let i = 1; i < rects.length; i++) {\n            const rect = rects[i];\n            minX = Math.min(minX, rect.x);\n            minY = Math.min(minY, rect.y);\n            maxX = Math.max(maxX, rect.x + rect.w);\n            maxY = Math.max(maxY, rect.y + rect.h);\n        }\n        return new Rect2(minX, minY, maxX - minX, maxY - minY);\n    }\n    static of(template) {\n        const width = template.width ?? template.w ?? 0;\n        const height = template.height ?? template.h ?? 0;\n        return new Rect2(template.x, template.y, width, height);\n    }\n}\nRect2.empty = new Rect2(0, 0, 0, 0);\nRect2.unitSquare = new Rect2(0, 0, 1, 1);\nexport default Rect2;\n","import  { Vec2 }  from '../Vec2.mjs';\n/**\n * Implements Gift Wrapping, in $O(nh)$. This algorithm is not the most efficient in the worst case.\n *\n * See https://en.wikipedia.org/wiki/Gift_wrapping_algorithm\n * and https://www.cs.jhu.edu/~misha/Spring16/06.pdf\n */\nconst convexHull2Of = (points) => {\n    if (points.length === 0) {\n        return [];\n    }\n    // 1. Start with a vertex on the hull\n    const lowestPoint = points.reduce((lowest, current) => (current.y < lowest.y ? current : lowest), points[0]);\n    const vertices = [lowestPoint];\n    let toProcess = [...points.filter((p) => !p.eq(lowestPoint))];\n    let lastBaseDirection = Vec2.of(-1, 0);\n    // 2. Find the point with greatest angle from the vertex:\n    //\n    //  . .     .\n    //   . .   /  <- Notice that **all** other points are to the\n    //       /       **left** of the vector from the current\n    //    ./         vertex to the new point.\n    while (toProcess.length > 0) {\n        const lastVertex = vertices[vertices.length - 1];\n        let smallestDotProductSoFar = lastBaseDirection.dot(lowestPoint.minus(lastVertex).normalizedOrZero());\n        let furthestPointSoFar = lowestPoint;\n        for (const point of toProcess) {\n            // Maximizing the angle is the same as minimizing the dot product:\n            //              point.minus(lastVertex)\n            //             ^\n            //            /\n            //           /\n            //        ϑ /\n            //   <-----. lastBaseDirection\n            const currentDotProduct = lastBaseDirection.dot(point.minus(lastVertex).normalizedOrZero());\n            if (currentDotProduct <= smallestDotProductSoFar) {\n                furthestPointSoFar = point;\n                smallestDotProductSoFar = currentDotProduct;\n            }\n        }\n        toProcess = toProcess.filter((p) => !p.eq(furthestPointSoFar));\n        const newBaseDirection = furthestPointSoFar.minus(lastVertex).normalized();\n        // If the last vertex is on the same edge as the current, there's no need to include\n        // the previous one.\n        if (Math.abs(newBaseDirection.dot(lastBaseDirection)) === 1 && vertices.length > 1) {\n            vertices.pop();\n        }\n        // Stoping condition: We've gone in a full circle.\n        if (furthestPointSoFar.eq(lowestPoint)) {\n            break;\n        }\n        else {\n            vertices.push(furthestPointSoFar);\n            lastBaseDirection = lastVertex.minus(furthestPointSoFar).normalized();\n        }\n    }\n    return vertices;\n};\nexport default convexHull2Of;\n","const Coloris = (() => {\n  /*!\r\n  * Copyright (c) 2021-2023 Momo Bassit.\r\n  * Licensed under the MIT License (MIT)\r\n  * https://github.com/mdbassit/Coloris\r\n  * Version: 0.21.1\r\n  * NPM: https://github.com/melloware/coloris-npm\r\n  */\n\n  return ((window, document, Math, undefined) => {\n    const ctx = document.createElement('canvas').getContext('2d');\n    const currentColor = { r: 0, g: 0, b: 0, h: 0, s: 0, v: 0, a: 1 };\n    let container,picker,colorArea,colorMarker,colorPreview,colorValue,clearButton,closeButton,\n      hueSlider,hueMarker,alphaSlider,alphaMarker,currentEl,currentFormat,oldColor,keyboardNav,\n      colorAreaDims = {};\n\n    // Default settings\n    const settings = {\n      el: '[data-coloris]',\n      parent: 'body',\n      theme: 'default',\n      themeMode: 'light',\n      rtl: false,\n      wrap: true,\n      margin: 2,\n      format: 'hex',\n      formatToggle: false,\n      swatches: [],\n      swatchesOnly: false,\n      alpha: true,\n      forceAlpha: false,\n      focusInput: true,\n      selectInput: false,\n      inline: false,\n      defaultColor: '#000000',\n      clearButton: false,\n      clearLabel: 'Clear',\n      closeButton: false,\n      closeLabel: 'Close',\n      onChange: () => undefined,\n      a11y: {\n        open: 'Open color picker',\n        close: 'Close color picker',\n        clear: 'Clear the selected color',\n        marker: 'Saturation: {s}. Brightness: {v}.',\n        hueSlider: 'Hue slider',\n        alphaSlider: 'Opacity slider',\n        input: 'Color value field',\n        format: 'Color format',\n        swatch: 'Color swatch',\n        instruction: 'Saturation and brightness selector. Use up, down, left and right arrow keys to select.'\n      }\n    };\n\n    // Virtual instances cache\n    const instances = {};\n    let currentInstanceId = '';\n    let defaultInstance = {};\n    let hasInstance = false;\n\n    /**\r\n     * Configure the color picker.\r\n     * @param {object} options Configuration options.\r\n     */\n    function configure(options) {\n      if (typeof options !== 'object') {\n        return;\n      }\n\n      for (const key in options) {\n        switch (key) {\n          case 'el':\n            bindFields(options.el);\n            if (options.wrap !== false) {\n              wrapFields(options.el);\n            }\n            break;\n          case 'parent':\n            container = document.querySelector(options.parent);\n            if (container) {\n              container.appendChild(picker);\n              settings.parent = options.parent;\n\n              // document.body is special\n              if (container === document.body) {\n                container = undefined;\n              }\n            }\n            break;\n          case 'themeMode':\n            settings.themeMode = options.themeMode;\n            if (options.themeMode === 'auto' && window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {\n              settings.themeMode = 'dark';\n            }\n          // The lack of a break statement is intentional\n          case 'theme':\n            if (options.theme) {\n              settings.theme = options.theme;\n            }\n\n            // Set the theme and color scheme\n            picker.className = `clr-picker clr-${settings.theme} clr-${settings.themeMode}`;\n\n            // Update the color picker's position if inline mode is in use\n            if (settings.inline) {\n              updatePickerPosition();\n            }\n            break;\n          case 'rtl':\n            settings.rtl = !!options.rtl;\n            document.querySelectorAll('.clr-field').forEach((field) => field.classList.toggle('clr-rtl', settings.rtl));\n            break;\n          case 'margin':\n            options.margin *= 1;\n            settings.margin = !isNaN(options.margin) ? options.margin : settings.margin;\n            break;\n          case 'wrap':\n            if (options.el && options.wrap) {\n              wrapFields(options.el);\n            }\n            break;\n          case 'formatToggle':\n            settings.formatToggle = !!options.formatToggle;\n            getEl('clr-format').style.display = settings.formatToggle ? 'block' : 'none';\n            if (settings.formatToggle) {\n              settings.format = 'auto';\n            }\n            break;\n          case 'swatches':\n            if (Array.isArray(options.swatches)) {\n              const swatches = [];\n\n              options.swatches.forEach((swatch, i) => {\n                swatches.push(`<button type=\"button\" id=\"clr-swatch-${i}\" aria-labelledby=\"clr-swatch-label clr-swatch-${i}\" style=\"color: ${swatch};\">${swatch}</button>`);\n              });\n\n              getEl('clr-swatches').innerHTML = swatches.length ? `<div>${swatches.join('')}</div>` : '';\n              settings.swatches = options.swatches.slice();\n            }\n            break;\n          case 'swatchesOnly':\n            settings.swatchesOnly = !!options.swatchesOnly;\n            picker.setAttribute('data-minimal', settings.swatchesOnly);\n            break;\n          case 'alpha':\n            settings.alpha = !!options.alpha;\n            picker.setAttribute('data-alpha', settings.alpha);\n            break;\n          case 'inline':\n            settings.inline = !!options.inline;\n            picker.setAttribute('data-inline', settings.inline);\n\n            if (settings.inline) {\n              const defaultColor = options.defaultColor || settings.defaultColor;\n\n              currentFormat = getColorFormatFromStr(defaultColor);\n              updatePickerPosition();\n              setColorFromStr(defaultColor);\n            }\n            break;\n          case 'clearButton':\n            // Backward compatibility\n            if (typeof options.clearButton === 'object') {\n              if (options.clearButton.label) {\n                settings.clearLabel = options.clearButton.label;\n                clearButton.innerHTML = settings.clearLabel;\n              }\n\n              options.clearButton = options.clearButton.show;\n            }\n\n            settings.clearButton = !!options.clearButton;\n            clearButton.style.display = settings.clearButton ? 'block' : 'none';\n            break;\n          case 'clearLabel':\n            settings.clearLabel = options.clearLabel;\n            clearButton.innerHTML = settings.clearLabel;\n            break;\n          case 'closeButton':\n            settings.closeButton = !!options.closeButton;\n\n            if (settings.closeButton) {\n              picker.insertBefore(closeButton, colorPreview);\n            } else {\n              colorPreview.appendChild(closeButton);\n            }\n\n            break;\n          case 'closeLabel':\n            settings.closeLabel = options.closeLabel;\n            closeButton.innerHTML = settings.closeLabel;\n            break;\n          case 'a11y':\n            const labels = options.a11y;\n            let update = false;\n\n            if (typeof labels === 'object') {\n              for (const label in labels) {\n                if (labels[label] && settings.a11y[label]) {\n                  settings.a11y[label] = labels[label];\n                  update = true;\n                }\n              }\n            }\n\n            if (update) {\n              const openLabel = getEl('clr-open-label');\n              const swatchLabel = getEl('clr-swatch-label');\n\n              openLabel.innerHTML = settings.a11y.open;\n              swatchLabel.innerHTML = settings.a11y.swatch;\n              closeButton.setAttribute('aria-label', settings.a11y.close);\n              clearButton.setAttribute('aria-label', settings.a11y.clear);\n              hueSlider.setAttribute('aria-label', settings.a11y.hueSlider);\n              alphaSlider.setAttribute('aria-label', settings.a11y.alphaSlider);\n              colorValue.setAttribute('aria-label', settings.a11y.input);\n              colorArea.setAttribute('aria-label', settings.a11y.instruction);\n            }\n            break;\n          default:\n            settings[key] = options[key];\n        }\n      }\n    }\n\n    /**\r\n     * Add or update a virtual instance.\r\n     * @param {String} selector The CSS selector of the elements to which the instance is attached.\r\n     * @param {Object} options Per-instance options to apply.\r\n     */\n    function setVirtualInstance(selector, options) {\n      if (typeof selector === 'string' && typeof options === 'object') {\n        instances[selector] = options;\n        hasInstance = true;\n      }\n    }\n\n    /**\r\n     * Remove a virtual instance.\r\n     * @param {String} selector The CSS selector of the elements to which the instance is attached.\r\n     */\n    function removeVirtualInstance(selector) {\n      delete instances[selector];\n\n      if (Object.keys(instances).length === 0) {\n        hasInstance = false;\n\n        if (selector === currentInstanceId) {\n          resetVirtualInstance();\n        }\n      }\n    }\n\n    /**\r\n     * Attach a virtual instance to an element if it matches a selector.\r\n     * @param {Object} element Target element that will receive a virtual instance if applicable.\r\n     */\n    function attachVirtualInstance(element) {\n      if (hasInstance) {\n        // These options can only be set globally, not per instance\n        const unsupportedOptions = ['el', 'wrap', 'rtl', 'inline', 'defaultColor', 'a11y'];\n\n        for (let selector in instances) {\n          const options = instances[selector];\n\n          // If the element matches an instance's CSS selector\n          if (element.matches(selector)) {\n            currentInstanceId = selector;\n            defaultInstance = {};\n\n            // Delete unsupported options\n            unsupportedOptions.forEach((option) => delete options[option]);\n\n            // Back up the default options so we can restore them later\n            for (let option in options) {\n              defaultInstance[option] = Array.isArray(settings[option]) ? settings[option].slice() : settings[option];\n            }\n\n            // Set the instance's options\n            configure(options);\n            break;\n          }\n        }\n      }\n    }\n\n    /**\r\n     * Revert any per-instance options that were previously applied.\r\n     */\n    function resetVirtualInstance() {\n      if (Object.keys(defaultInstance).length > 0) {\n        configure(defaultInstance);\n        currentInstanceId = '';\n        defaultInstance = {};\n      }\n    }\n\n    /**\r\n     * Bind the color picker to input fields that match the selector.\r\n     * @param {string} selector One or more selectors pointing to input fields.\r\n     */\n    function bindFields(selector) {\n      // Show the color picker on click on the input fields that match the selector\n      addListener(document, 'click', selector, (event) => {\n        // Skip if inline mode is in use\n        if (settings.inline) {\n          return;\n        }\n\n        // Apply any per-instance options first\n        attachVirtualInstance(event.target);\n\n        currentEl = event.target;\n        oldColor = currentEl.value;\n        currentFormat = getColorFormatFromStr(oldColor);\n        picker.classList.add('clr-open');\n\n        updatePickerPosition();\n        setColorFromStr(oldColor);\n\n        if (settings.focusInput || settings.selectInput) {\n          colorValue.focus({ preventScroll: true });\n          colorValue.setSelectionRange(currentEl.selectionStart, currentEl.selectionEnd);\n        }\n\n        if (settings.selectInput) {\n          colorValue.select();\n        }\n\n        // Always focus the first element when using keyboard navigation\n        if (keyboardNav || settings.swatchesOnly) {\n          getFocusableElements().shift().focus();\n        }\n\n        // Trigger an \"open\" event\n        currentEl.dispatchEvent(new Event('open', { bubbles: true }));\n      });\n\n      // Update the color preview of the input fields that match the selector\n      addListener(document, 'input', selector, (event) => {\n        const parent = event.target.parentNode;\n\n        // Only update the preview if the field has been previously wrapped\n        if (parent.classList.contains('clr-field')) {\n          parent.style.color = event.target.value;\n        }\n      });\n    }\n\n    /**\r\n     * Update the color picker's position and the color gradient's offset\r\n     */\n    function updatePickerPosition() {\n      if (!picker || !currentEl && !settings.inline) return; //** DO NOT REMOVE: in case called before initialized\n      const parent = container;\n      const scrollY = window.scrollY;\n      const pickerWidth = picker.offsetWidth;\n      const pickerHeight = picker.offsetHeight;\n      const reposition = { left: false, top: false };\n      let parentStyle, parentMarginTop, parentBorderTop;\n      let offset = { x: 0, y: 0 };\n\n      if (parent) {\n        parentStyle = window.getComputedStyle(parent);\n        parentMarginTop = parseFloat(parentStyle.marginTop);\n        parentBorderTop = parseFloat(parentStyle.borderTopWidth);\n\n        offset = parent.getBoundingClientRect();\n        offset.y += parentBorderTop + scrollY;\n      }\n\n      if (!settings.inline) {\n        const coords = currentEl.getBoundingClientRect();\n        let left = coords.x;\n        let top = scrollY + coords.y + coords.height + settings.margin;\n\n        // If the color picker is inside a custom container\n        // set the position relative to it\n        if (parent) {\n          left -= offset.x;\n          top -= offset.y;\n\n          if (left + pickerWidth > parent.clientWidth) {\n            left += coords.width - pickerWidth;\n            reposition.left = true;\n          }\n\n          if (top + pickerHeight > parent.clientHeight - parentMarginTop) {\n            if (pickerHeight + settings.margin <= coords.top - (offset.y - scrollY)) {\n              top -= coords.height + pickerHeight + settings.margin * 2;\n              reposition.top = true;\n            }\n          }\n\n          top += parent.scrollTop;\n\n          // Otherwise set the position relative to the whole document\n        } else {\n          if (left + pickerWidth > document.documentElement.clientWidth) {\n            left += coords.width - pickerWidth;\n            reposition.left = true;\n          }\n\n          if (top + pickerHeight - scrollY > document.documentElement.clientHeight) {\n            if (pickerHeight + settings.margin <= coords.top) {\n              top = scrollY + coords.y - pickerHeight - settings.margin;\n              reposition.top = true;\n            }\n          }\n        }\n\n        picker.classList.toggle('clr-left', reposition.left);\n        picker.classList.toggle('clr-top', reposition.top);\n        picker.style.left = `${left}px`;\n        picker.style.top = `${top}px`;\n        offset.x += picker.offsetLeft;\n        offset.y += picker.offsetTop;\n      }\n\n      colorAreaDims = {\n        width: colorArea.offsetWidth,\n        height: colorArea.offsetHeight,\n        x: colorArea.offsetLeft + offset.x,\n        y: colorArea.offsetTop + offset.y\n      };\n    }\n\n    /**\r\n     * Wrap the linked input fields in a div that adds a color preview.\r\n     * @param {string} selector One or more selectors pointing to input fields.\r\n     */\n    function wrapFields(selector) {\n      document.querySelectorAll(selector).forEach((field) => {\n        const parentNode = field.parentNode;\n\n        if (!parentNode.classList.contains('clr-field')) {\n          const wrapper = document.createElement('div');\n          let classes = 'clr-field';\n\n          if (settings.rtl || field.classList.contains('clr-rtl')) {\n            classes += ' clr-rtl';\n          }\n\n          wrapper.innerHTML = `<button type=\"button\" aria-labelledby=\"clr-open-label\"></button>`;\n          parentNode.insertBefore(wrapper, field);\n          wrapper.setAttribute('class', classes);\n          wrapper.style.color = field.value;\n          wrapper.appendChild(field);\n        }\n      });\n    }\n\n    /**\r\n     * Close the color picker.\r\n     * @param {boolean} [revert] If true, revert the color to the original value.\r\n     */\n    function closePicker(revert) {\n      if (currentEl && !settings.inline) {\n        const prevEl = currentEl;\n\n        // Revert the color to the original value if needed\n        if (revert) {\n          // This will prevent the \"change\" event on the colorValue input to execute its handler\n          currentEl = undefined;\n\n          if (oldColor !== prevEl.value) {\n            prevEl.value = oldColor;\n\n            // Trigger an \"input\" event to force update the thumbnail next to the input field\n            prevEl.dispatchEvent(new Event('input', { bubbles: true }));\n          }\n        }\n\n        // Trigger a \"change\" event if needed\n        setTimeout(() => {// Add this to the end of the event loop\n          if (oldColor !== prevEl.value) {\n            prevEl.dispatchEvent(new Event('change', { bubbles: true }));\n          }\n        });\n\n        // Hide the picker dialog\n        picker.classList.remove('clr-open');\n\n        // Reset any previously set per-instance options\n        if (hasInstance) {\n          resetVirtualInstance();\n        }\n\n        // Trigger a \"close\" event\n        prevEl.dispatchEvent(new Event('close', { bubbles: true }));\n\n        if (settings.focusInput) {\n          prevEl.focus({ preventScroll: true });\n        }\n\n        // This essentially marks the picker as closed\n        currentEl = undefined;\n      }\n    }\n\n    /**\r\n     * Set the active color from a string.\r\n     * @param {string} str String representing a color.\r\n     */\n    function setColorFromStr(str) {\n      const rgba = strToRGBA(str);\n      const hsva = RGBAtoHSVA(rgba);\n\n      updateMarkerA11yLabel(hsva.s, hsva.v);\n      updateColor(rgba, hsva);\n\n      // Update the UI\n      hueSlider.value = hsva.h;\n      picker.style.color = `hsl(${hsva.h}, 100%, 50%)`;\n      hueMarker.style.left = `${hsva.h / 360 * 100}%`;\n\n      colorMarker.style.left = `${colorAreaDims.width * hsva.s / 100}px`;\n      colorMarker.style.top = `${colorAreaDims.height - colorAreaDims.height * hsva.v / 100}px`;\n\n      alphaSlider.value = hsva.a * 100;\n      alphaMarker.style.left = `${hsva.a * 100}%`;\n    }\n\n    /**\r\n     * Guess the color format from a string.\r\n     * @param {string} str String representing a color.\r\n     * @return {string} The color format.\r\n     */\n    function getColorFormatFromStr(str) {\n      const format = str.substring(0, 3).toLowerCase();\n\n      if (format === 'rgb' || format === 'hsl') {\n        return format;\n      }\n\n      return 'hex';\n    }\n\n    /**\r\n     * Copy the active color to the linked input field.\r\n     * @param {number} [color] Color value to override the active color.\r\n     */\n    function pickColor(color) {\n      color = color !== undefined ? color : colorValue.value;\n\n      if (currentEl) {\n        currentEl.value = color;\n        currentEl.dispatchEvent(new Event('input', { bubbles: true }));\n      }\n\n      if (settings.onChange) {\n        settings.onChange.call(window, color, currentEl);\n      }\n\n      document.dispatchEvent(new CustomEvent('coloris:pick', { detail: { color, currentEl } }));\n    }\n\n    /**\r\n     * Set the active color based on a specific point in the color gradient.\r\n     * @param {number} x Left position.\r\n     * @param {number} y Top position.\r\n     */\n    function setColorAtPosition(x, y) {\n      const hsva = {\n        h: hueSlider.value * 1,\n        s: x / colorAreaDims.width * 100,\n        v: 100 - y / colorAreaDims.height * 100,\n        a: alphaSlider.value / 100\n      };\n      const rgba = HSVAtoRGBA(hsva);\n\n      updateMarkerA11yLabel(hsva.s, hsva.v);\n      updateColor(rgba, hsva);\n      pickColor();\n    }\n\n    /**\r\n     * Update the color marker's accessibility label.\r\n     * @param {number} saturation\r\n     * @param {number} value\r\n     */\n    function updateMarkerA11yLabel(saturation, value) {\n      let label = settings.a11y.marker;\n\n      saturation = saturation.toFixed(1) * 1;\n      value = value.toFixed(1) * 1;\n      label = label.replace('{s}', saturation);\n      label = label.replace('{v}', value);\n      colorMarker.setAttribute('aria-label', label);\n    }\n\n    //\n    /**\r\n     * Get the pageX and pageY positions of the pointer.\r\n     * @param {object} event The MouseEvent or TouchEvent object.\r\n     * @return {object} The pageX and pageY positions.\r\n     */\n    function getPointerPosition(event) {\n      return {\n        pageX: event.changedTouches ? event.changedTouches[0].pageX : event.pageX,\n        pageY: event.changedTouches ? event.changedTouches[0].pageY : event.pageY\n      };\n    }\n\n    /**\r\n     * Move the color marker when dragged.\r\n     * @param {object} event The MouseEvent object.\r\n     */\n    function moveMarker(event) {\n      const pointer = getPointerPosition(event);\n      let x = pointer.pageX - colorAreaDims.x;\n      let y = pointer.pageY - colorAreaDims.y;\n\n      if (container) {\n        y += container.scrollTop;\n      }\n\n      setMarkerPosition(x, y);\n\n      // Prevent scrolling while dragging the marker\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    /**\r\n     * Move the color marker when the arrow keys are pressed.\r\n     * @param {number} offsetX The horizontal amount to move.\r\n     * @param {number} offsetY The vertical amount to move.\r\n     */\n    function moveMarkerOnKeydown(offsetX, offsetY) {\n      let x = colorMarker.style.left.replace('px', '') * 1 + offsetX;\n      let y = colorMarker.style.top.replace('px', '') * 1 + offsetY;\n\n      setMarkerPosition(x, y);\n    }\n\n    /**\r\n     * Set the color marker's position.\r\n     * @param {number} x Left position.\r\n     * @param {number} y Top position.\r\n     */\n    function setMarkerPosition(x, y) {\n      // Make sure the marker doesn't go out of bounds\n      x = x < 0 ? 0 : x > colorAreaDims.width ? colorAreaDims.width : x;\n      y = y < 0 ? 0 : y > colorAreaDims.height ? colorAreaDims.height : y;\n\n      // Set the position\n      colorMarker.style.left = `${x}px`;\n      colorMarker.style.top = `${y}px`;\n\n      // Update the color\n      setColorAtPosition(x, y);\n\n      // Make sure the marker is focused\n      colorMarker.focus();\n    }\n\n    /**\r\n     * Update the color picker's input field and preview thumb.\r\n     * @param {Object} rgba Red, green, blue and alpha values.\r\n     * @param {Object} [hsva] Hue, saturation, value and alpha values.\r\n     */\n    function updateColor(rgba, hsva) {if (rgba === void 0) {rgba = {};}if (hsva === void 0) {hsva = {};}\n      let format = settings.format;\n\n      for (const key in rgba) {\n        currentColor[key] = rgba[key];\n      }\n\n      for (const key in hsva) {\n        currentColor[key] = hsva[key];\n      }\n\n      const hex = RGBAToHex(currentColor);\n      const opaqueHex = hex.substring(0, 7);\n\n      colorMarker.style.color = opaqueHex;\n      alphaMarker.parentNode.style.color = opaqueHex;\n      alphaMarker.style.color = hex;\n      colorPreview.style.color = hex;\n\n      // Force repaint the color and alpha gradients as a workaround for a Google Chrome bug\n      colorArea.style.display = 'none';\n      colorArea.offsetHeight;\n      colorArea.style.display = '';\n      alphaMarker.nextElementSibling.style.display = 'none';\n      alphaMarker.nextElementSibling.offsetHeight;\n      alphaMarker.nextElementSibling.style.display = '';\n\n      if (format === 'mixed') {\n        format = currentColor.a === 1 ? 'hex' : 'rgb';\n      } else if (format === 'auto') {\n        format = currentFormat;\n      }\n\n      switch (format) {\n        case 'hex':\n          colorValue.value = hex;\n          break;\n        case 'rgb':\n          colorValue.value = RGBAToStr(currentColor);\n          break;\n        case 'hsl':\n          colorValue.value = HSLAToStr(HSVAtoHSLA(currentColor));\n          break;\n      }\n\n      // Select the current format in the format switcher\n      document.querySelector(`.clr-format [value=\"${format}\"]`).checked = true;\n    }\n\n    /**\r\n     * Set the hue when its slider is moved.\r\n     */\n    function setHue() {\n      const hue = hueSlider.value * 1;\n      const x = colorMarker.style.left.replace('px', '') * 1;\n      const y = colorMarker.style.top.replace('px', '') * 1;\n\n      picker.style.color = `hsl(${hue}, 100%, 50%)`;\n      hueMarker.style.left = `${hue / 360 * 100}%`;\n\n      setColorAtPosition(x, y);\n    }\n\n    /**\r\n     * Set the alpha when its slider is moved.\r\n     */\n    function setAlpha() {\n      const alpha = alphaSlider.value / 100;\n\n      alphaMarker.style.left = `${alpha * 100}%`;\n      updateColor({ a: alpha });\n      pickColor();\n    }\n\n    /**\r\n     * Convert HSVA to RGBA.\r\n     * @param {object} hsva Hue, saturation, value and alpha values.\r\n     * @return {object} Red, green, blue and alpha values.\r\n     */\n    function HSVAtoRGBA(hsva) {\n      const saturation = hsva.s / 100;\n      const value = hsva.v / 100;\n      let chroma = saturation * value;\n      let hueBy60 = hsva.h / 60;\n      let x = chroma * (1 - Math.abs(hueBy60 % 2 - 1));\n      let m = value - chroma;\n\n      chroma = chroma + m;\n      x = x + m;\n\n      const index = Math.floor(hueBy60) % 6;\n      const red = [chroma, x, m, m, x, chroma][index];\n      const green = [x, chroma, chroma, x, m, m][index];\n      const blue = [m, m, x, chroma, chroma, x][index];\n\n      return {\n        r: Math.round(red * 255),\n        g: Math.round(green * 255),\n        b: Math.round(blue * 255),\n        a: hsva.a\n      };\n    }\n\n    /**\r\n     * Convert HSVA to HSLA.\r\n     * @param {object} hsva Hue, saturation, value and alpha values.\r\n     * @return {object} Hue, saturation, lightness and alpha values.\r\n     */\n    function HSVAtoHSLA(hsva) {\n      const value = hsva.v / 100;\n      const lightness = value * (1 - hsva.s / 100 / 2);\n      let saturation;\n\n      if (lightness > 0 && lightness < 1) {\n        saturation = Math.round((value - lightness) / Math.min(lightness, 1 - lightness) * 100);\n      }\n\n      return {\n        h: hsva.h,\n        s: saturation || 0,\n        l: Math.round(lightness * 100),\n        a: hsva.a\n      };\n    }\n\n    /**\r\n     * Convert RGBA to HSVA.\r\n     * @param {object} rgba Red, green, blue and alpha values.\r\n     * @return {object} Hue, saturation, value and alpha values.\r\n     */\n    function RGBAtoHSVA(rgba) {\n      const red = rgba.r / 255;\n      const green = rgba.g / 255;\n      const blue = rgba.b / 255;\n      const xmax = Math.max(red, green, blue);\n      const xmin = Math.min(red, green, blue);\n      const chroma = xmax - xmin;\n      const value = xmax;\n      let hue = 0;\n      let saturation = 0;\n\n      if (chroma) {\n        if (xmax === red) {hue = (green - blue) / chroma;}\n        if (xmax === green) {hue = 2 + (blue - red) / chroma;}\n        if (xmax === blue) {hue = 4 + (red - green) / chroma;}\n        if (xmax) {saturation = chroma / xmax;}\n      }\n\n      hue = Math.floor(hue * 60);\n\n      return {\n        h: hue < 0 ? hue + 360 : hue,\n        s: Math.round(saturation * 100),\n        v: Math.round(value * 100),\n        a: rgba.a\n      };\n    }\n\n    /**\r\n     * Parse a string to RGBA.\r\n     * @param {string} str String representing a color.\r\n     * @return {object} Red, green, blue and alpha values.\r\n     */\n    function strToRGBA(str) {\n      const regex = /^((rgba)|rgb)[\\D]+([\\d.]+)[\\D]+([\\d.]+)[\\D]+([\\d.]+)[\\D]*?([\\d.]+|$)/i;\n      let match, rgba;\n\n      // Default to black for invalid color strings\n      ctx.fillStyle = '#000';\n\n      // Use canvas to convert the string to a valid color string\n      ctx.fillStyle = str;\n      match = regex.exec(ctx.fillStyle);\n\n      if (match) {\n        rgba = {\n          r: match[3] * 1,\n          g: match[4] * 1,\n          b: match[5] * 1,\n          a: match[6] * 1\n        };\n\n        // Workaround to mitigate a Chromium bug where the alpha value is rounded incorrectly\n        rgba.a = +rgba.a.toFixed(2);\n\n      } else {\n        match = ctx.fillStyle.replace('#', '').match(/.{2}/g).map((h) => parseInt(h, 16));\n        rgba = {\n          r: match[0],\n          g: match[1],\n          b: match[2],\n          a: 1\n        };\n      }\n\n      return rgba;\n    }\n\n    /**\r\n     * Convert RGBA to Hex.\r\n     * @param {object} rgba Red, green, blue and alpha values.\r\n     * @return {string} Hex color string.\r\n     */\n    function RGBAToHex(rgba) {\n      let R = rgba.r.toString(16);\n      let G = rgba.g.toString(16);\n      let B = rgba.b.toString(16);\n      let A = '';\n\n      if (rgba.r < 16) {\n        R = '0' + R;\n      }\n\n      if (rgba.g < 16) {\n        G = '0' + G;\n      }\n\n      if (rgba.b < 16) {\n        B = '0' + B;\n      }\n\n      if (settings.alpha && (rgba.a < 1 || settings.forceAlpha)) {\n        const alpha = rgba.a * 255 | 0;\n        A = alpha.toString(16);\n\n        if (alpha < 16) {\n          A = '0' + A;\n        }\n      }\n\n      return '#' + R + G + B + A;\n    }\n\n    /**\r\n     * Convert RGBA values to a CSS rgb/rgba string.\r\n     * @param {object} rgba Red, green, blue and alpha values.\r\n     * @return {string} CSS color string.\r\n     */\n    function RGBAToStr(rgba) {\n      if (!settings.alpha || rgba.a === 1 && !settings.forceAlpha) {\n        return `rgb(${rgba.r}, ${rgba.g}, ${rgba.b})`;\n      } else {\n        return `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`;\n      }\n    }\n\n    /**\r\n     * Convert HSLA values to a CSS hsl/hsla string.\r\n     * @param {object} hsla Hue, saturation, lightness and alpha values.\r\n     * @return {string} CSS color string.\r\n     */\n    function HSLAToStr(hsla) {\n      if (!settings.alpha || hsla.a === 1 && !settings.forceAlpha) {\n        return `hsl(${hsla.h}, ${hsla.s}%, ${hsla.l}%)`;\n      } else {\n        return `hsla(${hsla.h}, ${hsla.s}%, ${hsla.l}%, ${hsla.a})`;\n      }\n    }\n\n    /**\r\n     * Init the color picker.\r\n     */\n    function init() {\n      if (document.getElementById('clr-picker')) return; //** DO NOT REMOVE: Prevent binding events multiple times\n      // Render the UI\n      container = undefined;\n      picker = document.createElement('div');\n      picker.setAttribute('id', 'clr-picker');\n      picker.className = 'clr-picker';\n      picker.innerHTML =\n      `<input id=\"clr-color-value\" name=\"clr-color-value\" class=\"clr-color\" type=\"text\" value=\"\" spellcheck=\"false\" aria-label=\"${settings.a11y.input}\">` +\n      `<div id=\"clr-color-area\" class=\"clr-gradient\" role=\"application\" aria-label=\"${settings.a11y.instruction}\">` +\n      '<div id=\"clr-color-marker\" class=\"clr-marker\" tabindex=\"0\"></div>' +\n      '</div>' +\n      '<div class=\"clr-hue\">' +\n      `<input id=\"clr-hue-slider\" name=\"clr-hue-slider\" type=\"range\" min=\"0\" max=\"360\" step=\"1\" aria-label=\"${settings.a11y.hueSlider}\">` +\n      '<div id=\"clr-hue-marker\"></div>' +\n      '</div>' +\n      '<div class=\"clr-alpha\">' +\n      `<input id=\"clr-alpha-slider\" name=\"clr-alpha-slider\" type=\"range\" min=\"0\" max=\"100\" step=\"1\" aria-label=\"${settings.a11y.alphaSlider}\">` +\n      '<div id=\"clr-alpha-marker\"></div>' +\n      '<span></span>' +\n      '</div>' +\n      '<div id=\"clr-format\" class=\"clr-format\">' +\n      '<fieldset class=\"clr-segmented\">' +\n      `<legend>${settings.a11y.format}</legend>` +\n      '<input id=\"clr-f1\" type=\"radio\" name=\"clr-format\" value=\"hex\">' +\n      '<label for=\"clr-f1\">Hex</label>' +\n      '<input id=\"clr-f2\" type=\"radio\" name=\"clr-format\" value=\"rgb\">' +\n      '<label for=\"clr-f2\">RGB</label>' +\n      '<input id=\"clr-f3\" type=\"radio\" name=\"clr-format\" value=\"hsl\">' +\n      '<label for=\"clr-f3\">HSL</label>' +\n      '<span></span>' +\n      '</fieldset>' +\n      '</div>' +\n      '<div id=\"clr-swatches\" class=\"clr-swatches\"></div>' +\n      `<button type=\"button\" id=\"clr-clear\" class=\"clr-clear\" aria-label=\"${settings.a11y.clear}\">${settings.clearLabel}</button>` +\n      '<div id=\"clr-color-preview\" class=\"clr-preview\">' +\n      `<button type=\"button\" id=\"clr-close\" class=\"clr-close\" aria-label=\"${settings.a11y.close}\">${settings.closeLabel}</button>` +\n      '</div>' +\n      `<span id=\"clr-open-label\" hidden>${settings.a11y.open}</span>` +\n      `<span id=\"clr-swatch-label\" hidden>${settings.a11y.swatch}</span>`;\n\n      // Append the color picker to the DOM\n      document.body.appendChild(picker);\n\n      // Reference the UI elements\n      colorArea = getEl('clr-color-area');\n      colorMarker = getEl('clr-color-marker');\n      clearButton = getEl('clr-clear');\n      closeButton = getEl('clr-close');\n      colorPreview = getEl('clr-color-preview');\n      colorValue = getEl('clr-color-value');\n      hueSlider = getEl('clr-hue-slider');\n      hueMarker = getEl('clr-hue-marker');\n      alphaSlider = getEl('clr-alpha-slider');\n      alphaMarker = getEl('clr-alpha-marker');\n\n      // Bind the picker to the default selector\n      bindFields(settings.el);\n      wrapFields(settings.el);\n\n      addListener(picker, 'mousedown', (event) => {\n        picker.classList.remove('clr-keyboard-nav');\n        event.stopPropagation();\n      });\n\n      addListener(colorArea, 'mousedown', (event) => {\n        addListener(document, 'mousemove', moveMarker);\n      });\n\n      addListener(colorArea, 'touchstart', (event) => {\n        document.addEventListener('touchmove', moveMarker, { passive: false });\n      });\n\n      addListener(colorMarker, 'mousedown', (event) => {\n        addListener(document, 'mousemove', moveMarker);\n      });\n\n      addListener(colorMarker, 'touchstart', (event) => {\n        document.addEventListener('touchmove', moveMarker, { passive: false });\n      });\n\n      addListener(colorValue, 'change', (event) => {\n        const value = colorValue.value;\n\n        if (currentEl || settings.inline) {\n          const color = value === '' ? value : setColorFromStr(value);\n          pickColor(color);\n        }\n      });\n\n      addListener(clearButton, 'click', (event) => {\n        pickColor('');\n        closePicker();\n      });\n\n      addListener(closeButton, 'click', (event) => {\n        pickColor();\n        closePicker();\n      });\n\n      addListener(getEl('clr-format'), 'click', '.clr-format input', (event) => {\n        currentFormat = event.target.value;\n        updateColor();\n        pickColor();\n      });\n\n      addListener(picker, 'click', '.clr-swatches button', (event) => {\n        setColorFromStr(event.target.textContent);\n        pickColor();\n\n        if (settings.swatchesOnly) {\n          closePicker();\n        }\n      });\n\n      addListener(document, 'mouseup', (event) => {\n        document.removeEventListener('mousemove', moveMarker);\n      });\n\n      addListener(document, 'touchend', (event) => {\n        document.removeEventListener('touchmove', moveMarker);\n      });\n\n      addListener(document, 'mousedown', (event) => {\n        keyboardNav = false;\n        picker.classList.remove('clr-keyboard-nav');\n        closePicker();\n      });\n\n      addListener(document, 'keydown', (event) => {\n        const key = event.key;\n        const target = event.target;\n        const shiftKey = event.shiftKey;\n        const navKeys = ['Tab', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];\n\n        if (key === 'Escape') {\n          closePicker(true);\n\n          // Display focus rings when using the keyboard\n        } else if (navKeys.includes(key)) {\n          keyboardNav = true;\n          picker.classList.add('clr-keyboard-nav');\n        }\n\n        // Trap the focus within the color picker while it's open\n        if (key === 'Tab' && target.matches('.clr-picker *')) {\n          const focusables = getFocusableElements();\n          const firstFocusable = focusables.shift();\n          const lastFocusable = focusables.pop();\n\n          if (shiftKey && target === firstFocusable) {\n            lastFocusable.focus();\n            event.preventDefault();\n          } else if (!shiftKey && target === lastFocusable) {\n            firstFocusable.focus();\n            event.preventDefault();\n          }\n        }\n      });\n\n      addListener(document, 'click', '.clr-field button', (event) => {\n        // Reset any previously set per-instance options\n        if (hasInstance) {\n          resetVirtualInstance();\n        }\n\n        // Open the color picker\n        event.target.nextElementSibling.dispatchEvent(new Event('click', { bubbles: true }));\n      });\n\n      addListener(colorMarker, 'keydown', (event) => {\n        const movements = {\n          ArrowUp: [0, -1],\n          ArrowDown: [0, 1],\n          ArrowLeft: [-1, 0],\n          ArrowRight: [1, 0]\n        };\n\n        if (Object.keys(movements).includes(event.key)) {\n          moveMarkerOnKeydown(...movements[event.key]);\n          event.preventDefault();\n        }\n      });\n\n      addListener(colorArea, 'click', moveMarker);\n      addListener(hueSlider, 'input', setHue);\n      addListener(alphaSlider, 'input', setAlpha);\n    }\n\n    /**\r\n     * Return a list of focusable elements within the color picker.\r\n     * @return {array} The list of focusable DOM elemnts.\r\n     */\n    function getFocusableElements() {\n      const controls = Array.from(picker.querySelectorAll('input, button'));\n      const focusables = controls.filter((node) => !!node.offsetWidth);\n\n      return focusables;\n    }\n\n    /**\r\n     * Shortcut for getElementById to optimize the minified JS.\r\n     * @param {string} id The element id.\r\n     * @return {object} The DOM element with the provided id.\r\n     */\n    function getEl(id) {\n      return document.getElementById(id);\n    }\n\n    /**\r\n     * Shortcut for addEventListener to optimize the minified JS.\r\n     * @param {object} context The context to which the listener is attached.\r\n     * @param {string} type Event type.\r\n     * @param {(string|function)} selector Event target if delegation is used, event handler if not.\r\n     * @param {function} [fn] Event handler if delegation is used.\r\n     */\n    function addListener(context, type, selector, fn) {\n      const matches = Element.prototype.matches || Element.prototype.msMatchesSelector;\n\n      // Delegate event to the target of the selector\n      if (typeof selector === 'string') {\n        context.addEventListener(type, (event) => {\n          if (matches.call(event.target, selector)) {\n            fn.call(event.target, event);\n          }\n        });\n\n        // If the selector is not a string then it's a function\n        // in which case we need a regular event listener\n      } else {\n        fn = selector;\n        context.addEventListener(type, fn);\n      }\n    }\n\n    /**\r\n     * Call a function only when the DOM is ready.\r\n     * @param {function} fn The function to call.\r\n     * @param {array} [args] Arguments to pass to the function.\r\n     */\n    function DOMReady(fn, args) {\n      args = args !== undefined ? args : [];\n\n      if (document.readyState !== 'loading') {\n        fn(...args);\n      } else {\n        document.addEventListener('DOMContentLoaded', () => {\n          fn(...args);\n        });\n      }\n    }\n\n    // Polyfill for Nodelist.forEach\n    if (NodeList !== undefined && NodeList.prototype && !NodeList.prototype.forEach) {\n      NodeList.prototype.forEach = Array.prototype.forEach;\n    }\n\n    //*****************************************************\n    //******* NPM: Custom code starts here ****************\n    //*****************************************************\n\n    /**\r\n     * Copy the active color to the linked input field and set the color.\r\n     * @param {string} [color] Color value to override the active color.\r\n     * @param {HTMLelement} [target] the element setting the color on\r\n     */\n    function setColor(color, target) {\n      currentEl = target;\n      oldColor = currentEl.value;\n      attachVirtualInstance(target);\n      currentFormat = getColorFormatFromStr(color);\n      updatePickerPosition();\n      setColorFromStr(color);\n      pickColor();\n      if (oldColor !== color) {\n        currentEl.dispatchEvent(new Event('change', { bubbles: true }));\n      }\n    }\n\n    // Expose the color picker to the global scope\n    const Coloris = (() => {\n      const methods = {\n        init: init,\n        set: configure,\n        wrap: wrapFields,\n        close: closePicker,\n        setInstance: setVirtualInstance,\n        setColor: setColor,\n        removeInstance: removeVirtualInstance,\n        updatePosition: updatePickerPosition,\n        ready: DOMReady\n      };\n\n      function Coloris(options) {\n        DOMReady(() => {\n          if (options) {\n            if (typeof options === 'string') {\n              bindFields(options);\n            } else {\n              configure(options);\n            }\n          }\n        });\n      }\n\n      for (const key in methods) {\n        Coloris[key] = function () {for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}\n          DOMReady(methods[key], args);\n        };\n      }\n\n      // handle window resize events re-aligning the panel\n      DOMReady(() => {\n        window.addEventListener('resize', (event) => {Coloris.updatePosition();});\n        window.addEventListener('scroll', (event) => {Coloris.updatePosition();});\n      });\n\n      return Coloris;\n    })();\n\n    // Ensure init function is available not only as as a default import\n    Coloris.coloris = Coloris;\n\n    // Init the color picker when the DOM is ready\n    return Coloris;\n\n  })(window, document, Math);\n})();\n\nconst _coloris = Coloris.coloris;\nconst _init = Coloris.init;\nconst _set = Coloris.set;\nconst _wrap = Coloris.wrap;\nconst _close = Coloris.close;\nconst _setInstance = Coloris.setInstance;\nconst _removeInstance = Coloris.removeInstance;\nconst _updatePosition = Coloris.updatePosition;\nexport default Coloris;\nexport {\n  _coloris as coloris,\n  _close as close,\n  _init as init,\n  _set as set,\n  _wrap as wrap,\n  _setInstance as setInstance,\n  _removeInstance as removeInstance,\n  _updatePosition as updatePosition };","/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\nimport { utils } from \"./utils.js\";\nimport { PolyBezier } from \"./poly-bezier.js\";\n\n// math-inlining.\nconst { abs, min, max, cos, sin, acos, sqrt } = Math;\nconst pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nconst ZERO = { x: 0, y: 0, z: 0 };\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nclass Bezier {\n  constructor(coords) {\n    let args =\n      coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n      }\n    }\n\n    const _3d = (this._3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== \"undefined\"));\n\n    const points = (this.points = []);\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1],\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = (this.order = points.length - 1);\n\n    const dims = (this.dims = [\"x\", \"y\"]);\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n\n    // is this curve, practically speaking, a straight line?\n    const aligned = utils.align(points, { p1: points[0], p2: points[order] });\n    const baselength = utils.dist(points[0], points[order]);\n    this._linear = aligned.reduce((t, p) => t + abs(p.y), 0) < baselength / 50;\n\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    // shortcuts, although they're really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t);\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n    const d2 = (d1 * (1 - t)) / t;\n\n    const selen = utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    const e1 = { x: B.x - bx1, y: B.y - by1 },\n      e2 = { x: B.x + bx2, y: B.y + by2 },\n      A = abc.A,\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t),\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n      x = p[0].x,\n      y = p[0].y,\n      s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points\n      .map(function (c, pos) {\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n      })\n      .join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y,\n      },\n      s = utils.abcratio(t, order),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s,\n      };\n    return { A, B, C, S, E };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps + 1) {\n      return this._lut;\n    }\n    this._lut = [];\n    // n steps means n+1 points\n    steps++;\n    this._lut = [];\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n      hits = [];\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n    if (!hits.length) return false;\n    return (t /= hits.length);\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n      l = LUT.length - 1,\n      closest = utils.closest(LUT, point),\n      mpos = closest.mpos,\n      t1 = (mpos - 1) / l,\n      t2 = (mpos + 1) / l,\n      step = 0.1 / l;\n\n    // step 2: fine check\n    let mdist = closest.mdist,\n      t = t1,\n      ft = t,\n      p;\n    mdist += 1;\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n      np = [p[0]],\n      k = p.length;\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: ((k - i) / k) * pi.x + (i / k) * pim.x,\n        y: ((k - i) / k) * pi.y + (i / k) * pim.y,\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt(d.x * d.x + d.y * d.y);\n    return { t, x: -d.y / q, y: d.x / q };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n      r2 = this.derivative(t + 0.01),\n      q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n      q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x,\n    };\n    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    // rotation matrix\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z,\n    ];\n    // normal vector:\n    const n = {\n      t,\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n      _p = [],\n      q = [],\n      idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use \"de Casteljau\" iteration.\n    const q = this.hull(t1);\n    const result = {\n      left:\n        this.order === 2\n          ? new Bezier([q[0], q[3], q[5]])\n          : new Bezier([q[0], q[4], q[7], q[9]]),\n      right:\n        this.order === 2\n          ? new Bezier([q[5], q[4], q[2]])\n          : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q,\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we're done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n\n    this.dims.forEach(\n      function (dim) {\n        let mfn = function (v) {\n          return v[dim];\n        };\n        let p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this)\n    );\n\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n      result = {};\n    this.dims.forEach(\n      function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this)\n    );\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n      tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n        n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d,\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0),\n        coords = this.points.map(function (p) {\n          const ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y,\n          };\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return abs(acos(s)) < pi / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n      t1 = 0,\n      t2 = 0,\n      step = 0.01,\n      segment,\n      pass1 = [],\n      pass2 = [];\n    // first pass: split on extrema\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  translate(v, d1, d2) {\n    d2 = typeof d2 === \"number\" ? d2 : d1;\n\n    // TODO: make this take curves with control points outside\n    //       of the start-end interval into account\n\n    const o = this.order;\n    let d = this.points.map((_, i) => (1 - i / o) * d1 + (i / o) * d2);\n    return new Bezier(\n      this.points.map((p, i) => ({\n        x: p.x + v.x * d[i],\n        y: p.y + v.y * d[i],\n      }))\n    );\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for non-linear degenerate curves.\n\n    const clockwise = this.clockwise;\n    const points = this.points;\n\n    if (this._linear) {\n      return this.translate(\n        this.normal(0),\n        distanceFn ? distanceFn(0) : d,\n        distanceFn ? distanceFn(1) : d\n      );\n    }\n\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    }\n\n    // move all points by distance 'd' wrt the origin 'o',\n    // and move end points by fixed distance along normal.\n    [0, 1].forEach(function (t) {\n      const p = (np[t * order] = utils.copy(points[t * order]));\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach((t) => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = { x: p.x + d.x, y: p.y + d.y };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    }\n\n    // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y,\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y,\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = d2 === undefined ? d1 : d2;\n\n    if (this._linear) {\n      // TODO: find the actual extrema, because they might\n      //       be before the start, or past the end.\n\n      const n = this.normal(0);\n      const start = this.points[0];\n      const end = this.points[this.points.length - 1];\n      let s, mid, e;\n\n      if (d3 === undefined) {\n        d3 = d1;\n        d4 = d2;\n      }\n\n      s = { x: start.x + n.x * d1, y: start.y + n.y * d1 };\n      e = { x: end.x + n.x * d3, y: end.y + n.y * d3 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const fline = [s, mid, e];\n\n      s = { x: start.x - n.x * d2, y: start.y - n.y * d2 };\n      e = { x: end.x - n.x * d4, y: end.y - n.y * d4 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const bline = [e, mid, s];\n\n      const ls = utils.makeline(bline[2], fline[0]);\n      const le = utils.makeline(fline[2], bline[0]);\n      const segments = [ls, new Bezier(fline), le, new Bezier(bline)];\n      return new PolyBezier(segments);\n    }\n\n    const reduced = this.reduce(),\n      len = reduced.length,\n      fcurves = [];\n\n    let bcurves = [],\n      p,\n      alen = 0,\n      tlen = this.length();\n\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n          f2 = (alen + slen) / tlen,\n          d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n        );\n        bcurves.push(\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n        );\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the \"return\" outline\n    bcurves = bcurves\n      .map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      })\n      .reverse();\n\n    // form the endcaps as lines\n    const fs = fcurves[0].points[0],\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n      be = bcurves[0].points[0],\n      ls = utils.makeline(bs, fs),\n      le = utils.makeline(fe, be),\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(\n        outline[i],\n        outline[len - i],\n        curveIntersectionThreshold\n      );\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(\n      this.reduce(),\n      curve,\n      curveIntersectionThreshold\n    );\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n      my = min(line.p1.y, line.p2.y),\n      MX = max(line.p1.x, line.p2.x),\n      MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter((t) => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n\n    const reduced = this.reduce(),\n      len = reduced.length - 2,\n      results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(\n        pair.left,\n        pair.right,\n        curveIntersectionThreshold\n      );\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n      c1 = this.get(s + q),\n      c2 = this.get(e - q),\n      ref = utils.dist(pc, np1),\n      d1 = utils.dist(pc, c1),\n      d2 = utils.dist(pc, c2);\n    return abs(d1 - ref) + abs(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n      t_e = 1,\n      safety;\n    // we do a binary search to find the \"good `t` closest to no-longer-good\"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      let np1 = this.get(t_s),\n        np2,\n        np3,\n        arc,\n        prev_arc;\n\n      // booleans:\n      let curr_good = false,\n        prev_good = false,\n        done;\n\n      // numbers:\n      let t_m = t_e,\n        prev_e = 1,\n        step = 0;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n\n        arc = utils.getccenter(np1, np2, np3);\n\n        //also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e,\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move 'e' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos(arc.e),\n                y: arc.y + arc.r * sin(arc.e),\n              };\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n}\n\nexport { Bezier };\n","import { utils } from \"./utils.js\";\n\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\nclass PolyBezier {\n  constructor(curves) {\n    this.curves = [];\n    this._3d = false;\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return (\n      \"[\" +\n      this.curves\n        .map(function (curve) {\n          return utils.pointsToString(curve.points);\n        })\n        .join(\", \") +\n      \"]\"\n    );\n  }\n\n  addCurve(curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n\n  length() {\n    return this.curves\n      .map(function (v) {\n        return v.length();\n      })\n      .reduce(function (a, b) {\n        return a + b;\n      });\n  }\n\n  curve(idx) {\n    return this.curves[idx];\n  }\n\n  bbox() {\n    const c = this.curves;\n    var bbox = c[0].bbox();\n    for (var i = 1; i < c.length; i++) {\n      utils.expandbox(bbox, c[i].bbox());\n    }\n    return bbox;\n  }\n\n  offset(d) {\n    const offset = [];\n    this.curves.forEach(function (v) {\n      offset.push(...v.offset(d));\n    });\n    return new PolyBezier(offset);\n  }\n}\n\nexport { PolyBezier };\n","import { Bezier } from \"./bezier.js\";\n\n// math-inlining.\nconst { abs, cos, sin, acos, atan2, sqrt, pow } = Math;\n\n// cube root function yielding real roots\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n}\n\n// trig constants\nconst pi = Math.PI,\n  tau = 2 * pi,\n  quart = pi / 2,\n  // float precision significant decimal\n  epsilon = 0.000001,\n  // extremas used in bbox calculation and similar algorithms\n  nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n  // a zero coordinate, which is surprisingly useful\n  ZERO = { x: 0, y: 0, z: 0 };\n\n// Bezier utility functions\nconst utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [\n    -0.0640568928626056260850430826247450385909,\n    0.0640568928626056260850430826247450385909,\n    -0.1911188674736163091586398207570696318404,\n    0.1911188674736163091586398207570696318404,\n    -0.3150426796961633743867932913198102407864,\n    0.3150426796961633743867932913198102407864,\n    -0.4337935076260451384870842319133497124524,\n    0.4337935076260451384870842319133497124524,\n    -0.5454214713888395356583756172183723700107,\n    0.5454214713888395356583756172183723700107,\n    -0.6480936519369755692524957869107476266696,\n    0.6480936519369755692524957869107476266696,\n    -0.7401241915785543642438281030999784255232,\n    0.7401241915785543642438281030999784255232,\n    -0.8200019859739029219539498726697452080761,\n    0.8200019859739029219539498726697452080761,\n    -0.8864155270044010342131543419821967550873,\n    0.8864155270044010342131543419821967550873,\n    -0.9382745520027327585236490017087214496548,\n    0.9382745520027327585236490017087214496548,\n    -0.9747285559713094981983919930081690617411,\n    0.9747285559713094981983919930081690617411,\n    -0.9951872199970213601799974097007368118745,\n    0.9951872199970213601799974097007368118745,\n  ],\n\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [\n    0.1279381953467521569740561652246953718517,\n    0.1279381953467521569740561652246953718517,\n    0.1258374563468282961213753825111836887264,\n    0.1258374563468282961213753825111836887264,\n    0.121670472927803391204463153476262425607,\n    0.121670472927803391204463153476262425607,\n    0.1155056680537256013533444839067835598622,\n    0.1155056680537256013533444839067835598622,\n    0.1074442701159656347825773424466062227946,\n    0.1074442701159656347825773424466062227946,\n    0.0976186521041138882698806644642471544279,\n    0.0976186521041138882698806644642471544279,\n    0.086190161531953275917185202983742667185,\n    0.086190161531953275917185202983742667185,\n    0.0733464814110803057340336152531165181193,\n    0.0733464814110803057340336152531165181193,\n    0.0592985849154367807463677585001085845412,\n    0.0592985849154367807463677585001085845412,\n    0.0442774388174198061686027482113382288593,\n    0.0442774388174198061686027482113382288593,\n    0.0285313886289336631813078159518782864491,\n    0.0285313886289336631813078159518782864491,\n    0.0123412297999871995468056670700372915759,\n    0.0123412297999871995468056670700372915759,\n  ],\n\n  arcfn: function (t, derivativeFn) {\n    const d = derivativeFn(t);\n    let l = d.x * d.x + d.y * d.y;\n    if (typeof d.z !== \"undefined\") {\n      l += d.z * d.z;\n    }\n    return sqrt(l);\n  },\n\n  compute: function (t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n\n    const order = points.length - 1;\n\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n\n    const mt = 1 - t;\n    let p = points;\n\n    // constant?\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    }\n\n    // linear?\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n      return ret;\n    }\n\n    // quadratic/cubic curve?\n    if (order < 4) {\n      let mt2 = mt * mt,\n        t2 = t * t,\n        a,\n        b,\n        c,\n        d = 0;\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n      return ret;\n    }\n\n    // higher order curves: use de Casteljau's computation\n    const dCpts = JSON.parse(JSON.stringify(points));\n    while (dCpts.length > 1) {\n      for (let i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t,\n        };\n        if (typeof dCpts[i].z !== \"undefined\") {\n          dCpts[i] = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n\n  computeWithRatios: function (t, points, ratios, _3d) {\n    const mt = 1 - t,\n      r = ratios,\n      p = points;\n\n    let f1 = r[0],\n      f2 = r[1],\n      f3 = r[2],\n      f4 = r[3],\n      d;\n\n    // spec for linear\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to quadratic\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to cubic\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d\n          ? false\n          : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t,\n      };\n    }\n  },\n\n  derive: function (points, _3d) {\n    const dpoints = [];\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      const list = [];\n      for (let j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y),\n        };\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n        list.push(dpt);\n      }\n      dpoints.push(list);\n      p = list;\n    }\n    return dpoints;\n  },\n\n  between: function (v, m, M) {\n    return (\n      (m <= v && v <= M) ||\n      utils.approximately(v, m) ||\n      utils.approximately(v, M)\n    );\n  },\n\n  approximately: function (a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n\n  length: function (derivativeFn) {\n    const z = 0.5,\n      len = utils.Tvalues.length;\n\n    let sum = 0;\n\n    for (let i = 0, t; i < len; i++) {\n      t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\n    }\n    return z * sum;\n  },\n\n  map: function (v, ds, de, ts, te) {\n    const d1 = de - ds,\n      d2 = te - ts,\n      v2 = v - ds,\n      r = v2 / d1;\n    return ts + d2 * r;\n  },\n\n  lerp: function (r, v1, v2) {\n    const ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y),\n    };\n    if (v1.z !== undefined && v2.z !== undefined) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n    return ret;\n  },\n\n  pointToString: function (p) {\n    let s = p.x + \"/\" + p.y;\n    if (typeof p.z !== \"undefined\") {\n      s += \"/\" + p.z;\n    }\n    return s;\n  },\n\n  pointsToString: function (points) {\n    return \"[\" + points.map(utils.pointToString).join(\", \") + \"]\";\n  },\n\n  copy: function (obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n\n  angle: function (o, v1, v2) {\n    const dx1 = v1.x - o.x,\n      dy1 = v1.y - o.y,\n      dx2 = v2.x - o.x,\n      dy2 = v2.y - o.y,\n      cross = dx1 * dy2 - dy1 * dx2,\n      dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n\n  // round as string, to avoid rounding errors\n  round: function (v, d) {\n    const s = \"\" + v;\n    const pos = s.indexOf(\".\");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n\n  dist: function (p1, p2) {\n    const dx = p1.x - p2.x,\n      dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n\n  closest: function (LUT, point) {\n    let mdist = pow(2, 63),\n      mpos,\n      d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return { mdist: mdist, mpos: mpos };\n  },\n\n  abcratio: function (t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const bottom = pow(t, n) + pow(1 - t, n),\n      top = bottom - 1;\n    return abs(top / bottom);\n  },\n\n  projectionratio: function (t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const top = pow(1 - t, n),\n      bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n\n  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx =\n        (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n      d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (d == 0) {\n      return false;\n    }\n    return { x: nx / d, y: ny / d };\n  },\n\n  lli4: function (p1, p2, p3, p4) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      x3 = p3.x,\n      y3 = p3.y,\n      x4 = p4.x,\n      y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n\n  lli: function (v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n\n  makeline: function (p1, p2) {\n    return new Bezier(\n      p1.x,\n      p1.y,\n      (p1.x + p2.x) / 2,\n      (p1.y + p2.y) / 2,\n      p2.x,\n      p2.y\n    );\n  },\n\n  findbbox: function (sections) {\n    let mx = nMax,\n      my = nMax,\n      MX = nMin,\n      MY = nMin;\n    sections.forEach(function (s) {\n      const bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },\n      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my },\n    };\n  },\n\n  shapeintersections: function (\n    s1,\n    bbox1,\n    s2,\n    bbox2,\n    curveIntersectionThreshold\n  ) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    const intersections = [];\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n\n  makeshape: function (forward, back, curveIntersectionThreshold) {\n    const bpl = back.points.length;\n    const fpl = forward.points.length;\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    const shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end]),\n    };\n    shape.intersections = function (s2) {\n      return utils.shapeintersections(\n        shape,\n        shape.bbox,\n        s2,\n        s2.bbox,\n        curveIntersectionThreshold\n      );\n    };\n    return shape;\n  },\n\n  getminmax: function (curve, d, list) {\n    if (!list) return { min: 0, max: 0 };\n    let min = nMax,\n      max = nMin,\n      t,\n      c;\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n    for (let i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n      if (c[d] < min) {\n        min = c[d];\n      }\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n    return { min: min, mid: (min + max) / 2, max: max, size: max - min };\n  },\n\n  align: function (points, line) {\n    const tx = line.p1.x,\n      ty = line.p1.y,\n      a = -atan2(line.p2.y - ty, line.p2.x - tx),\n      d = function (v) {\n        return {\n          x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n          y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a),\n        };\n      };\n    return points.map(d);\n  },\n\n  roots: function (points, line) {\n    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };\n\n    const order = points.length - 1;\n    const aligned = utils.align(points, line);\n    const reduce = function (t) {\n      return 0 <= t && t <= 1;\n    };\n\n    if (order === 2) {\n      const a = aligned[0].y,\n        b = aligned[1].y,\n        c = aligned[2].y,\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2].filter(reduce);\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\n      }\n      return [];\n    }\n\n    // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n    const pa = aligned[0].y,\n      pb = aligned[1].y,\n      pc = aligned[2].y,\n      pd = aligned[3].y;\n\n    let d = -pa + 3 * pb - 3 * pc + pd,\n      a = 3 * pa - 6 * pb + 3 * pc,\n      b = -3 * pa + 3 * pb,\n      c = pa;\n\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        }\n        // linear solution:\n        return [-c / b].filter(reduce);\n      }\n      // quadratic solution:\n      const q = sqrt(b * b - 4 * a * c),\n        a2 = 2 * a;\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\n    }\n\n    // at this point, we know we need a cubic solution:\n\n    a /= d;\n    b /= d;\n    c /= d;\n\n    const p = (3 * b - a * a) / 3,\n      p3 = p / 3,\n      q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n      q2 = q / 2,\n      discriminant = q2 * q2 + p3 * p3 * p3;\n\n    let u1, v1, x1, x2, x3;\n    if (discriminant < 0) {\n      const mp3 = -p / 3,\n        mp33 = mp3 * mp3 * mp3,\n        r = sqrt(mp33),\n        t = -q / (2 * r),\n        cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n        phi = acos(cosphi),\n        crtr = crt(r),\n        t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      const sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n\n  droots: function (p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      const a = p[0],\n        b = p[1],\n        c = p[2],\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n      return [];\n    }\n\n    // linear roots are even easier\n    if (p.length === 2) {\n      const a = p[0],\n        b = p[1];\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n      return [];\n    }\n\n    return [];\n  },\n\n  curvature: function (t, d1, d2, _3d, kOnly) {\n    let num,\n      dnm,\n      adk,\n      dk,\n      k = 0,\n      r = 0;\n\n    //\n    // We're using the following formula for curvature:\n    //\n    //              x'y\" - y'x\"\n    //   k(t) = ------------------\n    //           (x'² + y'²)^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y'z\" - y\"z')² + (z'x\" - z\"x')² + (x'y\" - x\"y')²)\n    //   k(t) = -------------------------------------------------------\n    //                     (x'² + y'² + z'²)^(3/2)\n    //\n\n    const d = utils.compute(t, d1);\n    const dd = utils.compute(t, d2);\n    const qdsum = d.x * d.x + d.y * d.y;\n\n    if (_3d) {\n      num = sqrt(\n        pow(d.y * dd.z - dd.y * d.z, 2) +\n          pow(d.z * dd.x - dd.z * d.x, 2) +\n          pow(d.x * dd.y - dd.x * d.y, 2)\n      );\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return { k: 0, r: 0 };\n    }\n\n    k = num / dnm;\n    r = dnm / num;\n\n    // We're also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we're just going to\n    // ballpark it based on an epsilon.\n    if (!kOnly) {\n      // compute k'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\n      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n\n    return { k: k, r: r, dk: dk, adk: adk };\n  },\n\n  inflections: function (points) {\n    if (points.length < 4) return [];\n\n    // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),\n      a = p[2].x * p[1].y,\n      b = p[3].x * p[1].y,\n      c = p[1].x * p[2].y,\n      d = p[3].x * p[2].y,\n      v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n      v2 = 18 * (3 * a - b - 3 * c),\n      v3 = 18 * (c - a);\n\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        let t = -v3 / v2;\n        if (0 <= t && t <= 1) return [t];\n      }\n      return [];\n    }\n\n    const d2 = 2 * v1;\n\n    if (utils.approximately(d2, 0)) return [];\n\n    const trm = v2 * v2 - 4 * v1 * v3;\n\n    if (trm < 0) return [];\n\n    const sq = Math.sqrt(trm);\n\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n\n  bboxoverlap: function (b1, b2) {\n    const dims = [\"x\", \"y\"],\n      len = dims.length;\n\n    for (let i = 0, dim, l, t, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t) >= d) return false;\n    }\n    return true;\n  },\n\n  expandbox: function (bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n\n  pairiteration: function (c1, c2, curveIntersectionThreshold) {\n    const c1b = c1.bbox(),\n      c2b = c2.bbox(),\n      r = 100000,\n      threshold = curveIntersectionThreshold || 0.5;\n\n    if (\n      c1b.x.size + c1b.y.size < threshold &&\n      c2b.x.size + c2b.y.size < threshold\n    ) {\n      return [\n        (((r * (c1._t1 + c1._t2)) / 2) | 0) / r +\n          \"/\" +\n          (((r * (c2._t1 + c2._t2)) / 2) | 0) / r,\n      ];\n    }\n\n    let cc1 = c1.split(0.5),\n      cc2 = c2.split(0.5),\n      pairs = [\n        { left: cc1.left, right: cc2.left },\n        { left: cc1.left, right: cc2.right },\n        { left: cc1.right, right: cc2.right },\n        { left: cc1.right, right: cc2.left },\n      ];\n\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n\n    let results = [];\n\n    if (pairs.length === 0) return results;\n\n    pairs.forEach(function (pair) {\n      results = results.concat(\n        utils.pairiteration(pair.left, pair.right, threshold)\n      );\n    });\n\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n\n    return results;\n  },\n\n  getccenter: function (p1, p2, p3) {\n    const dx1 = p2.x - p1.x,\n      dy1 = p2.y - p1.y,\n      dx2 = p3.x - p2.x,\n      dy2 = p3.y - p2.y,\n      dx1p = dx1 * cos(quart) - dy1 * sin(quart),\n      dy1p = dx1 * sin(quart) + dy1 * cos(quart),\n      dx2p = dx2 * cos(quart) - dy2 * sin(quart),\n      dy2p = dx2 * sin(quart) + dy2 * cos(quart),\n      // chord midpoints\n      mx1 = (p1.x + p2.x) / 2,\n      my1 = (p1.y + p2.y) / 2,\n      mx2 = (p2.x + p3.x) / 2,\n      my2 = (p2.y + p3.y) / 2,\n      // midpoint offsets\n      mx1n = mx1 + dx1p,\n      my1n = my1 + dy1p,\n      mx2n = mx2 + dx2p,\n      my2n = my2 + dy2p,\n      // intersection of these lines:\n      arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n      r = utils.dist(arc, p1);\n\n    // arc start/end values, over mid point:\n    let s = atan2(p1.y - arc.y, p1.x - arc.x),\n      m = atan2(p2.y - arc.y, p2.x - arc.x),\n      e = atan2(p3.y - arc.y, p3.x - arc.x),\n      _;\n\n    // determine arc direction (cw/ccw correction)\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    }\n    // assign and done.\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n\n  numberSort: function (a, b) {\n    return a - b;\n  },\n};\n\nexport { utils };\n","import  EditorImage  from './image/EditorImage.mjs';\nimport  ToolController  from './tools/ToolController.mjs';\nimport  { EditorEventType }  from './types.mjs';\nimport  { InputEvtType, keyUpEventFromHTMLEvent, keyPressEventFromHTMLEvent, }  from './inputEvents.mjs';\nimport  UndoRedoHistory  from './UndoRedoHistory.mjs';\nimport  Viewport  from './Viewport.mjs';\nimport  EventDispatcher  from './EventDispatcher.mjs';\nimport { Vec2, Vec3, Color4, Mat33, Rect2 } from '@js-draw/math';\nimport  Display, { RenderingMode }  from './rendering/Display.mjs';\nimport  SVGLoader  from './SVGLoader/SVGLoader.mjs';\nimport  Pointer  from './Pointer.mjs';\nimport  getLocalizationTable  from './localizations/getLocalizationTable.mjs';\nimport  IconProvider  from './toolbar/IconProvider.mjs';\nimport  CanvasRenderer  from './rendering/renderers/CanvasRenderer.mjs';\nimport  untilNextAnimationFrame  from './util/untilNextAnimationFrame.mjs';\nimport  uniteCommands  from './commands/uniteCommands.mjs';\nimport  SelectionTool  from './tools/SelectionTool/SelectionTool.mjs';\nimport  Erase  from './commands/Erase.mjs';\nimport  BackgroundComponent, { BackgroundType }  from './components/BackgroundComponent.mjs';\nimport  sendPenEvent  from './testing/sendPenEvent.mjs';\nimport  KeyboardShortcutManager  from './shortcuts/KeyboardShortcutManager.mjs';\nimport  EdgeToolbar  from './toolbar/EdgeToolbar.mjs';\nimport  StrokeKeyboardControl  from './tools/InputFilter/StrokeKeyboardControl.mjs';\nimport  guessKeyCodeFromKey  from './util/guessKeyCodeFromKey.mjs';\nimport  makeAboutDialog  from './dialogs/makeAboutDialog.mjs';\nimport  version  from './version.mjs';\nimport  { editorImageToSVGSync, editorImageToSVGAsync }  from './image/export/editorImageToSVG.mjs';\nimport  ReactiveValue, { MutableReactiveValue }  from './util/ReactiveValue.mjs';\nimport  listenForKeyboardEventsFrom  from './util/listenForKeyboardEventsFrom.mjs';\nimport  mitLicenseAttribution  from './util/mitLicenseAttribution.mjs';\nimport  ClipboardHandler  from './util/ClipboardHandler.mjs';\nimport  ContextMenuRecognizer  from './tools/InputFilter/ContextMenuRecognizer.mjs';\n/**\n * The main entrypoint for the full editor.\n *\n * ## Example\n * To create an editor with a toolbar,\n * ```ts,runnable\n * import { Editor } from 'js-draw';\n *\n * const editor = new Editor(document.body);\n *\n * const toolbar = editor.addToolbar();\n * toolbar.addSaveButton(() => {\n *   const saveData = editor.toSVG().outerHTML;\n *   // Do something with saveData...\n * });\n * ```\n *\n * See also\n * * [`examples.md`](https://github.com/personalizedrefrigerator/js-draw/blob/main/docs/examples.md).\n */\nexport class Editor {\n    /**\n     * @example\n     * ```ts,runnable\n     * import { Editor } from 'js-draw';\n     *\n     * const container = document.body;\n     *\n     * // Create an editor\n     * const editor = new Editor(container, {\n     *   // 2e-10 and 1e12 are the default values for minimum/maximum zoom.\n     *   minZoom: 2e-10,\n     *   maxZoom: 1e12,\n     * });\n     *\n     * // Add the default toolbar\n     * const toolbar = editor.addToolbar();\n     *\n     * const createCustomIcon = () => {\n     *   // Create/return an icon here.\n     * };\n     *\n     * // Add a custom button\n     * toolbar.addActionButton({\n     *   label: 'Custom Button'\n     *   icon: createCustomIcon(),\n     * }, () => {\n     *   // Do something here\n     * });\n     * ```\n     */\n    constructor(parent, settings = {}) {\n        this.eventListenerTargets = [];\n        this.previousAccessibilityAnnouncement = '';\n        this.pointers = {};\n        this.announceUndoCallback = (command) => {\n            this.announceForAccessibility(this.localization.undoAnnouncement(command.description(this, this.localization)));\n        };\n        this.announceRedoCallback = (command) => {\n            this.announceForAccessibility(this.localization.redoAnnouncement(command.description(this, this.localization)));\n        };\n        // Listeners to be called once at the end of the next re-render.\n        this.nextRerenderListeners = [];\n        this.rerenderQueued = false;\n        this.closeAboutDialog = null;\n        this.localization = {\n            ...getLocalizationTable(),\n            ...settings.localization,\n        };\n        // Fill default settings.\n        this.settings = {\n            wheelEventsEnabled: settings.wheelEventsEnabled ?? true,\n            renderingMode: settings.renderingMode ?? RenderingMode.CanvasRenderer,\n            localization: this.localization,\n            minZoom: settings.minZoom ?? 2e-10,\n            maxZoom: settings.maxZoom ?? 1e12,\n            keyboardShortcutOverrides: settings.keyboardShortcutOverrides ?? {},\n            iconProvider: settings.iconProvider ?? new IconProvider(),\n            notices: settings.notices ?? [],\n            appInfo: settings.appInfo ? { ...settings.appInfo } : null,\n            pens: {\n                additionalPenTypes: settings.pens?.additionalPenTypes ?? [],\n                filterPenTypes: settings.pens?.filterPenTypes ?? (() => true),\n            },\n            text: {\n                fonts: settings.text?.fonts ?? ['sans-serif', 'serif', 'monospace'],\n            },\n            image: {\n                showImagePicker: settings.image?.showImagePicker ?? undefined,\n            },\n            clipboardApi: settings.clipboardApi ?? null,\n        };\n        // Validate settings\n        if (this.settings.minZoom > this.settings.maxZoom) {\n            throw new Error('Minimum zoom must be lesser than maximum zoom!');\n        }\n        this.readOnly = MutableReactiveValue.fromInitialValue(false);\n        this.icons = this.settings.iconProvider;\n        this.shortcuts = new KeyboardShortcutManager(this.settings.keyboardShortcutOverrides);\n        this.container = document.createElement('div');\n        this.renderingRegion = document.createElement('div');\n        this.container.appendChild(this.renderingRegion);\n        this.container.classList.add('imageEditorContainer', 'js-draw');\n        this.loadingWarning = document.createElement('div');\n        this.loadingWarning.classList.add('loadingMessage');\n        this.loadingWarning.ariaLive = 'polite';\n        this.container.appendChild(this.loadingWarning);\n        this.accessibilityControlArea = document.createElement('textarea');\n        this.accessibilityControlArea.setAttribute('placeholder', this.localization.accessibilityInputInstructions);\n        this.accessibilityControlArea.style.opacity = '0';\n        this.accessibilityControlArea.style.width = '0';\n        this.accessibilityControlArea.style.height = '0';\n        this.accessibilityControlArea.style.position = 'absolute';\n        this.accessibilityAnnounceArea = document.createElement('div');\n        this.accessibilityAnnounceArea.setAttribute('aria-live', 'assertive');\n        this.accessibilityAnnounceArea.className = 'accessibilityAnnouncement';\n        this.container.appendChild(this.accessibilityAnnounceArea);\n        this.renderingRegion.style.touchAction = 'none';\n        this.renderingRegion.className = 'imageEditorRenderArea';\n        this.renderingRegion.appendChild(this.accessibilityControlArea);\n        this.renderingRegion.setAttribute('tabIndex', '0');\n        this.renderingRegion.setAttribute('alt', '');\n        this.notifier = new EventDispatcher();\n        this.viewport = new Viewport((oldTransform, newTransform) => {\n            this.notifier.dispatch(EditorEventType.ViewportChanged, {\n                kind: EditorEventType.ViewportChanged,\n                newTransform,\n                oldTransform,\n            });\n        });\n        this.display = new Display(this, this.settings.renderingMode, this.renderingRegion);\n        this.image = new EditorImage();\n        this.history = new UndoRedoHistory(this, this.announceRedoCallback, this.announceUndoCallback);\n        this.toolController = new ToolController(this, this.localization);\n        // TODO: Make this pipeline configurable (e.g. allow users to add global input stabilization)\n        this.toolController.addInputMapper(StrokeKeyboardControl.fromEditor(this));\n        this.toolController.addInputMapper(new ContextMenuRecognizer());\n        parent.appendChild(this.container);\n        this.viewport.updateScreenSize(Vec2.of(this.display.width, this.display.height));\n        this.registerListeners();\n        this.queueRerender();\n        this.hideLoadingWarning();\n        // Enforce zoom limits.\n        this.notifier.on(EditorEventType.ViewportChanged, (evt) => {\n            if (evt.kind !== EditorEventType.ViewportChanged)\n                return;\n            const getZoom = (mat) => mat.transformVec3(Vec2.unitX).length();\n            const zoom = getZoom(evt.newTransform);\n            if (zoom > this.settings.maxZoom || zoom < this.settings.minZoom) {\n                const oldZoom = getZoom(evt.oldTransform);\n                let resetTransform = Mat33.identity;\n                if (oldZoom <= this.settings.maxZoom && oldZoom >= this.settings.minZoom) {\n                    resetTransform = evt.oldTransform;\n                }\n                else {\n                    // If 1x zoom isn't acceptable, try a zoom between the minimum and maximum.\n                    resetTransform = Mat33.scaling2D((this.settings.minZoom + this.settings.maxZoom) / 2);\n                }\n                this.viewport.resetTransform(resetTransform);\n            }\n            else if (!isFinite(zoom)) {\n                // Recover from possible division-by-zero\n                console.warn(`Non-finite zoom (${zoom}) detected. Resetting the viewport. This was likely caused by division by zero.`);\n                if (isFinite(getZoom(evt.oldTransform))) {\n                    this.viewport.resetTransform(evt.oldTransform);\n                }\n                else {\n                    this.viewport.resetTransform();\n                }\n            }\n        });\n    }\n    /**\n     * @returns a shallow copy of the current settings of the editor.\n     *\n     * Do not modify.\n     */\n    getCurrentSettings() {\n        return {\n            ...this.settings,\n        };\n    }\n    /**\n     * @returns a reference to the editor's container.\n     *\n     * @example\n     * ```\n     *   // Set the editor's height to 500px\n     *   editor.getRootElement().style.height = '500px';\n     * ```\n     */\n    getRootElement() {\n        return this.container;\n    }\n    /**\n     * @returns the bounding box of the main rendering region of the editor in the HTML viewport.\n     *\n     * @internal\n     */\n    getOutputBBoxInDOM() {\n        return Rect2.of(this.renderingRegion.getBoundingClientRect());\n    }\n    /**\n     * Shows a \"Loading...\" message.\n     * @param fractionLoaded - should be a number from 0 to 1, where 1 represents completely loaded.\n     */\n    showLoadingWarning(fractionLoaded) {\n        const loadingPercent = Math.round(fractionLoaded * 100);\n        this.loadingWarning.innerText = this.localization.loading(loadingPercent);\n        this.loadingWarning.style.display = 'block';\n    }\n    /** @see {@link showLoadingWarning} */\n    hideLoadingWarning() {\n        this.loadingWarning.style.display = 'none';\n        this.announceForAccessibility(this.localization.doneLoading);\n    }\n    /**\n     * Announce `message` for screen readers. If `message` is the same as the previous\n     * message, it is re-announced.\n     */\n    announceForAccessibility(message) {\n        // Force re-announcing an announcement if announced again.\n        if (message === this.previousAccessibilityAnnouncement) {\n            message = message + '. ';\n        }\n        this.accessibilityAnnounceArea.innerText = message;\n        this.previousAccessibilityAnnouncement = message;\n    }\n    /**\n     * Creates a toolbar. If `defaultLayout` is true, default buttons are used.\n     * @returns a reference to the toolbar.\n     */\n    addToolbar(defaultLayout = true) {\n        const toolbar = new EdgeToolbar(this, this.container, this.localization);\n        if (defaultLayout) {\n            toolbar.addDefaults();\n        }\n        return toolbar;\n    }\n    registerListeners() {\n        this.handlePointerEventsFrom(this.renderingRegion);\n        this.handleKeyEventsFrom(this.renderingRegion);\n        this.handlePointerEventsFrom(this.accessibilityAnnounceArea);\n        // Prevent selected text from control areas from being dragged.\n        // See https://github.com/personalizedrefrigerator/joplin-plugin-freehand-drawing/issues/8\n        const preventSelectionOf = [\n            this.renderingRegion,\n            this.accessibilityAnnounceArea,\n            this.accessibilityControlArea,\n            this.loadingWarning,\n        ];\n        for (const element of preventSelectionOf) {\n            element.addEventListener('drag', (event) => {\n                event.preventDefault();\n                return false;\n            });\n            element.addEventListener('dragstart', (event) => {\n                event.preventDefault();\n                return false;\n            });\n        }\n        this.container.addEventListener('wheel', (evt) => {\n            this.handleHTMLWheelEvent(evt);\n        });\n        const handleResize = () => {\n            this.viewport.updateScreenSize(Vec2.of(this.display.width, this.display.height));\n            this.rerender();\n            this.updateEditorSizeVariables();\n        };\n        if ('ResizeObserver' in window) {\n            const resizeObserver = new ResizeObserver(handleResize);\n            resizeObserver.observe(this.renderingRegion);\n            resizeObserver.observe(this.container);\n        }\n        else {\n            addEventListener('resize', handleResize);\n        }\n        this.accessibilityControlArea.addEventListener('input', () => {\n            this.accessibilityControlArea.value = '';\n        });\n        const copyHandler = new ClipboardHandler(this);\n        document.addEventListener('copy', async (evt) => {\n            if (!this.isEventSink(document.querySelector(':focus'))) {\n                return;\n            }\n            copyHandler.copy(evt);\n        });\n        document.addEventListener('paste', (evt) => {\n            this.handlePaste(evt);\n        });\n    }\n    updateEditorSizeVariables() {\n        // Add CSS variables so that absolutely-positioned children of the editor can\n        // still fill the screen.\n        this.container.style.setProperty('--editor-current-width-px', `${this.container.clientWidth}px`);\n        this.container.style.setProperty('--editor-current-height-px', `${this.container.clientHeight}px`);\n        this.container.style.setProperty('--editor-current-display-width-px', `${this.renderingRegion.clientWidth}px`);\n        this.container.style.setProperty('--editor-current-display-height-px', `${this.renderingRegion.clientHeight}px`);\n    }\n    /** @internal */\n    handleHTMLWheelEvent(event) {\n        let delta = Vec3.of(event.deltaX, event.deltaY, event.deltaZ);\n        // Process wheel events if the ctrl key is down, even if disabled -- we do want to handle\n        // pinch-zooming.\n        if (!event.ctrlKey && !event.metaKey) {\n            if (!this.settings.wheelEventsEnabled) {\n                return;\n            }\n            else if (this.settings.wheelEventsEnabled === 'only-if-focused') {\n                const focusedChild = this.container.querySelector(':focus');\n                if (!focusedChild) {\n                    return;\n                }\n            }\n        }\n        if (event.deltaMode === WheelEvent.DOM_DELTA_LINE) {\n            delta = delta.times(15);\n        }\n        else if (event.deltaMode === WheelEvent.DOM_DELTA_PAGE) {\n            delta = delta.times(100);\n        }\n        if (event.ctrlKey || event.metaKey) {\n            delta = Vec3.of(0, 0, event.deltaY);\n        }\n        // Ensure that `pos` is relative to `this.renderingRegion`\n        const bbox = this.getOutputBBoxInDOM();\n        const pos = Vec2.of(event.clientX, event.clientY).minus(bbox.topLeft);\n        if (this.toolController.dispatchInputEvent({\n            kind: InputEvtType.WheelEvt,\n            delta,\n            screenPos: pos,\n        })) {\n            event.preventDefault();\n            return true;\n        }\n        return false;\n    }\n    getPointerList() {\n        const nowTime = performance.now();\n        const res = [];\n        for (const id in this.pointers) {\n            const maxUnupdatedTime = 2000; // Maximum time without a pointer update (ms)\n            if (this.pointers[id] && nowTime - this.pointers[id].timeStamp < maxUnupdatedTime) {\n                res.push(this.pointers[id]);\n            }\n        }\n        return res;\n    }\n    /**\n     * A protected method that can override setPointerCapture in environments where it may fail\n     * (e.g. with synthetic events). @internal\n     */\n    setPointerCapture(target, pointerId) {\n        try {\n            target.setPointerCapture(pointerId);\n        }\n        catch (error) {\n            console.warn('Failed to setPointerCapture', error);\n        }\n    }\n    /** Can be overridden in a testing environment to handle synthetic events. @internal */\n    releasePointerCapture(target, pointerId) {\n        try {\n            target.releasePointerCapture(pointerId);\n        }\n        catch (error) {\n            console.warn('Failed to releasePointerCapture', error);\n        }\n    }\n    /**\n     * Dispatches a `PointerEvent` to the editor. The target element for `evt` must have the same top left\n     * as the content of the editor.\n     */\n    handleHTMLPointerEvent(eventType, evt) {\n        const eventsRelativeTo = this.renderingRegion;\n        const eventTarget = evt.target ?? this.renderingRegion;\n        if (eventType === 'pointerdown') {\n            const pointer = Pointer.ofEvent(evt, true, this.viewport, eventsRelativeTo);\n            this.pointers[pointer.id] = pointer;\n            this.setPointerCapture(eventTarget, pointer.id);\n            const event = {\n                kind: InputEvtType.PointerDownEvt,\n                current: pointer,\n                allPointers: this.getPointerList(),\n            };\n            this.toolController.dispatchInputEvent(event);\n            return true;\n        }\n        else if (eventType === 'pointermove') {\n            const pointer = Pointer.ofEvent(evt, this.pointers[evt.pointerId]?.down ?? false, this.viewport, eventsRelativeTo);\n            if (pointer.down) {\n                const prevData = this.pointers[pointer.id];\n                if (prevData) {\n                    const distanceMoved = pointer.screenPos.distanceTo(prevData.screenPos);\n                    // If the pointer moved less than two pixels, don't send a new event.\n                    if (distanceMoved < 2) {\n                        return false;\n                    }\n                }\n                this.pointers[pointer.id] = pointer;\n                if (this.toolController.dispatchInputEvent({\n                    kind: InputEvtType.PointerMoveEvt,\n                    current: pointer,\n                    allPointers: this.getPointerList(),\n                })) {\n                    evt.preventDefault();\n                }\n            }\n            return true;\n        }\n        else if (eventType === 'pointercancel' || eventType === 'pointerup') {\n            const pointer = Pointer.ofEvent(evt, false, this.viewport, eventsRelativeTo);\n            if (!this.pointers[pointer.id]) {\n                return false;\n            }\n            this.pointers[pointer.id] = pointer;\n            this.releasePointerCapture(eventTarget, pointer.id);\n            if (this.toolController.dispatchInputEvent({\n                kind: InputEvtType.PointerUpEvt,\n                current: pointer,\n                allPointers: this.getPointerList(),\n            })) {\n                evt.preventDefault();\n            }\n            delete this.pointers[pointer.id];\n            return true;\n        }\n        return eventType;\n    }\n    isEventSink(evtTarget) {\n        let currentElem = evtTarget;\n        while (currentElem !== null) {\n            for (const elem of this.eventListenerTargets) {\n                if (elem === currentElem) {\n                    return true;\n                }\n            }\n            currentElem = currentElem.parentElement;\n        }\n        return false;\n    }\n    /** @internal */\n    async handleDrop(evt) {\n        evt.preventDefault();\n        await this.handlePaste(evt);\n    }\n    /** @internal */\n    async handlePaste(evt) {\n        const target = document.querySelector(':focus') ?? evt.target;\n        if (!this.isEventSink(target)) {\n            return;\n        }\n        return await new ClipboardHandler(this).paste(evt);\n    }\n    /**\n     * Forward pointer events from `elem` to this editor. Such that right-click/right-click drag\n     * events are also forwarded, `elem`'s contextmenu is disabled.\n     *\n     * `filter` is called once per pointer event, before doing any other processing. If `filter` returns `true` the event is\n     * forwarded to the editor.\n     *\n     * **Note**: `otherEventsFilter` is like `filter`, but is called for other pointer-related\n     * events that could also be forwarded to the editor. To forward just pointer events,\n     * for example, `otherEventsFilter` could be given as `()=>false`.\n     *\n     * @example\n     * ```ts\n     * const overlay = document.createElement('div');\n     * editor.createHTMLOverlay(overlay);\n     *\n     * // Send all pointer events that don't have the control key pressed\n     * // to the editor.\n     * editor.handlePointerEventsFrom(overlay, (event) => {\n     *   if (event.ctrlKey) {\n     *     return false;\n     *   }\n     *   return true;\n     * });\n     * ```\n     */\n    handlePointerEventsFrom(elem, filter, otherEventsFilter) {\n        // May be required to prevent text selection on iOS/Safari:\n        // See https://stackoverflow.com/a/70992717/17055750\n        const touchstartListener = (evt) => {\n            if (otherEventsFilter && !otherEventsFilter('touchstart', evt)) {\n                return;\n            }\n            evt.preventDefault();\n        };\n        const contextmenuListener = (evt) => {\n            if (otherEventsFilter && !otherEventsFilter('contextmenu', evt)) {\n                return;\n            }\n            // Don't show a context menu\n            evt.preventDefault();\n        };\n        const listeners = {\n            touchstart: touchstartListener,\n            contextmenu: contextmenuListener,\n        };\n        const eventNames = [\n            'pointerdown',\n            'pointermove',\n            'pointerup',\n            'pointercancel',\n        ];\n        for (const eventName of eventNames) {\n            listeners[eventName] = (evt) => {\n                // This listener will only be called in the context of PointerEvents.\n                const event = evt;\n                if (filter && !filter(eventName, event)) {\n                    return undefined;\n                }\n                return this.handleHTMLPointerEvent(eventName, event);\n            };\n        }\n        // Add all listeners.\n        for (const eventName in listeners) {\n            elem.addEventListener(eventName, listeners[eventName]);\n        }\n        return {\n            /** Remove all event listeners registered by this function. */\n            remove: () => {\n                for (const eventName in listeners) {\n                    elem.removeEventListener(eventName, listeners[eventName]);\n                }\n            },\n        };\n    }\n    /**\n     * Like {@link handlePointerEventsFrom} except ignores short input gestures like clicks.\n     *\n     * `filter` is called once per event, before doing any other processing. If `filter` returns `true` the event is\n     * forwarded to the editor.\n     *\n     * `otherEventsFilter` is passed unmodified to `handlePointerEventsFrom`.\n     */\n    handlePointerEventsExceptClicksFrom(elem, filter, otherEventsFilter) {\n        // Maps pointer IDs to gesture start points\n        const gestureData = Object.create(null);\n        return this.handlePointerEventsFrom(elem, (eventName, event) => {\n            if (filter && !filter(eventName, event)) {\n                return false;\n            }\n            // Position of the current event.\n            // jsdom doesn't seem to support pageX/pageY -- use clientX/clientY if unavailable\n            const currentPos = Vec2.of(event.pageX ?? event.clientX, event.pageY ?? event.clientY);\n            const pointerId = event.pointerId ?? 0;\n            // Whether to send the current event to the editor\n            let sendToEditor = true;\n            if (eventName === 'pointerdown') {\n                // Buffer the event, but don't send it to the editor yet.\n                // We don't want to send single-click events, but we do want to send full strokes.\n                gestureData[pointerId] = {\n                    eventBuffer: [[eventName, event]],\n                    startPoint: currentPos,\n                    hasMovedSignificantly: false,\n                };\n                // Capture the pointer so we receive future events even if the overlay is hidden.\n                this.setPointerCapture(elem, event.pointerId);\n                // Don't send to the editor.\n                sendToEditor = false;\n            }\n            else if (eventName === 'pointermove' && gestureData[pointerId]) {\n                const gestureStartPos = gestureData[pointerId].startPoint;\n                const eventBuffer = gestureData[pointerId].eventBuffer;\n                // Skip if the pointer hasn't moved enough to not be a \"click\".\n                const strokeStartThreshold = 10;\n                const isWithinClickThreshold = gestureStartPos && currentPos.distanceTo(gestureStartPos) < strokeStartThreshold;\n                if (isWithinClickThreshold && !gestureData[pointerId].hasMovedSignificantly) {\n                    eventBuffer.push([eventName, event]);\n                    sendToEditor = false;\n                }\n                else {\n                    // Send all buffered events to the editor -- start the stroke.\n                    for (const [eventName, event] of eventBuffer) {\n                        this.handleHTMLPointerEvent(eventName, event);\n                    }\n                    gestureData[pointerId].eventBuffer = [];\n                    gestureData[pointerId].hasMovedSignificantly = true;\n                    sendToEditor = true;\n                }\n            }\n            // Pointers that aren't down -- send to the editor.\n            else if (eventName === 'pointermove') {\n                sendToEditor = true;\n            }\n            // Otherwise, if we received a pointerup/pointercancel without flushing all pointerevents from the\n            // buffer, the gesture wasn't recognised as a stroke. Thus, the editor isn't expecting a pointerup/\n            // pointercancel event.\n            else if ((eventName === 'pointerup' || eventName === 'pointercancel') &&\n                gestureData[pointerId] &&\n                gestureData[pointerId].eventBuffer.length > 0) {\n                this.releasePointerCapture(elem, event.pointerId);\n                // Don't send to the editor.\n                sendToEditor = false;\n                delete gestureData[pointerId];\n            }\n            // Forward all other events to the editor.\n            return sendToEditor;\n        }, otherEventsFilter);\n    }\n    /** @internal */\n    handleHTMLKeyDownEvent(htmlEvent) {\n        console.assert(htmlEvent.type === 'keydown', `handling a keydown event with type ${htmlEvent.type}`);\n        const event = keyPressEventFromHTMLEvent(htmlEvent);\n        if (this.toolController.dispatchInputEvent(event)) {\n            htmlEvent.preventDefault();\n            return true;\n        }\n        else if (event.key === 't' || event.key === 'T') {\n            htmlEvent.preventDefault();\n            this.display.rerenderAsText();\n            return true;\n        }\n        else if (event.key === 'Escape') {\n            this.renderingRegion.blur();\n            return true;\n        }\n        return false;\n    }\n    /** @internal */\n    handleHTMLKeyUpEvent(htmlEvent) {\n        console.assert(htmlEvent.type === 'keyup', `Handling a keyup event with type ${htmlEvent.type}`);\n        const event = keyUpEventFromHTMLEvent(htmlEvent);\n        if (this.toolController.dispatchInputEvent(event)) {\n            htmlEvent.preventDefault();\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Adds event listners for keypresses (and drop events) on `elem` and forwards those\n     * events to the editor.\n     *\n     * If the given `filter` returns `false` for an event, the event is ignored and not\n     * passed to the editor.\n     */\n    handleKeyEventsFrom(elem, filter = () => true) {\n        listenForKeyboardEventsFrom(elem, {\n            filter,\n            handleKeyDown: (htmlEvent) => {\n                this.handleHTMLKeyDownEvent(htmlEvent);\n            },\n            handleKeyUp: (htmlEvent) => {\n                this.handleHTMLKeyUpEvent(htmlEvent);\n            },\n            getHandlesKeyEventsFrom: (element) => {\n                return this.eventListenerTargets.includes(element);\n            },\n        });\n        // Allow drop.\n        elem.ondragover = (evt) => {\n            evt.preventDefault();\n        };\n        elem.ondrop = (evt) => {\n            this.handleDrop(evt);\n        };\n        this.eventListenerTargets.push(elem);\n    }\n    /**\n     * Attempts to prevent **user-triggered** events from modifying\n     * the content of the image.\n     */\n    setReadOnly(readOnly) {\n        if (readOnly !== this.readOnly.get()) {\n            this.readOnly.set(readOnly);\n            this.notifier.dispatch(EditorEventType.ReadOnlyModeToggled, {\n                kind: EditorEventType.ReadOnlyModeToggled,\n                editorIsReadOnly: readOnly,\n            });\n        }\n    }\n    // @internal\n    isReadOnlyReactiveValue() {\n        return this.readOnly;\n    }\n    isReadOnly() {\n        return this.readOnly;\n    }\n    /**\n     * `apply` a command. `command` will be announced for accessibility.\n     *\n     * **Example**:\n     * [[include:doc-pages/inline-examples/adding-a-stroke.md]]\n     */\n    dispatch(command, addToHistory = true) {\n        const dispatchResult = this.dispatchNoAnnounce(command, addToHistory);\n        const commandDescription = command.description(this, this.localization);\n        this.announceForAccessibility(commandDescription);\n        return dispatchResult;\n    }\n    /**\n     * Dispatches a command without announcing it. By default, does not add to history.\n     * Use this to show finalized commands that don't need to have `announceForAccessibility`\n     * called.\n     *\n     * If `addToHistory` is `false`, this is equivalent to `command.apply(editor)`.\n     *\n     * @example\n     * ```\n     * const addToHistory = false;\n     * editor.dispatchNoAnnounce(editor.viewport.zoomTo(someRectangle), addToHistory);\n     * ```\n     */\n    dispatchNoAnnounce(command, addToHistory = false) {\n        const result = command.apply(this);\n        if (addToHistory) {\n            const apply = false; // Don't double-apply\n            this.history.push(command, apply);\n        }\n        return result;\n    }\n    /**\n     * Apply a large transformation in chunks.\n     * If `apply` is `false`, the commands are unapplied.\n     * Triggers a re-render after each `updateChunkSize`-sized group of commands\n     * has been applied.\n     */\n    async asyncApplyOrUnapplyCommands(commands, apply, updateChunkSize) {\n        console.assert(updateChunkSize > 0);\n        this.display.setDraftMode(true);\n        for (let i = 0; i < commands.length; i += updateChunkSize) {\n            this.showLoadingWarning(i / commands.length);\n            for (let j = i; j < commands.length && j < i + updateChunkSize; j++) {\n                const cmd = commands[j];\n                if (apply) {\n                    cmd.apply(this);\n                }\n                else {\n                    cmd.unapply(this);\n                }\n            }\n            // Re-render to show progress, but only if we're not done.\n            if (i + updateChunkSize < commands.length) {\n                await new Promise((resolve) => {\n                    this.rerender();\n                    requestAnimationFrame(resolve);\n                });\n            }\n        }\n        this.display.setDraftMode(false);\n        this.hideLoadingWarning();\n    }\n    /** @see {@link asyncApplyOrUnapplyCommands } */\n    asyncApplyCommands(commands, chunkSize) {\n        return this.asyncApplyOrUnapplyCommands(commands, true, chunkSize);\n    }\n    /**\n     * @see {@link asyncApplyOrUnapplyCommands}\n     *\n     * If `unapplyInReverseOrder`, commands are reversed before unapplying.\n     */\n    asyncUnapplyCommands(commands, chunkSize, unapplyInReverseOrder = false) {\n        if (unapplyInReverseOrder) {\n            commands = [...commands]; // copy\n            commands.reverse();\n        }\n        return this.asyncApplyOrUnapplyCommands(commands, false, chunkSize);\n    }\n    /**\n     * Schedule a re-render for some time in the near future. Does not schedule an additional\n     * re-render if a re-render is already queued.\n     *\n     * @returns a promise that resolves when re-rendering has completed.\n     */\n    queueRerender() {\n        if (!this.rerenderQueued) {\n            this.rerenderQueued = true;\n            requestAnimationFrame(() => {\n                // If .rerender was called manually, we might not need to\n                // re-render.\n                if (this.rerenderQueued) {\n                    this.rerender();\n                    this.rerenderQueued = false;\n                }\n            });\n        }\n        return new Promise((resolve) => {\n            this.nextRerenderListeners.push(() => resolve());\n        });\n    }\n    // @internal\n    isRerenderQueued() {\n        return this.rerenderQueued;\n    }\n    /**\n     * Re-renders the entire image.\n     *\n     * @see {@link Editor.queueRerender}\n     */\n    rerender(showImageBounds = true) {\n        this.display.startRerender();\n        // Don't render if the display has zero size.\n        if (this.display.width === 0 || this.display.height === 0) {\n            return;\n        }\n        const renderer = this.display.getDryInkRenderer();\n        this.image.renderWithCache(renderer, this.display.getCache(), this.viewport);\n        // Draw a rectangle around the region that will be visible on save\n        if (showImageBounds && !this.image.getAutoresizeEnabled()) {\n            const exportRectFill = { fill: Color4.fromHex('#44444455') };\n            const exportRectStrokeWidth = 5 * this.viewport.getSizeOfPixelOnCanvas();\n            renderer.drawRect(this.getImportExportRect(), exportRectStrokeWidth, exportRectFill);\n        }\n        this.rerenderQueued = false;\n        this.nextRerenderListeners.forEach((listener) => listener());\n        this.nextRerenderListeners = [];\n    }\n    /**\n     * Draws the given path onto the wet ink renderer. The given path will\n     * be displayed on top of the main image.\n     *\n     * @see {@link Display.getWetInkRenderer} {@link Display.flatten}\n     */\n    drawWetInk(...path) {\n        for (const part of path) {\n            this.display.getWetInkRenderer().drawPath(part);\n        }\n    }\n    /**\n     * Clears the wet ink display.\n     *\n     * The wet ink display can be used by the currently active tool to display a preview\n     * of an in-progress action.\n     *\n     * @see {@link Display.getWetInkRenderer}\n     */\n    clearWetInk() {\n        this.display.getWetInkRenderer().clear();\n    }\n    /**\n     * Focuses the region used for text input/key commands.\n     */\n    focus() {\n        this.renderingRegion.focus();\n    }\n    /**\n     * Creates an element that will be positioned on top of the dry/wet ink\n     * renderers.\n     *\n     * So as not to change the position of other overlays, `overlay` should either\n     * be styled to have 0 height or have `position: absolute`.\n     *\n     * This is useful for displaying content on top of the rendered content\n     * (e.g. a selection box).\n     */\n    createHTMLOverlay(overlay) {\n        // TODO(v2): Fix conflict with toolbars that have been added to the editor.\n        overlay.classList.add('overlay', 'js-draw-editor-overlay');\n        this.container.appendChild(overlay);\n        return {\n            remove: () => overlay.remove(),\n        };\n    }\n    /**\n     * Anchors the given `element` to the canvas with a given position/transformation in canvas space.\n     */\n    anchorElementToCanvas(element, canvasTransform) {\n        if (canvasTransform instanceof Mat33) {\n            canvasTransform = ReactiveValue.fromImmutable(canvasTransform);\n        }\n        // The element hierarchy looks like this:\n        //   overlay > contentWrapper > content\n        //\n        // Both contentWrapper and overlay are present to:\n        // 1. overlay: Positions the content at the top left of the viewport. The overlay\n        //    has `height: 0` to allow other overlays to also be aligned with the viewport's\n        //    top left.\n        // 2. contentWrapper: Has the same width/height as the editor's visible region and\n        //    has `overflow: hidden`. This prevents the anchored element from being visible\n        //    when not in the visible region of the canvas.\n        const overlay = document.createElement('div');\n        overlay.classList.add('anchored-element-overlay');\n        const contentWrapper = document.createElement('div');\n        contentWrapper.classList.add('content-wrapper');\n        element.classList.add('content');\n        // Updates CSS variables that specify the position/rotation/scale of the content.\n        const updateElementPositioning = () => {\n            const transform = canvasTransform.get();\n            const canvasRotation = transform.transformVec3(Vec2.unitX).angle();\n            const screenRotation = canvasRotation + this.viewport.getRotationAngle();\n            const screenTransform = this.viewport.canvasToScreenTransform.rightMul(canvasTransform.get());\n            overlay.style.setProperty('--full-transform', screenTransform.toCSSMatrix());\n            const translation = screenTransform.transformVec2(Vec2.zero);\n            overlay.style.setProperty('--position-x', `${translation.x}px`);\n            overlay.style.setProperty('--position-y', `${translation.y}px`);\n            overlay.style.setProperty('--rotation', `${(screenRotation * 180) / Math.PI}deg`);\n            overlay.style.setProperty('--scale', `${screenTransform.getScaleFactor()}`);\n        };\n        updateElementPositioning();\n        // The anchored element needs to be updated both when the user moves the canvas\n        // and when the anchored element's transform changes.\n        const updateListener = canvasTransform.onUpdate(updateElementPositioning);\n        const viewportListener = this.notifier.on(EditorEventType.ViewportChanged, updateElementPositioning);\n        contentWrapper.appendChild(element);\n        overlay.appendChild(contentWrapper);\n        overlay.classList.add('overlay', 'js-draw-editor-overlay');\n        this.renderingRegion.insertAdjacentElement('afterend', overlay);\n        return {\n            remove: () => {\n                overlay.remove();\n                updateListener.remove();\n                viewportListener.remove();\n            },\n        };\n    }\n    /**\n     * Creates a CSS stylesheet with `content` and applies it to the document\n     * (and thus, to this editor).\n     */\n    addStyleSheet(content) {\n        const styleSheet = document.createElement('style');\n        styleSheet.innerText = content;\n        this.container.appendChild(styleSheet);\n        return styleSheet;\n    }\n    /**\n     * Dispatch a keyboard event to the currently selected tool.\n     * Intended for unit testing.\n     *\n     * If `shiftKey` is undefined, it is guessed from `key`.\n     *\n     * At present, the **key code** dispatched is guessed from the given key and,\n     * while this works for ASCII alphanumeric characters, this does not work for\n     * most non-alphanumeric keys.\n     *\n     * Because guessing the key code from `key` is problematic, **only use this for testing**.\n     */\n    sendKeyboardEvent(eventType, key, ctrlKey = false, altKey = false, shiftKey = undefined) {\n        shiftKey ??= key.toUpperCase() === key && key.toLowerCase() !== key;\n        this.toolController.dispatchInputEvent({\n            kind: eventType,\n            key,\n            code: guessKeyCodeFromKey(key),\n            ctrlKey,\n            altKey,\n            shiftKey,\n        });\n    }\n    /**\n     * Dispatch a pen event to the currently selected tool.\n     * Intended primarially for unit tests.\n     *\n     * @deprecated\n     * @see {@link sendPenEvent} {@link sendTouchEvent}\n     */\n    sendPenEvent(eventType, point, \n    // @deprecated\n    allPointers) {\n        sendPenEvent(this, eventType, point, allPointers);\n    }\n    /**\n     * Adds all components in `components` such that they are in the center of the screen.\n     * This is a convenience method that creates **and applies** a single command.\n     *\n     * If `selectComponents` is true (the default), the components are selected.\n     *\n     * `actionDescription`, if given, should be a screenreader-friendly description of the\n     * reason components were added (e.g. \"pasted\").\n     */\n    async addAndCenterComponents(components, selectComponents = true, actionDescription) {\n        let bbox = null;\n        for (const component of components) {\n            if (bbox) {\n                bbox = bbox.union(component.getBBox());\n            }\n            else {\n                bbox = component.getBBox();\n            }\n        }\n        if (!bbox) {\n            return;\n        }\n        // Find a transform that scales/moves bbox onto the screen.\n        const visibleRect = this.viewport.visibleRect;\n        const scaleRatioX = visibleRect.width / bbox.width;\n        const scaleRatioY = visibleRect.height / bbox.height;\n        let scaleRatio = scaleRatioX;\n        if (bbox.width * scaleRatio > visibleRect.width ||\n            bbox.height * scaleRatio > visibleRect.height) {\n            scaleRatio = scaleRatioY;\n        }\n        scaleRatio *= 2 / 3;\n        scaleRatio = Viewport.roundScaleRatio(scaleRatio);\n        const transfm = Mat33.translation(visibleRect.center.minus(bbox.center)).rightMul(Mat33.scaling2D(scaleRatio, bbox.center));\n        const commands = [];\n        for (const component of components) {\n            // To allow deserialization, we need to add first, then transform.\n            commands.push(EditorImage.addElement(component));\n            commands.push(component.transformBy(transfm));\n        }\n        const applyChunkSize = 100;\n        await this.dispatch(uniteCommands(commands, { applyChunkSize, description: actionDescription }), true);\n        if (selectComponents) {\n            for (const selectionTool of this.toolController.getMatchingTools(SelectionTool)) {\n                selectionTool.setEnabled(true);\n                selectionTool.setSelection(components);\n            }\n        }\n    }\n    /**\n     * Get a data URL (e.g. as produced by `HTMLCanvasElement::toDataURL`).\n     * If `format` is not `image/png`, a PNG image URL may still be returned (as in the\n     * case of `HTMLCanvasElement::toDataURL`).\n     *\n     * The export resolution is the same as the size of the drawing canvas, unless `outputSize`\n     * is given.\n     *\n     * **Example**:\n     * [[include:doc-pages/inline-examples/adding-an-image-and-data-urls.md]]\n     */\n    toDataURL(format = 'image/png', outputSize) {\n        const { element: canvas, renderer } = CanvasRenderer.fromViewport(this.image.getImportExportViewport(), { canvasSize: outputSize });\n        this.image.renderAll(renderer);\n        const dataURL = canvas.toDataURL(format);\n        return dataURL;\n    }\n    /**\n     * Converts the editor's content into an SVG image.\n     *\n     * If the output SVG has width or height less than `options.minDimension`, its size\n     * will be increased.\n     *\n     * @see\n     * {@link SVGRenderer}\n     */\n    toSVG(options) {\n        return editorImageToSVGSync(this.image, options ?? {});\n    }\n    /**\n     * Converts the editor's content into an SVG image in an asynchronous,\n     * but **potentially lossy** way.\n     *\n     * **Warning**: If the image is being edited during an async rendering, edited components\n     * may not be rendered.\n     *\n     * Like {@link toSVG}, but can be configured to briefly pause after processing every\n     * `pauseAfterCount` items. This can prevent the editor from becoming unresponsive\n     * when saving very large images.\n     */\n    async toSVGAsync(options = {}) {\n        const pauseAfterCount = options.pauseAfterCount ?? 100;\n        return await editorImageToSVGAsync(this.image, async (_component, processedCount, totalComponents) => {\n            if (options.onProgress) {\n                const shouldContinue = await options.onProgress(processedCount, totalComponents);\n                if (shouldContinue === false) {\n                    return false;\n                }\n            }\n            if (processedCount % pauseAfterCount === 0) {\n                await untilNextAnimationFrame();\n            }\n            return true;\n        }, {\n            minDimension: options.minDimension,\n        });\n    }\n    /**\n     * Load editor data from an `ImageLoader` (e.g. an {@link SVGLoader}).\n     *\n     * @see loadFromSVG\n     */\n    async loadFrom(loader) {\n        this.showLoadingWarning(0);\n        this.display.setDraftMode(true);\n        const originalBackgrounds = this.image.getBackgroundComponents();\n        const eraseBackgroundCommand = new Erase(originalBackgrounds);\n        await loader.start(async (component) => {\n            await this.dispatchNoAnnounce(EditorImage.addElement(component));\n        }, (countProcessed, totalToProcess) => {\n            if (countProcessed % 500 === 0) {\n                this.showLoadingWarning(countProcessed / totalToProcess);\n                this.rerender();\n                return untilNextAnimationFrame();\n            }\n            return null;\n        }, (importExportRect, options) => {\n            this.dispatchNoAnnounce(this.setImportExportRect(importExportRect), false);\n            this.dispatchNoAnnounce(this.viewport.zoomTo(importExportRect), false);\n            if (options) {\n                this.dispatchNoAnnounce(this.image.setAutoresizeEnabled(options.autoresize), false);\n            }\n        });\n        // Ensure that we don't have multiple overlapping BackgroundComponents. Remove\n        // old BackgroundComponents.\n        // Overlapping BackgroundComponents may cause changing the background color to\n        // not work properly.\n        if (this.image.getBackgroundComponents().length !== originalBackgrounds.length) {\n            await this.dispatchNoAnnounce(eraseBackgroundCommand);\n        }\n        this.hideLoadingWarning();\n        this.display.setDraftMode(false);\n        this.queueRerender();\n    }\n    getTopmostBackgroundComponent() {\n        let background = null;\n        // Find a background component, if one exists.\n        // Use the last (topmost) background component if there are multiple.\n        for (const component of this.image.getBackgroundComponents()) {\n            if (component instanceof BackgroundComponent) {\n                background = component;\n            }\n        }\n        return background;\n    }\n    /**\n     * This is a convenience method for adding or updating the {@link BackgroundComponent}\n     * and {@link EditorImage.setAutoresizeEnabled} for the current image.\n     *\n     * If there are multiple {@link BackgroundComponent}s in the image, this only modifies\n     * the topmost such element.\n     *\n     * **Example**:\n     * ```ts,runnable\n     * import { Editor, Color4, BackgroundComponentBackgroundType } from 'js-draw';\n     * const editor = new Editor(document.body);\n     * editor.dispatch(editor.setBackgroundStyle({\n     *     color: Color4.orange,\n     *     type: BackgroundComponentBackgroundType.Grid,\n     *     autoresize: true,\n     * }));\n     * ```\n     *\n     * To change the background size, see {@link EditorImage.setImportExportRect}.\n     */\n    setBackgroundStyle(style) {\n        const originalBackground = this.getTopmostBackgroundComponent();\n        const commands = [];\n        if (originalBackground) {\n            commands.push(new Erase([originalBackground]));\n        }\n        const originalType = originalBackground?.getBackgroundType?.() ?? BackgroundType.None;\n        const originalColor = originalBackground?.getStyle?.().color ?? Color4.transparent;\n        const originalFillsScreen = this.image.getAutoresizeEnabled();\n        const defaultType = style.color && originalType === BackgroundType.None\n            ? BackgroundType.SolidColor\n            : originalType;\n        const backgroundType = style.type ?? defaultType;\n        const backgroundColor = style.color ?? originalColor;\n        const fillsScreen = style.autoresize ?? originalFillsScreen;\n        if (backgroundType !== BackgroundType.None) {\n            const newBackground = new BackgroundComponent(backgroundType, backgroundColor);\n            commands.push(EditorImage.addElement(newBackground));\n        }\n        if (fillsScreen !== originalFillsScreen) {\n            commands.push(this.image.setAutoresizeEnabled(fillsScreen));\n            // Avoid 0x0 backgrounds\n            if (!fillsScreen && this.image.getImportExportRect().maxDimension === 0) {\n                commands.push(this.image.setImportExportRect(this.image.getImportExportRect().resizedTo(Vec2.of(500, 500))));\n            }\n        }\n        return uniteCommands(commands);\n    }\n    /**\n     * Set the background color of the image.\n     *\n     * This is a convenience method for adding or updating the {@link BackgroundComponent}\n     * for the current image.\n     *\n     * @see {@link setBackgroundStyle}\n     */\n    setBackgroundColor(color) {\n        let background = this.getTopmostBackgroundComponent();\n        if (!background) {\n            const backgroundType = color.eq(Color4.transparent)\n                ? BackgroundType.None\n                : BackgroundType.SolidColor;\n            background = new BackgroundComponent(backgroundType, color);\n            return this.image.addElement(background);\n        }\n        else {\n            return background.updateStyle({ color });\n        }\n    }\n    /**\n     * @returns the average of the colors of all background components. Use this to get the current background\n     * color.\n     */\n    estimateBackgroundColor() {\n        const backgroundColors = [];\n        for (const component of this.image.getBackgroundComponents()) {\n            if (component instanceof BackgroundComponent) {\n                backgroundColors.push(component.getStyle().color ?? Color4.transparent);\n            }\n        }\n        return Color4.average(backgroundColors);\n    }\n    // Returns the size of the visible region of the output SVG\n    getImportExportRect() {\n        return this.image.getImportExportViewport().visibleRect;\n    }\n    // Resize the output SVG to match `imageRect`.\n    setImportExportRect(imageRect) {\n        return this.image.setImportExportRect(imageRect);\n    }\n    /**\n     * Alias for `loadFrom(SVGLoader.fromString)`.\n     *\n     * @example\n     * ```ts,runnable\n     * import {Editor} from 'js-draw';\n     * const editor = new Editor(document.body);\n     *\n     * ---visible---\n     * await editor.loadFromSVG(`\n     *   <svg viewBox=\"5 23 52 30\" width=\"52\" height=\"16\" version=\"1.1\" baseProfile=\"full\" xmlns=\"http://www.w3.org/2000/svg\">\n     *     <text style=\"\n     *       transform: matrix(0.181846, 0.1, 0, 0.181846, 11.4, 33.2);\n     *       font-family: serif;\n     *       font-size: 32px;\n     *       fill: rgb(100, 140, 61);\n     *     \">An SVG image!</text>\n     *   </svg>\n     * `);\n     * ```\n     */\n    async loadFromSVG(svgData, sanitize = false) {\n        const loader = SVGLoader.fromString(svgData, sanitize);\n        await this.loadFrom(loader);\n    }\n    /**\n     * Shows an information dialog with legal notices.\n     */\n    showAboutDialog() {\n        const iconLicenseText = this.icons.licenseInfo();\n        const notices = [];\n        if (this.settings.appInfo) {\n            const descriptionLines = [];\n            if (this.settings.appInfo.version) {\n                descriptionLines.push(`v${this.settings.appInfo.version}`, '');\n            }\n            if (this.settings.appInfo.description) {\n                descriptionLines.push(this.settings.appInfo.description + '\\n');\n            }\n            else {\n                descriptionLines.push(`js-draw v${version.number}`);\n            }\n            notices.push({\n                heading: `${this.settings.appInfo.name}`,\n                text: descriptionLines.join('\\n'),\n            });\n        }\n        else {\n            notices.push({\n                heading: 'js-draw',\n                text: `v${version.number}`,\n            });\n        }\n        const screenSize = this.viewport.getScreenRectSize();\n        notices.push({\n            heading: this.localization.developerInformation,\n            text: [\n                'Image debug information (from when this dialog was opened):',\n                `    ${this.viewport.getScaleFactor()}x zoom, ${(180 / Math.PI) * this.viewport.getRotationAngle()}° rotation`,\n                `    ${this.image.estimateNumElements()} components`,\n                `    auto-resize: ${this.image.getAutoresizeEnabled() ? 'enabled' : 'disabled'}`,\n                `    image size: ${this.getImportExportRect().w}x${this.getImportExportRect().h}`,\n                `    screen size: ${screenSize.x}x${screenSize.y}`,\n                `    device pixel ratio: ${this.display.getDevicePixelRatio()}`,\n                '    cache:',\n                `        ${this.display\n                    .getCache()\n                    .getDebugInfo()\n                    // Indent\n                    .replace(/([\\n])/g, '\\n        ')}`,\n            ].join('\\n'),\n            minimized: true,\n        });\n        notices.push({\n            heading: this.localization.softwareLibraries,\n            text: [\n                `This image editor is powered by js-draw v${version.number}.`,\n                '',\n                'At runtime, js-draw uses',\n                ' - The Coloris color picker: https://github.com/mdbassit/Coloris',\n                ' - The bezier.js Bézier curve library: https://github.com/Pomax/bezierjs',\n                '',\n                'Both are licensed under the MIT license:',\n                '',\n                '',\n                '== Coloris ==',\n                mitLicenseAttribution('2021 Mohammed Bassit'),\n                '',\n                '',\n                '== Bezier.js ==',\n                mitLicenseAttribution('2023 Mike \"Pomax\" Kamermans'),\n                '',\n                '',\n                '== js-draw ==',\n                mitLicenseAttribution('2023-2025 Henry Heino'),\n                '',\n            ].join('\\n'),\n            minimized: true,\n        });\n        if (iconLicenseText) {\n            notices.push({\n                heading: 'Icon Pack',\n                text: iconLicenseText,\n                minimized: true,\n            });\n        }\n        notices.push(...this.settings.notices);\n        this.closeAboutDialog?.();\n        this.closeAboutDialog = makeAboutDialog(this, notices).close;\n    }\n    /**\n     * Removes and **destroys** the editor. The editor cannot be added to a parent\n     * again after calling this method.\n     */\n    remove() {\n        this.container.remove();\n        // TODO: Is additional cleanup necessary here?\n        this.toolController.onEditorDestroyed();\n    }\n}\nexport default Editor;\n","// Code shared with Joplin (from when it was MIT licensed)\n// (js-draw was originally intended to be part of Joplin).\n/**\n * Handles notifying listeners of events.\n *\n * `EventKeyType` is used to distinguish events (e.g. a `ClickEvent` vs a `TouchEvent`)\n * while `EventMessageType` is the type of the data sent with an event (can be `void`).\n *\n * @example\n * ```\n * const dispatcher = new EventDispatcher<'event1'|'event2'|'event3', void>();\n * dispatcher.on('event1', () => {\n *   console.log('Event 1 triggered.');\n * });\n * dispatcher.dispatch('event1');\n * ```\n *\n */\nexport default class EventDispatcher {\n    constructor() {\n        this.listeners = {};\n    }\n    dispatch(eventName, event) {\n        const listenerList = this.listeners[eventName];\n        if (listenerList) {\n            for (let i = 0; i < listenerList.length; i++) {\n                listenerList[i](event);\n            }\n        }\n    }\n    on(eventName, callback) {\n        if (!this.listeners[eventName])\n            this.listeners[eventName] = [];\n        this.listeners[eventName].push(callback);\n        return {\n            // Retuns false if the listener has already been removed, true otherwise.\n            remove: () => {\n                const originalListeners = this.listeners[eventName];\n                this.off(eventName, callback);\n                return originalListeners.length !== this.listeners[eventName].length;\n            },\n        };\n    }\n    /** Removes an event listener. This is equivalent to calling `.remove()` on the object returned by `.on`. */\n    off(eventName, callback) {\n        const listeners = this.listeners[eventName];\n        if (!listeners)\n            return;\n        // Replace the current list of listeners with a new, shortened list.\n        // This allows any iterators over this.listeners to continue iterating\n        // without skipping elements.\n        this.listeners[eventName] = listeners.filter((otherCallback) => otherCallback !== callback);\n    }\n}\n","import { Vec2 } from '@js-draw/math';\nexport var PointerDevice;\n(function (PointerDevice) {\n    PointerDevice[PointerDevice[\"Pen\"] = 0] = \"Pen\";\n    PointerDevice[PointerDevice[\"Eraser\"] = 1] = \"Eraser\";\n    PointerDevice[PointerDevice[\"Touch\"] = 2] = \"Touch\";\n    PointerDevice[PointerDevice[\"PrimaryButtonMouse\"] = 3] = \"PrimaryButtonMouse\";\n    PointerDevice[PointerDevice[\"RightButtonMouse\"] = 4] = \"RightButtonMouse\";\n    PointerDevice[PointerDevice[\"Other\"] = 5] = \"Other\";\n})(PointerDevice || (PointerDevice = {}));\n// Provides a snapshot containing information about a pointer. A Pointer\n// object is immutable — it will not be updated when the pointer's information changes.\nexport default class Pointer {\n    constructor(\n    // The (x, y) position of the pointer relative to the top-left corner\n    // of the visible canvas.\n    screenPos, \n    // Position of the pointer relative to the top left corner of the drawing\n    // surface.\n    canvasPos, pressure, isPrimary, down, device, \n    // Unique ID for the pointer\n    id, \n    // Numeric timestamp (milliseconds, as from `performance.now()`).\n    timeStamp) {\n        this.screenPos = screenPos;\n        this.canvasPos = canvasPos;\n        this.pressure = pressure;\n        this.isPrimary = isPrimary;\n        this.down = down;\n        this.device = device;\n        this.id = id;\n        this.timeStamp = timeStamp;\n    }\n    /**\n     * Snaps this pointer to the nearest grid point (rounds the coordinates of this\n     * pointer based on the current zoom). Returns a new Pointer and does not modify\n     * this.\n     */\n    snappedToGrid(viewport) {\n        const snappedCanvasPos = viewport.snapToGrid(this.canvasPos);\n        return this.withCanvasPosition(snappedCanvasPos, viewport);\n    }\n    // Snap this pointer to the X or Y axis (whichever is closer), where (0,0)\n    // is considered to be at `originPointScreen`.\n    // @internal\n    lockedToXYAxesScreen(originPointScreen, viewport) {\n        const current = this.screenPos;\n        const currentFromStart = current.minus(originPointScreen);\n        // Determine whether the last point was closer to being on the\n        // x- or y- axis.\n        const projOntoXAxis = Vec2.unitX.times(currentFromStart.x);\n        const projOntoYAxis = Vec2.unitY.times(currentFromStart.y);\n        let pos;\n        if (currentFromStart.dot(projOntoXAxis) > currentFromStart.dot(projOntoYAxis)) {\n            pos = projOntoXAxis;\n        }\n        else {\n            pos = projOntoYAxis;\n        }\n        pos = pos.plus(originPointScreen);\n        return this.withScreenPosition(pos, viewport);\n    }\n    /** @see {@link withCanvasPosition} */\n    withScreenPosition(screenPos, viewport) {\n        const canvasPos = viewport.screenToCanvas(screenPos);\n        return this.withCanvasPosition(canvasPos, viewport);\n    }\n    /** Returns a copy of this pointer with a changed timestamp. */\n    withTimestamp(timeStamp) {\n        return new Pointer(this.screenPos, this.canvasPos, this.pressure, this.isPrimary, this.down, this.device, this.id, timeStamp);\n    }\n    /**\n     * Returns a copy of this pointer with a new position. The screen position is determined\n     * by the given `canvasPos`.\n     */\n    withCanvasPosition(canvasPos, viewport) {\n        const screenPos = viewport.canvasToScreen(canvasPos);\n        return new Pointer(screenPos, canvasPos, this.pressure, this.isPrimary, this.down, this.device, this.id, this.timeStamp);\n    }\n    // Creates a Pointer from a DOM event. If `relativeTo` is given, (0, 0) in screen coordinates is\n    // considered the top left of `relativeTo`.\n    static ofEvent(evt, isDown, viewport, relativeTo) {\n        let screenPos = Vec2.of(evt.clientX, evt.clientY);\n        if (relativeTo) {\n            const bbox = relativeTo.getBoundingClientRect();\n            screenPos = screenPos.minus(Vec2.of(bbox.left, bbox.top));\n        }\n        const pointerTypeToDevice = {\n            mouse: PointerDevice.PrimaryButtonMouse,\n            pen: PointerDevice.Pen,\n            touch: PointerDevice.Touch,\n        };\n        let device = pointerTypeToDevice[evt.pointerType] ?? PointerDevice.Other;\n        const eraserButtonMask = 0x20;\n        if (device === PointerDevice.Pen && (evt.buttons & eraserButtonMask) !== 0) {\n            device = PointerDevice.Eraser;\n        }\n        const timeStamp = evt.timeStamp;\n        const canvasPos = viewport.roundPoint(viewport.screenToCanvas(screenPos));\n        if (device === PointerDevice.PrimaryButtonMouse) {\n            if (evt.buttons & 0x2) {\n                device = PointerDevice.RightButtonMouse;\n            }\n            // Commented out: Mouse up events seem to not satisfy this condition on mouse up.\n            // else if (!(evt.buttons & 0x1)) {\n            //\tdevice = PointerDevice.Other;\n            //}\n        }\n        return new Pointer(screenPos, canvasPos, evt.pressure ?? null, evt.isPrimary, isDown, device, evt.pointerId, timeStamp);\n    }\n    // Create a new Pointer from a point on the canvas.\n    // Intended for unit tests.\n    static ofCanvasPoint(canvasPos, isDown, viewport, id = 0, device = PointerDevice.Pen, isPrimary = true, pressure = null, timeStamp = null) {\n        const screenPos = viewport.canvasToScreen(canvasPos);\n        timeStamp ??= performance.now();\n        return new Pointer(screenPos, canvasPos, pressure, isPrimary, isDown, device, id, timeStamp);\n    }\n    // Create a new Pointer from a point on the screen.\n    // Intended for unit tests.\n    static ofScreenPoint(screenPos, isDown, viewport, id = 0, device = PointerDevice.Pen, isPrimary = true, pressure = null, timeStamp = null) {\n        const canvasPos = viewport.screenToCanvas(screenPos);\n        timeStamp ??= performance.now();\n        return new Pointer(screenPos, canvasPos, pressure, isPrimary, isDown, device, id, timeStamp);\n    }\n}\n","import { Color4, Mat33, Path, Rect2, Vec2 } from '@js-draw/math';\nimport  BackgroundComponent, { BackgroundType, backgroundTypeToClassNameMap, imageBackgroundCSSClassName, imageBackgroundGridSizeCSSPrefix, imageBackgroundNonAutomaticSecondaryColorCSSClassName, }  from '../components/BackgroundComponent.mjs';\nimport  ImageComponent  from '../components/ImageComponent.mjs';\nimport  Stroke  from '../components/Stroke.mjs';\nimport  SVGGlobalAttributesObject  from '../components/SVGGlobalAttributesObject.mjs';\nimport  TextComponent, { TextTransformMode }  from '../components/TextComponent.mjs';\nimport  UnknownSVGObject  from '../components/UnknownSVGObject.mjs';\nimport  { pathToRenderable }  from '../rendering/RenderablePathSpec.mjs';\nimport  { renderedStylesheetId }  from '../rendering/renderers/SVGRenderer.mjs';\nimport  determineFontSize  from './utils/determineFontSize.mjs';\n// Size of a loaded image if no size is specified.\nexport const defaultSVGViewRect = new Rect2(0, 0, 500, 500);\n// Key to retrieve unrecognised attributes from an AbstractComponent\nexport const svgAttributesDataKey = 'svgAttrs';\n// Like {@link svgAttributesDataKey}, but for styles\nexport const svgStyleAttributesDataKey = 'svgStyleAttrs';\n// Key that specifies the ID of an SVG element that contained a given node when the image\n// was first loaded.\nexport const svgLoaderAttributeContainerID = 'svgContainerID';\n// If present in the exported SVG's class list, the image will be\n// autoresized when components are added/removed.\nexport const svgLoaderAutoresizeClassName = 'js-draw--autoresize';\n// @internal\nexport var SVGLoaderLoadMethod;\n(function (SVGLoaderLoadMethod) {\n    SVGLoaderLoadMethod[\"IFrame\"] = \"iframe\";\n    SVGLoaderLoadMethod[\"DOMParser\"] = \"domparser\";\n})(SVGLoaderLoadMethod || (SVGLoaderLoadMethod = {}));\nconst supportedStrokeFillStyleAttrs = ['stroke', 'fill', 'stroke-width'];\n// Handles loading images from SVG.\nexport default class SVGLoader {\n    constructor(source, onFinish, options) {\n        this.source = source;\n        this.onFinish = onFinish;\n        this.onAddComponent = null;\n        this.onProgress = null;\n        this.onDetermineExportRect = null;\n        this.processedCount = 0;\n        this.totalToProcess = 0;\n        this.containerGroupIDs = [];\n        this.encounteredIDs = [];\n        this.storeUnknown = !(options.sanitize ?? false);\n        this.disableUnknownObjectWarnings = !!options.disableUnknownObjectWarnings;\n    }\n    // If [computedStyles] is given, it is preferred to directly accessing node's style object.\n    getStyle(node, computedStyles) {\n        let fill = Color4.transparent;\n        let stroke;\n        // If possible, use computedStyles (allows property inheritance).\n        // Chromium, however, sets .fill to a falsy, but not undefined value in some cases where\n        // styles are available. As such, use || instead of ??.\n        const fillAttribute = node.getAttribute('fill') ?? (computedStyles?.fill || node.style?.fill);\n        if (fillAttribute) {\n            try {\n                fill = Color4.fromString(fillAttribute);\n            }\n            catch {\n                console.error('Unknown fill color,', fillAttribute);\n            }\n        }\n        const strokeAttribute = node.getAttribute('stroke') ?? computedStyles?.stroke ?? node.style?.stroke ?? '';\n        const strokeWidthAttr = node.getAttribute('stroke-width') ??\n            computedStyles?.strokeWidth ??\n            node.style?.strokeWidth ??\n            '';\n        if (strokeAttribute && strokeWidthAttr) {\n            try {\n                let width = parseFloat(strokeWidthAttr ?? '1');\n                if (!isFinite(width)) {\n                    width = 0;\n                }\n                const strokeColor = Color4.fromString(strokeAttribute);\n                if (strokeColor.a > 0) {\n                    stroke = {\n                        width,\n                        color: strokeColor,\n                    };\n                }\n            }\n            catch (e) {\n                console.error('Error parsing stroke data:', e);\n            }\n        }\n        const style = {\n            fill,\n            stroke,\n        };\n        return style;\n    }\n    strokeDataFromElem(node) {\n        const result = [];\n        const pathData = node.getAttribute('d') ?? '';\n        const style = this.getStyle(node);\n        // Break the path into chunks at each moveTo ('M') command:\n        const parts = pathData.split('M');\n        let isFirst = true;\n        for (const part of parts) {\n            // Skip effective no-ops -- moveTos without additional commands.\n            const isNoOpMoveTo = /^[0-9., \\t\\n]+$/.exec(part);\n            if (part !== '' && !isNoOpMoveTo) {\n                // We split the path by moveTo commands, so add the 'M' back in\n                // if it was present.\n                const current = !isFirst ? `M${part}` : part;\n                const path = Path.fromString(current);\n                const spec = pathToRenderable(path, style);\n                result.push(spec);\n            }\n            isFirst = false;\n        }\n        return result;\n    }\n    attachUnrecognisedAttrs(elem, node, supportedAttrs, supportedStyleAttrs) {\n        if (!this.storeUnknown) {\n            return;\n        }\n        for (const attr of node.getAttributeNames()) {\n            if (supportedAttrs.has(attr) || (attr === 'style' && supportedStyleAttrs)) {\n                continue;\n            }\n            elem.attachLoadSaveData(svgAttributesDataKey, [\n                attr,\n                node.getAttribute(attr),\n            ]);\n        }\n        if (supportedStyleAttrs && node.style) {\n            // Use a for loop instead of an iterator: js-dom seems to not\n            // support using node.style as an iterator.\n            for (let i = 0; i < node.style.length; i++) {\n                const attr = node.style[i];\n                if (attr === '' || !attr) {\n                    continue;\n                }\n                if (supportedStyleAttrs.has(attr)) {\n                    continue;\n                }\n                // TODO: Do we need special logic for !important properties?\n                elem.attachLoadSaveData(svgStyleAttributesDataKey, {\n                    key: attr,\n                    value: node.style.getPropertyValue(attr),\n                    priority: node.style.getPropertyPriority(attr),\n                });\n            }\n        }\n    }\n    // Adds a stroke with a single path\n    async addPath(node) {\n        let elem;\n        try {\n            const strokeData = this.strokeDataFromElem(node);\n            elem = new Stroke(strokeData);\n            this.attachUnrecognisedAttrs(elem, node, new Set([...supportedStrokeFillStyleAttrs, 'd']), new Set(supportedStrokeFillStyleAttrs));\n        }\n        catch (e) {\n            console.error('Invalid path in node', node, '\\nError:', e, '\\nAdding as an unknown object.');\n            if (this.storeUnknown) {\n                elem = new UnknownSVGObject(node);\n            }\n            else {\n                return;\n            }\n        }\n        await this.addComponent(elem);\n    }\n    async addBackground(node) {\n        // If a grid background,\n        if (node.classList.contains(backgroundTypeToClassNameMap[BackgroundType.Grid])) {\n            let foregroundStr;\n            let backgroundStr;\n            let gridStrokeWidthStr;\n            // If a group,\n            if (node.tagName.toLowerCase() === 'g') {\n                // We expect exactly two children. One of these is the solid\n                // background of the grid\n                if (node.children.length !== 2) {\n                    await this.addUnknownNode(node);\n                    return;\n                }\n                const background = node.children[0];\n                const grid = node.children[1];\n                backgroundStr = background.getAttribute('fill');\n                foregroundStr = grid.getAttribute('stroke');\n                gridStrokeWidthStr = grid.getAttribute('stroke-width');\n            }\n            else {\n                backgroundStr = node.getAttribute('fill');\n                foregroundStr = node.getAttribute('stroke');\n                gridStrokeWidthStr = node.getAttribute('stroke-width');\n            }\n            // Default to a transparent background.\n            backgroundStr ??= Color4.transparent.toHexString();\n            // A grid must have a foreground color specified.\n            if (!foregroundStr) {\n                await this.addUnknownNode(node);\n                return;\n            }\n            // Extract the grid size from the class name\n            let gridSize = undefined;\n            for (const className of node.classList) {\n                if (className.startsWith(imageBackgroundGridSizeCSSPrefix)) {\n                    const sizeStr = className.substring(imageBackgroundGridSizeCSSPrefix.length);\n                    gridSize = parseFloat(sizeStr.replace(/p/g, '.'));\n                }\n            }\n            let gridStrokeWidth = undefined;\n            if (gridStrokeWidthStr) {\n                gridStrokeWidth = parseFloat(gridStrokeWidthStr);\n            }\n            const backgroundColor = Color4.fromString(backgroundStr);\n            let foregroundColor = Color4.fromString(foregroundStr);\n            // Should the foreground color be determined automatically?\n            if (!node.classList.contains(imageBackgroundNonAutomaticSecondaryColorCSSClassName)) {\n                foregroundColor = undefined;\n            }\n            const elem = BackgroundComponent.ofGrid(backgroundColor, gridSize, foregroundColor, gridStrokeWidth);\n            await this.addComponent(elem);\n        }\n        // Otherwise, if just a <path/>, it's a solid color background.\n        else if (node.tagName.toLowerCase() === 'path') {\n            const fill = Color4.fromString(node.getAttribute('fill') ?? node.style.fill ?? 'black');\n            const elem = new BackgroundComponent(BackgroundType.SolidColor, fill);\n            await this.addComponent(elem);\n        }\n        else {\n            await this.addUnknownNode(node);\n        }\n    }\n    getComputedStyle(element) {\n        try {\n            // getComputedStyle may fail in jsdom when using a DOMParser.\n            return window.getComputedStyle(element);\n        }\n        catch (error) {\n            console.warn('Error computing style', error);\n            return undefined;\n        }\n    }\n    // If given, 'supportedAttrs' will have x, y, etc. attributes that were used in computing the transform added to it,\n    // to prevent storing duplicate transform information when saving the component.\n    getTransform(elem, supportedAttrs, computedStyles) {\n        // If possible, load the js-draw specific transform attribute\n        const highpTransformAttribute = 'data-highp-transform';\n        const rawTransformData = elem.getAttribute(highpTransformAttribute);\n        let transform;\n        if (rawTransformData) {\n            try {\n                transform = Mat33.fromCSSMatrix(rawTransformData);\n                supportedAttrs?.push(highpTransformAttribute);\n            }\n            catch (e) {\n                console.warn(`Unable to parse raw transform data, ${rawTransformData}. Falling back to CSS data. Error:`, e);\n            }\n        }\n        if (!transform) {\n            computedStyles ??= this.getComputedStyle(elem);\n            let transformProperty = computedStyles?.transform;\n            if (!transformProperty || transformProperty === 'none') {\n                transformProperty = elem.style?.transform || 'none';\n            }\n            // Prefer the actual .style.transform\n            // to the computed stylesheet -- in some browsers, the computedStyles version\n            // can have lower precision.\n            try {\n                transform = Mat33.fromCSSMatrix(elem.style.transform);\n            }\n            catch (_e) {\n                console.warn('matrix parse error', _e);\n                transform = Mat33.fromCSSMatrix(transformProperty);\n            }\n            const elemX = elem.getAttribute('x');\n            const elemY = elem.getAttribute('y');\n            if (elemX || elemY) {\n                const x = parseFloat(elemX ?? '0');\n                const y = parseFloat(elemY ?? '0');\n                if (!isNaN(x) && !isNaN(y)) {\n                    supportedAttrs?.push('x', 'y');\n                    transform = transform.rightMul(Mat33.translation(Vec2.of(x, y)));\n                }\n            }\n        }\n        return transform;\n    }\n    makeText(elem) {\n        const contentList = [];\n        for (const child of elem.childNodes) {\n            if (child.nodeType === Node.TEXT_NODE) {\n                contentList.push(child.nodeValue ?? '');\n            }\n            else if (child.nodeType === Node.ELEMENT_NODE) {\n                const subElem = child;\n                if (subElem.tagName.toLowerCase() === 'tspan') {\n                    // FIXME: tspan's (x, y) components are absolute, not relative to the parent.\n                    contentList.push(this.makeText(subElem));\n                }\n                else {\n                    throw new Error(`Unrecognized text child element: ${subElem}`);\n                }\n            }\n            else {\n                throw new Error(`Unrecognized text child node: ${child}.`);\n            }\n        }\n        // If no content, the content is an empty string.\n        if (contentList.length === 0) {\n            contentList.push('');\n        }\n        // Compute styles.\n        const computedStyles = this.getComputedStyle(elem);\n        const supportedStyleAttrs = new Set([\n            'fontFamily',\n            'transform',\n            ...supportedStrokeFillStyleAttrs,\n        ]);\n        const style = {\n            size: determineFontSize(elem, computedStyles, supportedStyleAttrs),\n            fontFamily: computedStyles?.fontFamily || elem.style?.fontFamily || 'sans-serif',\n            fontWeight: computedStyles?.fontWeight || elem.style?.fontWeight || undefined,\n            fontStyle: computedStyles?.fontStyle || elem.style?.fontStyle || undefined,\n            renderingStyle: this.getStyle(elem, computedStyles),\n        };\n        const supportedAttrs = [];\n        let transform = this.getTransform(elem, supportedAttrs, computedStyles);\n        let transformMode = TextTransformMode.ABSOLUTE_XY;\n        const elemDX = elem.getAttribute('dx');\n        if (elemDX) {\n            transformMode = TextTransformMode.RELATIVE_X_ABSOLUTE_Y;\n            transform = transform.rightMul(Mat33.translation(Vec2.of(parseFloat(elemDX), 0)));\n            supportedAttrs.push('dx');\n        }\n        const elemDY = elem.getAttribute('dy');\n        if (elemDY) {\n            if (transformMode === TextTransformMode.RELATIVE_X_ABSOLUTE_Y) {\n                transformMode = TextTransformMode.RELATIVE_XY;\n            }\n            else {\n                transformMode = TextTransformMode.RELATIVE_Y_ABSOLUTE_X;\n            }\n            transform = transform.rightMul(Mat33.translation(Vec2.of(0, parseFloat(elemDY))));\n            supportedAttrs.push('dy');\n        }\n        const result = new TextComponent(contentList, transform, style, transformMode);\n        this.attachUnrecognisedAttrs(result, elem, new Set(supportedAttrs), new Set(supportedStyleAttrs));\n        return result;\n    }\n    async addText(elem) {\n        try {\n            const textElem = this.makeText(elem);\n            await this.addComponent(textElem);\n        }\n        catch (e) {\n            console.error('Invalid text object in node', elem, '. Continuing.... Error:', e);\n            this.addUnknownNode(elem);\n        }\n    }\n    async addImage(elem) {\n        const image = new Image();\n        image.src = elem.getAttribute('xlink:href') ?? elem.href.baseVal;\n        image.setAttribute('alt', elem.getAttribute('aria-label') ?? '');\n        try {\n            const supportedAttrs = [];\n            const transform = this.getTransform(elem, supportedAttrs);\n            const imageElem = await ImageComponent.fromImage(image, transform);\n            this.attachUnrecognisedAttrs(imageElem, elem, new Set(supportedAttrs), new Set(['transform']));\n            await this.addComponent(imageElem);\n        }\n        catch (e) {\n            console.error('Error loading image:', e, '. Element: ', elem, '. Continuing...');\n            await this.addUnknownNode(elem);\n        }\n    }\n    async addUnknownNode(node) {\n        if (this.storeUnknown) {\n            const component = new UnknownSVGObject(node);\n            await this.addComponent(component);\n        }\n    }\n    async startGroup(node) {\n        node = node.cloneNode(false);\n        // Select a unique ID based on the node's ID property (if it exists).\n        // Use `||` and not `??` so that empty string IDs are also replaced.\n        let id = node.id || `id-${this.encounteredIDs.length}`;\n        // Make id unique.\n        let idSuffixCounter = 0;\n        let suffix = '';\n        while (this.encounteredIDs.includes(id + suffix)) {\n            idSuffixCounter++;\n            suffix = '--' + idSuffixCounter;\n        }\n        id += suffix;\n        // Remove all children from the node -- children will be handled separately\n        // (not removing children here could cause duplicates in the result, when rendered).\n        node.replaceChildren();\n        node.id = id;\n        const component = new UnknownSVGObject(node);\n        this.addComponent(component);\n        // Add to IDs after -- we don't want the <g> element to be marked\n        // as its own container.\n        this.containerGroupIDs.push(node.id);\n        this.encounteredIDs.push(node.id);\n    }\n    // Ends the most recent group started by .startGroup\n    async endGroup() {\n        this.containerGroupIDs.pop();\n    }\n    async addComponent(component) {\n        // Attach the stack of container IDs\n        if (this.containerGroupIDs.length > 0) {\n            component.attachLoadSaveData(svgLoaderAttributeContainerID, [...this.containerGroupIDs]);\n        }\n        await this.onAddComponent?.(component);\n    }\n    updateViewBox(node) {\n        const viewBoxAttr = node.getAttribute('viewBox');\n        if (this.rootViewBox || !viewBoxAttr) {\n            return;\n        }\n        const components = viewBoxAttr.split(/[ \\t\\n,]+/);\n        const x = parseFloat(components[0]);\n        const y = parseFloat(components[1]);\n        const width = parseFloat(components[2]);\n        const height = parseFloat(components[3]);\n        if (isNaN(x) || isNaN(y) || isNaN(width) || isNaN(height)) {\n            console.warn(`node ${node} has an unparsable viewbox. Viewbox: ${viewBoxAttr}. Match: ${components}.`);\n            return;\n        }\n        const autoresize = node.classList.contains(svgLoaderAutoresizeClassName);\n        this.rootViewBox = new Rect2(x, y, width, height);\n        this.onDetermineExportRect?.(this.rootViewBox, { autoresize });\n    }\n    async updateSVGAttrs(node) {\n        if (this.storeUnknown) {\n            await this.onAddComponent?.(new SVGGlobalAttributesObject(this.getSourceAttrs(node)));\n        }\n    }\n    async visit(node) {\n        this.totalToProcess += node.childElementCount;\n        let visitChildren = true;\n        switch (node.tagName.toLowerCase()) {\n            case 'g':\n                if (node.classList.contains(imageBackgroundCSSClassName)) {\n                    await this.addBackground(node);\n                    visitChildren = false;\n                }\n                else {\n                    await this.startGroup(node);\n                }\n                // Otherwise, continue -- visit the node's children.\n                break;\n            case 'path':\n                if (node.classList.contains(imageBackgroundCSSClassName)) {\n                    await this.addBackground(node);\n                }\n                else {\n                    await this.addPath(node);\n                }\n                break;\n            case 'text':\n                await this.addText(node);\n                visitChildren = false;\n                break;\n            case 'image':\n                await this.addImage(node);\n                // Images should not have children.\n                visitChildren = false;\n                break;\n            case 'svg':\n                this.updateViewBox(node);\n                this.updateSVGAttrs(node);\n                break;\n            case 'style':\n                // Keeping unnecessary style sheets can cause the browser to keep all\n                // SVG elements *referenced* by the style sheet in some browsers.\n                //\n                // Only keep the style sheet if it won't be discarded on save.\n                if (node.getAttribute('id') !== renderedStylesheetId) {\n                    await this.addUnknownNode(node);\n                }\n                break;\n            default:\n                if (!this.disableUnknownObjectWarnings) {\n                    console.warn('Unknown SVG element,', node, node.tagName);\n                    if (!(node instanceof SVGElement)) {\n                        console.warn('Element', node, 'is not an SVGElement!', this.storeUnknown ? 'Continuing anyway.' : 'Skipping.');\n                    }\n                }\n                await this.addUnknownNode(node);\n                return;\n        }\n        if (visitChildren) {\n            for (const child of node.children) {\n                await this.visit(child);\n            }\n            if (node.tagName.toLowerCase() === 'g') {\n                await this.endGroup();\n            }\n        }\n        this.processedCount++;\n        await this.onProgress?.(this.processedCount, this.totalToProcess);\n    }\n    // Get SVG element attributes (e.g. xlink=...)\n    getSourceAttrs(node) {\n        return node.getAttributeNames().map((attr) => {\n            return [attr, node.getAttribute(attr)];\n        });\n    }\n    async start(onAddComponent, onProgress, onDetermineExportRect = null) {\n        this.onAddComponent = onAddComponent;\n        this.onProgress = onProgress;\n        this.onDetermineExportRect = onDetermineExportRect;\n        // Estimate the number of tags to process.\n        this.totalToProcess = this.source.childElementCount;\n        this.processedCount = 0;\n        this.rootViewBox = null;\n        await this.visit(this.source);\n        const viewBox = this.rootViewBox;\n        if (!viewBox) {\n            this.onDetermineExportRect?.(defaultSVGViewRect);\n        }\n        this.onFinish?.();\n        this.onFinish = null;\n    }\n    /**\n     * Create an `SVGLoader` from the content of an SVG image. SVGs are loaded within a sandboxed\n     * iframe with `sandbox=\"allow-same-origin\"`\n     * [thereby disabling JavaScript](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#sandbox).\n     *\n     * @see {@link Editor.loadFrom}\n     * @param text - Textual representation of the SVG (e.g. `<svg viewbox='...'>...</svg>`).\n     * @param options - if `true` or `false`, treated as the `sanitize` option -- don't store unknown attributes.\n     */\n    static fromString(text, options = false) {\n        const domParserLoad = typeof options !== 'boolean' && options?.loadMethod === SVGLoaderLoadMethod.DOMParser;\n        const { svgElem, cleanUp } = (() => {\n            // If the user requested an iframe load (the default) try to load with an iframe.\n            // There are some cases (e.g. in a sandboxed iframe) where this doesn't work.\n            // TODO(v2): Use domParserLoad by default.\n            if (!domParserLoad) {\n                try {\n                    const sandbox = document.createElement('iframe');\n                    sandbox.src = 'about:blank';\n                    // allow-same-origin is necessary for how we interact with the sandbox. As such,\n                    // DO NOT ENABLE ALLOW-SCRIPTS.\n                    sandbox.setAttribute('sandbox', 'allow-same-origin');\n                    sandbox.setAttribute('csp', \"default-src 'about:blank'\");\n                    sandbox.style.display = 'none';\n                    // Required to access the frame's DOM. See https://stackoverflow.com/a/17777943/17055750\n                    document.body.appendChild(sandbox);\n                    if (!sandbox.hasAttribute('sandbox')) {\n                        sandbox.remove();\n                        throw new Error('SVG loading iframe is not sandboxed.');\n                    }\n                    const sandboxDoc = sandbox.contentWindow?.document ?? sandbox.contentDocument;\n                    if (sandboxDoc == null)\n                        throw new Error('Unable to open a sandboxed iframe!');\n                    sandboxDoc.open();\n                    sandboxDoc.write(`\n\t\t\t\t\t\t<!DOCTYPE html>\n\t\t\t\t\t\t<html>\n\t\t\t\t\t\t\t<head>\n\t\t\t\t\t\t\t\t<title>SVG Loading Sandbox</title>\n\t\t\t\t\t\t\t\t<meta name='viewport' conent='width=device-width,initial-scale=1.0'/>\n\t\t\t\t\t\t\t\t<meta charset='utf-8'/>\n\t\t\t\t\t\t\t</head>\n\t\t\t\t\t\t\t<body style='font-size: 12px;'>\n\t\t\t\t\t\t\t\t<script>\n\t\t\t\t\t\t\t\t\tconsole.error('JavaScript should not be able to run here!');\n\t\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\t'The SVG sandbox is broken! Please double-check the sandboxing setting.'\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t</script>\n\t\t\t\t\t\t\t</body>\n\t\t\t\t\t\t</html>\n\t\t\t\t\t`);\n                    sandboxDoc.close();\n                    const svgElem = sandboxDoc.createElementNS('http://www.w3.org/2000/svg', 'svg');\n                    // eslint-disable-next-line no-unsanitized/property -- setting innerHTML in a sandboxed document.\n                    svgElem.innerHTML = text;\n                    sandboxDoc.body.appendChild(svgElem);\n                    const cleanUp = () => {\n                        svgElem.remove();\n                        sandbox.remove();\n                        sandbox.src = '';\n                    };\n                    return { svgElem, cleanUp };\n                }\n                catch (error) {\n                    console.warn('Failed loading SVG via a sandboxed iframe. Some styles may not be loaded correctly. Error: ', error);\n                }\n            }\n            // Fall back to creating a DOMParser\n            const parser = new DOMParser();\n            const doc = parser.parseFromString(`<svg xmlns=\"http://www.w3.org/2000/svg\">${text}</svg>`, 'text/html');\n            const svgElem = doc.querySelector('svg');\n            // Handle error messages reported while parsing. See\n            // https://developer.mozilla.org/en-US/docs/Web/Guide/Parsing_and_serializing_XML\n            const errorReportNode = doc.querySelector('parsererror');\n            if (errorReportNode) {\n                throw new Error('Parse error: ' + errorReportNode.textContent);\n            }\n            const cleanUp = () => { };\n            return { svgElem, cleanUp };\n        })();\n        // Handle options\n        let sanitize;\n        let disableUnknownObjectWarnings;\n        if (typeof options === 'boolean') {\n            sanitize = options;\n            disableUnknownObjectWarnings = false;\n        }\n        else {\n            sanitize = options.sanitize ?? false;\n            disableUnknownObjectWarnings = options.disableUnknownObjectWarnings ?? false;\n        }\n        return new SVGLoader(svgElem, cleanUp, {\n            sanitize,\n            disableUnknownObjectWarnings,\n        });\n    }\n}\n","/** Computes the font size of a text element, based on style information. */\nconst determineFontSize = (elem, computedStyles, \n// output: Written to to update supported style attributes\nsupportedStyleAttrs) => {\n    const fontSizeExp = /^([-0-9.e]+)px/i;\n    // In some environments, computedStyles.fontSize can be increased by the system.\n    // Thus, to prevent text from growing on load/save, prefer .style.fontSize.\n    let fontSizeMatch = fontSizeExp.exec(elem.style?.fontSize ?? '');\n    if (!fontSizeMatch && elem.tagName.toLowerCase() === 'tspan' && elem.parentElement) {\n        // Try to inherit the font size of the parent text element.\n        fontSizeMatch = fontSizeExp.exec(elem.parentElement.style?.fontSize ?? '');\n    }\n    // If we still couldn't find a font size, try to use computedStyles (which can be\n    // wrong).\n    if (!fontSizeMatch && computedStyles) {\n        fontSizeMatch = fontSizeExp.exec(computedStyles.fontSize);\n    }\n    let fontSize = 12;\n    if (fontSizeMatch) {\n        supportedStyleAttrs.add('fontSize');\n        fontSize = parseFloat(fontSizeMatch[1]);\n    }\n    return fontSize;\n};\nexport default determineFontSize;\n","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _UndoRedoHistory_undoStack, _UndoRedoHistory_redoStack;\nimport  { EditorEventType, UndoEventType }  from './types.mjs';\nclass UndoRedoHistory {\n    // @internal\n    constructor(editor, announceRedoCallback, announceUndoCallback) {\n        this.editor = editor;\n        this.announceRedoCallback = announceRedoCallback;\n        this.announceUndoCallback = announceUndoCallback;\n        _UndoRedoHistory_undoStack.set(this, void 0);\n        _UndoRedoHistory_redoStack.set(this, void 0);\n        this.maxUndoRedoStackSize = 700;\n        __classPrivateFieldSet(this, _UndoRedoHistory_undoStack, [], \"f\");\n        __classPrivateFieldSet(this, _UndoRedoHistory_redoStack, [], \"f\");\n    }\n    fireUpdateEvent(stackUpdateType, triggeringCommand) {\n        this.editor.notifier.dispatch(EditorEventType.UndoRedoStackUpdated, {\n            kind: EditorEventType.UndoRedoStackUpdated,\n            undoStackSize: __classPrivateFieldGet(this, _UndoRedoHistory_undoStack, \"f\").length,\n            redoStackSize: __classPrivateFieldGet(this, _UndoRedoHistory_redoStack, \"f\").length,\n            command: triggeringCommand,\n            stackUpdateType,\n        });\n    }\n    // Adds the given command to this and applies it to the editor.\n    push(command, apply = true) {\n        if (apply) {\n            command.apply(this.editor);\n        }\n        __classPrivateFieldGet(this, _UndoRedoHistory_undoStack, \"f\").push(command);\n        for (const elem of __classPrivateFieldGet(this, _UndoRedoHistory_redoStack, \"f\")) {\n            elem.onDrop(this.editor);\n        }\n        __classPrivateFieldSet(this, _UndoRedoHistory_redoStack, [], \"f\");\n        if (__classPrivateFieldGet(this, _UndoRedoHistory_undoStack, \"f\").length > this.maxUndoRedoStackSize) {\n            const removeAtOnceCount = Math.ceil(this.maxUndoRedoStackSize / 100);\n            const removedElements = __classPrivateFieldGet(this, _UndoRedoHistory_undoStack, \"f\").splice(0, removeAtOnceCount);\n            removedElements.forEach((elem) => elem.onDrop(this.editor));\n        }\n        this.fireUpdateEvent(UndoEventType.CommandDone, command);\n        this.editor.notifier.dispatch(EditorEventType.CommandDone, {\n            kind: EditorEventType.CommandDone,\n            command,\n        });\n    }\n    // Remove the last command from this' undo stack and apply it.\n    undo() {\n        const command = __classPrivateFieldGet(this, _UndoRedoHistory_undoStack, \"f\").pop();\n        if (command) {\n            __classPrivateFieldGet(this, _UndoRedoHistory_redoStack, \"f\").push(command);\n            const result = command.unapply(this.editor);\n            this.announceUndoCallback(command);\n            this.fireUpdateEvent(UndoEventType.CommandUndone, command);\n            this.editor.notifier.dispatch(EditorEventType.CommandUndone, {\n                kind: EditorEventType.CommandUndone,\n                command,\n            });\n            return result;\n        }\n    }\n    redo() {\n        const command = __classPrivateFieldGet(this, _UndoRedoHistory_redoStack, \"f\").pop();\n        if (command) {\n            __classPrivateFieldGet(this, _UndoRedoHistory_undoStack, \"f\").push(command);\n            const result = command.apply(this.editor);\n            this.announceRedoCallback(command);\n            this.fireUpdateEvent(UndoEventType.CommandRedone, command);\n            this.editor.notifier.dispatch(EditorEventType.CommandDone, {\n                kind: EditorEventType.CommandDone,\n                command,\n            });\n            return result;\n        }\n    }\n    get undoStackSize() {\n        return __classPrivateFieldGet(this, _UndoRedoHistory_undoStack, \"f\").length;\n    }\n    get redoStackSize() {\n        return __classPrivateFieldGet(this, _UndoRedoHistory_redoStack, \"f\").length;\n    }\n}\n_UndoRedoHistory_undoStack = new WeakMap(), _UndoRedoHistory_redoStack = new WeakMap();\nexport default UndoRedoHistory;\n","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _inverseTransform, _a;\nimport  Command  from './commands/Command.mjs';\nimport { Mat33, Rect2, Vec2, Vec3 } from '@js-draw/math';\nexport class ViewportTransform extends Command {\n}\nexport class Viewport {\n    // @internal\n    constructor(onTransformChangeCallback) {\n        this.onTransformChangeCallback = onTransformChangeCallback;\n        this.resetTransform(Mat33.identity);\n        this.screenRect = Rect2.empty;\n    }\n    /**\n     * @returns a temporary copy of `this` that does not notify when modified. This is\n     * useful when rendering with a temporarily different viewport.\n     */\n    getTemporaryClone() {\n        const result = new Viewport(() => { });\n        result.transform = this.transform;\n        result.inverseTransform = this.inverseTransform;\n        result.screenRect = this.screenRect;\n        return result;\n    }\n    /** Resizes the screen rect to the given size. @internal */\n    updateScreenSize(screenSize) {\n        this.screenRect = this.screenRect.resizedTo(screenSize);\n    }\n    /** Get the screen's visible region transformed into canvas space. */\n    get visibleRect() {\n        return this.screenRect.transformedBoundingBox(this.inverseTransform);\n    }\n    /** @returns the given point, but in canvas coordinates */\n    screenToCanvas(screenPoint) {\n        return this.inverseTransform.transformVec2(screenPoint);\n    }\n    /** @returns the given point transformed into screen coordinates. */\n    canvasToScreen(canvasPoint) {\n        return this.transform.transformVec2(canvasPoint);\n    }\n    /** @returns a command that transforms the canvas by `transform`. */\n    static transformBy(transform) {\n        return new Viewport.ViewportTransform(transform);\n    }\n    /**\n     * Updates the transformation directly. Using `transformBy` is preferred.\n     * @param newTransform - should map from canvas coordinates to screen coordinates.\n     */\n    resetTransform(newTransform = Mat33.identity) {\n        const oldTransform = this.transform;\n        this.transform = newTransform;\n        this.inverseTransform = newTransform.inverse();\n        this.onTransformChangeCallback?.(oldTransform, newTransform);\n    }\n    get screenToCanvasTransform() {\n        return this.inverseTransform;\n    }\n    get canvasToScreenTransform() {\n        return this.transform;\n    }\n    /** @returns the size of the visible region in pixels (screen units). */\n    getScreenRectSize() {\n        return this.screenRect.size;\n    }\n    /** Alias for `getScreenRectSize`. @deprecated */\n    getResolution() {\n        return this.getScreenRectSize();\n    }\n    /** @returns the amount a vector on the canvas is scaled to become a vector on the screen. */\n    getScaleFactor() {\n        // Use transformVec3 to avoid translating the vector\n        return this.transform.transformVec3(Vec3.unitX).magnitude();\n    }\n    /**\n     * @returns `getScaleFactor()` rounded to the nearest power of 10.\n     * For example, if `getScaleFactor()` returns 101, `getScaleFactorToNearestPowerOfTen()`\n     * should return `100` because `100` is the nearest power of 10 to 101.\n     */\n    getScaleFactorToNearestPowerOfTen() {\n        return this.getScaleFactorToNearestPowerOf(10);\n    }\n    getScaleFactorToNearestPowerOf(powerOf) {\n        const scaleFactor = this.getScaleFactor();\n        return Math.pow(powerOf, Math.round(Math.log(scaleFactor) / Math.log(powerOf)));\n    }\n    /** Returns the size of a grid cell (in canvas units) as used by {@link snapToGrid}. */\n    static getGridSize(scaleFactor) {\n        return 50 / scaleFactor;\n    }\n    /**\n     * Snaps `canvasPos` to the nearest grid cell corner.\n     *\n     * @see {@link getGridSize}.\n     */\n    snapToGrid(canvasPos) {\n        const scaleFactor = this.getScaleFactorToNearestPowerOf(2);\n        const snapCoordinate = (coordinate) => {\n            const roundFactor = 1 / Viewport.getGridSize(scaleFactor);\n            const snapped = Math.round(coordinate * roundFactor) / roundFactor;\n            return snapped;\n        };\n        const snappedCanvasPos = Vec2.of(snapCoordinate(canvasPos.x), snapCoordinate(canvasPos.y));\n        return snappedCanvasPos;\n    }\n    /** Returns the size of one screen pixel in canvas units. */\n    getSizeOfPixelOnCanvas() {\n        return 1 / this.getScaleFactor();\n    }\n    /**\n     * @returns the angle of the canvas in radians.\n     * This is the angle by which the canvas is rotated relative to the screen.\n     *\n     * Returns an angle in the range $[-\\pi, \\pi]$ (the same range as {@link Vec3.angle}).\n     */\n    getRotationAngle() {\n        return this.transform.transformVec3(Vec3.unitX).angle();\n    }\n    // The separate function type definition seems necessary here.\n    // See https://stackoverflow.com/a/58163623/17055750.\n    static roundPoint(point, tolerance) {\n        const scaleFactor = 10 ** Math.floor(Math.log10(tolerance));\n        const roundComponent = (component) => {\n            return Math.round(component / scaleFactor) * scaleFactor;\n        };\n        if (typeof point === 'number') {\n            return roundComponent(point);\n        }\n        return point.map(roundComponent);\n    }\n    /** Round a point with a tolerance of ±1 screen unit. */\n    roundPoint(point) {\n        return Viewport.roundPoint(point, 1 / this.getScaleFactor());\n    }\n    // `roundAmount`: An integer >= 0, larger numbers cause less rounding. Smaller numbers cause more\n    // (as such `roundAmount = 0` does the most rounding).\n    static roundScaleRatio(scaleRatio, roundAmount = 1) {\n        if (Math.abs(scaleRatio) <= 1e-12) {\n            return 0;\n        }\n        // Represent as k 10ⁿ for some n, k ∈ ℤ.\n        const decimalComponent = 10 ** Math.floor(Math.log10(Math.abs(scaleRatio)));\n        const roundAmountFactor = 2 ** roundAmount;\n        scaleRatio =\n            (Math.round((scaleRatio / decimalComponent) * roundAmountFactor) / roundAmountFactor) *\n                decimalComponent;\n        return scaleRatio;\n    }\n    // Computes and returns an affine transformation that makes `toMakeVisible` visible and roughly centered on the screen.\n    computeZoomToTransform(toMakeVisible, allowZoomIn = true, allowZoomOut = true) {\n        let transform = Mat33.identity;\n        // Invalid size? (Would divide by zero)\n        if (toMakeVisible.w === 0 || toMakeVisible.h === 0) {\n            // Create a new rectangle with a valid size\n            let newSize = Math.max(toMakeVisible.w, toMakeVisible.h);\n            // Choose a reasonable default size, but don't zoom.\n            if (newSize === 0) {\n                newSize = 50;\n                allowZoomIn = false;\n                allowZoomOut = false;\n            }\n            toMakeVisible = new Rect2(toMakeVisible.x, toMakeVisible.y, newSize, newSize);\n        }\n        if (isNaN(toMakeVisible.size.magnitude())) {\n            throw new Error(`${toMakeVisible.toString()} rectangle has NaN size! Cannot zoom to!`);\n        }\n        // Try to move the selection within the center 4/5ths of the viewport.\n        const recomputeTargetRect = () => {\n            // transform transforms objects on the canvas. As such, we need to invert it\n            // to transform the viewport.\n            const visibleRect = this.visibleRect.transformedBoundingBox(transform.inverse());\n            return visibleRect.transformedBoundingBox(Mat33.scaling2D(4 / 5, visibleRect.center));\n        };\n        let targetRect = recomputeTargetRect();\n        const largerThanTarget = targetRect.w < toMakeVisible.w || targetRect.h < toMakeVisible.h;\n        // Ensure that toMakeVisible is at least 1/3rd of the visible region.\n        const muchSmallerThanTarget = toMakeVisible.maxDimension / targetRect.maxDimension < 1 / 3;\n        if ((largerThanTarget && allowZoomOut) || (muchSmallerThanTarget && allowZoomIn)) {\n            const multiplier = Math.max(toMakeVisible.w / targetRect.w, toMakeVisible.h / targetRect.h);\n            const visibleRectTransform = Mat33.scaling2D(multiplier, targetRect.topLeft);\n            const viewportContentTransform = visibleRectTransform.inverse();\n            transform = transform.rightMul(viewportContentTransform);\n        }\n        targetRect = recomputeTargetRect();\n        // Ensure that the center of the region is visible\n        if (!targetRect.containsRect(toMakeVisible)) {\n            // target position - current position\n            const translation = toMakeVisible.center.minus(targetRect.center);\n            const visibleRectTransform = Mat33.translation(translation);\n            const viewportContentTransform = visibleRectTransform.inverse();\n            transform = transform.rightMul(viewportContentTransform);\n        }\n        if (!transform.invertable()) {\n            console.warn('Unable to zoom to ', toMakeVisible, '! Computed transform', transform, 'is singular.');\n            transform = Mat33.identity;\n        }\n        return transform;\n    }\n    // Returns a Command that transforms the view such that [rect] is visible, and perhaps\n    // centered in the viewport.\n    // Returns null if no transformation is necessary\n    //\n    // @see {@link computeZoomToTransform}\n    zoomTo(toMakeVisible, allowZoomIn = true, allowZoomOut = true) {\n        const transform = this.computeZoomToTransform(toMakeVisible, allowZoomIn, allowZoomOut);\n        return new Viewport.ViewportTransform(transform);\n    }\n}\n// Command that translates/scales the viewport.\nViewport.ViewportTransform = (_a = class extends ViewportTransform {\n        constructor(transform) {\n            super();\n            this.transform = transform;\n            _inverseTransform.set(this, void 0);\n            __classPrivateFieldSet(this, _inverseTransform, transform.inverse(), \"f\");\n        }\n        apply(editor) {\n            const viewport = editor.viewport;\n            viewport.resetTransform(viewport.transform.rightMul(this.transform));\n            editor.queueRerender();\n        }\n        unapply(editor) {\n            const viewport = editor.viewport;\n            viewport.resetTransform(viewport.transform.rightMul(__classPrivateFieldGet(this, _inverseTransform, \"f\")));\n            editor.queueRerender();\n        }\n        description(editor, localizationTable) {\n            const result = [];\n            // Describe the transformation's affect on the viewport (note that transformation transforms\n            // the **elements** within the viewport). Assumes the transformation only does rotation/scale/translation.\n            const origVec = editor.viewport.visibleRect.center;\n            const linearTransformedVec = this.transform.transformVec3(Vec2.unitX);\n            const affineTransformedVec = this.transform.transformVec2(origVec);\n            const scale = linearTransformedVec.magnitude();\n            const rotation = (180 / Math.PI) * linearTransformedVec.angle();\n            const translation = affineTransformedVec.minus(origVec);\n            if (scale > 1.2) {\n                result.push(localizationTable.zoomedIn);\n            }\n            else if (scale < 0.8) {\n                result.push(localizationTable.zoomedOut);\n            }\n            if (Math.floor(Math.abs(rotation)) > 0) {\n                result.push(localizationTable.rotatedBy(Math.round(rotation)));\n            }\n            const minTranslation = 1e-4;\n            if (translation.x > minTranslation) {\n                result.push(localizationTable.movedLeft);\n            }\n            else if (translation.x < -minTranslation) {\n                result.push(localizationTable.movedRight);\n            }\n            if (translation.y < -minTranslation) {\n                result.push(localizationTable.movedDown);\n            }\n            else if (translation.y > minTranslation) {\n                result.push(localizationTable.movedUp);\n            }\n            return result.join('; ');\n        }\n    },\n    _inverseTransform = new WeakMap(),\n    _a);\nexport default Viewport;\n","/**\n * A `Command` is an action that can be done, redone, and undone. It's used to enable undo/redo.\n *\n * See {@link Editor.dispatch}.\n */\nexport class Command {\n    // Called when the command is being deleted\n    onDrop(_editor) { }\n    /** @deprecated Use {@link uniteCommands} */\n    static union(a, b) {\n        return new (class extends Command {\n            apply(editor) {\n                a.apply(editor);\n                b.apply(editor);\n            }\n            unapply(editor) {\n                b.unapply(editor);\n                a.unapply(editor);\n            }\n            description(editor, localizationTable) {\n                const aDescription = a.description(editor, localizationTable);\n                const bDescription = b.description(editor, localizationTable);\n                if (aDescription === bDescription) {\n                    return aDescription;\n                }\n                return `${aDescription}, ${bDescription}`;\n            }\n        })();\n    }\n}\nCommand.empty = new (class extends Command {\n    description(_editor, _localizationTable) {\n        return '';\n    }\n    apply(_editor) { }\n    unapply(_editor) { }\n})();\nexport default Command;\n","import  describeComponentList  from '../components/util/describeComponentList.mjs';\nimport  Erase  from './Erase.mjs';\nimport  SerializableCommand  from './SerializableCommand.mjs';\n/**\n * A command that duplicates the {@link AbstractComponent}s it's given. This command\n * is the reverse of an {@link Erase} command.\n *\n * @example\n * ```ts\n * // Given some editor...\n *\n * // Find all elements intersecting the rectangle with top left (0,0) and\n * // (width,height)=(100,100).\n * const elems = editor.image.getElementsIntersectingRegion(\n * \tnew Rect2(0, 0, 100, 100)\n * );\n *\n * // Create a command that, when applied, will duplicate the elements.\n * const duplicateElems = new Duplicate(elems);\n *\n * // Apply the command (and make it undoable)\n * editor.dispatch(duplicateElems);\n * ```\n *\n * @see {@link Editor.dispatch} {@link EditorImage.getElementsIntersectingRegion}\n */\nclass Duplicate extends SerializableCommand {\n    constructor(toDuplicate) {\n        super('duplicate');\n        this.toDuplicate = toDuplicate;\n        this.duplicates = toDuplicate.map((elem) => elem.clone());\n        this.reverse = new Erase(this.duplicates);\n    }\n    apply(editor) {\n        this.reverse.unapply(editor);\n    }\n    unapply(editor) {\n        this.reverse.apply(editor);\n    }\n    onDrop(editor) {\n        this.reverse.onDrop(editor);\n    }\n    description(_editor, localizationTable) {\n        if (this.duplicates.length === 0) {\n            return localizationTable.duplicatedNoElements;\n        }\n        return localizationTable.duplicateAction(describeComponentList(localizationTable, this.duplicates) ?? localizationTable.elements, this.duplicates.length);\n    }\n    serializeToJSON() {\n        return this.toDuplicate.map((elem) => elem.getId());\n    }\n}\n(() => {\n    SerializableCommand.register('duplicate', (json, editor) => {\n        const elems = json.map((id) => editor.image.lookupElement(id));\n        return new Duplicate(elems);\n    });\n})();\nexport default Duplicate;\n","import  AbstractComponent  from '../components/AbstractComponent.mjs';\nimport  describeComponentList  from '../components/util/describeComponentList.mjs';\nimport  EditorImage  from '../image/EditorImage.mjs';\nimport  SerializableCommand  from './SerializableCommand.mjs';\n/**\n * Removes the given {@link AbstractComponent}s from the image.\n *\n * **Example**:\n * ```ts,runnable\n * import { Editor, Erase, uniteCommands, Color4, Path, Stroke, Rect2, pathToRenderable } from 'js-draw';\n *\n * const editor = new Editor(document.body);\n * editor.addToolbar();\n *\n * // Add a large number of strokes\n * const commands = [];\n * for (let x = -20; x < 20; x++) {\n *   for (let y = 0; y < 60; y++) {\n *     const stroke = new Stroke([\n *       pathToRenderable(\n *         Path.fromString(`m${x * 5},${y * 5}l1,1`),\n *         { fill: Color4.transparent, stroke: {width: 2, color: Color4.ofRGB(x / 10, y / 10, 0.5)}} )\n *       ]);\n *     commands.push(editor.image.addElement(stroke));\n *   }\n * }\n * await editor.dispatch(uniteCommands(commands, 100));\n *\n * ---visible---\n * // Given some editor...\n *\n * // Find all elements intersecting the rectangle with top left (-10,-30) and\n * // (width,height)=(50,100).\n * const elems = editor.image.getElementsIntersectingRegion(\n * \tnew Rect2(-10, -30, 50, 100)\n * );\n *\n * // Create a command that erases [elems] when applied\n * const eraseElemsCmd = new Erase(elems);\n *\n * // Apply the command (and make it undoable)\n * editor.dispatch(eraseElemsCmd);\n * ```\n */\nclass Erase extends SerializableCommand {\n    constructor(toRemove) {\n        super('erase');\n        // Clone the list\n        this.toRemove = toRemove.map((elem) => elem);\n        this.applied = false;\n    }\n    apply(editor) {\n        for (const part of this.toRemove) {\n            const parent = editor.image.findParent(part);\n            if (parent) {\n                parent.remove();\n                editor.image.onDestroyElement(part);\n            }\n        }\n        this.applied = true;\n        editor.queueRerender();\n    }\n    unapply(editor) {\n        for (const part of this.toRemove) {\n            if (!editor.image.findParent(part)) {\n                EditorImage.addElement(part).apply(editor);\n            }\n        }\n        this.applied = false;\n        editor.queueRerender();\n    }\n    onDrop(editor) {\n        if (this.applied) {\n            for (const part of this.toRemove) {\n                editor.image.onDestroyElement(part);\n            }\n        }\n    }\n    description(_editor, localizationTable) {\n        if (this.toRemove.length === 0) {\n            return localizationTable.erasedNoElements;\n        }\n        const description = describeComponentList(localizationTable, this.toRemove) ?? localizationTable.elements;\n        return localizationTable.eraseAction(description, this.toRemove.length);\n    }\n    serializeToJSON() {\n        // If applied, the elements can't be fetched from the image because they're\n        // erased. Serialize and return the elements themselves.\n        const elems = this.toRemove.map((elem) => elem.serialize());\n        return elems;\n    }\n}\n(() => {\n    SerializableCommand.register('erase', (json, editor) => {\n        if (!Array.isArray(json)) {\n            throw new Error('seralized erase data must be an array');\n        }\n        const elems = json.map((elemData) => {\n            const componentId = typeof elemData === 'string' ? elemData : `${elemData.id}`;\n            const component = editor.image.lookupElement(componentId) ?? AbstractComponent.deserialize(elemData);\n            return component;\n        });\n        return new Erase(elems);\n    });\n})();\nexport default Erase;\n","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _SerializableCommand_commandTypeId;\nimport  Command  from './Command.mjs';\n/**\n * A command that can be serialized to or deserialized from JSON. To allow a command to be deserialized, {@link SerializableCommand.register}\n * must be called for each {@link SerializableCommand}.\n *\n * This is used to [allow collaborative editing](https://github.com/personalizedrefrigerator/js-draw/tree/main/docs/examples/example-collaborative).\n */\nclass SerializableCommand extends Command {\n    /** @param commandTypeId - A unique identifier for this command. */\n    constructor(commandTypeId) {\n        super();\n        _SerializableCommand_commandTypeId.set(this, void 0);\n        if (!(commandTypeId in SerializableCommand.deserializationCallbacks)) {\n            throw new Error(`Command ${commandTypeId} must have a registered deserialization callback. To do this, call SerializableCommand.register.`);\n        }\n        __classPrivateFieldSet(this, _SerializableCommand_commandTypeId, commandTypeId, \"f\");\n    }\n    // Convert this command to an object that can be passed to `JSON.stringify`.\n    //\n    // Do not rely on the stability of the optupt of this function — it can change\n    // form without a major version increase.\n    serialize() {\n        return {\n            data: this.serializeToJSON(),\n            commandType: __classPrivateFieldGet(this, _SerializableCommand_commandTypeId, \"f\"),\n        };\n    }\n    // Convert a `string` containing JSON data (or the output of `JSON.parse`) into a\n    // `Command`.\n    //\n    // Implementations should assume that `data` is untrusted.\n    static deserialize(data, editor) {\n        const json = typeof data === 'string' ? JSON.parse(data) : data;\n        const commandType = json.commandType;\n        if (!(commandType in SerializableCommand.deserializationCallbacks)) {\n            throw new Error(`Unrecognised command type ${commandType}!`);\n        }\n        return SerializableCommand.deserializationCallbacks[commandType](json.data, editor);\n    }\n    // Register a deserialization callback. This must be called at least once for every subclass of\n    // `SerializableCommand`.\n    static register(commandTypeId, deserialize) {\n        SerializableCommand.deserializationCallbacks[commandTypeId] = deserialize;\n    }\n}\n_SerializableCommand_commandTypeId = new WeakMap();\nSerializableCommand.deserializationCallbacks = {};\nexport default SerializableCommand;\n","import  SerializableCommand  from './SerializableCommand.mjs';\n/**\n * A command that requires a component that may or may not be present in the editor when\n * the command is created.\n */\nexport default class UnresolvedSerializableCommand extends SerializableCommand {\n    constructor(commandId, componentID, component) {\n        super(commandId);\n        this.component = component ?? null;\n        this.componentID = componentID;\n    }\n    resolveComponent(image) {\n        if (this.component) {\n            return;\n        }\n        const component = image.lookupElement(this.componentID);\n        if (!component) {\n            throw new Error(`Unable to resolve component with ID ${this.componentID}`);\n        }\n        this.component = component;\n    }\n}\n","import  Command  from './Command.mjs';\nimport  SerializableCommand  from './SerializableCommand.mjs';\n// Returns a command that does the opposite of the given command --- `result.apply()` calls\n// `command.unapply()` and `result.unapply()` calls `command.apply()`.\nconst invertCommand = (command) => {\n    if (command instanceof SerializableCommand) {\n        // SerializableCommand that does the inverse of [command]\n        return new (class extends SerializableCommand {\n            constructor() {\n                super(...arguments);\n                // For debugging\n                this._command = command;\n            }\n            serializeToJSON() {\n                return command.serialize();\n            }\n            apply(editor) {\n                command.unapply(editor);\n            }\n            unapply(editor) {\n                command.apply(editor);\n            }\n            onDrop(editor) {\n                command.onDrop(editor);\n            }\n            description(editor, localizationTable) {\n                return localizationTable.inverseOf(command.description(editor, localizationTable));\n            }\n        })('inverse');\n    }\n    else {\n        // Command that does the inverse of [command].\n        const result = new (class extends Command {\n            apply(editor) {\n                command.unapply(editor);\n            }\n            unapply(editor) {\n                command.apply(editor);\n            }\n            onDrop(editor) {\n                command.onDrop(editor);\n            }\n            description(editor, localizationTable) {\n                return localizationTable.inverseOf(command.description(editor, localizationTable));\n            }\n        })();\n        // We know that T does not extend SerializableCommand, and thus returning a Command\n        // is appropriate.\n        return result;\n    }\n};\nSerializableCommand.register('inverse', (data, editor) => {\n    return invertCommand(SerializableCommand.deserialize(data, editor));\n});\nexport default invertCommand;\n","import  Command  from './Command.mjs';\nimport  Duplicate  from './Duplicate.mjs';\nimport  Erase  from './Erase.mjs';\nimport  invertCommand  from './invertCommand.mjs';\nimport  SerializableCommand  from './SerializableCommand.mjs';\nimport  uniteCommands  from './uniteCommands.mjs';\nexport { Command, Duplicate, Erase, SerializableCommand, invertCommand, uniteCommands };\n","export const defaultCommandLocalization = {\n    updatedViewport: 'Transformed Viewport',\n    transformedElements: (elemCount) => `Transformed ${elemCount} element${elemCount === 1 ? '' : 's'}`,\n    resizeOutputCommand: (newSize) => `Resized image to ${newSize.w}x${newSize.h}`,\n    enabledAutoresizeOutputCommand: 'Enabled output autoresize',\n    disabledAutoresizeOutputCommand: 'Disabled output autoresize',\n    addElementAction: (componentDescription) => `Added ${componentDescription}`,\n    eraseAction: (componentDescription, numElems) => `Erased ${numElems} ${componentDescription}`,\n    duplicateAction: (componentDescription, numElems) => `Duplicated ${numElems} ${componentDescription}`,\n    unionOf: (actionDescription, actionCount) => `Union: ${actionCount} ${actionDescription}`,\n    inverseOf: (actionDescription) => `Inverse of ${actionDescription}`,\n    elements: 'Elements',\n    erasedNoElements: 'Erased nothing',\n    duplicatedNoElements: 'Duplicated nothing',\n    rotatedBy: (degrees) => `Rotated by ${Math.abs(degrees)} degrees ${degrees < 0 ? 'clockwise' : 'counter-clockwise'}`,\n    movedLeft: 'Moved left',\n    movedUp: 'Moved up',\n    movedDown: 'Moved down',\n    movedRight: 'Moved right',\n    zoomedOut: 'Zoomed out',\n    zoomedIn: 'Zoomed in',\n    andNMoreCommands: (count) => `And ${count} more commands.`,\n    selectedElements: (count) => `Selected ${count} element${count === 1 ? '' : 's'}`,\n};\n","import  waitForAll  from '../util/waitForAll.mjs';\nimport  Command  from './Command.mjs';\nimport  SerializableCommand  from './SerializableCommand.mjs';\nclass NonSerializableUnion extends Command {\n    constructor(commands, applyChunkSize, descriptionOverride) {\n        super();\n        this.commands = commands;\n        this.applyChunkSize = applyChunkSize;\n        this.descriptionOverride = descriptionOverride;\n    }\n    apply(editor) {\n        if (this.applyChunkSize === undefined) {\n            const results = this.commands.map((cmd) => cmd.apply(editor));\n            return waitForAll(results);\n        }\n        else {\n            return editor.asyncApplyCommands(this.commands, this.applyChunkSize);\n        }\n    }\n    unapply(editor) {\n        const commands = [...this.commands];\n        commands.reverse();\n        if (this.applyChunkSize === undefined) {\n            const results = commands.map((cmd) => cmd.unapply(editor));\n            return waitForAll(results);\n        }\n        else {\n            return editor.asyncUnapplyCommands(commands, this.applyChunkSize, false);\n        }\n    }\n    onDrop(editor) {\n        this.commands.forEach((command) => command.onDrop(editor));\n    }\n    description(editor, localizationTable) {\n        if (this.descriptionOverride) {\n            return this.descriptionOverride;\n        }\n        const descriptions = [];\n        let lastDescription = null;\n        let duplicateDescriptionCount = 0;\n        let handledCommandCount = 0;\n        for (const part of this.commands) {\n            const description = part.description(editor, localizationTable);\n            if (description !== lastDescription && lastDescription !== null) {\n                descriptions.push(localizationTable.unionOf(lastDescription, duplicateDescriptionCount));\n                lastDescription = null;\n                duplicateDescriptionCount = 0;\n            }\n            duplicateDescriptionCount++;\n            handledCommandCount++;\n            lastDescription ??= description;\n            // Long descriptions aren't very useful to the user.\n            const maxDescriptionLength = 12;\n            if (descriptions.length > maxDescriptionLength) {\n                break;\n            }\n        }\n        if (duplicateDescriptionCount > 1) {\n            descriptions.push(localizationTable.unionOf(lastDescription, duplicateDescriptionCount));\n        }\n        else if (duplicateDescriptionCount === 1) {\n            descriptions.push(lastDescription);\n        }\n        if (handledCommandCount < this.commands.length) {\n            descriptions.push(localizationTable.andNMoreCommands(this.commands.length - handledCommandCount));\n        }\n        return descriptions.join(', ');\n    }\n}\nclass SerializableUnion extends SerializableCommand {\n    constructor(commands, applyChunkSize, descriptionOverride) {\n        super('union');\n        this.commands = commands;\n        this.applyChunkSize = applyChunkSize;\n        this.descriptionOverride = descriptionOverride;\n        this.nonserializableCommand = new NonSerializableUnion(commands, applyChunkSize, descriptionOverride);\n    }\n    serializeToJSON() {\n        if (this.serializedData) {\n            return this.serializedData;\n        }\n        return {\n            applyChunkSize: this.applyChunkSize,\n            data: this.commands.map((command) => command.serialize()),\n            description: this.descriptionOverride,\n        };\n    }\n    apply(editor) {\n        // Cache this' serialized form -- applying this may change how commands serialize.\n        this.serializedData = this.serializeToJSON();\n        return this.nonserializableCommand.apply(editor);\n    }\n    unapply(editor) {\n        return this.nonserializableCommand.unapply(editor);\n    }\n    onDrop(editor) {\n        this.nonserializableCommand.onDrop(editor);\n    }\n    description(editor, localizationTable) {\n        return this.nonserializableCommand.description(editor, localizationTable);\n    }\n}\n/**\n * Creates a single command from `commands`. This is useful when undoing should undo *all* commands\n * in `commands` at once, rather than one at a time.\n *\n * @example\n *\n * ```ts,runnable\n * import { Editor, pathToRenderable, Stroke, uniteCommands } from 'js-draw';\n * import { Path, Color4 } from '@js-draw/math';\n *\n * const editor = new Editor(document.body);\n * editor.addToolbar();\n *\n * // Create strokes!\n * const strokes = [];\n * for (let i = 0; i < 10; i++) {\n *   const renderablePath = pathToRenderable(\n *     Path.fromString(`M0,${i * 10} L100,100 L300,30 z`),\n *     { fill: Color4.transparent, stroke: { color: Color4.red, width: 1, } }\n *   );\n *   strokes.push(new Stroke([ renderablePath ]));\n * }\n *\n * // Convert to commands\n * const addStrokesCommands = strokes.map(stroke => editor.image.addElement(stroke));\n *\n * // Apply all as a single undoable command (try applying each in a loop instead!)\n * await editor.dispatch(uniteCommands(addStrokesCommands));\n *\n * // The second parameter to uniteCommands is for very large numbers of commands, when\n * // applying them shouldn't be done all at once (which would block the UI).\n *\n * // The second parameter to uniteCommands is for very large numbers of commands, when\n * // applying them shouldn't be done all at once (which would block the UI).\n * ```\n */\nconst uniteCommands = (commands, options) => {\n    let allSerializable = true;\n    for (const command of commands) {\n        if (!(command instanceof SerializableCommand)) {\n            allSerializable = false;\n            break;\n        }\n    }\n    let applyChunkSize;\n    let description;\n    if (typeof options === 'number') {\n        applyChunkSize = options;\n    }\n    else {\n        applyChunkSize = options?.applyChunkSize;\n        description = options?.description;\n    }\n    if (!allSerializable) {\n        return new NonSerializableUnion(commands, applyChunkSize, description);\n    }\n    else {\n        const castedCommands = commands;\n        return new SerializableUnion(castedCommands, applyChunkSize, description);\n    }\n};\nSerializableCommand.register('union', (data, editor) => {\n    if (typeof data.data.length !== 'number') {\n        throw new Error('Unions of commands must serialize to lists of serialization data.');\n    }\n    const applyChunkSize = data.applyChunkSize;\n    if (typeof applyChunkSize !== 'number' && applyChunkSize !== undefined) {\n        throw new Error('serialized applyChunkSize is neither undefined nor a number.');\n    }\n    const description = typeof data.description === 'string' ? data.description : undefined;\n    const commands = [];\n    for (const part of data.data) {\n        commands.push(SerializableCommand.deserialize(part, editor));\n    }\n    return uniteCommands(commands, { applyChunkSize, description });\n});\nexport default uniteCommands;\n","var __setFunctionName = (this && this.__setFunctionName) || function (f, name, prefix) {\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\nvar _a;\nimport  SerializableCommand  from '../commands/SerializableCommand.mjs';\nimport  EditorImage  from '../image/EditorImage.mjs';\nimport { Mat33 } from '@js-draw/math';\nimport  UnresolvedSerializableCommand  from '../commands/UnresolvedCommand.mjs';\nexport var ComponentSizingMode;\n(function (ComponentSizingMode) {\n    /** The default. The compnent gets its size from its bounding box. */\n    ComponentSizingMode[ComponentSizingMode[\"BoundingBox\"] = 0] = \"BoundingBox\";\n    /** Causes the component to fill the entire visible region of the screen */\n    ComponentSizingMode[ComponentSizingMode[\"FillScreen\"] = 1] = \"FillScreen\";\n    /**\n     * Displays the component anywhere (arbitrary location) on the\n     * canvas. (Ignoring the bounding box).\n     *\n     * These components may be ignored unless a full render is done.\n     *\n     * Intended for compnents that need to be rendered on a full export,\n     * but won't be visible to the user.\n     *\n     * For example, a metadata component.\n     */\n    ComponentSizingMode[ComponentSizingMode[\"Anywhere\"] = 2] = \"Anywhere\";\n})(ComponentSizingMode || (ComponentSizingMode = {}));\n/**\n * A base class for everything that can be added to an {@link EditorImage}.\n */\nclass AbstractComponent {\n    constructor(\n    // A unique identifier for the type of component\n    componentKind, initialZIndex) {\n        this.componentKind = componentKind;\n        // Stores data attached by a loader.\n        this.loadSaveData = {};\n        this.lastChangedTime = new Date().getTime();\n        if (initialZIndex !== undefined) {\n            this.zIndex = initialZIndex;\n        }\n        else {\n            this.zIndex = AbstractComponent.zIndexCounter++;\n        }\n        // Create a unique ID.\n        this.id = `${new Date().getTime()}-${Math.random()}`;\n        if (AbstractComponent.deserializationCallbacks[componentKind] === undefined) {\n            throw new Error(`Component ${componentKind} has not been registered using AbstractComponent.registerComponent`);\n        }\n    }\n    // Returns a unique ID for this element.\n    // @see { @link EditorImage.lookupElement }\n    getId() {\n        return this.id;\n    }\n    // Store the deserialization callback (or lack of it) for [componentKind].\n    // If components are registered multiple times (as may be done in automated tests),\n    // the most recent deserialization callback is used.\n    static registerComponent(componentKind, deserialize) {\n        this.deserializationCallbacks[componentKind] = deserialize ?? null;\n    }\n    /**\n     * Attach data that can be used while exporting the component (e.g. to SVG).\n     *\n     * This is intended for use by an {@link ImageLoader}.\n     */\n    attachLoadSaveData(key, data) {\n        if (!this.loadSaveData[key]) {\n            this.loadSaveData[key] = [];\n        }\n        this.loadSaveData[key].push(data);\n    }\n    /** See {@link attachLoadSaveData} */\n    getLoadSaveData() {\n        return this.loadSaveData;\n    }\n    getZIndex() {\n        return this.zIndex;\n    }\n    /**\n     * @returns the bounding box of this. This can be a slight overestimate if doing so\n     * \t\t\tsignificantly improves performance.\n     */\n    getBBox() {\n        return this.contentBBox;\n    }\n    /**\n     * @returns the bounding box of this. Unlike `getBBox`, this should **not** be a rough estimate.\n     */\n    getExactBBox() {\n        return this.getBBox();\n    }\n    /**\n     * Returns information about how this component should be displayed\n     * (e.g. fill the screen or get its size from {@link getBBox}).\n     *\n     * {@link EditorImage.queueRerenderOf} must be called to apply changes to\n     * the output of this method if this component has already been added to an\n     * {@link EditorImage}.\n     */\n    getSizingMode() {\n        return ComponentSizingMode.BoundingBox;\n    }\n    /**\n     * **Optimization**\n     *\n     * Should return `true` if this component covers the entire `visibleRect`\n     * and would prevent anything below this component from being visible.\n     *\n     * Should return `false` otherwise.\n     */\n    occludesEverythingBelowWhenRenderedInRect(_visibleRect) {\n        return false;\n    }\n    /** Called when this component is added to the given image. */\n    onAddToImage(_image) { }\n    onRemoveFromImage() { }\n    /**\n     * @returns true if this component intersects `rect` -- it is entirely contained\n     *  within the rectangle or one of the rectangle's edges intersects this component.\n     *\n     * The default implementation assumes that `this.getExactBBox()` returns a tight bounding box\n     * -- that any horiziontal/vertical line that intersects this' boounding box also\n     * intersects a point in this component. If this is not the case, components must override\n     * this function.\n     */\n    intersectsRect(rect) {\n        // If this component intersects the given rectangle,\n        // it is either contained entirely within rect or intersects one of rect's edges.\n        // If contained within,\n        if (rect.containsRect(this.getExactBBox())) {\n            return true;\n        }\n        // Otherwise check if it intersects one of the rectangle's edges.\n        const testLines = rect.getEdges();\n        return testLines.some((edge) => this.intersects(edge));\n    }\n    // @returns true iff this component can be selected (e.g. by the selection tool.)\n    isSelectable() {\n        return true;\n    }\n    // @returns true iff this component should be added to the background, rather than the\n    // foreground of the image.\n    isBackground() {\n        return false;\n    }\n    // @returns an approximation of the proportional time it takes to render this component.\n    // This is intended to be a rough estimate, but, for example, a stroke with two points sould have\n    // a renderingWeight approximately twice that of a stroke with one point.\n    getProportionalRenderingTime() {\n        return 1;\n    }\n    /**\n     * Returns a command that, when applied, transforms this by [affineTransfm] and\n     * updates the editor.\n     *\n     * The transformed component is also moved to the top (use\n     * {@link AbstractComponent#setZIndexAndTransformBy} to avoid this behavior).\n     */\n    transformBy(affineTransfm) {\n        return new AbstractComponent.TransformElementCommand(affineTransfm, this.getId(), this);\n    }\n    // Returns a command that updates this component's z-index.\n    setZIndex(newZIndex) {\n        return new AbstractComponent.TransformElementCommand(Mat33.identity, this.getId(), this, newZIndex);\n    }\n    /**\n     * Combines {@link transformBy} and {@link setZIndex} into a single command.\n     *\n     * @param newZIndex - The z-index this component should have after applying this command.\n     * @param originalZIndex - @internal The z-index the component should revert to after unapplying\n     *                         this command.\n     */\n    setZIndexAndTransformBy(affineTransfm, newZIndex, originalZIndex) {\n        return new AbstractComponent.TransformElementCommand(affineTransfm, this.getId(), this, newZIndex, originalZIndex);\n    }\n    // Returns a copy of this component.\n    clone() {\n        const clone = this.createClone();\n        for (const attachmentKey in this.loadSaveData) {\n            for (const val of this.loadSaveData[attachmentKey]) {\n                clone.attachLoadSaveData(attachmentKey, val);\n            }\n        }\n        return clone;\n    }\n    // Convert the component to an object that can be passed to\n    // `JSON.stringify`.\n    //\n    // Do not rely on the output of this function to take a particular form —\n    // this function's output can change form without a major version increase.\n    serialize() {\n        const data = this.serializeToJSON();\n        if (data === null) {\n            throw new Error(`${this} cannot be serialized.`);\n        }\n        return {\n            name: this.componentKind,\n            zIndex: this.zIndex,\n            id: this.id,\n            loadSaveData: this.loadSaveData,\n            data,\n        };\n    }\n    // Returns true if `data` is not deserializable. May return false even if [data]\n    // is not deserializable.\n    static isNotDeserializable(json) {\n        if (typeof json === 'string') {\n            json = JSON.parse(json);\n        }\n        if (typeof json !== 'object') {\n            return true;\n        }\n        if (!this.deserializationCallbacks[json?.name]) {\n            return true;\n        }\n        if (!json.data) {\n            return true;\n        }\n        return false;\n    }\n    // Convert a string or an object produced by `JSON.parse` into an `AbstractComponent`.\n    static deserialize(json) {\n        if (typeof json === 'string') {\n            json = JSON.parse(json);\n        }\n        if (AbstractComponent.isNotDeserializable(json)) {\n            throw new Error(`Element with data ${json} cannot be deserialized.`);\n        }\n        const instance = this.deserializationCallbacks[json.name](json.data);\n        instance.id = json.id;\n        if (isFinite(json.zIndex)) {\n            instance.zIndex = json.zIndex;\n            // Ensure that new components will be added on top.\n            AbstractComponent.zIndexCounter = Math.max(AbstractComponent.zIndexCounter, instance.zIndex + 1);\n        }\n        // TODO: What should we do with json.loadSaveData?\n        //       If we attach it to [instance], we create a potential security risk — loadSaveData\n        //       is often used to store unrecognised attributes so they can be preserved on output.\n        //       ...but what if we're deserializing data sent across the network?\n        return instance;\n    }\n}\n// Topmost z-index\n// TODO: Should be a property of the EditorImage.\nAbstractComponent.zIndexCounter = 0;\nAbstractComponent.deserializationCallbacks = {};\nAbstractComponent.transformElementCommandId = 'transform-element';\nAbstractComponent.TransformElementCommand = (_a = class extends UnresolvedSerializableCommand {\n        // Construct a new TransformElementCommand. `component`, while optional, should\n        // be provided if available. If not provided, it will be fetched from the editor's\n        // document when the command is applied.\n        constructor(affineTransfm, componentID, component, targetZIndex, origZIndex) {\n            super(AbstractComponent.transformElementCommandId, componentID, component);\n            this.affineTransfm = affineTransfm;\n            this.origZIndex = origZIndex;\n            this.targetZIndex = targetZIndex ?? AbstractComponent.zIndexCounter++;\n            // Ensure that we keep drawing on top even after changing the z-index.\n            if (this.targetZIndex >= AbstractComponent.zIndexCounter) {\n                AbstractComponent.zIndexCounter = this.targetZIndex + 1;\n            }\n            if (component && origZIndex === undefined) {\n                this.origZIndex = component.getZIndex();\n            }\n        }\n        resolveComponent(image) {\n            if (this.component) {\n                return;\n            }\n            super.resolveComponent(image);\n            this.origZIndex ??= this.component.getZIndex();\n        }\n        updateTransform(editor, newTransfm, targetZIndex) {\n            if (!this.component) {\n                throw new Error('this.component is undefined or null!');\n            }\n            // Any parent should have only one direct child.\n            const parent = editor.image.findParent(this.component);\n            let hadParent = false;\n            if (parent) {\n                parent.remove();\n                hadParent = true;\n            }\n            this.component.applyTransformation(newTransfm);\n            this.component.zIndex = targetZIndex;\n            this.component.lastChangedTime = new Date().getTime();\n            // Ensure that new components are automatically drawn above the current component.\n            if (targetZIndex >= AbstractComponent.zIndexCounter) {\n                AbstractComponent.zIndexCounter = targetZIndex + 1;\n            }\n            // Add the element back to the document.\n            if (hadParent) {\n                EditorImage.addElement(this.component).apply(editor);\n            }\n        }\n        apply(editor) {\n            this.resolveComponent(editor.image);\n            this.updateTransform(editor, this.affineTransfm, this.targetZIndex);\n            editor.queueRerender();\n        }\n        unapply(editor) {\n            this.resolveComponent(editor.image);\n            this.updateTransform(editor, this.affineTransfm.inverse(), this.origZIndex);\n            editor.queueRerender();\n        }\n        description(_editor, localizationTable) {\n            return localizationTable.transformedElements(1);\n        }\n        serializeToJSON() {\n            return {\n                id: this.componentID,\n                transfm: this.affineTransfm.toArray(),\n                targetZIndex: this.targetZIndex,\n                origZIndex: this.origZIndex,\n            };\n        }\n    },\n    __setFunctionName(_a, \"TransformElementCommand\"),\n    (() => {\n        SerializableCommand.register(AbstractComponent.transformElementCommandId, (json, editor) => {\n            const elem = editor.image.lookupElement(json.id) ?? undefined;\n            const transform = new Mat33(...json.transfm);\n            const targetZIndex = json.targetZIndex;\n            const origZIndex = json.origZIndex ?? undefined;\n            return new AbstractComponent.TransformElementCommand(transform, json.id, elem, targetZIndex, origZIndex);\n        });\n    })(),\n    _a);\nexport default AbstractComponent;\n","import  { EditorImageEventType }  from '../image/EditorImage.mjs';\nimport { Rect2, Color4, toRoundedString, Path, PathCommandType, Vec2, } from '@js-draw/math';\nimport  AbstractComponent, { ComponentSizingMode }  from './AbstractComponent.mjs';\nimport  { createRestyleComponentCommand, }  from './RestylableComponent.mjs';\nimport  Viewport  from '../Viewport.mjs';\nimport  { pathToRenderable }  from '../rendering/RenderablePathSpec.mjs';\nexport var BackgroundType;\n(function (BackgroundType) {\n    BackgroundType[BackgroundType[\"SolidColor\"] = 0] = \"SolidColor\";\n    BackgroundType[BackgroundType[\"Grid\"] = 1] = \"Grid\";\n    BackgroundType[BackgroundType[\"None\"] = 2] = \"None\";\n})(BackgroundType || (BackgroundType = {}));\nexport const imageBackgroundCSSClassName = 'js-draw-image-background';\n// Class name prefix indicating the size of the background's grid cells (if present).\nexport const imageBackgroundGridSizeCSSPrefix = 'js-draw-image-background-grid-';\n// Flag included in rendered SVGs (etc) that indicates that the secondary color of the\n// background has been manually set.\nexport const imageBackgroundNonAutomaticSecondaryColorCSSClassName = 'js-draw-image-background-non-automatic-secondary-color';\nexport const backgroundTypeToClassNameMap = {\n    [BackgroundType.Grid]: 'js-draw-image-background-grid',\n    [BackgroundType.SolidColor]: imageBackgroundCSSClassName,\n    [BackgroundType.None]: '',\n};\n// Represents the background of the editor's canvas.\nexport default class BackgroundComponent extends AbstractComponent {\n    constructor(backgroundType, mainColor) {\n        super('image-background', 0);\n        this.backgroundType = backgroundType;\n        this.mainColor = mainColor;\n        this.viewportSizeChangeListener = null;\n        this.autoresizeChangedListener = null;\n        // Whether the background should grow/shrink to match the screen size,\n        // rather than being clipped to the image boundaries.\n        this.fillsScreen = false;\n        this.gridSize = Viewport.getGridSize(2);\n        this.gridStrokeWidth = 0.7;\n        this.secondaryColor = null;\n        // eslint-disable-next-line @typescript-eslint/prefer-as-const\n        this.isRestylableComponent = true;\n        this.contentBBox = Rect2.empty;\n    }\n    static ofGrid(backgroundColor, gridSize, gridColor, gridStrokeWidth) {\n        const background = new BackgroundComponent(BackgroundType.Grid, backgroundColor);\n        if (gridSize !== undefined) {\n            background.gridSize = gridSize;\n        }\n        if (gridColor !== undefined) {\n            background.secondaryColor = gridColor;\n        }\n        if (gridStrokeWidth !== undefined) {\n            background.gridStrokeWidth = gridStrokeWidth;\n        }\n        return background;\n    }\n    getBackgroundType() {\n        return this.backgroundType;\n    }\n    // @internal\n    getMainColor() {\n        return this.mainColor;\n    }\n    // @internal\n    getSecondaryColor() {\n        return this.secondaryColor;\n    }\n    // @internal\n    getGridSize() {\n        return this.gridSize;\n    }\n    getStyle() {\n        let color = this.mainColor;\n        if (this.backgroundType === BackgroundType.None) {\n            color = undefined;\n        }\n        return {\n            color,\n        };\n    }\n    updateStyle(style) {\n        return createRestyleComponentCommand(this.getStyle(), style, this);\n    }\n    // @internal\n    forceStyle(style, editor) {\n        const fill = style.color;\n        if (!fill) {\n            return;\n        }\n        this.mainColor = fill;\n        // A solid background and transparent fill is equivalent to no background.\n        if (fill.eq(Color4.transparent) && this.backgroundType === BackgroundType.SolidColor) {\n            this.backgroundType = BackgroundType.None;\n        }\n        else if (this.backgroundType === BackgroundType.None) {\n            this.backgroundType = BackgroundType.SolidColor;\n        }\n        if (editor) {\n            editor.image.queueRerenderOf(this);\n            editor.queueRerender();\n        }\n    }\n    onAddToImage(image) {\n        if (this.viewportSizeChangeListener) {\n            console.warn('onAddToImage called when background is already in an image');\n            this.onRemoveFromImage();\n        }\n        this.viewportSizeChangeListener = image.notifier.on(EditorImageEventType.ExportViewportChanged, () => {\n            this.recomputeBBox(image);\n        });\n        this.autoresizeChangedListener = image.notifier.on(EditorImageEventType.AutoresizeModeChanged, () => {\n            this.recomputeBBox(image);\n        });\n        this.recomputeBBox(image);\n    }\n    onRemoveFromImage() {\n        this.viewportSizeChangeListener?.remove();\n        this.autoresizeChangedListener?.remove();\n        this.viewportSizeChangeListener = null;\n        this.autoresizeChangedListener = null;\n    }\n    recomputeBBox(image) {\n        const importExportRect = image.getImportExportViewport().visibleRect;\n        let needsRerender = false;\n        if (!this.contentBBox.eq(importExportRect)) {\n            this.contentBBox = importExportRect;\n            // If the box already fills the screen, rerendering it will have\n            // no visual effect.\n            //\n            // TODO: This decision should be made by queueRerenderOf and not here.\n            //\n            needsRerender ||= !this.fillsScreen;\n        }\n        const imageAutoresizes = image.getAutoresizeEnabled();\n        if (imageAutoresizes !== this.fillsScreen) {\n            this.fillsScreen = imageAutoresizes;\n            needsRerender = true;\n        }\n        if (needsRerender) {\n            // Re-renders this if already added to the EditorImage.\n            image.queueRerenderOf(this);\n        }\n    }\n    generateGridPath(visibleRect) {\n        const contentBBox = this.getFullBoundingBox(visibleRect);\n        // .grownBy acts on all sides, so we need only grow by strokeWidth / 2 (1 * the stroke radius)\n        const targetRect = (visibleRect?.intersection(contentBBox) ?? contentBBox).grownBy(this.gridStrokeWidth / 2);\n        const roundDownToGrid = (coord) => Math.floor(coord / this.gridSize) * this.gridSize;\n        const roundUpToGrid = (coord) => Math.ceil(coord / this.gridSize) * this.gridSize;\n        const startY = roundUpToGrid(targetRect.y);\n        const endY = roundDownToGrid(targetRect.y + targetRect.h);\n        const startX = roundUpToGrid(targetRect.x);\n        const endX = roundDownToGrid(targetRect.x + targetRect.w);\n        const result = [];\n        // Don't generate grids with a huge number of rows/columns -- such grids\n        // take a long time to render and are likely invisible due to the number of\n        // cells.\n        const rowCount = (endY - startY) / this.gridSize;\n        const colCount = (endX - startX) / this.gridSize;\n        const maxGridCols = 1000;\n        const maxGridRows = 1000;\n        if (rowCount > maxGridRows || colCount > maxGridCols) {\n            return Path.empty;\n        }\n        const startPoint = Vec2.of(targetRect.x, startY);\n        for (let y = startY; y <= endY; y += this.gridSize) {\n            result.push({\n                kind: PathCommandType.MoveTo,\n                point: Vec2.of(targetRect.x, y),\n            });\n            result.push({\n                kind: PathCommandType.LineTo,\n                point: Vec2.of(targetRect.x + targetRect.w, y),\n            });\n        }\n        for (let x = startX; x <= endX; x += this.gridSize) {\n            result.push({\n                kind: PathCommandType.MoveTo,\n                point: Vec2.of(x, targetRect.y),\n            });\n            result.push({\n                kind: PathCommandType.LineTo,\n                point: Vec2.of(x, targetRect.y + targetRect.h),\n            });\n        }\n        return new Path(startPoint, result);\n    }\n    /**\n     * @returns this background's bounding box if the screen size is taken into\n     * account (which may be necessary if this component is configured to fill the\n     * entire screen).\n     */\n    getFullBoundingBox(visibleRect) {\n        return (this.fillsScreen ? visibleRect : this.contentBBox) ?? this.contentBBox;\n    }\n    render(canvas, visibleRect) {\n        if (this.backgroundType === BackgroundType.None) {\n            return;\n        }\n        // If visibleRect is null, components should render everything.\n        // In that case, a full render is being done.\n        const mustRender = !visibleRect;\n        // If this.fillsScreen, the visibleRect needs to be known.\n        // Use the screen rect.\n        if (this.fillsScreen) {\n            visibleRect ??= canvas.getVisibleRect();\n        }\n        const clip = this.backgroundType === BackgroundType.Grid;\n        const contentBBox = this.getFullBoundingBox(visibleRect);\n        canvas.startObject(contentBBox, clip);\n        if (this.backgroundType === BackgroundType.SolidColor ||\n            this.backgroundType === BackgroundType.Grid) {\n            // If the rectangle for this region contains the visible rect,\n            // we can fill the entire visible rectangle (which may be more efficient than\n            // filling the entire region for this.)\n            const intersection = visibleRect?.intersection(contentBBox);\n            if (intersection) {\n                canvas.fillRect(intersection, this.mainColor);\n            }\n            else if (mustRender) {\n                canvas.fillRect(contentBBox, this.mainColor);\n            }\n        }\n        if (this.backgroundType === BackgroundType.Grid) {\n            let gridColor = this.secondaryColor;\n            gridColor ??= Color4.ofRGBA(1 - this.mainColor.r, 1 - this.mainColor.g, 1 - this.mainColor.b, 0.2);\n            // If the background fill is completely transparent, ensure visibility on otherwise light\n            // and dark backgrounds.\n            if (this.mainColor.a === 0) {\n                gridColor = Color4.ofRGBA(0.5, 0.5, 0.5, 0.2);\n            }\n            const style = {\n                fill: Color4.transparent,\n                stroke: { width: this.gridStrokeWidth, color: gridColor },\n            };\n            canvas.drawPath(pathToRenderable(this.generateGridPath(visibleRect), style));\n        }\n        const backgroundTypeCSSClass = backgroundTypeToClassNameMap[this.backgroundType];\n        const classNames = [imageBackgroundCSSClassName];\n        if (backgroundTypeCSSClass !== imageBackgroundCSSClassName) {\n            classNames.push(backgroundTypeCSSClass);\n            const gridSizeStr = toRoundedString(this.gridSize).replace(/[.]/g, 'p');\n            classNames.push(imageBackgroundGridSizeCSSPrefix + gridSizeStr);\n        }\n        if (this.secondaryColor !== null) {\n            classNames.push(imageBackgroundNonAutomaticSecondaryColorCSSClassName);\n        }\n        canvas.endObject(this.getLoadSaveData(), classNames);\n    }\n    intersects(lineSegment) {\n        return this.contentBBox.getEdges().some((edge) => edge.intersects(lineSegment));\n    }\n    isSelectable() {\n        return false;\n    }\n    isBackground() {\n        return true;\n    }\n    getSizingMode() {\n        return this.fillsScreen ? ComponentSizingMode.FillScreen : ComponentSizingMode.BoundingBox;\n    }\n    serializeToJSON() {\n        return {\n            mainColor: this.mainColor.toHexString(),\n            secondaryColor: this.secondaryColor?.toHexString(),\n            backgroundType: this.backgroundType,\n            gridSize: this.gridSize,\n            gridStrokeWidth: this.gridStrokeWidth,\n        };\n    }\n    applyTransformation(_affineTransfm) {\n        // Do nothing — it doesn't make sense to transform the background.\n    }\n    description(localizationTable) {\n        if (this.backgroundType === BackgroundType.SolidColor) {\n            return localizationTable.filledBackgroundWithColor(this.mainColor.toString());\n        }\n        else if (this.backgroundType === BackgroundType.None) {\n            return localizationTable.emptyBackground;\n        }\n        else if (this.backgroundType === BackgroundType.Grid) {\n            return localizationTable.gridBackground;\n        }\n        else {\n            const exhaustivenessCheck = this.backgroundType;\n            return exhaustivenessCheck;\n        }\n    }\n    createClone() {\n        return new BackgroundComponent(this.backgroundType, this.mainColor);\n    }\n    // @internal\n    static deserializeFromJSON(json) {\n        if (typeof json === 'string') {\n            json = JSON.parse(json);\n        }\n        if (typeof json.mainColor !== 'string') {\n            throw new Error('Error deserializing — mainColor must be of type string.');\n        }\n        let backgroundType;\n        const jsonBackgroundType = json.backgroundType;\n        if (jsonBackgroundType === BackgroundType.None ||\n            jsonBackgroundType === BackgroundType.Grid ||\n            jsonBackgroundType === BackgroundType.SolidColor) {\n            backgroundType = jsonBackgroundType;\n        }\n        else {\n            const exhaustivenessCheck = jsonBackgroundType;\n            return exhaustivenessCheck;\n        }\n        const mainColor = Color4.fromHex(json.mainColor);\n        const secondaryColor = json.secondaryColor ? Color4.fromHex(json.secondaryColor) : null;\n        const gridSize = json.gridSize ?? undefined;\n        const gridStrokeWidth = json.gridStrokeWidth ?? undefined;\n        const result = new BackgroundComponent(backgroundType, mainColor);\n        result.secondaryColor = secondaryColor;\n        if (gridSize) {\n            result.gridSize = gridSize;\n        }\n        if (gridStrokeWidth) {\n            result.gridStrokeWidth = gridStrokeWidth;\n        }\n        return result;\n    }\n}\nAbstractComponent.registerComponent('image-background', BackgroundComponent.deserializeFromJSON);\n","import { Rect2, Mat33 } from '@js-draw/math';\nimport  { assertIsNumber, assertIsNumberArray }  from '../util/assertions.mjs';\nimport  AbstractComponent  from './AbstractComponent.mjs';\nimport  waitForImageLoaded  from '../util/waitForImageLoaded.mjs';\n/**\n * Represents a raster image.\n *\n * **Example: Adding images**:\n * [[include:doc-pages/inline-examples/adding-an-image-and-data-urls.md]]\n */\nexport default class ImageComponent extends AbstractComponent {\n    constructor(image) {\n        super('image-component');\n        this.image = {\n            ...image,\n            label: image.label ??\n                image.image.getAttribute('alt') ??\n                image.image.getAttribute('aria-label') ??\n                undefined,\n        };\n        const isHTMLImageElem = (elem) => {\n            return elem.getAttribute('src') !== undefined;\n        };\n        if (isHTMLImageElem(image.image) && !image.image.complete) {\n            image.image.onload = () => this.recomputeBBox();\n        }\n        this.recomputeBBox();\n    }\n    getImageRect() {\n        return new Rect2(0, 0, this.image.image.width, this.image.image.height);\n    }\n    recomputeBBox() {\n        this.contentBBox = this.getImageRect();\n        this.contentBBox = this.contentBBox.transformedBoundingBox(this.image.transform);\n    }\n    /**\n     * Load from an image. Waits for the image to load if incomplete.\n     *\n     * The image, `elem`, must not [taint](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image#security_and_tainted_canvases)\n     * an HTMLCanvasElement when rendered.\n     */\n    static async fromImage(elem, transform) {\n        await waitForImageLoaded(elem);\n        let width, height;\n        if (typeof elem.width === 'number' &&\n            typeof elem.height === 'number' &&\n            elem.width !== 0 &&\n            elem.height !== 0) {\n            width = elem.width;\n            height = elem.height;\n        }\n        else {\n            width = elem.clientWidth;\n            height = elem.clientHeight;\n        }\n        let image;\n        let url = elem.src ?? '';\n        if (!url.startsWith('data:image/')) {\n            // Convert to a data URL:\n            const canvas = document.createElement('canvas');\n            canvas.width = width;\n            canvas.height = height;\n            const ctx = canvas.getContext('2d');\n            ctx.drawImage(elem, 0, 0, canvas.width, canvas.height);\n            url = canvas.toDataURL();\n            image = canvas;\n        }\n        else {\n            image = new Image();\n            image.src = url;\n            image.width = width;\n            image.height = height;\n        }\n        image.setAttribute('alt', elem.getAttribute('alt') ?? '');\n        image.setAttribute('aria-label', elem.getAttribute('aria-label') ?? '');\n        return new ImageComponent({\n            image,\n            base64Url: url,\n            transform: transform,\n        });\n    }\n    render(canvas, _visibleRect) {\n        canvas.startObject(this.contentBBox);\n        canvas.drawImage(this.image);\n        canvas.endObject(this.getLoadSaveData());\n    }\n    // A *very* rough estimate of how long it takes to render this component\n    getProportionalRenderingTime() {\n        // Estimate: Equivalent to a stroke with 10 segments.\n        return 10;\n    }\n    intersects(lineSegment) {\n        const rect = this.getImageRect();\n        const edges = rect.getEdges().map((edge) => edge.transformedBy(this.image.transform));\n        for (const edge of edges) {\n            if (edge.intersects(lineSegment)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    applyTransformation(affineTransfm) {\n        this.image.transform = affineTransfm.rightMul(this.image.transform);\n        this.recomputeBBox();\n    }\n    description(localizationTable) {\n        return this.image.label\n            ? localizationTable.imageNode(this.image.label)\n            : localizationTable.unlabeledImageNode;\n    }\n    getAltText() {\n        return this.image.label;\n    }\n    // The base64 image URL of this image.\n    getURL() {\n        return this.image.base64Url;\n    }\n    getTransformation() {\n        return this.image.transform;\n    }\n    createClone() {\n        return new ImageComponent({\n            ...this.image,\n        });\n    }\n    serializeToJSON() {\n        return {\n            src: this.image.base64Url,\n            label: this.image.label,\n            // Store the width and height for bounding box computations while the image is loading.\n            width: this.image.image.width,\n            height: this.image.image.height,\n            transform: this.image.transform.toArray(),\n        };\n    }\n    static deserializeFromJSON(data) {\n        if (!(typeof data.src === 'string')) {\n            throw new Error(`${data} has invalid format! Expected src property.`);\n        }\n        assertIsNumberArray(data.transform);\n        assertIsNumber(data.width);\n        assertIsNumber(data.height);\n        const image = new Image();\n        image.src = data.src;\n        image.width = data.width;\n        image.height = data.height;\n        const transform = new Mat33(...data.transform);\n        return new ImageComponent({\n            image: image,\n            base64Url: data.src,\n            label: data.label,\n            transform,\n        });\n    }\n}\nAbstractComponent.registerComponent('image-component', ImageComponent.deserializeFromJSON);\n","import { Color4 } from '@js-draw/math';\nimport  SerializableCommand  from '../commands/SerializableCommand.mjs';\nimport  UnresolvedSerializableCommand  from '../commands/UnresolvedCommand.mjs';\nimport  { textStyleFromJSON, textStyleToJSON, }  from '../rendering/TextRenderingStyle.mjs';\nconst serializeComponentStyle = (style) => {\n    const result = {};\n    if (style.color) {\n        result.color = style.color.toHexString();\n    }\n    if (style.textStyle) {\n        result.textStyle = textStyleToJSON(style.textStyle);\n    }\n    return result;\n};\nconst deserializeComponentStyle = (json) => {\n    const color = json.color ? Color4.fromHex(json.color) : undefined;\n    const textStyle = json.textStyle ? textStyleFromJSON(json.textStyle) : undefined;\n    return {\n        color,\n        textStyle,\n    };\n};\n// For internal use by Components implementing `updateStyle`:\nexport const createRestyleComponentCommand = (initialStyle, newStyle, component) => {\n    return new DefaultRestyleComponentCommand(initialStyle, newStyle, component.getId(), component);\n};\n// Returns true if `component` is a `RestylableComponent`.\nexport const isRestylableComponent = (component) => {\n    const hasMethods = 'getStyle' in component && 'updateStyle' in component && 'forceStyle' in component;\n    if (!hasMethods) {\n        return false;\n    }\n    if (!('isRestylableComponent' in component) || !component['isRestylableComponent']) {\n        return false;\n    }\n    return true;\n};\nconst defaultRestyleComponentCommandId = 'default-restyle-element';\nclass DefaultRestyleComponentCommand extends UnresolvedSerializableCommand {\n    constructor(originalStyle, newStyle, componentID, component) {\n        super(defaultRestyleComponentCommandId, componentID, component);\n        this.originalStyle = originalStyle;\n        this.newStyle = newStyle;\n    }\n    getComponent(editor) {\n        this.resolveComponent(editor.image);\n        const component = this.component;\n        if (!component || !component['forceStyle'] || !component['updateStyle']) {\n            throw new Error('this.component is missing forceStyle and/or updateStyle methods!');\n        }\n        return component;\n    }\n    apply(editor) {\n        this.getComponent(editor).forceStyle(this.newStyle, editor);\n    }\n    unapply(editor) {\n        this.getComponent(editor).forceStyle(this.originalStyle, editor);\n    }\n    description(editor, localizationTable) {\n        return localizationTable.restyledElement(this.getComponent(editor).description(localizationTable));\n    }\n    serializeToJSON() {\n        return {\n            id: this.componentID,\n            originalStyle: serializeComponentStyle(this.originalStyle),\n            newStyle: serializeComponentStyle(this.newStyle),\n        };\n    }\n}\n(() => {\n    SerializableCommand.register(defaultRestyleComponentCommandId, (json, _editor) => {\n        const origStyle = deserializeComponentStyle(json.originalStyle);\n        const newStyle = deserializeComponentStyle(json.newStyle);\n        const id = json.id;\n        if (typeof json.id !== 'string') {\n            throw new Error(`json.id is of type ${typeof json.id}, not string.`);\n        }\n        return new DefaultRestyleComponentCommand(origStyle, newStyle, id);\n    });\n})();\n","//\n// Used by `SVGLoader`s to store unrecognised global attributes\n// (e.g. unrecognised XML namespace declarations).\n// @internal\n// @packageDocumentation\n//\nimport { Rect2 } from '@js-draw/math';\nimport  SVGRenderer  from '../rendering/renderers/SVGRenderer.mjs';\nimport  AbstractComponent, { ComponentSizingMode }  from './AbstractComponent.mjs';\nconst componentKind = 'svg-global-attributes';\n// Stores global SVG attributes (e.g. namespace identifiers.)\nexport default class SVGGlobalAttributesObject extends AbstractComponent {\n    // Does not modify `attrs`\n    constructor(attrs) {\n        super(componentKind);\n        this.contentBBox = Rect2.empty;\n        // Already stored/managed in `editor.image`.\n        const attrsManagedByRenderer = ['viewBox', 'width', 'height'];\n        // Only store attributes that aren't managed by other parts of the app.\n        this.attrs = attrs.filter(([attr, _value]) => {\n            return !attrsManagedByRenderer.includes(attr);\n        });\n    }\n    render(canvas, _visibleRect) {\n        if (!(canvas instanceof SVGRenderer)) {\n            // Don't draw unrenderable objects if we can't\n            return;\n        }\n        for (const [attr, value] of this.attrs) {\n            canvas.setRootSVGAttribute(attr, value);\n        }\n    }\n    intersects(_lineSegment) {\n        return false;\n    }\n    applyTransformation(_affineTransfm) { }\n    isSelectable() {\n        return false;\n    }\n    getSizingMode() {\n        // This component can be shown anywhere (it won't be\n        // visible to the user, it just needs to be saved with\n        // the image).\n        return ComponentSizingMode.Anywhere;\n    }\n    createClone() {\n        return new SVGGlobalAttributesObject(this.attrs);\n    }\n    description(localization) {\n        return localization.svgObject;\n    }\n    serializeToJSON() {\n        return JSON.stringify(this.attrs);\n    }\n    static deserializeFromString(_data) {\n        // To be safe, don't deserialize any attributes\n        return new SVGGlobalAttributesObject([]);\n    }\n}\nAbstractComponent.registerComponent(componentKind, SVGGlobalAttributesObject.deserializeFromString);\n","import { Path, Rect2, PathCommandType, comparePathIndices, stepPathIndexBy, } from '@js-draw/math';\nimport  { styleFromJSON, styleToJSON }  from '../rendering/RenderingStyle.mjs';\nimport  AbstractComponent  from './AbstractComponent.mjs';\nimport  { createRestyleComponentCommand, }  from './RestylableComponent.mjs';\nimport  { pathFromRenderable, pathToRenderable, simplifyPathToFullScreenOrEmpty, }  from '../rendering/RenderablePathSpec.mjs';\n/**\n * Represents an {@link AbstractComponent} made up of one or more {@link Path}s.\n *\n * @example\n * For some {@link Editor} editor and `Stroke` stroke,\n *\n * **Restyling**:\n * ```ts\n * editor.dispatch(stroke.updateStyle({ color: Color4.red }));\n * ```\n *\n * **Transforming**:\n * ```ts\n * editor.dispatch(stroke.transformBy(Mat33.translation(Vec2.of(10, 0))));\n * ```\n *\n * **Adding**:\n * [[include:doc-pages/inline-examples/adding-a-stroke.md]]\n */\nexport default class Stroke extends AbstractComponent {\n    /**\n     * Creates a `Stroke` from the given `parts`. All parts should have the\n     * same color.\n     *\n     * @example\n     * ```ts\n     * // A path that starts at (1,1), moves to the right by (2, 0),\n     * // then moves down and right by (3, 3)\n     * const path = Path.fromString('m1,1 2,0 3,3');\n     *\n     * const stroke = new Stroke([\n     *     // Fill with red\n     *     pathToRenderable(path, { fill: Color4.red })\n     * ]);\n     * ```\n     */\n    constructor(parts, initialZIndex) {\n        super('stroke', initialZIndex);\n        // @internal\n        // eslint-disable-next-line @typescript-eslint/prefer-as-const\n        this.isRestylableComponent = true;\n        // A simplification of the path for a given visibleRect. Intended\n        // to help check for occlusion.\n        this.simplifiedPath = null;\n        this.approximateRenderingTime = 0;\n        this.parts = [];\n        for (const section of parts) {\n            const path = pathFromRenderable(section);\n            const pathBBox = this.bboxForPart(path.bbox, section.style);\n            if (!this.contentBBox) {\n                this.contentBBox = pathBBox;\n            }\n            else {\n                this.contentBBox = this.contentBBox.union(pathBBox);\n            }\n            this.parts.push({\n                path,\n                // To implement RenderablePathSpec\n                startPoint: path.startPoint,\n                style: section.style,\n                commands: path.parts,\n            });\n            this.approximateRenderingTime += path.parts.length;\n        }\n        this.contentBBox ??= Rect2.empty;\n    }\n    getStyle() {\n        if (this.parts.length === 0) {\n            return {};\n        }\n        const firstPart = this.parts[0];\n        if (firstPart.style.stroke === undefined || firstPart.style.stroke.width === 0) {\n            return {\n                color: firstPart.style.fill,\n            };\n        }\n        return {\n            color: firstPart.style.stroke.color,\n        };\n    }\n    updateStyle(style) {\n        return createRestyleComponentCommand(this.getStyle(), style, this);\n    }\n    forceStyle(style, editor) {\n        if (!style.color) {\n            return;\n        }\n        this.parts = this.parts.map((part) => {\n            const newStyle = {\n                ...part.style,\n                stroke: part.style.stroke\n                    ? {\n                        ...part.style.stroke,\n                    }\n                    : undefined,\n            };\n            // Change the stroke color if a stroked shape. Else,\n            // change the fill.\n            if (newStyle.stroke && newStyle.stroke.width > 0) {\n                newStyle.stroke.color = style.color;\n            }\n            else {\n                newStyle.fill = style.color;\n            }\n            return {\n                path: part.path,\n                startPoint: part.startPoint,\n                commands: part.commands,\n                style: newStyle,\n            };\n        });\n        if (editor) {\n            editor.image.queueRerenderOf(this);\n            editor.queueRerender();\n        }\n    }\n    /** @beta -- May fail for concave `path`s */\n    withRegionErased(eraserPath, viewport) {\n        const polyline = eraserPath.polylineApproximation();\n        const isPointInsideEraser = (point) => {\n            return eraserPath.closedContainsPoint(point);\n        };\n        const newStrokes = [];\n        let failedAssertions = false;\n        for (const part of this.parts) {\n            const path = part.path;\n            const makeStroke = (path) => {\n                if (part.style.fill.a > 0) {\n                    // Remove visually empty paths.\n                    if (path.parts.length < 1 ||\n                        (path.parts.length === 1 && path.parts[0].kind === PathCommandType.LineTo)) {\n                        // TODO: If this isn't present, a very large number of strokes are created while erasing.\n                        return null;\n                    }\n                    else {\n                        // Filled paths must be closed (allows for optimizations elsewhere)\n                        path = path.asClosed();\n                    }\n                }\n                if (isNaN(path.getExactBBox().area)) {\n                    console.warn('Prevented creating a stroke with NaN area');\n                    failedAssertions = true;\n                    return null;\n                }\n                return new Stroke([pathToRenderable(path, part.style)], this.getZIndex());\n            };\n            const intersectionPoints = [];\n            // If stroked, finds intersections with the middle of the stroke.\n            // If filled, finds intersections with the edge of the stroke.\n            for (const segment of polyline) {\n                intersectionPoints.push(...path.intersection(segment));\n            }\n            // When stroked, if the stroke width is significantly larger than the eraser,\n            // it can't intersect both the edge of the stroke and its middle at the same time\n            // (generally, erasing is triggered by the eraser touching the edge of this stroke).\n            //\n            // As such, we also look for intersections along the edge of this, if none with the\n            // center were found, but only within a certain range of sizes because:\n            // 1. Intersection testing with stroked paths is generally much slower than with\n            //    non-stroked paths.\n            // 2. If zoomed in significantly, it's unlikely that the user wants to erase a large\n            //    part of the stroke.\n            let isErasingFromEdge = false;\n            if (intersectionPoints.length === 0 &&\n                part.style.stroke &&\n                part.style.stroke.width > eraserPath.bbox.minDimension * 0.3 &&\n                part.style.stroke.width < eraserPath.bbox.maxDimension * 30) {\n                for (const segment of polyline) {\n                    intersectionPoints.push(...path.intersection(segment, part.style.stroke.width / 2));\n                }\n                isErasingFromEdge = true;\n            }\n            // Sort first by curve index, then by parameter value\n            intersectionPoints.sort(comparePathIndices);\n            const isInsideJustBeforeFirst = (() => {\n                if (intersectionPoints.length === 0) {\n                    return false;\n                }\n                // The eraser may not be near the center of the curve -- approximate.\n                if (isErasingFromEdge) {\n                    return (intersectionPoints[0].curveIndex === 0 && intersectionPoints[0].parameterValue <= 0);\n                }\n                const justBeforeFirstIntersection = stepPathIndexBy(intersectionPoints[0], -1e-10);\n                return isPointInsideEraser(path.at(justBeforeFirstIntersection));\n            })();\n            let intersectionCount = isInsideJustBeforeFirst ? 1 : 0;\n            const addNewPath = (path, knownToBeInside) => {\n                const component = makeStroke(path);\n                let isInside = intersectionCount % 2 === 1;\n                intersectionCount++;\n                if (knownToBeInside !== undefined) {\n                    isInside = knownToBeInside;\n                }\n                // Here, we work around bugs in the underlying Bezier curve library\n                // (including https://github.com/Pomax/bezierjs/issues/179).\n                // Even if not all intersections are returned correctly, we still want\n                // isInside to be roughly correct.\n                if (knownToBeInside === undefined &&\n                    !isInside &&\n                    eraserPath.closedContainsPoint(path.getExactBBox().center)) {\n                    isInside = !isInside;\n                }\n                if (!component) {\n                    return;\n                }\n                // Assertion: Avoid deleting sections that are much larger than the eraser.\n                failedAssertions ||=\n                    isInside && path.getExactBBox().maxDimension > eraserPath.getExactBBox().maxDimension * 2;\n                if (!isInside) {\n                    newStrokes.push(component);\n                }\n            };\n            if (part.style.fill.a === 0) {\n                // Not filled?\n                // An additional case where we erase completely -- without the padding of the stroke,\n                // the path is smaller than the eraser (allows us to erase dots completely).\n                const shouldEraseCompletely = eraserPath.getExactBBox().maxDimension / 10 > path.getExactBBox().maxDimension;\n                if (!shouldEraseCompletely) {\n                    const split = path.splitAt(intersectionPoints, {\n                        mapNewPoint: (p) => viewport.roundPoint(p),\n                    });\n                    for (const splitPart of split) {\n                        addNewPath(splitPart);\n                    }\n                }\n            }\n            else if (intersectionPoints.length >= 2 && intersectionPoints.length % 2 === 0) {\n                // TODO: Support subtractive erasing on small scales -- see https://github.com/personalizedrefrigerator/js-draw/pull/63/commits/568686e2384219ad0bb07617ea4efff1540aed00\n                //       for a broken implementation.\n                //\n                // We currently assume that a 4-point intersection means that the intersection\n                // looks similar to this:\n                //   -----------\n                //  |   STROKE  |\n                //  |           |\n                //%%x-----------x%%%%%%%\n                //%                    %\n                //%      ERASER        %\n                //%                    %\n                //%%x-----------x%%%%%%%\n                //  |   STROKE  |\n                //   -----------\n                //\n                // Our goal is to separate STROKE into the contiguous parts outside\n                // of the eraser (as shown above).\n                //\n                // To do this, we split STROKE at each intersection:\n                //   3 3 3 3 3 3\n                //  3   STROKE  3\n                //  3           3\n                //  x           x\n                //  2           4\n                //  2   STROKE  4\n                //  2           4\n                //  x           x\n                //  1   STROKE  5\n                //   . 5 5 5 5 5\n                //   ^\n                // Start\n                //\n                // The difficulty here is correctly pairing edges to create the the output\n                // strokes, particularly because we don't know the order of intersection points.\n                const parts = path.splitAt(intersectionPoints, {\n                    mapNewPoint: (p) => viewport.roundPoint(p),\n                });\n                for (let i = 0; i < Math.floor(parts.length / 2); i++) {\n                    addNewPath(parts[i].union(parts[parts.length - i - 1]).asClosed());\n                }\n                if (parts.length % 2 !== 0) {\n                    addNewPath(parts[Math.floor(parts.length / 2)].asClosed());\n                }\n            }\n            else {\n                addNewPath(path, false);\n            }\n        }\n        if (failedAssertions) {\n            return [this];\n        }\n        return newStrokes;\n    }\n    intersects(line) {\n        for (const part of this.parts) {\n            const strokeWidth = part.style.stroke?.width;\n            const strokeRadius = strokeWidth ? strokeWidth / 2 : undefined;\n            if (part.path.intersection(line, strokeRadius).length > 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n    intersectsRect(rect) {\n        // AbstractComponent::intersectsRect can be inexact for strokes with non-zero\n        // stroke radius (has many false negatives). As such, additional checks are\n        // done here, before passing to the superclass.\n        if (!rect.intersects(this.getBBox())) {\n            return false;\n        }\n        // The following check only checks for the positive case:\n        // Sample a set of points that are known to be within each part of this\n        // stroke. For example, the points marked with an \"x\" below:\n        //   ___________________\n        //  /                   \\\n        //  | x              x  |\n        //  \\_____________      |\n        //                |  x  |\n        //                \\_____/\n        //\n        // Because we don't want the following case to result in selection,\n        //   __________________\n        //  /.___.             \\\n        //  || x |          x  |    <-  /* The\n        //  |·---·             |            .___.\n        //  \\____________      |            |   |\n        //               |  x  |            ·---·\n        //               \\_____/           denotes the input rectangle */\n        //\n        // we need to ensure that the rectangle intersects each point **and** the\n        // edge of the rectangle.\n        for (const part of this.parts) {\n            // As such, we need to shrink the input rectangle to verify that the original,\n            // unshrunken rectangle would have intersected the edge of the stroke if it\n            // intersects a point within the stroke.\n            const interiorRect = rect.grownBy(-(part.style.stroke?.width ?? 0));\n            if (interiorRect.area === 0) {\n                continue;\n            }\n            for (const point of part.path.startEndPoints()) {\n                if (interiorRect.containsPoint(point)) {\n                    return true;\n                }\n            }\n        }\n        return super.intersectsRect(rect);\n    }\n    computeSimplifiedPathFor(visibleRect) {\n        const simplifiedParts = [];\n        let occludes = false;\n        let skipSimplification = false;\n        for (const part of this.parts) {\n            if (skipSimplification ||\n                // Simplification currently only works for stroked paths\n                !part.style.stroke ||\n                // One of the main purposes of this is to check for occlusion.\n                // We can't occlude things if the stroke is partially transparent.\n                part.style.stroke.color.a < 0.99) {\n                simplifiedParts.push(part);\n                continue;\n            }\n            const mapping = simplifyPathToFullScreenOrEmpty(part, visibleRect);\n            if (mapping) {\n                simplifiedParts.push(mapping.path);\n                if (mapping.fullScreen) {\n                    occludes = true;\n                    skipSimplification = true;\n                }\n            }\n            else {\n                simplifiedParts.push(part);\n            }\n        }\n        return {\n            forVisibleRect: visibleRect,\n            parts: simplifiedParts,\n            occludes,\n        };\n    }\n    occludesEverythingBelowWhenRenderedInRect(rect) {\n        // Can't occlude if doesn't contain.\n        if (!this.getBBox().containsRect(rect)) {\n            return false;\n        }\n        if (!this.simplifiedPath || !this.simplifiedPath.forVisibleRect.eq(rect)) {\n            this.simplifiedPath = this.computeSimplifiedPathFor(rect);\n        }\n        return this.simplifiedPath.occludes;\n    }\n    render(canvas, visibleRect) {\n        canvas.startObject(this.getBBox());\n        // Can we use a cached simplified path for faster rendering?\n        let parts = this.parts;\n        if (visibleRect && this.simplifiedPath?.forVisibleRect?.containsRect(visibleRect)) {\n            parts = this.simplifiedPath.parts;\n        }\n        else {\n            // Save memory\n            this.simplifiedPath = null;\n        }\n        for (const part of parts) {\n            const bbox = this.bboxForPart(part.path.bbox, part.style);\n            if (visibleRect) {\n                if (!bbox.intersects(visibleRect)) {\n                    continue;\n                }\n                const muchBiggerThanVisible = bbox.size.x > visibleRect.size.x * 3 || bbox.size.y > visibleRect.size.y * 3;\n                if (muchBiggerThanVisible &&\n                    !part.path.roughlyIntersects(visibleRect, part.style.stroke?.width ?? 0)) {\n                    continue;\n                }\n            }\n            canvas.drawPath(part);\n        }\n        canvas.endObject(this.getLoadSaveData());\n    }\n    getProportionalRenderingTime() {\n        return this.approximateRenderingTime;\n    }\n    // Grows the bounding box for a given stroke part based on that part's style.\n    bboxForPart(origBBox, style) {\n        if (!style.stroke) {\n            return origBBox;\n        }\n        return origBBox.grownBy(style.stroke.width / 2);\n    }\n    getExactBBox() {\n        let bbox = null;\n        for (const { path, style } of this.parts) {\n            // Paths' default .bbox can be\n            const partBBox = this.bboxForPart(path.getExactBBox(), style);\n            bbox ??= partBBox;\n            bbox = bbox.union(partBBox);\n        }\n        return bbox ?? Rect2.empty;\n    }\n    applyTransformation(affineTransfm) {\n        this.contentBBox = Rect2.empty;\n        let isFirstPart = true;\n        // Update each part\n        this.parts = this.parts.map((part) => {\n            const newPath = part.path.transformedBy(affineTransfm);\n            const newStyle = {\n                ...part.style,\n                stroke: part.style.stroke\n                    ? {\n                        ...part.style.stroke,\n                    }\n                    : undefined,\n            };\n            // Approximate the scale factor.\n            if (newStyle.stroke) {\n                const scaleFactor = affineTransfm.getScaleFactor();\n                newStyle.stroke.width *= scaleFactor;\n            }\n            const newBBox = this.bboxForPart(newPath.bbox, newStyle);\n            if (isFirstPart) {\n                this.contentBBox = newBBox;\n                isFirstPart = false;\n            }\n            else {\n                this.contentBBox = this.contentBBox.union(newBBox);\n            }\n            return {\n                path: newPath,\n                startPoint: newPath.startPoint,\n                commands: newPath.parts,\n                style: newStyle,\n            };\n        });\n    }\n    /**\n     * @returns A list of the parts that make up this path. Many paths only have one part.\n     *\n     * Each part (a {@link RenderablePathSpec}) contains information about the style and geometry\n     * of that part of the stroke. Use the `.path` property to do collision detection and other\n     * operations involving the stroke's geometry.\n     *\n     * Note that many of {@link Path}'s methods (e.g. {@link Path.intersection}) take a\n     * `strokeWidth` parameter that can be gotten from {@link RenderablePathSpec.style} `.stroke.width`.\n     */\n    getParts() {\n        return [...this.parts];\n    }\n    /**\n     * @returns the {@link Path.union} of all paths that make up this stroke.\n     */\n    getPath() {\n        let result = null;\n        for (const part of this.parts) {\n            if (result) {\n                result = result.union(part.path);\n            }\n            else {\n                result ??= part.path;\n            }\n        }\n        return result ?? Path.empty;\n    }\n    description(localization) {\n        return localization.stroke;\n    }\n    createClone() {\n        return new Stroke(this.parts);\n    }\n    serializeToJSON() {\n        return this.parts.map((part) => {\n            return {\n                style: styleToJSON(part.style),\n                path: part.path.serialize(),\n            };\n        });\n    }\n    /** @internal */\n    static deserializeFromJSON(json) {\n        if (typeof json === 'string') {\n            json = JSON.parse(json);\n        }\n        if (typeof json !== 'object' || typeof json.length !== 'number') {\n            throw new Error(`${json} is missing required field, parts, or parts is of the wrong type.`);\n        }\n        const pathSpec = json.map((part) => {\n            const style = styleFromJSON(part.style);\n            return pathToRenderable(Path.fromString(part.path), style);\n        });\n        return new Stroke(pathSpec);\n    }\n}\nAbstractComponent.registerComponent('stroke', Stroke.deserializeFromJSON);\n","import { Vec2, Rect2, Mat33, Color4 } from '@js-draw/math';\nimport  { cloneTextStyle, textStyleFromJSON, textStyleToJSON, }  from '../rendering/TextRenderingStyle.mjs';\nimport  AbstractComponent  from './AbstractComponent.mjs';\nimport  { createRestyleComponentCommand, }  from './RestylableComponent.mjs';\nconst componentTypeId = 'text';\nexport var TextTransformMode;\n(function (TextTransformMode) {\n    /** Absolutely positioned in both the X and Y dimensions. */\n    TextTransformMode[TextTransformMode[\"ABSOLUTE_XY\"] = 0] = \"ABSOLUTE_XY\";\n    /** Relatively positioned in both the X and Y dimensions. */\n    TextTransformMode[TextTransformMode[\"RELATIVE_XY\"] = 1] = \"RELATIVE_XY\";\n    /**Relatively positioned in the X direction, absolutely positioned in the Y direction. */\n    TextTransformMode[TextTransformMode[\"RELATIVE_X_ABSOLUTE_Y\"] = 2] = \"RELATIVE_X_ABSOLUTE_Y\";\n    /**Relatively positioned in the Y direction, absolutely positioned in the X direction. */\n    TextTransformMode[TextTransformMode[\"RELATIVE_Y_ABSOLUTE_X\"] = 3] = \"RELATIVE_Y_ABSOLUTE_X\";\n})(TextTransformMode || (TextTransformMode = {}));\nconst defaultTextStyle = {\n    fontFamily: 'sans',\n    size: 12,\n    renderingStyle: { fill: Color4.purple },\n};\n/**\n * Displays text.\n *\n * A `TextComponent` is a collection of `TextElement`s (`string`s or {@link TextComponent}s).\n *\n * **Example**:\n *\n * ```ts,runnable\n * import { Editor, TextComponent, Mat33, Vec2, Color4, TextRenderingStyle } from 'js-draw';\n * const editor = new Editor(document.body);\n * editor.dispatch(editor.setBackgroundStyle({ color: Color4.black, autoresize: true ));\n * ---visible---\n * /// Adding a simple TextComponent\n * ///------------------------------\n *\n * const positioning1 = Mat33.translation(Vec2.of(10, 10));\n * const style: TextRenderingStyle = {\n *     fontFamily: 'sans', size: 12, renderingStyle: { fill: Color4.green },\n * };\n *\n * editor.dispatch(\n *     editor.image.addElement(new TextComponent(['Hello, world'], positioning1, style)),\n * );\n *\n *\n * /// Adding nested TextComponents\n * ///-----------------------------\n *\n * // Add another TextComponent that contains text and a TextComponent. Observe that '[Test]'\n * // is placed directly after 'Test'.\n * const positioning2 = Mat33.translation(Vec2.of(10, 50));\n * editor.dispatch(\n *     editor.image.addElement(\n *         new TextComponent([ new TextComponent(['Test'], positioning1, style), '[Test]' ], positioning2, style)\n *     ),\n * );\n * ```\n */\nclass TextComponent extends AbstractComponent {\n    /**\n     * Creates a new text object from a list of component text or child TextComponents.\n     *\n     * @see {@link fromLines}\n     */\n    constructor(textObjects, \n    // Transformation relative to this component's parent element.\n    transform, style = defaultTextStyle, \n    // @internal\n    transformMode = TextTransformMode.ABSOLUTE_XY) {\n        super(componentTypeId);\n        this.textObjects = textObjects;\n        this.transform = transform;\n        this.style = style;\n        this.transformMode = transformMode;\n        // eslint-disable-next-line @typescript-eslint/prefer-as-const\n        this.isRestylableComponent = true;\n        this.recomputeBBox();\n        // If this has no direct children, choose a style representative of this' content\n        // (useful for estimating the style of the TextComponent).\n        const hasDirectContent = textObjects.some((obj) => typeof obj === 'string');\n        if (!hasDirectContent && textObjects.length > 0) {\n            this.style = textObjects[0].getTextStyle();\n        }\n    }\n    static applyTextStyles(ctx, style) {\n        // Quote the font family if necessary.\n        const hasSpaces = style.fontFamily.match(/\\s/);\n        const isQuoted = style.fontFamily.match(/^\".*\"$/);\n        const fontFamily = hasSpaces && !isQuoted ? `\"${style.fontFamily.replace(/[\"]/g, '\\\\\"')}\"` : style.fontFamily;\n        ctx.font = [\n            style.fontStyle ?? '',\n            style.fontWeight ?? '',\n            (style.size ?? 12) + 'px',\n            `${fontFamily}`,\n        ].join(' ');\n        // TODO: Support RTL\n        ctx.textAlign = 'left';\n    }\n    // Roughly estimate the bounding box of `text`. Use if no CanvasRenderingContext2D is available.\n    static estimateTextDimens(text, style) {\n        const widthEst = text.length * style.size;\n        const heightEst = style.size;\n        // Text is drawn with (0, 0) as its baseline. As such, the majority of the text's height should\n        // be above (0, 0).\n        return new Rect2(0, (-heightEst * 2) / 3, widthEst, heightEst);\n    }\n    // Returns a set of TextMetrics for the given text, if a canvas is available.\n    static getTextMetrics(text, style) {\n        TextComponent.textMeasuringCtx ??= document.createElement('canvas').getContext('2d') ?? null;\n        if (!TextComponent.textMeasuringCtx) {\n            return null;\n        }\n        const ctx = TextComponent.textMeasuringCtx;\n        TextComponent.applyTextStyles(ctx, style);\n        return ctx.measureText(text);\n    }\n    // Returns the bounding box of `text`. This is approximate if no Canvas is available.\n    static getTextDimens(text, style) {\n        const metrics = this.getTextMetrics(text, style);\n        if (!metrics) {\n            return this.estimateTextDimens(text, style);\n        }\n        // Text is drawn with (0,0) at the bottom left of the baseline.\n        const textY = -metrics.actualBoundingBoxAscent;\n        const textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n        return new Rect2(0, textY, metrics.width, textHeight);\n    }\n    static getFontHeight(style) {\n        return style.size;\n    }\n    computeUntransformedBBoxOfPart(part) {\n        if (typeof part === 'string') {\n            return TextComponent.getTextDimens(part, this.style);\n        }\n        else {\n            return part.contentBBox;\n        }\n    }\n    recomputeBBox() {\n        let bbox = null;\n        const cursor = new TextComponent.TextCursor(this.transform, this.style);\n        for (const textObject of this.textObjects) {\n            const transform = cursor.update(textObject).transform;\n            const currentBBox = this.computeUntransformedBBoxOfPart(textObject).transformedBoundingBox(transform);\n            bbox ??= currentBBox;\n            bbox = bbox.union(currentBBox);\n        }\n        this.contentBBox = bbox ?? Rect2.empty;\n    }\n    /**\n     * Renders a TextComponent or a TextComponent child onto a `canvas`.\n     *\n     * `visibleRect` can be provided as a performance optimization. If not the top-level\n     * text node, `baseTransform` (specifies the transformation of the parent text component\n     * in canvas space) should also be provided.\n     *\n     * Note that passing a `baseTransform` is preferable to transforming `visibleRect`. At high\n     * zoom levels, transforming `visibleRect` by the inverse of the parent transform can lead to\n     * inaccuracy due to precision loss.\n     */\n    renderInternal(canvas, visibleRect, baseTransform = Mat33.identity) {\n        const cursor = new TextComponent.TextCursor(this.transform, this.style);\n        for (const textObject of this.textObjects) {\n            const { transform, bbox } = cursor.update(textObject);\n            if (visibleRect && !visibleRect.intersects(bbox.transformedBoundingBox(baseTransform))) {\n                continue;\n            }\n            if (typeof textObject === 'string') {\n                canvas.drawText(textObject, transform, this.style);\n            }\n            else {\n                canvas.pushTransform(transform);\n                textObject.renderInternal(canvas, visibleRect, baseTransform.rightMul(transform));\n                canvas.popTransform();\n            }\n        }\n    }\n    render(canvas, visibleRect) {\n        canvas.startObject(this.contentBBox);\n        this.renderInternal(canvas, visibleRect);\n        canvas.endObject(this.getLoadSaveData());\n    }\n    getProportionalRenderingTime() {\n        return this.textObjects.length;\n    }\n    intersects(lineSegment) {\n        const cursor = new TextComponent.TextCursor(this.transform, this.style);\n        for (const subObject of this.textObjects) {\n            // Convert canvas space to internal space relative to the current object.\n            const invTransform = cursor.update(subObject).transform.inverse();\n            const transformedLine = lineSegment.transformedBy(invTransform);\n            if (typeof subObject === 'string') {\n                const textBBox = TextComponent.getTextDimens(subObject, this.style);\n                // TODO: Use a better intersection check. Perhaps draw the text onto a CanvasElement and\n                // use pixel-testing to check for intersection with its contour.\n                if (textBBox.getEdges().some((edge) => transformedLine.intersection(edge) !== null)) {\n                    return true;\n                }\n            }\n            else {\n                if (subObject.intersects(transformedLine)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    getStyle() {\n        return {\n            color: this.style.renderingStyle.fill,\n            // Make a copy\n            textStyle: {\n                ...this.style,\n                renderingStyle: {\n                    ...this.style.renderingStyle,\n                },\n            },\n        };\n    }\n    updateStyle(style) {\n        return createRestyleComponentCommand(this.getStyle(), style, this);\n    }\n    forceStyle(style, editor) {\n        if (style.textStyle) {\n            this.style = cloneTextStyle(style.textStyle);\n        }\n        else if (style.color) {\n            this.style = {\n                ...this.style,\n                renderingStyle: {\n                    ...this.style.renderingStyle,\n                    fill: style.color,\n                },\n            };\n        }\n        else {\n            return;\n        }\n        for (const child of this.textObjects) {\n            if (child instanceof TextComponent) {\n                child.forceStyle(style, editor);\n            }\n        }\n        if (editor) {\n            editor.image.queueRerenderOf(this);\n            editor.queueRerender();\n        }\n    }\n    // See {@link getStyle}\n    getTextStyle() {\n        return cloneTextStyle(this.style);\n    }\n    getBaselinePos() {\n        return this.transform.transformVec2(Vec2.zero);\n    }\n    getTransform() {\n        return this.transform;\n    }\n    applyTransformation(affineTransfm) {\n        this.transform = affineTransfm.rightMul(this.transform);\n        this.recomputeBBox();\n    }\n    createClone() {\n        const clonedTextObjects = this.textObjects.map((obj) => {\n            if (typeof obj === 'string') {\n                return obj;\n            }\n            else {\n                return obj.createClone();\n            }\n        });\n        return new TextComponent(clonedTextObjects, this.transform, this.style);\n    }\n    getText() {\n        const result = [];\n        for (const textObject of this.textObjects) {\n            if (typeof textObject === 'string') {\n                result.push(textObject);\n            }\n            else {\n                result.push(textObject.getText());\n            }\n        }\n        return result.join('\\n');\n    }\n    description(localizationTable) {\n        return localizationTable.text(this.getText());\n    }\n    // Do not rely on the output of `serializeToJSON` taking any particular format.\n    serializeToJSON() {\n        const serializableStyle = textStyleToJSON(this.style);\n        const serializedTextObjects = this.textObjects.map((text) => {\n            if (typeof text === 'string') {\n                return {\n                    text,\n                };\n            }\n            else {\n                return {\n                    json: text.serializeToJSON(),\n                };\n            }\n        });\n        return {\n            textObjects: serializedTextObjects,\n            transform: this.transform.toArray(),\n            style: serializableStyle,\n        };\n    }\n    // @internal\n    static deserializeFromString(json) {\n        if (typeof json === 'string') {\n            json = JSON.parse(json);\n        }\n        const style = textStyleFromJSON(json.style);\n        const textObjects = json.textObjects.map((data) => {\n            if ((data.text ?? null) !== null) {\n                return data.text;\n            }\n            return TextComponent.deserializeFromString(data.json);\n        });\n        json.transform = json.transform.filter((elem) => typeof elem === 'number');\n        if (json.transform.length !== 9) {\n            throw new Error(`Unable to deserialize transform, ${json.transform}.`);\n        }\n        const transformData = json.transform;\n        const transform = new Mat33(...transformData);\n        return new TextComponent(textObjects, transform, style);\n    }\n    /**\n     * Creates a `TextComponent` from `lines`.\n     *\n     * @example\n     * ```ts\n     * const textStyle = {\n     *   size: 12,\n     *   fontFamily: 'serif',\n     *   renderingStyle: { fill: Color4.black },\n     * };\n     *\n     * const text = TextComponent.fromLines('foo\\nbar'.split('\\n'), Mat33.identity, textStyle);\n     * ```\n     */\n    static fromLines(lines, transform, style) {\n        let lastComponent = null;\n        const components = [];\n        const lineMargin = Math.round(this.getFontHeight(style));\n        let position = Vec2.zero;\n        for (const line of lines) {\n            if (lastComponent) {\n                position = position.plus(Vec2.unitY.times(lineMargin));\n            }\n            const component = new TextComponent([line], Mat33.translation(position), style);\n            components.push(component);\n            lastComponent = component;\n        }\n        return new TextComponent(components, transform, style);\n    }\n}\nTextComponent.textMeasuringCtx = null;\nTextComponent.TextCursor = class {\n    constructor(parentTransform = Mat33.identity, parentStyle) {\n        this.parentTransform = parentTransform;\n        this.parentStyle = parentStyle;\n        this.transform = Mat33.identity;\n    }\n    /**\n     * Based on previous calls to `update`, returns the transformation and bounding box (relative\n     * to the parent element, or if none, the canvas) of the given `element`. Note that\n     * this is computed in part using the `parentTransform` provivded to this cursor's constructor.\n     *\n     * Warning: There may be edge cases here that are not taken into account.\n     */\n    update(elem) {\n        let elementTransform = Mat33.identity;\n        let elemInternalTransform = Mat33.identity;\n        let textSize;\n        if (typeof elem === 'string') {\n            textSize = TextComponent.getTextDimens(elem, this.parentStyle);\n        }\n        else {\n            // TODO: Double-check whether we need to take elem.transform into account here.\n            // elementTransform = elem.transform;\n            elemInternalTransform = elem.transform;\n            textSize = elem.getBBox();\n        }\n        const positioning = typeof elem === 'string' ? TextTransformMode.RELATIVE_XY : elem.transformMode;\n        if (positioning === TextTransformMode.RELATIVE_XY) {\n            // Position relative to the previous element's transform.\n            elementTransform = this.transform.rightMul(elementTransform);\n        }\n        else if (positioning === TextTransformMode.RELATIVE_X_ABSOLUTE_Y ||\n            positioning === TextTransformMode.RELATIVE_Y_ABSOLUTE_X) {\n            // Zero the absolute component of this.transform's translation\n            const transform = this.transform.mapEntries((component, [row, col]) => {\n                if (positioning === TextTransformMode.RELATIVE_X_ABSOLUTE_Y) {\n                    // Zero the y component of this.transform's translation\n                    return row === 1 && col === 2 ? 0 : component;\n                }\n                else if (positioning === TextTransformMode.RELATIVE_Y_ABSOLUTE_X) {\n                    // Zero the x component of this.transform's translation\n                    return row === 0 && col === 2 ? 0 : component;\n                }\n                throw new Error('Unreachable');\n                return 0;\n            });\n            elementTransform = transform.rightMul(elementTransform);\n        }\n        // Update this.transform so that future calls to update return correct values.\n        const endShiftTransform = Mat33.translation(Vec2.of(textSize.width, 0));\n        this.transform = elementTransform.rightMul(elemInternalTransform).rightMul(endShiftTransform);\n        const transform = this.parentTransform.rightMul(elementTransform);\n        return {\n            transform,\n            bbox: textSize.transformedBoundingBox(transform),\n        };\n    }\n};\nexport default TextComponent;\nAbstractComponent.registerComponent(componentTypeId, (data) => TextComponent.deserializeFromString(data));\n","//\n// Stores objects loaded from an SVG that aren't recognised by the editor.\n// @internal\n// @packageDocumentation\n//\nimport { Rect2 } from '@js-draw/math';\nimport  SVGRenderer  from '../rendering/renderers/SVGRenderer.mjs';\nimport  AbstractComponent, { ComponentSizingMode }  from './AbstractComponent.mjs';\nconst componentId = 'unknown-svg-object';\nexport default class UnknownSVGObject extends AbstractComponent {\n    constructor(svgObject) {\n        super(componentId);\n        this.svgObject = svgObject;\n        this.contentBBox = Rect2.of(svgObject.getBoundingClientRect());\n    }\n    render(canvas, _visibleRect) {\n        if (!(canvas instanceof SVGRenderer)) {\n            // Don't draw unrenderable objects if we can't\n            return;\n        }\n        canvas.startObject(this.contentBBox);\n        canvas.drawSVGElem(this.svgObject);\n        canvas.endObject(this.getLoadSaveData());\n    }\n    intersects(lineSegment) {\n        return this.contentBBox.getEdges().some((edge) => edge.intersection(lineSegment) !== null);\n    }\n    applyTransformation(_affineTransfm) { }\n    isSelectable() {\n        return false;\n    }\n    getSizingMode() {\n        // This component can be shown anywhere (it won't be\n        // visible to the user, it just needs to be saved with\n        // the image).\n        return ComponentSizingMode.Anywhere;\n    }\n    createClone() {\n        return new UnknownSVGObject(this.svgObject.cloneNode(true));\n    }\n    description(localization) {\n        return localization.svgObject;\n    }\n    serializeToJSON() {\n        return JSON.stringify({\n            html: this.svgObject.outerHTML,\n        });\n    }\n}\n// null: Do not deserialize UnknownSVGObjects.\nAbstractComponent.registerComponent(componentId, null);\n","import { Path, PathCommandType } from '@js-draw/math';\nimport  Stroke  from '../Stroke.mjs';\nimport  makeSnapToGridAutocorrect  from './autocorrect/makeSnapToGridAutocorrect.mjs';\n/**\n * Creates a stroke builder that generates arrows.\n *\n * Example:\n * [[include:doc-pages/inline-examples/changing-pen-types.md]]\n */\nexport const makeArrowBuilder = makeSnapToGridAutocorrect((initialPoint, viewport) => {\n    return new ArrowBuilder(initialPoint, viewport);\n});\nexport default class ArrowBuilder {\n    constructor(startPoint, viewport) {\n        this.startPoint = startPoint;\n        this.viewport = viewport;\n        this.endPoint = startPoint;\n    }\n    getLineWidth() {\n        return Math.max(this.endPoint.width, this.startPoint.width);\n    }\n    getBBox() {\n        const preview = this.buildPreview();\n        return preview.getBBox();\n    }\n    buildPreview() {\n        const lineStartPoint = this.startPoint.pos;\n        const endPoint = this.endPoint.pos;\n        const toEnd = endPoint.minus(lineStartPoint).normalized();\n        const arrowLength = endPoint.distanceTo(lineStartPoint);\n        // Ensure that the arrow tip is smaller than the arrow.\n        const arrowTipSize = Math.min(this.getLineWidth(), arrowLength / 2);\n        const startSize = this.startPoint.width / 2;\n        const endSize = this.endPoint.width / 2;\n        const arrowTipBase = endPoint.minus(toEnd.times(arrowTipSize));\n        // Scaled normal vectors.\n        const lineNormal = toEnd.orthog();\n        const scaledStartNormal = lineNormal.times(startSize);\n        const scaledBaseNormal = lineNormal.times(endSize);\n        const path = new Path(arrowTipBase.minus(scaledBaseNormal), [\n            // Stem\n            {\n                kind: PathCommandType.LineTo,\n                point: lineStartPoint.minus(scaledStartNormal),\n            },\n            {\n                kind: PathCommandType.LineTo,\n                point: lineStartPoint.plus(scaledStartNormal),\n            },\n            {\n                kind: PathCommandType.LineTo,\n                point: arrowTipBase.plus(scaledBaseNormal),\n            },\n            // Head\n            {\n                kind: PathCommandType.LineTo,\n                point: arrowTipBase.plus(lineNormal.times(arrowTipSize).plus(scaledBaseNormal)),\n            },\n            {\n                kind: PathCommandType.LineTo,\n                point: endPoint.plus(toEnd.times(endSize)),\n            },\n            {\n                kind: PathCommandType.LineTo,\n                point: arrowTipBase.plus(lineNormal.times(-arrowTipSize).minus(scaledBaseNormal)),\n            },\n            {\n                kind: PathCommandType.LineTo,\n                point: arrowTipBase.minus(scaledBaseNormal),\n            },\n            // Round all points in the arrow (to remove unnecessary decimal places)\n        ]).mapPoints((point) => this.viewport.roundPoint(point));\n        const preview = new Stroke([\n            {\n                startPoint: path.startPoint,\n                commands: path.parts,\n                style: {\n                    fill: this.startPoint.color,\n                },\n            },\n        ]);\n        return preview;\n    }\n    build() {\n        return this.buildPreview();\n    }\n    preview(renderer) {\n        this.buildPreview().render(renderer);\n    }\n    addPoint(point) {\n        this.endPoint = point;\n    }\n}\n","import { Vec2, Path, PathCommandType, Color4 } from '@js-draw/math';\nimport  { pathToRenderable }  from '../../rendering/RenderablePathSpec.mjs';\nimport  Viewport  from '../../Viewport.mjs';\nimport  Stroke  from '../Stroke.mjs';\nimport  makeSnapToGridAutocorrect  from './autocorrect/makeSnapToGridAutocorrect.mjs';\n/**\n * Creates a stroke builder that generates outlined circles.\n *\n * Example:\n * [[include:doc-pages/inline-examples/changing-pen-types.md]]\n */\nexport const makeOutlinedCircleBuilder = makeSnapToGridAutocorrect((initialPoint, viewport) => {\n    return new CircleBuilder(initialPoint, viewport);\n});\nclass CircleBuilder {\n    constructor(startPoint, viewport) {\n        this.startPoint = startPoint;\n        this.viewport = viewport;\n        // Initially, the start and end points are the same.\n        this.endPoint = startPoint;\n    }\n    getBBox() {\n        const preview = this.buildPreview();\n        return preview.getBBox();\n    }\n    buildPreview() {\n        const pathCommands = [];\n        const numDivisions = 6;\n        const stepSize = (Math.PI * 2) / numDivisions;\n        // Round the stroke width so that when exported it doesn't have unnecessary trailing decimals.\n        const strokeWidth = Viewport.roundPoint(this.endPoint.width, 5 / this.viewport.getScaleFactor());\n        const center = this.startPoint.pos.lerp(this.endPoint.pos, 0.5);\n        const startEndDelta = this.endPoint.pos.minus(center);\n        const radius = startEndDelta.length() - strokeWidth / 2;\n        const startPoint = center.plus(Vec2.of(radius, 0));\n        for (let t = stepSize; t <= Math.PI * 2; t += stepSize) {\n            const endPoint = Vec2.of(radius * Math.cos(t), -radius * Math.sin(t)).plus(center);\n            // controlPointRadiusScale is selected to make the circles appear circular and\n            // **does** depend on stepSize.\n            const controlPointRadiusScale = 1.141;\n            const controlPoint = Vec2.of(Math.cos(t - stepSize / 2), -Math.sin(t - stepSize / 2))\n                .times(radius * controlPointRadiusScale)\n                .plus(center);\n            pathCommands.push({\n                kind: PathCommandType.QuadraticBezierTo,\n                controlPoint,\n                endPoint,\n            });\n        }\n        pathCommands.push({\n            kind: PathCommandType.LineTo,\n            point: startPoint,\n        });\n        const path = new Path(startPoint, pathCommands).mapPoints((point) => this.viewport.roundPoint(point));\n        const preview = new Stroke([\n            pathToRenderable(path, {\n                fill: Color4.transparent,\n                stroke: {\n                    width: strokeWidth,\n                    color: this.endPoint.color,\n                },\n            }),\n        ]);\n        return preview;\n    }\n    build() {\n        return this.buildPreview();\n    }\n    preview(renderer) {\n        this.buildPreview().render(renderer);\n    }\n    addPoint(point) {\n        this.endPoint = point;\n    }\n}\n","import { Vec2, Rect2, Color4, PathCommandType } from '@js-draw/math';\nimport  Stroke  from '../Stroke.mjs';\nimport  Viewport  from '../../Viewport.mjs';\nimport  { StrokeSmoother }  from '../util/StrokeSmoother.mjs';\nimport  makeShapeFitAutocorrect  from './autocorrect/makeShapeFitAutocorrect.mjs';\n/**\n * Creates a stroke builder that draws freehand lines.\n *\n * Example:\n * [[include:doc-pages/inline-examples/changing-pen-types.md]]\n */\nexport const makeFreehandLineBuilder = makeShapeFitAutocorrect((initialPoint, viewport) => {\n    // Don't smooth if input is more than ± 3 pixels from the true curve, do smooth if\n    // less than ±1 px from the curve.\n    const maxSmoothingDist = viewport.getSizeOfPixelOnCanvas() * 3;\n    const minSmoothingDist = viewport.getSizeOfPixelOnCanvas();\n    return new FreehandLineBuilder(initialPoint, minSmoothingDist, maxSmoothingDist, viewport);\n});\n// Handles stroke smoothing and creates Strokes from user/stylus input.\nexport default class FreehandLineBuilder {\n    constructor(startPoint, minFitAllowed, maxFitAllowed, viewport) {\n        this.startPoint = startPoint;\n        this.minFitAllowed = minFitAllowed;\n        this.viewport = viewport;\n        this.isFirstSegment = true;\n        this.parts = [];\n        this.widthAverageNumSamples = 1;\n        this.curveFitter = new StrokeSmoother(startPoint, minFitAllowed, maxFitAllowed, (curve) => this.addCurve(curve));\n        this.averageWidth = startPoint.width;\n        this.bbox = new Rect2(this.startPoint.pos.x, this.startPoint.pos.y, 0, 0);\n    }\n    getBBox() {\n        return this.bbox;\n    }\n    getRenderingStyle() {\n        return {\n            fill: Color4.transparent,\n            stroke: {\n                color: this.startPoint.color,\n                width: this.roundDistance(this.averageWidth),\n            },\n        };\n    }\n    previewCurrentPath() {\n        const path = this.parts.slice();\n        const commands = [...path, ...this.curveToPathCommands(this.curveFitter.preview())];\n        const startPoint = this.startPoint.pos;\n        return {\n            startPoint,\n            commands,\n            style: this.getRenderingStyle(),\n        };\n    }\n    previewFullPath() {\n        const preview = this.previewCurrentPath();\n        if (preview) {\n            return [preview];\n        }\n        return null;\n    }\n    previewStroke() {\n        const pathPreview = this.previewFullPath();\n        if (pathPreview) {\n            return new Stroke(pathPreview);\n        }\n        return null;\n    }\n    preview(renderer) {\n        const paths = this.previewFullPath();\n        if (paths) {\n            const approxBBox = this.viewport.visibleRect;\n            renderer.startObject(approxBBox);\n            for (const path of paths) {\n                renderer.drawPath(path);\n            }\n            renderer.endObject();\n        }\n    }\n    build() {\n        this.curveFitter.finalizeCurrentCurve();\n        return this.previewStroke();\n    }\n    getMinFit() {\n        let minFit = Math.min(this.minFitAllowed, this.averageWidth / 3);\n        if (minFit < 1e-10) {\n            minFit = this.minFitAllowed;\n        }\n        return minFit;\n    }\n    roundPoint(point) {\n        const minFit = this.getMinFit();\n        return Viewport.roundPoint(point, minFit);\n    }\n    roundDistance(dist) {\n        const minFit = this.getMinFit();\n        return Viewport.roundPoint(dist, minFit);\n    }\n    curveToPathCommands(curve) {\n        // Case where no points have been added\n        if (!curve) {\n            // Don't create a circle around the initial point if the stroke has more than one point.\n            if (!this.isFirstSegment) {\n                return [];\n            }\n            // Make the circle small -- because of the stroke style, we'll be drawing a stroke around it.\n            const width = Viewport.roundPoint(this.averageWidth / 10, Math.min(this.minFitAllowed, this.averageWidth / 10));\n            const center = this.roundPoint(this.startPoint.pos);\n            // Start on the right, cycle clockwise:\n            //    |\n            //  ----- ←\n            //    |\n            // Draw a circle-ish shape around the start point\n            return [\n                {\n                    kind: PathCommandType.QuadraticBezierTo,\n                    controlPoint: center.plus(Vec2.of(width, width)),\n                    // Bottom of the circle\n                    //    |\n                    //  -----\n                    //    |\n                    //    ↑\n                    endPoint: center.plus(Vec2.of(0, width)),\n                },\n                {\n                    kind: PathCommandType.QuadraticBezierTo,\n                    controlPoint: center.plus(Vec2.of(-width, width)),\n                    endPoint: center.plus(Vec2.of(-width, 0)),\n                },\n                {\n                    kind: PathCommandType.QuadraticBezierTo,\n                    controlPoint: center.plus(Vec2.of(-width, -width)),\n                    endPoint: center.plus(Vec2.of(0, -width)),\n                },\n                {\n                    kind: PathCommandType.QuadraticBezierTo,\n                    controlPoint: center.plus(Vec2.of(width, -width)),\n                    endPoint: center.plus(Vec2.of(width, 0)),\n                },\n            ];\n        }\n        const result = [];\n        if (this.isFirstSegment) {\n            result.push({\n                kind: PathCommandType.MoveTo,\n                point: this.roundPoint(curve.startPoint),\n            });\n        }\n        result.push({\n            kind: PathCommandType.QuadraticBezierTo,\n            controlPoint: this.roundPoint(curve.controlPoint),\n            endPoint: this.roundPoint(curve.endPoint),\n        });\n        return result;\n    }\n    addCurve(curve) {\n        const parts = this.curveToPathCommands(curve);\n        this.parts.push(...parts);\n        if (this.isFirstSegment) {\n            this.isFirstSegment = false;\n        }\n    }\n    addPoint(newPoint) {\n        this.curveFitter.addPoint(newPoint);\n        this.widthAverageNumSamples++;\n        this.averageWidth =\n            (this.averageWidth * (this.widthAverageNumSamples - 1)) / this.widthAverageNumSamples +\n                newPoint.width / this.widthAverageNumSamples;\n    }\n}\n","import { Path, PathCommandType } from '@js-draw/math';\nimport  { pathToRenderable }  from '../../rendering/RenderablePathSpec.mjs';\nimport  Stroke  from '../Stroke.mjs';\nimport  makeSnapToGridAutocorrect  from './autocorrect/makeSnapToGridAutocorrect.mjs';\n/**\n * Creates a stroke builder that generates filled lines.\n *\n * Example:\n * [[include:doc-pages/inline-examples/changing-pen-types.md]]\n */\nexport const makeLineBuilder = makeSnapToGridAutocorrect((initialPoint, viewport) => {\n    return new LineBuilder(initialPoint, viewport);\n});\nexport default class LineBuilder {\n    constructor(startPoint, viewport) {\n        this.startPoint = startPoint;\n        this.viewport = viewport;\n        this.endPoint = startPoint;\n    }\n    getBBox() {\n        const preview = this.buildPreview();\n        return preview.getBBox();\n    }\n    buildPreview() {\n        const startPoint = this.startPoint.pos;\n        const endPoint = this.endPoint.pos;\n        const toEnd = endPoint.minus(startPoint).normalized();\n        const startSize = this.startPoint.width / 2;\n        const endSize = this.endPoint.width / 2;\n        const lineNormal = toEnd.orthog();\n        const scaledStartNormal = lineNormal.times(startSize);\n        const scaledEndNormal = lineNormal.times(endSize);\n        const strokeStartPoint = startPoint.minus(scaledStartNormal);\n        const path = new Path(strokeStartPoint, [\n            {\n                kind: PathCommandType.LineTo,\n                point: startPoint.plus(scaledStartNormal),\n            },\n            {\n                kind: PathCommandType.LineTo,\n                point: endPoint.plus(scaledEndNormal),\n            },\n            {\n                kind: PathCommandType.LineTo,\n                point: endPoint.minus(scaledEndNormal),\n            },\n            {\n                kind: PathCommandType.LineTo,\n                point: startPoint.minus(scaledStartNormal),\n            },\n        ]).mapPoints((point) => this.viewport.roundPoint(point));\n        const preview = new Stroke([pathToRenderable(path, { fill: this.startPoint.color })]);\n        return preview;\n    }\n    build() {\n        return this.buildPreview();\n    }\n    preview(renderer) {\n        this.buildPreview().render(renderer);\n    }\n    addPoint(point) {\n        this.endPoint = point;\n    }\n}\n","import { Rect2, Color4, PathCommandType, Vec2, LineSegment2, } from '@js-draw/math';\nimport  Stroke  from '../Stroke.mjs';\nimport  Viewport  from '../../Viewport.mjs';\nimport  makeShapeFitAutocorrect  from './autocorrect/makeShapeFitAutocorrect.mjs';\n/**\n * Creates a freehand line builder that creates strokes from line segments\n * rather than Bézier curves.\n *\n * Example:\n * [[include:doc-pages/inline-examples/changing-pen-types.md]]\n */\nexport const makePolylineBuilder = makeShapeFitAutocorrect((initialPoint, viewport) => {\n    // Fit to a value slightly smaller than the pixel size. A larger value can\n    // cause the stroke to appear jagged at some zoom levels.\n    const minFit = viewport.getSizeOfPixelOnCanvas() * 0.75;\n    return new PolylineBuilder(initialPoint, minFit, viewport);\n});\nexport default class PolylineBuilder {\n    constructor(startPoint, minFitAllowed, viewport) {\n        this.minFitAllowed = minFitAllowed;\n        this.viewport = viewport;\n        this.parts = [];\n        this.widthAverageNumSamples = 1;\n        this.lastLineSegment = null;\n        this.averageWidth = startPoint.width;\n        this.startPoint = {\n            ...startPoint,\n            pos: this.roundPoint(startPoint.pos),\n        };\n        this.lastPoint = this.startPoint.pos;\n        this.bbox = new Rect2(this.startPoint.pos.x, this.startPoint.pos.y, 0, 0);\n        this.parts = [\n            {\n                kind: PathCommandType.MoveTo,\n                point: this.startPoint.pos,\n            },\n        ];\n    }\n    getBBox() {\n        return this.bbox.grownBy(this.averageWidth);\n    }\n    getRenderingStyle() {\n        return {\n            fill: Color4.transparent,\n            stroke: {\n                color: this.startPoint.color,\n                width: this.roundDistance(this.averageWidth),\n            },\n        };\n    }\n    previewCurrentPath() {\n        const startPoint = this.startPoint.pos;\n        const commands = [...this.parts];\n        // TODO: For now, this is necesary for the path to be visible.\n        if (commands.length <= 1) {\n            commands.push({\n                kind: PathCommandType.LineTo,\n                point: startPoint.plus(Vec2.of(this.averageWidth / 4, 0)),\n            });\n        }\n        return {\n            startPoint,\n            commands,\n            style: this.getRenderingStyle(),\n        };\n    }\n    previewFullPath() {\n        return [this.previewCurrentPath()];\n    }\n    preview(renderer) {\n        const paths = this.previewFullPath();\n        if (paths) {\n            const approxBBox = this.viewport.visibleRect;\n            renderer.startObject(approxBBox);\n            for (const path of paths) {\n                renderer.drawPath(path);\n            }\n            renderer.endObject();\n        }\n    }\n    build() {\n        return new Stroke(this.previewFullPath());\n    }\n    getMinFit() {\n        let minFit = Math.min(this.minFitAllowed, this.averageWidth / 4);\n        if (minFit < 1e-10) {\n            minFit = this.minFitAllowed;\n        }\n        return minFit;\n    }\n    roundPoint(point) {\n        const minFit = this.getMinFit();\n        return Viewport.roundPoint(point, minFit);\n    }\n    roundDistance(dist) {\n        const minFit = this.getMinFit();\n        return Viewport.roundPoint(dist, minFit);\n    }\n    addPoint(newPoint) {\n        this.widthAverageNumSamples++;\n        this.averageWidth =\n            (this.averageWidth * (this.widthAverageNumSamples - 1)) / this.widthAverageNumSamples +\n                newPoint.width / this.widthAverageNumSamples;\n        const roundedPoint = this.roundPoint(newPoint.pos);\n        if (!roundedPoint.eq(this.lastPoint)) {\n            // If almost exactly in the same line as the previous\n            if (this.lastLineSegment &&\n                this.lastLineSegment.direction.dot(roundedPoint.minus(this.lastPoint).normalized()) > 0.997) {\n                this.parts.pop();\n                this.lastPoint = this.lastLineSegment.p1;\n            }\n            this.parts.push({\n                kind: PathCommandType.LineTo,\n                point: this.roundPoint(newPoint.pos),\n            });\n            this.bbox = this.bbox.grownToPoint(roundedPoint);\n            this.lastLineSegment = new LineSegment2(this.lastPoint, roundedPoint);\n            this.lastPoint = roundedPoint;\n        }\n    }\n}\n","import { Vec2, Rect2, PathCommandType, QuadraticBezier, } from '@js-draw/math';\nimport  Stroke  from '../Stroke.mjs';\nimport  Viewport  from '../../Viewport.mjs';\nimport  { StrokeSmoother }  from '../util/StrokeSmoother.mjs';\nimport  makeShapeFitAutocorrect  from './autocorrect/makeShapeFitAutocorrect.mjs';\nexport const makePressureSensitiveFreehandLineBuilder = makeShapeFitAutocorrect((initialPoint, viewport) => {\n    // Don't smooth if input is more than ± 3 pixels from the true curve, do smooth if\n    // less than ±1 px from the curve.\n    const maxSmoothingDist = viewport.getSizeOfPixelOnCanvas() * 3;\n    const minSmoothingDist = viewport.getSizeOfPixelOnCanvas();\n    return new PressureSensitiveFreehandLineBuilder(initialPoint, minSmoothingDist, maxSmoothingDist, viewport);\n});\n// Handles stroke smoothing and creates Strokes from user/stylus input.\nexport default class PressureSensitiveFreehandLineBuilder {\n    constructor(startPoint, \n    // Maximum distance from the actual curve (irrespective of stroke width)\n    // for which a point is considered 'part of the curve'.\n    // Note that the maximum will be smaller if the stroke width is less than\n    // [maxFitAllowed].\n    minFitAllowed, maxFitAllowed, viewport) {\n        this.startPoint = startPoint;\n        this.minFitAllowed = minFitAllowed;\n        this.viewport = viewport;\n        this.isFirstSegment = true;\n        this.pathStartConnector = null;\n        this.mostRecentConnector = null;\n        this.nextCurveStartConnector = null;\n        this.lastUpperBezier = null;\n        this.lastLowerBezier = null;\n        this.parts = [];\n        this.upperSegments = [];\n        this.lowerSegments = [];\n        this.curveFitter = new StrokeSmoother(startPoint, minFitAllowed, maxFitAllowed, (curve) => this.addCurve(curve));\n        this.curveStartWidth = startPoint.width;\n        this.bbox = new Rect2(this.startPoint.pos.x, this.startPoint.pos.y, 0, 0);\n    }\n    getBBox() {\n        return this.bbox;\n    }\n    getRenderingStyle() {\n        return {\n            fill: this.startPoint.color ?? null,\n        };\n    }\n    previewCurrentPath(extendWithLatest = true) {\n        const upperPath = this.upperSegments.slice();\n        const lowerPath = this.lowerSegments.slice();\n        let lowerToUpperCap;\n        let pathStartConnector;\n        const currentCurve = this.curveFitter.preview();\n        if (currentCurve && extendWithLatest) {\n            const { upperCurveCommand, lowerToUpperConnector, upperToLowerConnector, lowerCurveCommand } = this.segmentToPath(currentCurve);\n            upperPath.push(upperCurveCommand);\n            lowerPath.push(lowerCurveCommand);\n            lowerToUpperCap = lowerToUpperConnector;\n            pathStartConnector = this.pathStartConnector ?? [upperToLowerConnector];\n        }\n        else {\n            if (this.mostRecentConnector === null || this.pathStartConnector === null) {\n                return null;\n            }\n            lowerToUpperCap = this.mostRecentConnector;\n            pathStartConnector = this.pathStartConnector;\n        }\n        let startPoint;\n        const lastLowerSegment = lowerPath[lowerPath.length - 1];\n        if (lastLowerSegment.kind === PathCommandType.LineTo ||\n            lastLowerSegment.kind === PathCommandType.MoveTo) {\n            startPoint = lastLowerSegment.point;\n        }\n        else {\n            startPoint = lastLowerSegment.endPoint;\n        }\n        return {\n            // Start at the end of the lower curve:\n            //    Start point\n            //     ↓\n            //  __/  __/ ← Most recent points on this end\n            // /___ /\n            //  ↑\n            //  Oldest points\n            startPoint,\n            commands: [\n                // Move to the most recent point on the upperPath:\n                //     ----→•\n                //  __/  __/\n                // /___ /\n                lowerToUpperCap,\n                // Move to the beginning of the upperPath:\n                //  __/  __/\n                // /___ /\n                //     • ←-\n                ...upperPath.reverse(),\n                // Move to the beginning of the lowerPath:\n                //  __/  __/\n                // /___ /\n                // •\n                ...pathStartConnector,\n                // Move back to the start point:\n                //     •\n                //  __/  __/\n                // /___ /\n                ...lowerPath,\n            ],\n            style: this.getRenderingStyle(),\n        };\n    }\n    previewFullPath() {\n        const preview = this.previewCurrentPath();\n        if (preview) {\n            return [...this.parts, preview];\n        }\n        return null;\n    }\n    preview(renderer) {\n        const paths = this.previewFullPath();\n        if (paths) {\n            const approxBBox = this.viewport.visibleRect;\n            renderer.startObject(approxBBox);\n            for (const path of paths) {\n                renderer.drawPath(path);\n            }\n            renderer.endObject();\n        }\n    }\n    build() {\n        this.curveFitter.finalizeCurrentCurve();\n        if (this.isFirstSegment) {\n            // Ensure we have something.\n            this.addCurve(null);\n        }\n        return new Stroke(this.previewFullPath());\n    }\n    roundPoint(point) {\n        let minFit = Math.min(this.minFitAllowed, this.curveStartWidth / 3);\n        if (minFit < 1e-10) {\n            minFit = this.minFitAllowed;\n        }\n        return Viewport.roundPoint(point, minFit);\n    }\n    // Returns true if, due to overlap with previous segments, a new RenderablePathSpec should be created.\n    shouldStartNewSegment(lowerCurve, upperCurve) {\n        if (!this.lastLowerBezier || !this.lastUpperBezier) {\n            return false;\n        }\n        const getIntersection = (curve1, curve2) => {\n            const intersections = curve1.intersectsBezier(curve2);\n            if (!intersections.length)\n                return null;\n            return intersections[0].point;\n        };\n        const getExitDirection = (curve) => {\n            return curve.p2.minus(curve.p1).normalized();\n        };\n        const getEnterDirection = (curve) => {\n            return curve.p1.minus(curve.p0).normalized();\n        };\n        // Prevent\n        //         /\n        //       / /\n        //      /  /  /|\n        //    /    /   |\n        //  /          |\n        // where the next stroke and the previous stroke are in different directions.\n        //\n        // Are the exit/enter directions of the previous and current curves in different enough directions?\n        if (getEnterDirection(upperCurve).dot(getExitDirection(this.lastUpperBezier)) < 0.35 ||\n            getEnterDirection(lowerCurve).dot(getExitDirection(this.lastLowerBezier)) < 0.35 ||\n            // Also handle if the curves exit/enter directions differ\n            getEnterDirection(upperCurve).dot(getExitDirection(upperCurve)) < 0 ||\n            getEnterDirection(lowerCurve).dot(getExitDirection(lowerCurve)) < 0) {\n            return true;\n        }\n        // Check whether the lower curve intersects the other wall:\n        //       /    / ← lower\n        //    / /   /\n        // /   / /\n        //   //\n        // / /\n        const lowerIntersection = getIntersection(lowerCurve, this.lastUpperBezier);\n        const upperIntersection = getIntersection(upperCurve, this.lastLowerBezier);\n        if (lowerIntersection || upperIntersection) {\n            return true;\n        }\n        return false;\n    }\n    addCurve(curve) {\n        // Case where no points have been added\n        if (!curve) {\n            // Don't create a circle around the initial point if the stroke has more than one point.\n            if (!this.isFirstSegment) {\n                return;\n            }\n            const width = Viewport.roundPoint(this.startPoint.width / 2.2, Math.min(this.minFitAllowed, this.startPoint.width / 4));\n            const center = this.roundPoint(this.startPoint.pos);\n            // Start on the right, cycle clockwise:\n            //    |\n            //  ----- ←\n            //    |\n            const startPoint = this.startPoint.pos.plus(Vec2.of(width, 0));\n            // Draw a circle-ish shape around the start point\n            this.lowerSegments.push({\n                kind: PathCommandType.QuadraticBezierTo,\n                controlPoint: center.plus(Vec2.of(width, width)),\n                // Bottom of the circle\n                //    |\n                //  -----\n                //    |\n                //    ↑\n                endPoint: center.plus(Vec2.of(0, width)),\n            }, {\n                kind: PathCommandType.QuadraticBezierTo,\n                controlPoint: center.plus(Vec2.of(-width, width)),\n                endPoint: center.plus(Vec2.of(-width, 0)),\n            }, {\n                kind: PathCommandType.QuadraticBezierTo,\n                controlPoint: center.plus(Vec2.of(-width, -width)),\n                endPoint: center.plus(Vec2.of(0, -width)),\n            }, {\n                kind: PathCommandType.QuadraticBezierTo,\n                controlPoint: center.plus(Vec2.of(width, -width)),\n                endPoint: center.plus(Vec2.of(width, 0)),\n            });\n            const connector = {\n                kind: PathCommandType.LineTo,\n                point: startPoint,\n            };\n            this.pathStartConnector = [connector];\n            this.mostRecentConnector = connector;\n            return;\n        }\n        const { upperCurveCommand, lowerToUpperConnector, upperToLowerConnector, lowerCurveCommand, lowerCurve, upperCurve, nextCurveStartConnector, } = this.segmentToPath(curve);\n        let shouldStartNew = this.shouldStartNewSegment(lowerCurve, upperCurve);\n        if (shouldStartNew) {\n            const part = this.previewCurrentPath(false);\n            if (part) {\n                this.parts.push(part);\n                this.upperSegments = [];\n                this.lowerSegments = [];\n            }\n            else {\n                shouldStartNew = false;\n            }\n        }\n        if (this.isFirstSegment || shouldStartNew) {\n            // We draw the upper path (reversed), then the lower path, so we need the\n            // upperToLowerConnector to join the two paths.\n            this.pathStartConnector = this.nextCurveStartConnector ?? [upperToLowerConnector];\n            this.isFirstSegment = false;\n        }\n        // With the most recent connector, we're joining the end of the lowerPath to the most recent\n        // upperPath:\n        this.mostRecentConnector = lowerToUpperConnector;\n        this.nextCurveStartConnector = nextCurveStartConnector;\n        this.lowerSegments.push(lowerCurveCommand);\n        this.upperSegments.push(upperCurveCommand);\n        this.lastLowerBezier = lowerCurve;\n        this.lastUpperBezier = upperCurve;\n        this.curveStartWidth = curve.startWidth;\n    }\n    // Returns [upper curve, connector, lower curve]\n    segmentToPath(curve) {\n        const bezier = new QuadraticBezier(curve.startPoint, curve.controlPoint, curve.endPoint);\n        let startVec = bezier.normal(0);\n        let endVec = bezier.normal(1);\n        startVec = startVec.times(curve.startWidth / 2);\n        endVec = endVec.times(curve.endWidth / 2);\n        if (!isFinite(startVec.magnitude())) {\n            console.error('Warning: startVec is NaN or ∞', startVec, endVec, curve);\n            startVec = endVec;\n        }\n        const startPt = curve.startPoint;\n        const endPt = curve.endPoint;\n        const controlPoint = curve.controlPoint;\n        // Approximate the normal at the location of the control point\n        const projectionT = bezier.nearestPointTo(controlPoint).parameterValue;\n        const halfVecT = projectionT;\n        const halfVec = bezier\n            .normal(halfVecT)\n            .times((curve.startWidth / 2) * halfVecT + (curve.endWidth / 2) * (1 - halfVecT));\n        // Each starts at startPt ± startVec\n        const lowerCurveStartPoint = this.roundPoint(startPt.plus(startVec));\n        const lowerCurveControlPoint = this.roundPoint(controlPoint.plus(halfVec));\n        const lowerCurveEndPoint = this.roundPoint(endPt.plus(endVec));\n        const upperCurveControlPoint = this.roundPoint(controlPoint.minus(halfVec));\n        const upperCurveStartPoint = this.roundPoint(endPt.minus(endVec));\n        const upperCurveEndPoint = this.roundPoint(startPt.minus(startVec));\n        const lowerCurveCommand = {\n            kind: PathCommandType.QuadraticBezierTo,\n            controlPoint: lowerCurveControlPoint,\n            endPoint: lowerCurveEndPoint,\n        };\n        // From the end of the upperCurve to the start of the lowerCurve:\n        const upperToLowerConnector = {\n            kind: PathCommandType.LineTo,\n            point: lowerCurveStartPoint,\n        };\n        // From the end of lowerCurve to the start of upperCurve:\n        const lowerToUpperConnector = {\n            kind: PathCommandType.LineTo,\n            point: upperCurveStartPoint,\n        };\n        // The segment to be used to start the next path (to insert to connect the start of its\n        // lower and the end of its upper).\n        const nextCurveStartConnector = [\n            {\n                kind: PathCommandType.LineTo,\n                point: upperCurveStartPoint,\n            },\n            {\n                kind: PathCommandType.LineTo,\n                point: lowerCurveEndPoint,\n            },\n        ];\n        const upperCurveCommand = {\n            kind: PathCommandType.QuadraticBezierTo,\n            controlPoint: upperCurveControlPoint,\n            endPoint: upperCurveEndPoint,\n        };\n        const upperCurve = new QuadraticBezier(upperCurveStartPoint, upperCurveControlPoint, upperCurveEndPoint);\n        const lowerCurve = new QuadraticBezier(lowerCurveStartPoint, lowerCurveControlPoint, lowerCurveEndPoint);\n        return {\n            upperCurveCommand,\n            upperToLowerConnector,\n            lowerToUpperConnector,\n            lowerCurveCommand,\n            upperCurve,\n            lowerCurve,\n            nextCurveStartConnector,\n        };\n    }\n    addPoint(newPoint) {\n        this.curveFitter.addPoint(newPoint);\n    }\n}\n","import { Mat33, Rect2, Path } from '@js-draw/math';\nimport  { pathToRenderable }  from '../../rendering/RenderablePathSpec.mjs';\nimport  Stroke  from '../Stroke.mjs';\nimport  makeSnapToGridAutocorrect  from './autocorrect/makeSnapToGridAutocorrect.mjs';\n/**\n * Creates filled rectangles with sharp corners.\n *\n * Example:\n * [[include:doc-pages/inline-examples/changing-pen-types.md]]\n */\nexport const makeFilledRectangleBuilder = makeSnapToGridAutocorrect((initialPoint, viewport) => {\n    return new RectangleBuilder(initialPoint, true, viewport);\n});\n/**\n * Creates outlined rectangles with sharp corners.\n *\n * Example:\n * [[include:doc-pages/inline-examples/changing-pen-types.md]]\n */\nexport const makeOutlinedRectangleBuilder = makeSnapToGridAutocorrect((initialPoint, viewport) => {\n    return new RectangleBuilder(initialPoint, false, viewport);\n});\nexport default class RectangleBuilder {\n    constructor(startPoint, filled, viewport) {\n        this.startPoint = startPoint;\n        this.filled = filled;\n        this.viewport = viewport;\n        // Initially, the start and end points are the same.\n        this.endPoint = startPoint;\n    }\n    getBBox() {\n        const preview = this.buildPreview();\n        return preview.getBBox();\n    }\n    buildPreview() {\n        const canvasAngle = this.viewport.getRotationAngle();\n        const rotationMat = Mat33.zRotation(-canvasAngle);\n        // Adjust startPoint and endPoint such that applying [rotationMat] to them\n        // brings them to this.startPoint and this.endPoint.\n        const startPoint = rotationMat.inverse().transformVec2(this.startPoint.pos);\n        const endPoint = rotationMat.inverse().transformVec2(this.endPoint.pos);\n        const rect = Rect2.fromCorners(startPoint, endPoint);\n        const path = Path.fromRect(rect, this.filled ? null : this.endPoint.width)\n            .transformedBy(\n        // Rotate the canvas rectangle so that its rotation matches the screen\n        rotationMat)\n            .mapPoints((point) => this.viewport.roundPoint(point));\n        const preview = new Stroke([\n            pathToRenderable(path, {\n                fill: this.endPoint.color,\n            }),\n        ]);\n        return preview;\n    }\n    build() {\n        return this.buildPreview();\n    }\n    preview(renderer) {\n        this.buildPreview().render(renderer);\n    }\n    addPoint(point) {\n        this.endPoint = point;\n    }\n}\n","import { Rect2, LineSegment2 } from '@js-draw/math';\nconst makeShapeFitAutocorrect = (sourceFactory) => {\n    return (startPoint, viewport) => {\n        return new ShapeFitBuilder(sourceFactory, startPoint, viewport);\n    };\n};\nexport default makeShapeFitAutocorrect;\nconst makeLineTemplate = (startPoint, points, _bbox) => {\n    const templatePoints = [startPoint, points[points.length - 1]];\n    return { points: templatePoints };\n};\nconst makeRectangleTemplate = (_startPoint, _points, bbox) => {\n    return { points: [...bbox.corners, bbox.corners[0]] };\n};\nclass ShapeFitBuilder {\n    constructor(sourceFactory, startPoint, viewport) {\n        this.sourceFactory = sourceFactory;\n        this.startPoint = startPoint;\n        this.viewport = viewport;\n        this.builder = sourceFactory(startPoint, viewport);\n        this.points = [startPoint];\n    }\n    getBBox() {\n        return this.builder.getBBox();\n    }\n    build() {\n        return this.builder.build();\n    }\n    preview(renderer) {\n        this.builder.preview(renderer);\n    }\n    addPoint(point) {\n        this.points.push(point);\n        this.builder.addPoint(point);\n    }\n    async autocorrectShape() {\n        // Use screen points so that autocorrected shapes rotate with the screen.\n        const startPoint = this.viewport.canvasToScreen(this.startPoint.pos);\n        const points = this.points.map((point) => this.viewport.canvasToScreen(point.pos));\n        const bbox = Rect2.bboxOf(points);\n        const snappedStartPoint = this.viewport.canvasToScreen(this.viewport.snapToGrid(this.startPoint.pos));\n        const snappedPoints = this.points.map((point) => this.viewport.canvasToScreen(this.viewport.snapToGrid(point.pos)));\n        const snappedBBox = Rect2.bboxOf(snappedPoints);\n        // Only fit larger shapes\n        if (bbox.maxDimension < 32) {\n            return null;\n        }\n        const maxError = Math.min(30, bbox.maxDimension / 4);\n        // Create templates\n        const templates = [\n            {\n                ...makeLineTemplate(snappedStartPoint, snappedPoints, snappedBBox),\n                toleranceMultiplier: 0.5,\n            },\n            makeLineTemplate(startPoint, points, bbox),\n            {\n                ...makeRectangleTemplate(snappedStartPoint, snappedPoints, snappedBBox),\n                toleranceMultiplier: 0.6,\n            },\n            makeRectangleTemplate(startPoint, points, bbox),\n        ];\n        // Find a good fit fit\n        const selectTemplate = (maximumAllowedError) => {\n            for (const template of templates) {\n                const templatePoints = template.points;\n                // Maximum square error to accept the template\n                const acceptMaximumSquareError = maximumAllowedError * maximumAllowedError * (template.toleranceMultiplier ?? 1);\n                // Gets the point at index, wrapping the the start of the template if\n                // outside the array of points.\n                const templateAt = (index) => {\n                    while (index < 0) {\n                        index += templatePoints.length;\n                    }\n                    index %= templatePoints.length;\n                    return templatePoints[index];\n                };\n                let closestToFirst = null;\n                let closestToFirstSqrDist = Infinity;\n                let templateStartIndex = 0;\n                // Find the closest point to the startPoint\n                for (let i = 0; i < templatePoints.length; i++) {\n                    const current = templatePoints[i];\n                    const currentSqrDist = current.squareDistanceTo(startPoint);\n                    if (!closestToFirst || currentSqrDist < closestToFirstSqrDist) {\n                        closestToFirstSqrDist = currentSqrDist;\n                        closestToFirst = current;\n                        templateStartIndex = i;\n                    }\n                }\n                // Walk through the points and find the maximum error\n                let maximumSqrError = 0;\n                let templateIndex = templateStartIndex;\n                for (const point of points) {\n                    let minimumCurrentSqrError = Infinity;\n                    let minimumErrorAtIndex = templateIndex;\n                    const windowRadius = 6;\n                    for (let i = -windowRadius; i <= windowRadius; i++) {\n                        const index = templateIndex + i;\n                        const prevTemplatePoint = templateAt(index - 1);\n                        const currentTemplatePoint = templateAt(index);\n                        const nextTemplatePoint = templateAt(index + 1);\n                        const prevToCurrent = new LineSegment2(prevTemplatePoint, currentTemplatePoint);\n                        const currentToNext = new LineSegment2(currentTemplatePoint, nextTemplatePoint);\n                        const prevToCurrentDist = prevToCurrent.distance(point);\n                        const nextToCurrentDist = currentToNext.distance(point);\n                        const error = Math.min(prevToCurrentDist, nextToCurrentDist);\n                        const squareError = error * error;\n                        if (squareError < minimumCurrentSqrError) {\n                            minimumCurrentSqrError = squareError;\n                            minimumErrorAtIndex = index;\n                        }\n                    }\n                    templateIndex = minimumErrorAtIndex;\n                    maximumSqrError = Math.max(minimumCurrentSqrError, maximumSqrError);\n                    if (maximumSqrError > acceptMaximumSquareError) {\n                        break;\n                    }\n                }\n                if (maximumSqrError < acceptMaximumSquareError) {\n                    return templatePoints;\n                }\n            }\n            return null;\n        };\n        const template = selectTemplate(maxError);\n        if (!template) {\n            return null;\n        }\n        const lastDataPoint = this.points[this.points.length - 1];\n        const startWidth = this.startPoint.width;\n        const endWidth = lastDataPoint.width;\n        const startColor = this.startPoint.color;\n        const endColor = lastDataPoint.color;\n        const startTime = this.startPoint.time;\n        const endTime = lastDataPoint.time;\n        const templateIndexToStrokeDataPoint = (index) => {\n            const prevPoint = template[Math.max(0, Math.floor(index))];\n            const nextPoint = template[Math.min(Math.ceil(index), template.length - 1)];\n            const point = prevPoint.lerp(nextPoint, index - Math.floor(index));\n            const fractionToEnd = index / template.length;\n            return {\n                pos: this.viewport.screenToCanvas(point),\n                width: startWidth * (1 - fractionToEnd) + endWidth * fractionToEnd,\n                color: startColor.mix(endColor, fractionToEnd),\n                time: startTime * (1 - fractionToEnd) + endTime * fractionToEnd,\n            };\n        };\n        const builder = this.sourceFactory(templateIndexToStrokeDataPoint(0), this.viewport);\n        // Prevent the original builder from doing stroke smoothing if the template is short\n        // enough to likely have sharp corners.\n        const preventSmoothing = template.length < 10;\n        for (let i = 0; i < template.length; i++) {\n            if (preventSmoothing) {\n                builder.addPoint(templateIndexToStrokeDataPoint(i - 0.001));\n            }\n            builder.addPoint(templateIndexToStrokeDataPoint(i));\n            if (preventSmoothing) {\n                builder.addPoint(templateIndexToStrokeDataPoint(i + 0.001));\n            }\n        }\n        return builder.build();\n    }\n}\n","const makeSnapToGridAutocorrect = (sourceFactory) => {\n    return (startPoint, viewport) => {\n        return new SnapToGridAutocompleteBuilder(sourceFactory, startPoint, viewport);\n    };\n};\nexport default makeSnapToGridAutocorrect;\nclass SnapToGridAutocompleteBuilder {\n    constructor(sourceFactory, startPoint, viewport) {\n        this.sourceFactory = sourceFactory;\n        this.startPoint = startPoint;\n        this.viewport = viewport;\n        this.builder = sourceFactory(startPoint, viewport);\n        this.points = [startPoint];\n    }\n    getBBox() {\n        return this.builder.getBBox();\n    }\n    build() {\n        return this.builder.build();\n    }\n    preview(renderer) {\n        this.builder.preview(renderer);\n    }\n    addPoint(point) {\n        this.points.push(point);\n        this.builder.addPoint(point);\n    }\n    async autocorrectShape() {\n        const snapToGrid = (point) => {\n            return {\n                ...point,\n                pos: this.viewport.snapToGrid(point.pos),\n            };\n        };\n        // Use screen points so that snapped shapes rotate with the screen.\n        const startPoint = snapToGrid(this.startPoint);\n        const builder = this.sourceFactory(startPoint, this.viewport);\n        const points = this.points.map((point) => snapToGrid(point));\n        for (const point of points) {\n            builder.addPoint(point);\n        }\n        return builder.build();\n    }\n}\n","export  { makeFreehandLineBuilder }  from './FreehandLineBuilder.mjs';\nexport  { makePolylineBuilder }  from './PolylineBuilder.mjs';\nexport  { makePressureSensitiveFreehandLineBuilder }  from './PressureSensitiveFreehandLineBuilder.mjs';\nexport  { makeOutlinedCircleBuilder }  from './CircleBuilder.mjs';\nexport  { makeArrowBuilder }  from './ArrowBuilder.mjs';\nexport  { makeLineBuilder }  from './LineBuilder.mjs';\nexport  { makeFilledRectangleBuilder, makeOutlinedRectangleBuilder }  from './RectangleBuilder.mjs';\n","export {};\n","export  *  from './builders/types.mjs';\nexport  *  from './builders/lib.mjs';\nexport  { default as StrokeSmoother }  from './util/StrokeSmoother.mjs';\nexport  *  from './AbstractComponent.mjs';\nexport  { default as AbstractComponent }  from './AbstractComponent.mjs';\nimport  Stroke  from './Stroke.mjs';\nimport  TextComponent  from './TextComponent.mjs';\nimport  ImageComponent  from './ImageComponent.mjs';\nimport  { createRestyleComponentCommand, isRestylableComponent, }  from './RestylableComponent.mjs';\nimport  BackgroundComponent, { BackgroundType }  from './BackgroundComponent.mjs';\nexport { Stroke, createRestyleComponentCommand, isRestylableComponent, TextComponent, \n/** @deprecated use {@link TextComponent} */\nTextComponent as Text, Stroke as StrokeComponent, BackgroundComponent, BackgroundType as BackgroundComponentBackgroundType, ImageComponent, };\n","export const defaultComponentLocalization = {\n    unlabeledImageNode: 'Unlabeled image node',\n    stroke: 'Stroke',\n    svgObject: 'SVG Object',\n    emptyBackground: 'Empty background',\n    gridBackground: 'Grid background',\n    filledBackgroundWithColor: (color) => `Filled background (${color})`,\n    text: (text) => `Text object: ${text}`,\n    imageNode: (description) => `Image: ${description}`,\n    restyledElement: (elementDescription) => `Restyled ${elementDescription}`,\n};\n","import { Vec2, Rect2, LineSegment2, QuadraticBezier } from '@js-draw/math';\n// Handles stroke smoothing\nexport class StrokeSmoother {\n    constructor(startPoint, \n    // Maximum distance from the actual curve (irrespective of stroke width)\n    // for which a point is considered 'part of the curve'.\n    // Note that the maximum will be smaller if the stroke width is less than\n    // [maxFitAllowed].\n    minFitAllowed, maxFitAllowed, onCurveAdded) {\n        this.startPoint = startPoint;\n        this.minFitAllowed = minFitAllowed;\n        this.maxFitAllowed = maxFitAllowed;\n        this.onCurveAdded = onCurveAdded;\n        this.isFirstSegment = true;\n        this.lastExitingVec = null;\n        this.currentCurve = null;\n        this.lastPoint = this.startPoint;\n        this.buffer = [this.startPoint.pos];\n        this.momentum = Vec2.zero;\n        this.currentCurve = null;\n        this.curveStartWidth = startPoint.width;\n        this.bbox = new Rect2(this.startPoint.pos.x, this.startPoint.pos.y, 0, 0);\n    }\n    getBBox() {\n        return this.bbox;\n    }\n    preview() {\n        if (!this.currentCurve) {\n            return null;\n        }\n        return this.currentSegmentToPath();\n    }\n    // Returns the distance between the start, control, and end points of the curve.\n    approxCurrentCurveLength() {\n        if (!this.currentCurve) {\n            return 0;\n        }\n        const startPt = this.currentCurve.p0;\n        const controlPt = this.currentCurve.p1;\n        const endPt = this.currentCurve.p2;\n        const toControlDist = startPt.distanceTo(controlPt);\n        const toEndDist = endPt.distanceTo(controlPt);\n        return toControlDist + toEndDist;\n    }\n    finalizeCurrentCurve() {\n        // Case where no points have been added\n        if (!this.currentCurve) {\n            return;\n        }\n        this.onCurveAdded(this.currentSegmentToPath());\n        const lastPoint = this.buffer[this.buffer.length - 1];\n        this.lastExitingVec = this.currentCurve.p2.minus(this.currentCurve.p1);\n        console.assert(this.lastExitingVec.magnitude() !== 0, 'lastExitingVec has zero length!');\n        // Use the last two points to start a new curve (the last point isn't used\n        // in the current curve and we want connected curves to share end points)\n        this.buffer = [this.buffer[this.buffer.length - 2], lastPoint];\n        this.currentCurve = null;\n        this.isFirstSegment = false;\n    }\n    // Returns [upper curve, connector, lower curve]\n    currentSegmentToPath() {\n        if (this.currentCurve == null) {\n            throw new Error('Invalid State: currentCurve is null!');\n        }\n        const startVec = this.currentCurve.normal(0).normalized();\n        if (!isFinite(startVec.magnitude())) {\n            throw new Error(`startVec(${startVec}) is NaN or ∞`);\n        }\n        const startPt = this.currentCurve.at(0);\n        const endPt = this.currentCurve.at(1);\n        const controlPoint = this.currentCurve.p1;\n        return {\n            startPoint: startPt,\n            controlPoint,\n            endPoint: endPt,\n            startWidth: this.curveStartWidth,\n            endWidth: this.curveEndWidth,\n        };\n    }\n    // Compute the direction of the velocity at the end of this.buffer\n    computeExitingVec() {\n        return this.momentum.normalized().times(this.lastPoint.width / 2);\n    }\n    addPoint(newPoint) {\n        if (this.lastPoint) {\n            // Ignore points that are identical\n            const fuzzEq = 1e-10;\n            const deltaTime = newPoint.time - this.lastPoint.time;\n            if (newPoint.pos.eq(this.lastPoint.pos, fuzzEq) || deltaTime === 0) {\n                return;\n            }\n            else if (isNaN(newPoint.pos.magnitude())) {\n                console.warn('Discarding NaN point.', newPoint);\n                return;\n            }\n            const threshold = Math.min(this.lastPoint.width, newPoint.width) / 3;\n            const shouldSnapToInitial = this.startPoint.pos.distanceTo(newPoint.pos) < threshold && this.isFirstSegment;\n            // Snap to the starting point if the stroke is contained within a small ball centered\n            // at the starting point.\n            // This allows us to create a circle/dot at the start of the stroke.\n            if (shouldSnapToInitial) {\n                return;\n            }\n            const deltaTimeSeconds = deltaTime / 1000;\n            const velocity = newPoint.pos.minus(this.lastPoint.pos).times(1 / deltaTimeSeconds);\n            // TODO: Do we need momentum smoothing? (this.momentum.lerp(velocity, 0.9);)\n            this.momentum = velocity;\n        }\n        const lastPoint = this.lastPoint ?? newPoint;\n        this.lastPoint = newPoint;\n        this.buffer.push(newPoint.pos);\n        const pointRadius = newPoint.width;\n        const prevEndWidth = this.curveEndWidth;\n        this.curveEndWidth = pointRadius;\n        // recompute bbox\n        this.bbox = this.bbox.grownToPoint(newPoint.pos, pointRadius);\n        // If the last curve just ended or it's the first curve,\n        if (this.currentCurve === null) {\n            const p1 = lastPoint.pos;\n            const p2 = lastPoint.pos.plus(this.lastExitingVec ?? Vec2.unitX);\n            const p3 = newPoint.pos;\n            // Quadratic Bézier curve\n            this.currentCurve = new QuadraticBezier(p1, p2, p3);\n            console.assert(!isNaN(p1.magnitude()) && !isNaN(p2.magnitude()) && !isNaN(p3.magnitude()), 'Expected !NaN');\n            if (this.isFirstSegment) {\n                // The start of a curve often lacks accurate pressure information. Update it.\n                this.curveStartWidth = (this.curveStartWidth + pointRadius) / 2;\n            }\n            else {\n                this.curveStartWidth = prevEndWidth;\n            }\n        }\n        // If there isn't an entering vector (e.g. because this.isFirstCurve), approximate it.\n        let enteringVec = this.lastExitingVec;\n        if (!enteringVec) {\n            let sampleIdx = Math.ceil(this.buffer.length / 2);\n            if (sampleIdx === 0 || sampleIdx >= this.buffer.length) {\n                sampleIdx = this.buffer.length - 1;\n            }\n            enteringVec = this.buffer[sampleIdx].minus(this.buffer[0]);\n        }\n        let exitingVec = this.computeExitingVec();\n        // Find the intersection between the entering vector and the exiting vector\n        const maxRelativeLength = 1.7;\n        const segmentStart = this.buffer[0];\n        const segmentEnd = newPoint.pos;\n        const startEndDist = segmentEnd.distanceTo(segmentStart);\n        const maxControlPointDist = maxRelativeLength * startEndDist;\n        // Exit in cases where we would divide by zero\n        if (maxControlPointDist === 0 ||\n            exitingVec.magnitude() === 0 ||\n            !isFinite(exitingVec.magnitude())) {\n            return;\n        }\n        console.assert(isFinite(enteringVec.magnitude()), 'Pre-normalized enteringVec has NaN or ∞ magnitude!');\n        enteringVec = enteringVec.normalized();\n        exitingVec = exitingVec.normalized();\n        console.assert(isFinite(enteringVec.magnitude()), 'Normalized enteringVec has NaN or ∞ magnitude!');\n        const lineFromStart = new LineSegment2(segmentStart, segmentStart.plus(enteringVec.times(maxControlPointDist)));\n        const lineFromEnd = new LineSegment2(segmentEnd.minus(exitingVec.times(maxControlPointDist)), segmentEnd);\n        const intersection = lineFromEnd.intersection(lineFromStart);\n        // Position the control point at this intersection\n        let controlPoint = null;\n        if (intersection) {\n            controlPoint = intersection.point;\n        }\n        // No intersection?\n        if (!controlPoint) {\n            // Estimate the control point position based on the entering tangent line\n            controlPoint = segmentStart\n                .lerp(segmentEnd, 0.5)\n                .lerp(segmentStart.plus(enteringVec.times(startEndDist)), 0.1);\n        }\n        // Equal to an endpoint?\n        if (segmentStart.eq(controlPoint) || segmentEnd.eq(controlPoint)) {\n            // Position the control point closer to the first -- the connecting\n            // segment will be roughly a line.\n            controlPoint = segmentStart.plus(enteringVec.times(startEndDist / 5));\n        }\n        console.assert(!segmentStart.eq(controlPoint, 1e-11), 'Start and control points are equal!');\n        console.assert(!controlPoint.eq(segmentEnd, 1e-11), 'Control and end points are equal!');\n        const prevCurve = this.currentCurve;\n        this.currentCurve = new QuadraticBezier(segmentStart, controlPoint, segmentEnd);\n        if (isNaN(this.currentCurve.normal(0).magnitude())) {\n            console.error('NaN normal at 0. Curve:', this.currentCurve);\n            this.currentCurve = prevCurve;\n        }\n        // Should we start making a new curve? Check whether all buffer points are within\n        // ±strokeWidth of the curve.\n        const curveMatchesPoints = (curve) => {\n            const minFit = Math.min(Math.max(Math.min(this.curveStartWidth, this.curveEndWidth) / 4, this.minFitAllowed), this.maxFitAllowed);\n            // The sum of distances greater than minFit must not exceed this:\n            const maxNonMatchingDistSum = minFit;\n            // Sum of distances greater than minFit.\n            let nonMatchingDistSum = 0;\n            for (const point of this.buffer) {\n                let dist = curve.approximateDistance(point);\n                if (dist > minFit) {\n                    // Use the more accurate distance function\n                    dist = curve.distance(point);\n                    nonMatchingDistSum += Math.max(0, dist - minFit);\n                    if (nonMatchingDistSum > maxNonMatchingDistSum) {\n                        return false; // false: Curve doesn't match points well enough.\n                    }\n                }\n            }\n            return true;\n        };\n        if (this.buffer.length > 3 && this.approxCurrentCurveLength() > this.curveStartWidth / 2) {\n            if (!curveMatchesPoints(this.currentCurve)) {\n                // Use a curve that better fits the points\n                this.currentCurve = prevCurve;\n                this.curveEndWidth = prevEndWidth;\n                // Reset the last point -- the current point was not added to the curve.\n                this.lastPoint = lastPoint;\n                this.finalizeCurrentCurve();\n                return;\n            }\n        }\n    }\n}\nexport default StrokeSmoother;\n","// Returns the description of all given elements, if identical, otherwise,\n// returns null.\nexport default (localizationTable, elems) => {\n    if (elems.length === 0) {\n        return null;\n    }\n    const description = elems[0].description(localizationTable);\n    for (const elem of elems) {\n        if (elem.description(localizationTable) !== description) {\n            return null;\n        }\n    }\n    return description;\n};\n","import  makeMessageDialog  from './makeMessageDialog.mjs';\nconst makeAboutDialog = (editor, entries) => {\n    const dialog = makeMessageDialog(editor, {\n        title: editor.localization.about,\n        contentClassNames: ['about-dialog-content'],\n    });\n    for (const entry of entries) {\n        const container = document.createElement(entry.minimized ? 'details' : 'div');\n        container.classList.add('about-entry');\n        const header = document.createElement(entry.minimized ? 'summary' : 'h2');\n        if (typeof entry.heading === 'string') {\n            header.innerText = entry.heading;\n        }\n        else {\n            const link = document.createElement('a');\n            link.href = entry.heading.href.replace(/^javascript:/i, '');\n            link.text = entry.heading.text;\n            header.appendChild(link);\n        }\n        container.appendChild(header);\n        if (entry.text) {\n            const bodyText = document.createElement('div');\n            bodyText.innerText = entry.text;\n            container.appendChild(bodyText);\n        }\n        dialog.appendChild(container);\n    }\n    return {\n        close: () => {\n            return dialog.close();\n        },\n    };\n};\nexport default makeAboutDialog;\n","import  waitForTimeout  from '../util/waitForTimeout.mjs';\nconst makeAboutDialog = (editor, options) => {\n    const overlay = document.createElement('div');\n    const { remove: removeOverlay } = editor.createHTMLOverlay(overlay);\n    overlay.classList.add('dialog-container', 'message-dialog-container', ...(options.classNames ?? []));\n    const dialog = document.createElement('dialog');\n    const contentWrapper = document.createElement('div');\n    contentWrapper.classList.add('message-dialog-content', ...(options.contentClassNames ?? []));\n    const heading = document.createElement('h1');\n    heading.textContent = options.title;\n    heading.setAttribute('autofocus', 'true');\n    const closeButton = document.createElement('button');\n    closeButton.innerText = editor.localization.closeDialog;\n    closeButton.classList.add('close');\n    const scrollRegion = document.createElement('div');\n    scrollRegion.classList.add('scroll');\n    // Allow scrolling in the scrollable container -- don't forward wheel events.\n    scrollRegion.onwheel = (evt) => evt.stopPropagation();\n    contentWrapper.replaceChildren(heading, scrollRegion, closeButton);\n    dialog.replaceChildren(contentWrapper);\n    overlay.replaceChildren(dialog);\n    const closeTimeout = 300;\n    dialog.style.setProperty('--close-delay', `${closeTimeout}ms`);\n    const closeDialog = async () => {\n        dialog.classList.add('-closing');\n        await waitForTimeout(closeTimeout);\n        dialog.close();\n    };\n    const addCloseListeners = () => {\n        dialog.addEventListener('pointerdown', (event) => {\n            if (event.target === dialog) {\n                void closeDialog();\n            }\n        });\n        dialog.onclose = () => {\n            removeOverlay();\n        };\n        closeButton.onclick = () => closeDialog();\n    };\n    addCloseListeners();\n    dialog.showModal();\n    return {\n        close: () => {\n            return closeDialog();\n        },\n        appendChild: (child) => {\n            scrollRegion.appendChild(child);\n        },\n    };\n};\nexport default makeAboutDialog;\n","var __setFunctionName = (this && this.__setFunctionName) || function (f, name, prefix) {\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\nvar _a, _b, _c;\nimport  Viewport  from '../Viewport.mjs';\nimport  AbstractComponent, { ComponentSizingMode }  from '../components/AbstractComponent.mjs';\nimport { Rect2, Vec2, Mat33, Color4 } from '@js-draw/math';\nimport  SerializableCommand  from '../commands/SerializableCommand.mjs';\nimport  EventDispatcher  from '../EventDispatcher.mjs';\nimport  { assertIsBoolean, assertIsNumber, assertIsNumberArray }  from '../util/assertions.mjs';\nimport  Command  from '../commands/Command.mjs';\n// @internal Sort by z-index, low to high\nexport const sortLeavesByZIndex = (leaves) => {\n    leaves.sort((a, b) => a.getContent().getZIndex() - b.getContent().getZIndex());\n};\nexport var EditorImageEventType;\n(function (EditorImageEventType) {\n    EditorImageEventType[EditorImageEventType[\"ExportViewportChanged\"] = 0] = \"ExportViewportChanged\";\n    EditorImageEventType[EditorImageEventType[\"AutoresizeModeChanged\"] = 1] = \"AutoresizeModeChanged\";\n})(EditorImageEventType || (EditorImageEventType = {}));\nlet debugMode = false;\n/**\n * @summary Handles lookup/storage of elements in the image.\n *\n * `js-draw` images are made up of a collection of {@link AbstractComponent}s (which\n * includes {@link Stroke}s, {@link TextComponent}s, etc.). An `EditorImage`\n * is the data structure that stores these components.\n *\n * Here's how to do a few common operations:\n * - **Get all components in a {@link @js-draw/math!Rect2 | Rect2}**:\n *    {@link EditorImage.getElementsIntersectingRegion}.\n * - **Draw an `EditorImage` onto a canvas/SVG**: {@link EditorImage.render}.\n * - **Adding a new component**: {@link EditorImage.addElement}.\n *\n * **Example**:\n * [[include:doc-pages/inline-examples/image-add-and-lookup.md]]\n */\nclass EditorImage {\n    // @internal\n    constructor() {\n        this.componentCount = 0;\n        this.settingExportRect = false;\n        this.root = new RootImageNode();\n        this.background = new RootImageNode();\n        this.componentsById = Object.create(null);\n        this.notifier = new EventDispatcher();\n        this.importExportViewport = new Viewport(() => {\n            this.onExportViewportChanged();\n        });\n        // Default to a 500x500 image\n        this.importExportViewport.updateScreenSize(Vec2.of(500, 500));\n        this.shouldAutoresizeExportViewport = false;\n    }\n    // Returns all components that make up the background of this image. These\n    // components are rendered below all other components.\n    getBackgroundComponents() {\n        const result = [];\n        const leaves = this.background.getLeaves();\n        sortLeavesByZIndex(leaves);\n        for (const leaf of leaves) {\n            const content = leaf.getContent();\n            if (content) {\n                result.push(content);\n            }\n        }\n        return result;\n    }\n    // Returns the parent of the given element, if it exists.\n    findParent(elem) {\n        return this.background.getChildWithContent(elem) ?? this.root.getChildWithContent(elem);\n    }\n    // Forces a re-render of `elem` when the image is next re-rendered as a whole.\n    // Does nothing if `elem` is not in this.\n    queueRerenderOf(elem) {\n        // TODO: Make more efficient (e.g. increase IDs of all parents,\n        // make cache take into account last modified time instead of IDs, etc.)\n        const parent = this.findParent(elem);\n        if (parent) {\n            parent.remove();\n            this.addElementDirectly(elem);\n        }\n    }\n    /** @internal */\n    renderWithCache(screenRenderer, cache, viewport) {\n        this.background.render(screenRenderer, viewport.visibleRect);\n        // If in debug mode, avoid rendering with cache to show additional debug information\n        if (!debugMode) {\n            cache.render(screenRenderer, this.root, viewport);\n        }\n        else {\n            this.root.render(screenRenderer, viewport.visibleRect);\n        }\n    }\n    /**\n     * Renders this image to the given `renderer`.\n     *\n     * If `viewport` is non-null, only components that can be seen from that viewport\n     * will be rendered. If `viewport` is `null`, **all** components are rendered.\n     *\n     * **Example**:\n     * [[include:doc-pages/inline-examples/canvas-renderer.md]]\n     */\n    render(renderer, viewport) {\n        this.background.render(renderer, viewport?.visibleRect);\n        this.root.render(renderer, viewport?.visibleRect);\n    }\n    /**\n     * Like {@link renderAll}, but can be stopped early and paused.\n     *\n     * **Note**: If the image is being edited during an async rendering, there is no\n     * guarantee that all nodes will be rendered correctly (some may be missing).\n     *\n     * @internal\n     */\n    async renderAllAsync(renderer, preRenderComponent) {\n        const stoppedEarly = !(await this.background.renderAllAsync(renderer, preRenderComponent));\n        if (!stoppedEarly) {\n            return await this.root.renderAllAsync(renderer, preRenderComponent);\n        }\n        return false;\n    }\n    /**\n     * Renders all nodes, even ones not within the viewport.\n     *\n     * This can be slow for large images\n     * @internal\n     */\n    renderAll(renderer) {\n        this.render(renderer, null);\n    }\n    /**\n     * @returns all elements in the image, sorted by z-index (low to high).\n     *\n     * This can be slow for large images. If you only need all elemenst in part of the image,\n     * consider using {@link getElementsIntersectingRegion} instead.\n     *\n     * **Note**: The result does not include background elements. See {@link getBackgroundComponents}.\n     */\n    getAllElements() {\n        const leaves = this.root.getLeaves();\n        sortLeavesByZIndex(leaves);\n        return leaves.map((leaf) => leaf.getContent());\n    }\n    /** Returns the number of elements added to this image. @internal */\n    estimateNumElements() {\n        return this.componentCount;\n    }\n    /**\n     * @returns a list of `AbstractComponent`s intersecting `region`, sorted by increasing z-index.\n     *\n     * Components in the background layer are only included if `includeBackground` is `true`.\n     */\n    getElementsIntersectingRegion(region, includeBackground = false) {\n        let leaves = this.root.getLeavesIntersectingRegion(region);\n        if (includeBackground) {\n            leaves = leaves.concat(this.background.getLeavesIntersectingRegion(region));\n        }\n        sortLeavesByZIndex(leaves);\n        return leaves.map((leaf) => leaf.getContent());\n    }\n    /** Called whenever (just after) an element is completely removed. @internal */\n    onDestroyElement(elem) {\n        this.componentCount--;\n        delete this.componentsById[elem.getId()];\n        this.autoresizeExportViewport();\n    }\n    /** Called just after an element is added. @internal */\n    onElementAdded(elem) {\n        this.componentCount++;\n        this.componentsById[elem.getId()] = elem;\n        this.autoresizeExportViewport();\n    }\n    /**\n     * @returns the AbstractComponent with `id`, if it exists.\n     *\n     * @see {@link AbstractComponent.getId}\n     */\n    lookupElement(id) {\n        return this.componentsById[id] ?? null;\n    }\n    addElementDirectly(elem) {\n        // Because onAddToImage can affect the element's bounding box,\n        // this needs to be called before parentTree.addLeaf.\n        elem.onAddToImage(this);\n        // If a background component, add to the background. Else,\n        // add to the normal component tree.\n        const parentTree = elem.isBackground() ? this.background : this.root;\n        const result = parentTree.addLeaf(elem);\n        this.onElementAdded(elem);\n        return result;\n    }\n    removeElementDirectly(element) {\n        const container = this.findParent(element);\n        container?.remove();\n        if (container) {\n            this.onDestroyElement(element);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Returns a command that adds the given element to the `EditorImage`.\n     * If `applyByFlattening` is true, the content of the wet ink renderer is\n     * rendered onto the main rendering canvas instead of doing a full re-render.\n     *\n     * @see {@link Display.flatten}\n     *\n     * **Example**:\n     *\n     * [[include:doc-pages/inline-examples/adding-a-stroke.md]]\n     */\n    static addElement(elem, applyByFlattening = false) {\n        return new _a.AddElementCommand(elem, applyByFlattening);\n    }\n    /** @see EditorImage.addElement */\n    addElement(elem, applyByFlattening) {\n        return _a.addElement(elem, applyByFlattening);\n    }\n    /**\n     * @returns a `Viewport` for rendering the image when importing/exporting.\n     */\n    getImportExportViewport() {\n        return this.importExportViewport;\n    }\n    /**\n     * @see {@link setImportExportRect}\n     */\n    getImportExportRect() {\n        return this.getImportExportViewport().visibleRect;\n    }\n    /**\n     * Sets the import/export rectangle to the given `imageRect`. Disables\n     * autoresize if it was previously enabled.\n     *\n     * **Note**: The import/export rectangle is the same as the size of any\n     * {@link BackgroundComponent}s (and other components that auto-resize).\n     */\n    setImportExportRect(imageRect) {\n        return _a.SetImportExportRectCommand.of(this, imageRect, false);\n    }\n    /** @see {@link setAutoresizeEnabled} */\n    getAutoresizeEnabled() {\n        return this.shouldAutoresizeExportViewport;\n    }\n    /**\n     * Returns a `Command` that sets whether the image should autoresize when\n     * {@link AbstractComponent}s are added/removed.\n     *\n     * @example\n     *\n     * ```ts,runnable\n     * import { Editor } from 'js-draw';\n     *\n     * const editor = new Editor(document.body);\n     * const toolbar = editor.addToolbar();\n     *\n     * // Add a save button to demonstrate what the output looks like\n     * // (it should change size to fit whatever was drawn)\n     * toolbar.addSaveButton(() => {\n     *   document.body.replaceChildren(editor.toSVG({ sanitize: true }));\n     * });\n     *\n     * // Actually using setAutoresizeEnabled:\n     * //\n     * // To set autoresize without announcing for accessibility/making undoable\n     * const addToHistory = false;\n     * editor.dispatchNoAnnounce(editor.image.setAutoresizeEnabled(true), addToHistory);\n     *\n     * // Add to undo history **and** announce for accessibility\n     * //editor.dispatch(editor.image.setAutoresizeEnabled(true), true);\n     * ```\n     */\n    setAutoresizeEnabled(autoresize) {\n        if (autoresize === this.shouldAutoresizeExportViewport) {\n            return Command.empty;\n        }\n        const newBBox = this.root.getBBox();\n        return _a.SetImportExportRectCommand.of(this, newBBox, autoresize);\n    }\n    setAutoresizeEnabledDirectly(shouldAutoresize) {\n        if (shouldAutoresize !== this.shouldAutoresizeExportViewport) {\n            this.shouldAutoresizeExportViewport = shouldAutoresize;\n            this.notifier.dispatch(EditorImageEventType.AutoresizeModeChanged, {\n                image: this,\n            });\n        }\n    }\n    /** Updates the size/position of the viewport */\n    autoresizeExportViewport() {\n        // Only autoresize if in autoresize mode -- otherwise resizing the image\n        // should be done with undoable commands.\n        if (this.shouldAutoresizeExportViewport) {\n            this.setExportRectDirectly(this.root.getBBox());\n        }\n    }\n    /**\n     * Sets the import/export viewport directly, without returning a `Command`.\n     * As such, this is not undoable.\n     *\n     * See setImportExportRect\n     *\n     * Returns true if changes to the viewport were made (and thus\n     * ExportViewportChanged was fired.)\n     */\n    setExportRectDirectly(newRect) {\n        const viewport = this.getImportExportViewport();\n        const lastSize = viewport.getScreenRectSize();\n        const lastTransform = viewport.canvasToScreenTransform;\n        const newTransform = Mat33.translation(newRect.topLeft.times(-1));\n        if (!lastSize.eq(newRect.size) || !lastTransform.eq(newTransform)) {\n            // Prevent the ExportViewportChanged event from being fired\n            // multiple times for the same viewport change: Set settingExportRect\n            // to true.\n            this.settingExportRect = true;\n            viewport.updateScreenSize(newRect.size);\n            viewport.resetTransform(newTransform);\n            this.settingExportRect = false;\n            this.onExportViewportChanged();\n            return true;\n        }\n        return false;\n    }\n    onExportViewportChanged() {\n        // Prevent firing duplicate events -- changes\n        // made by exportViewport.resetTransform may cause this method to be\n        // called.\n        if (!this.settingExportRect) {\n            this.notifier.dispatch(EditorImageEventType.ExportViewportChanged, {\n                image: this,\n            });\n        }\n    }\n    /**\n     * @internal\n     *\n     * Enables debug mode for **all** `EditorImage`s.\n     *\n     * **Only use for debugging**.\n     *\n     * @internal\n     */\n    static setDebugMode(newDebugMode) {\n        debugMode = newDebugMode;\n    }\n}\n_a = EditorImage;\n// A Command that can access private [EditorImage] functionality\nEditorImage.AddElementCommand = (_b = class extends SerializableCommand {\n        // If [applyByFlattening], then the rendered content of this element\n        // is present on the display's wet ink canvas. As such, no re-render is necessary\n        // the first time this command is applied (the surfaces are joined instead).\n        constructor(element, applyByFlattening = false) {\n            super('add-element');\n            this.element = element;\n            this.applyByFlattening = applyByFlattening;\n            this.serializedElem = null;\n            // FIXME: The serialized version of this command may be inaccurate if this is\n            //        serialized when this command is not on the top of the undo stack.\n            //\n            // Caching the element's serialized data leads to additional memory usage *and*\n            // sometimes incorrect behavior in collaborative editing.\n            this.serializedElem = null;\n            if (isNaN(element.getBBox().area)) {\n                throw new Error('Elements in the image cannot have NaN bounding boxes');\n            }\n        }\n        apply(editor) {\n            editor.image.addElementDirectly(this.element);\n            if (!this.applyByFlattening) {\n                editor.queueRerender();\n            }\n            else {\n                this.applyByFlattening = false;\n                editor.display.flatten();\n            }\n        }\n        unapply(editor) {\n            editor.image.removeElementDirectly(this.element);\n            editor.queueRerender();\n        }\n        description(_editor, localization) {\n            return localization.addElementAction(this.element.description(localization));\n        }\n        serializeToJSON() {\n            return {\n                elemData: this.serializedElem ?? this.element.serialize(),\n            };\n        }\n    },\n    __setFunctionName(_b, \"AddElementCommand\"),\n    (() => {\n        SerializableCommand.register('add-element', (json, editor) => {\n            const id = json.elemData.id;\n            const foundElem = editor.image.lookupElement(id);\n            const elem = foundElem ?? AbstractComponent.deserialize(json.elemData);\n            const result = new _a.AddElementCommand(elem);\n            result.serializedElem = json.elemData;\n            return result;\n        });\n    })(),\n    _b);\n// Handles resizing the background import/export region of the image.\nEditorImage.SetImportExportRectCommand = (_c = class extends SerializableCommand {\n        constructor(originalSize, originalTransform, originalAutoresize, newExportRect, newAutoresize) {\n            super(_a.SetImportExportRectCommand.commandId);\n            this.originalSize = originalSize;\n            this.originalTransform = originalTransform;\n            this.originalAutoresize = originalAutoresize;\n            this.newExportRect = newExportRect;\n            this.newAutoresize = newAutoresize;\n        }\n        // Uses `image` to store the original size/transform\n        static of(image, newExportRect, newAutoresize) {\n            const importExportViewport = image.getImportExportViewport();\n            const originalSize = importExportViewport.visibleRect.size;\n            const originalTransform = importExportViewport.canvasToScreenTransform;\n            const originalAutoresize = image.getAutoresizeEnabled();\n            return new _a.SetImportExportRectCommand(originalSize, originalTransform, originalAutoresize, newExportRect, newAutoresize);\n        }\n        apply(editor) {\n            editor.image.setAutoresizeEnabledDirectly(this.newAutoresize);\n            editor.image.setExportRectDirectly(this.newExportRect);\n            editor.queueRerender();\n        }\n        unapply(editor) {\n            const viewport = editor.image.getImportExportViewport();\n            editor.image.setAutoresizeEnabledDirectly(this.originalAutoresize);\n            viewport.updateScreenSize(this.originalSize);\n            viewport.resetTransform(this.originalTransform);\n            editor.queueRerender();\n        }\n        description(_editor, localization) {\n            if (this.newAutoresize !== this.originalAutoresize) {\n                if (this.newAutoresize) {\n                    return localization.enabledAutoresizeOutputCommand;\n                }\n                else {\n                    return localization.disabledAutoresizeOutputCommand;\n                }\n            }\n            return localization.resizeOutputCommand(this.newExportRect);\n        }\n        serializeToJSON() {\n            return {\n                originalSize: this.originalSize.xy,\n                originalTransform: this.originalTransform.toArray(),\n                newRegion: {\n                    x: this.newExportRect.x,\n                    y: this.newExportRect.y,\n                    w: this.newExportRect.w,\n                    h: this.newExportRect.h,\n                },\n                autoresize: this.newAutoresize,\n                originalAutoresize: this.originalAutoresize,\n            };\n        }\n    },\n    __setFunctionName(_c, \"SetImportExportRectCommand\"),\n    _c.commandId = 'set-import-export-rect',\n    (() => {\n        const commandId = _c.commandId;\n        SerializableCommand.register(commandId, (json, _editor) => {\n            assertIsNumber(json.originalSize.x);\n            assertIsNumber(json.originalSize.y);\n            assertIsNumberArray(json.originalTransform);\n            assertIsNumberArray([\n                json.newRegion.x,\n                json.newRegion.y,\n                json.newRegion.w,\n                json.newRegion.h,\n            ]);\n            assertIsBoolean(json.autoresize ?? false);\n            assertIsBoolean(json.originalAutoresize ?? false);\n            const originalSize = Vec2.ofXY(json.originalSize);\n            const originalTransform = new Mat33(...json.originalTransform);\n            const finalRect = new Rect2(json.newRegion.x, json.newRegion.y, json.newRegion.w, json.newRegion.h);\n            const autoresize = json.autoresize ?? false;\n            const originalAutoresize = json.originalAutoresize ?? false;\n            return new _a.SetImportExportRectCommand(originalSize, originalTransform, originalAutoresize, finalRect, autoresize);\n        });\n    })(),\n    _c);\nexport default EditorImage;\n/**\n * Determines the first index in `sortedLeaves` that needs to be rendered\n * (based on occlusion -- everything before that index can be skipped and\n * produce a visually-equivalent image).\n *\n * Does nothing if visibleRect is not provided\n *\n * @internal\n */\nexport const computeFirstIndexToRender = (sortedLeaves, visibleRect) => {\n    let startIndex = 0;\n    if (visibleRect) {\n        for (let i = sortedLeaves.length - 1; i >= 1; i--) {\n            if (\n            // Check for occlusion\n            sortedLeaves[i].getBBox().containsRect(visibleRect) &&\n                sortedLeaves[i].getContent()?.occludesEverythingBelowWhenRenderedInRect(visibleRect)) {\n                startIndex = i;\n                break;\n            }\n        }\n    }\n    return startIndex;\n};\n/**\n * Part of the Editor's image. Does not handle fullscreen/invisible components.\n * @internal\n */\nexport class ImageNode {\n    constructor(parent = null) {\n        this.parent = parent;\n        this.targetChildCount = 30;\n        this.children = [];\n        this.bbox = Rect2.empty;\n        this.content = null;\n        this.id = ImageNode.idCounter++;\n    }\n    getId() {\n        return this.id;\n    }\n    onContentChange() {\n        this.id = ImageNode.idCounter++;\n    }\n    getContent() {\n        return this.content;\n    }\n    getParent() {\n        return this.parent;\n    }\n    // Override this to change how children are considered within a given region.\n    getChildrenIntersectingRegion(region, isTooSmallFilter) {\n        return this.children.filter((child) => {\n            const bbox = child.getBBox();\n            return !isTooSmallFilter?.(bbox) && bbox.intersects(region);\n        });\n    }\n    getChildrenOrSelfIntersectingRegion(region, isTooSmall) {\n        if (this.content && this.bbox.intersects(region) && !isTooSmall?.(this.bbox)) {\n            return [this];\n        }\n        return this.getChildrenIntersectingRegion(region, isTooSmall);\n    }\n    /**\n     * Returns a list of `ImageNode`s with content (and thus no children).\n     * Override getChildrenIntersectingRegion to customize how this method\n     * determines whether/which children are in `region`.\n     *\n     * @paran region - All resultant `ImageNode`s must intersect `region`.\n     * @param isTooSmall - If `isTooSmall` returns true for an image node, that node\n     *                     is excluded from the output.\n     *\n     */\n    getLeavesIntersectingRegion(region, isTooSmall) {\n        const result = [];\n        const workList = [];\n        workList.push(this);\n        while (workList.length > 0) {\n            const current = workList.pop();\n            // Split the children into leaves and non-leaves\n            const processed = current.getChildrenOrSelfIntersectingRegion(region, isTooSmall);\n            for (const item of processed) {\n                if (item.content) {\n                    result.push(item);\n                }\n                else {\n                    // Non-leaves need to be processed\n                    workList.push(item);\n                }\n            }\n        }\n        return result;\n    }\n    // Returns the child of this with the target content or `null` if no\n    // such child exists.\n    //\n    // Note: Relies on all children to have valid bounding boxes.\n    getChildWithContent(target) {\n        const candidates = this.getLeavesIntersectingRegion(target.getBBox());\n        for (const candidate of candidates) {\n            if (candidate.getContent() === target) {\n                return candidate;\n            }\n        }\n        return null;\n    }\n    // Returns a list of leaves with this as an ancestor.\n    // Like getLeavesInRegion, but does not check whether ancestors are in a given rectangle\n    getLeaves() {\n        if (this.content) {\n            return [this];\n        }\n        const result = [];\n        for (const child of this.children) {\n            result.push(...child.getLeaves());\n        }\n        return result;\n    }\n    addLeaf(leaf) {\n        this.onContentChange();\n        if (this.content === null && this.children.length === 0) {\n            this.content = leaf;\n            this.recomputeBBox(true);\n            return this;\n        }\n        if (this.content !== null) {\n            console.assert(this.children.length === 0);\n            const contentNode = new ImageNode(this);\n            contentNode.content = this.content;\n            this.content = null;\n            this.children.push(contentNode);\n            contentNode.recomputeBBox(false);\n        }\n        // If this node is contained within the leaf, make this and the leaf\n        // share a parent.\n        const leafBBox = leaf.getBBox();\n        if (leafBBox.containsRect(this.getBBox())) {\n            const nodeForNewLeaf = new ImageNode(this);\n            if (this.children.length < this.targetChildCount) {\n                this.children.push(nodeForNewLeaf);\n            }\n            else {\n                const nodeForChildren = new ImageNode(this);\n                nodeForChildren.children = this.children;\n                this.children = [nodeForNewLeaf, nodeForChildren];\n                nodeForChildren.updateParents();\n                nodeForChildren.recomputeBBox(true);\n            }\n            return nodeForNewLeaf.addLeaf(leaf);\n        }\n        const containingNodes = this.children.filter((child) => child.getBBox().containsRect(leafBBox));\n        // Does the leaf already fit within one of the children?\n        if (containingNodes.length > 0 && this.children.length >= this.targetChildCount) {\n            // Sort the containers in ascending order by area\n            containingNodes.sort((a, b) => a.getBBox().area - b.getBBox().area);\n            // Choose the smallest child that contains the new element.\n            const result = containingNodes[0].addLeaf(leaf);\n            result.rebalance();\n            return result;\n        }\n        const newNode = ImageNode.createLeafNode(this, leaf);\n        this.children.push(newNode);\n        newNode.recomputeBBox(true);\n        if (this.children.length >= this.targetChildCount) {\n            this.rebalance();\n        }\n        return newNode;\n    }\n    // Creates a new leaf node with the given content.\n    // This only establishes the parent-child linking in one direction. Callers\n    // must add the resultant node to the list of children manually.\n    static createLeafNode(parent, content) {\n        const newNode = new ImageNode(parent);\n        newNode.content = content;\n        return newNode;\n    }\n    getBBox() {\n        return this.bbox;\n    }\n    // Recomputes this' bounding box. If [bubbleUp], also recompute\n    // this' ancestors bounding boxes. This also re-computes this' bounding box\n    // in the z-direction (z-indicies).\n    recomputeBBox(bubbleUp) {\n        const oldBBox = this.bbox;\n        if (this.content !== null) {\n            this.bbox = this.content.getBBox();\n        }\n        else {\n            this.bbox = Rect2.union(...this.children.map((child) => child.getBBox()));\n        }\n        if (bubbleUp && !oldBBox.eq(this.bbox)) {\n            if (this.bbox.containsRect(oldBBox)) {\n                this.parent?.unionBBoxWith(this.bbox);\n            }\n            else {\n                this.parent?.recomputeBBox(true);\n            }\n        }\n        this.checkRep();\n    }\n    // Grows this' bounding box to also include `other`.\n    // Always bubbles up.\n    unionBBoxWith(other) {\n        this.bbox = this.bbox.union(other);\n        this.parent?.unionBBoxWith(other);\n    }\n    updateParents(recursive = false) {\n        for (const child of this.children) {\n            child.parent = this;\n            if (recursive) {\n                child.updateParents(recursive);\n            }\n        }\n    }\n    rebalance() {\n        // If the current node is its parent's only child,\n        if (this.parent && this.parent.children.length === 1) {\n            console.assert(this.parent.content === null);\n            console.assert(this.parent.children[0] === this);\n            // Remove this' parent, if this' parent isn't the root.\n            const oldParent = this.parent;\n            if (oldParent.parent !== null) {\n                const newParent = oldParent.parent;\n                newParent.children = newParent.children.filter((c) => c !== oldParent);\n                oldParent.parent = null;\n                oldParent.children = [];\n                this.parent = newParent;\n                newParent.children.push(this);\n                this.parent.recomputeBBox(false);\n            }\n            else if (this.content === null) {\n                // Remove this and transfer this' children to the parent.\n                this.parent.children = this.children;\n                this.parent.updateParents();\n                this.parent = null;\n            }\n        }\n        // Create virtual containers for children. Handles the case where there\n        // are many small, often non-overlapping children that we still want to be grouped.\n        if (this.children.length > this.targetChildCount * 10) {\n            const grid = this.getBBox().divideIntoGrid(4, 4);\n            const indexToCount = [];\n            while (indexToCount.length < grid.length) {\n                indexToCount.push(0);\n            }\n            for (const child of this.children) {\n                for (let i = 0; i < grid.length; i++) {\n                    if (grid[i].containsRect(child.getBBox())) {\n                        indexToCount[i]++;\n                    }\n                }\n            }\n            let indexWithGreatest = 0;\n            let greatestCount = indexToCount[0];\n            for (let i = 1; i < indexToCount.length; i++) {\n                if (indexToCount[i] > greatestCount) {\n                    indexWithGreatest = i;\n                    greatestCount = indexToCount[i];\n                }\n            }\n            const targetGridSquare = grid[indexWithGreatest];\n            // Avoid clustering if just a few children would be grouped.\n            // Unnecessary clustering can lead to unnecessarily nested nodes.\n            if (greatestCount > 4) {\n                const newChildren = [];\n                const childNodeChildren = [];\n                for (const child of this.children) {\n                    if (targetGridSquare.containsRect(child.getBBox())) {\n                        childNodeChildren.push(child);\n                    }\n                    else {\n                        newChildren.push(child);\n                    }\n                }\n                if (childNodeChildren.length < this.children.length) {\n                    this.children = newChildren;\n                    const child = new ImageNode(this);\n                    this.children.push(child);\n                    child.children = childNodeChildren;\n                    child.updateParents(false);\n                    child.recomputeBBox(false);\n                    child.rebalance();\n                }\n            }\n        }\n        // Empty?\n        if (this.parent && this.children.length === 0 && this.content === null) {\n            this.remove();\n        }\n    }\n    // Removes the parent-to-child link.\n    // Called internally by `.remove`\n    removeChild(child) {\n        this.checkRep();\n        const oldChildCount = this.children.length;\n        this.children = this.children.filter((node) => {\n            return node !== child;\n        });\n        console.assert(this.children.length === oldChildCount - 1, `${oldChildCount - 1} ≠ ${this.children.length} after removing all nodes equal to ${child}. Nodes should only be removed once.`);\n        this.children.forEach((child) => {\n            child.rebalance();\n        });\n        this.recomputeBBox(true);\n        this.rebalance();\n        this.checkRep();\n    }\n    // Remove this node and all of its children\n    remove() {\n        this.content?.onRemoveFromImage();\n        if (!this.parent) {\n            this.content = null;\n            this.children = [];\n            return;\n        }\n        this.parent.removeChild(this);\n        // Remove the child-to-parent link and invalid this\n        this.parent = null;\n        this.content = null;\n        this.children = [];\n        this.checkRep();\n    }\n    // Creates a (potentially incomplete) async rendering of this image.\n    // Returns false if stopped early\n    async renderAllAsync(renderer, \n    // Used to pause/stop the renderer process\n    preRenderComponent) {\n        const leaves = this.getLeaves();\n        sortLeavesByZIndex(leaves);\n        const totalLeaves = leaves.length;\n        for (let leafIndex = 0; leafIndex < totalLeaves; leafIndex++) {\n            const leaf = leaves[leafIndex];\n            const component = leaf.getContent();\n            // Even though leaf was originally a leaf, it might not be any longer --\n            // rendering is async and the tree can change during that time.\n            if (!component) {\n                continue;\n            }\n            const shouldContinue = await preRenderComponent(component, leafIndex, totalLeaves);\n            if (!shouldContinue) {\n                return false;\n            }\n            component.render(renderer, undefined);\n        }\n        return true;\n    }\n    render(renderer, visibleRect) {\n        let leaves;\n        if (visibleRect) {\n            leaves = this.getLeavesIntersectingRegion(visibleRect, (rect) => renderer.isTooSmallToRender(rect));\n        }\n        else {\n            leaves = this.getLeaves();\n        }\n        sortLeavesByZIndex(leaves);\n        // If some components hide others (and we're permitted to simplify,\n        // which is true in the case of visibleRect being defined), then only\n        // draw the non-hidden components:\n        const startIndex = computeFirstIndexToRender(leaves);\n        for (let i = startIndex; i < leaves.length; i++) {\n            const leaf = leaves[i];\n            // Leaves by definition have content\n            leaf.getContent().render(renderer, visibleRect);\n        }\n        // Show debug information\n        if (debugMode && visibleRect) {\n            if (startIndex !== 0) {\n                console.log('EditorImage: skipped ', startIndex, 'nodes due to occlusion');\n            }\n            this.renderDebugBoundingBoxes(renderer, visibleRect);\n        }\n    }\n    // Debug only: Shows bounding boxes of this and all children.\n    renderDebugBoundingBoxes(renderer, visibleRect, depth = 0) {\n        const bbox = this.getBBox();\n        const pixelSize = 1 / (renderer.getSizeOfCanvasPixelOnScreen() || 1);\n        if (bbox.maxDimension < 3 * pixelSize || !bbox.intersects(visibleRect)) {\n            return;\n        }\n        // Render debug information for this\n        renderer.startObject(bbox);\n        // Different styling for leaf nodes\n        const isLeaf = !!this.content;\n        const fill = isLeaf ? Color4.ofRGBA(1, 0, 1, 0.4) : Color4.ofRGBA(0, 1, Math.sin(depth), 0.6);\n        const lineWidth = isLeaf ? 1 * pixelSize : 2 * pixelSize;\n        renderer.drawRect(bbox.intersection(visibleRect), lineWidth, { fill });\n        renderer.endObject();\n        if (bbox.maxDimension > visibleRect.maxDimension / 3) {\n            const textStyle = {\n                fontFamily: 'monospace',\n                size: bbox.minDimension / 20,\n                renderingStyle: { fill: Color4.red },\n            };\n            renderer.drawText(`Depth: ${depth}`, Mat33.translation(bbox.bottomLeft), textStyle);\n        }\n        // Render debug information for children\n        for (const child of this.children) {\n            child.renderDebugBoundingBoxes(renderer, visibleRect, depth + 1);\n        }\n    }\n    checkRep(depth = 0) {\n        // Slow -- disabld by default\n        if (debugMode) {\n            if (this.parent && !this.parent.children.includes(this)) {\n                throw new Error(`Parent does not have this node as a child. (depth: ${depth})`);\n            }\n            let expectedBBox = null;\n            const seenChildren = new Set();\n            for (const child of this.children) {\n                expectedBBox ??= child.getBBox();\n                expectedBBox = expectedBBox.union(child.getBBox());\n                if (child.parent !== this) {\n                    throw new Error(`Child with bbox ${child.getBBox()} and ${child.children.length} has wrong parent (was ${child.parent}).`);\n                }\n                // Children should only be present once\n                if (seenChildren.has(child)) {\n                    throw new Error(`Child ${child} is present twice or more in its parent's child list`);\n                }\n                seenChildren.add(child);\n            }\n            const tolerance = this.bbox.minDimension / 100;\n            if (expectedBBox && !this.bbox.eq(expectedBBox, tolerance)) {\n                throw new Error(`Wrong bounding box ${expectedBBox} \\\\neq ${this.bbox} (depth: ${depth})`);\n            }\n        }\n    }\n}\nImageNode.idCounter = 0;\n/** An `ImageNode` that can properly handle fullscreen/data components. @internal */\nexport class RootImageNode extends ImageNode {\n    constructor() {\n        super(...arguments);\n        // Nodes that will always take up the entire screen\n        this.fullscreenChildren = [];\n        // Nodes that will never be visible unless a full render is done.\n        this.dataComponents = [];\n    }\n    getChildrenIntersectingRegion(region, _isTooSmall) {\n        const result = super.getChildrenIntersectingRegion(region);\n        for (const node of this.fullscreenChildren) {\n            result.push(node);\n        }\n        return result;\n    }\n    getChildrenOrSelfIntersectingRegion(region, _isTooSmall) {\n        const content = this.getContent();\n        // Fullscreen components always intersect/contain\n        if (content && content.getSizingMode() === ComponentSizingMode.FillScreen) {\n            return [this];\n        }\n        return super.getChildrenOrSelfIntersectingRegion(region, _isTooSmall);\n    }\n    getLeaves() {\n        const leaves = super.getLeaves();\n        // Add fullscreen/data components — this method should\n        // return *all* leaves.\n        return this.dataComponents.concat(this.fullscreenChildren, leaves);\n    }\n    removeChild(child) {\n        let removed = false;\n        const checkTargetChild = (component) => {\n            const isTarget = component === child;\n            removed ||= isTarget;\n            return !isTarget;\n        };\n        // Check whether the child is stored in the data/fullscreen\n        // component arrays first.\n        this.dataComponents = this.dataComponents.filter(checkTargetChild);\n        this.fullscreenChildren = this.fullscreenChildren.filter(checkTargetChild);\n        if (!removed) {\n            super.removeChild(child);\n        }\n    }\n    getChildWithContent(target) {\n        const searchExtendedChildren = () => {\n            // Search through all extended children\n            const candidates = this.fullscreenChildren.concat(this.dataComponents);\n            for (const candidate of candidates) {\n                if (candidate.getContent() === target) {\n                    return candidate;\n                }\n            }\n            return null;\n        };\n        // If positioned as if a standard child, search using the superclass first.\n        // Because it could be mislabeled, also search the extended children if the superclass\n        // search fails.\n        if (target.getSizingMode() === ComponentSizingMode.BoundingBox) {\n            return super.getChildWithContent(target) ?? searchExtendedChildren();\n        }\n        // Fall back to the superclass -- it's possible that the component has\n        // changed labels.\n        return super.getChildWithContent(target) ?? searchExtendedChildren();\n    }\n    addLeaf(leafContent) {\n        const sizingMode = leafContent.getSizingMode();\n        if (sizingMode === ComponentSizingMode.BoundingBox) {\n            return super.addLeaf(leafContent);\n        }\n        else if (sizingMode === ComponentSizingMode.FillScreen) {\n            this.onContentChange();\n            const newNode = ImageNode.createLeafNode(this, leafContent);\n            this.fullscreenChildren.push(newNode);\n            return newNode;\n        }\n        else if (sizingMode === ComponentSizingMode.Anywhere) {\n            this.onContentChange();\n            const newNode = ImageNode.createLeafNode(this, leafContent);\n            this.dataComponents.push(newNode);\n            return newNode;\n        }\n        else {\n            const exhaustivenessCheck = sizingMode;\n            throw new Error(`Invalid sizing mode, ${sizingMode}`);\n            return exhaustivenessCheck;\n        }\n    }\n}\n","import { toRoundedString } from '@js-draw/math';\n// @internal\nconst adjustExportedSVGSize = (svg, exportRect, options) => {\n    // Adjust the width/height as necessary\n    let width = exportRect.w;\n    let height = exportRect.h;\n    if (options?.minDimension && width < options.minDimension) {\n        const newWidth = options.minDimension;\n        height *= newWidth / (width || 1);\n        width = newWidth;\n    }\n    if (options?.minDimension && height < options.minDimension) {\n        const newHeight = options.minDimension;\n        width *= newHeight / (height || 1);\n        height = newHeight;\n    }\n    svg.setAttribute('width', toRoundedString(width));\n    svg.setAttribute('height', toRoundedString(height));\n};\nexport default adjustExportedSVGSize;\n","import { Rect2 } from '@js-draw/math';\nimport  SVGRenderer  from '../../rendering/renderers/SVGRenderer.mjs';\nimport  { svgLoaderAutoresizeClassName }  from '../../SVGLoader/SVGLoader.mjs';\nimport  adjustExportedSVGSize  from './adjustExportedSVGSize.mjs';\nconst toSVGInternal = (image, renderFunction, options) => {\n    const importExportViewport = image.getImportExportViewport().getTemporaryClone();\n    // If the rectangle has zero width or height, its size can't be increased\n    // -- set its size to the minimum.\n    if (options?.minDimension) {\n        const originalRect = importExportViewport.visibleRect;\n        let rect = originalRect;\n        if (rect.w <= 0) {\n            rect = new Rect2(rect.x, rect.y, options.minDimension, rect.h);\n        }\n        if (rect.h <= 0) {\n            rect = new Rect2(rect.x, rect.y, rect.w, options.minDimension);\n        }\n        if (!rect.eq(originalRect)) {\n            importExportViewport.updateScreenSize(rect.size);\n        }\n    }\n    const { element: result, renderer } = SVGRenderer.fromViewport(importExportViewport, {\n        sanitize: options.sanitize ?? false,\n        useViewBoxForPositioning: true,\n    });\n    // Use a callback rather than async/await to allow this function to create\n    // both sync and async render functions\n    renderFunction(renderer, () => {\n        if (image.getAutoresizeEnabled()) {\n            result.classList.add(svgLoaderAutoresizeClassName);\n        }\n        else {\n            result.classList.remove(svgLoaderAutoresizeClassName);\n        }\n        const exportRect = importExportViewport.visibleRect;\n        adjustExportedSVGSize(result, exportRect, options);\n        return result;\n    });\n    return result;\n};\nexport const editorImageToSVGSync = (image, options) => {\n    return toSVGInternal(image, (renderer, onComplete) => {\n        image.renderAll(renderer);\n        onComplete();\n    }, options);\n};\nexport const editorImageToSVGAsync = (image, preRenderComponent, options) => {\n    return new Promise((resolve) => {\n        toSVGInternal(image, async (renderer, onComplete) => {\n            await image.renderAllAsync(renderer, preRenderComponent);\n            const result = onComplete();\n            resolve(result);\n        }, options);\n    });\n};\n","export  { default as EditorImage }  from './EditorImage.mjs';\n","export var InputEvtType;\n(function (InputEvtType) {\n    InputEvtType[InputEvtType[\"PointerDownEvt\"] = 0] = \"PointerDownEvt\";\n    InputEvtType[InputEvtType[\"PointerMoveEvt\"] = 1] = \"PointerMoveEvt\";\n    InputEvtType[InputEvtType[\"PointerUpEvt\"] = 2] = \"PointerUpEvt\";\n    InputEvtType[InputEvtType[\"GestureCancelEvt\"] = 3] = \"GestureCancelEvt\";\n    InputEvtType[InputEvtType[\"WheelEvt\"] = 4] = \"WheelEvt\";\n    InputEvtType[InputEvtType[\"KeyPressEvent\"] = 5] = \"KeyPressEvent\";\n    InputEvtType[InputEvtType[\"KeyUpEvent\"] = 6] = \"KeyUpEvent\";\n    InputEvtType[InputEvtType[\"CopyEvent\"] = 7] = \"CopyEvent\";\n    InputEvtType[InputEvtType[\"PasteEvent\"] = 8] = \"PasteEvent\";\n    InputEvtType[InputEvtType[\"ContextMenu\"] = 9] = \"ContextMenu\";\n})(InputEvtType || (InputEvtType = {}));\n// Constructor\nconst keyEventFromHTMLEvent = (kind, event) => {\n    return {\n        kind,\n        key: event.key,\n        code: event.code,\n        ctrlKey: event.ctrlKey || event.metaKey,\n        altKey: event.altKey,\n        shiftKey: event.shiftKey,\n    };\n};\nexport const keyUpEventFromHTMLEvent = (event) => {\n    return keyEventFromHTMLEvent(InputEvtType.KeyUpEvent, event);\n};\nexport const keyPressEventFromHTMLEvent = (event) => {\n    return keyEventFromHTMLEvent(InputEvtType.KeyPressEvent, event);\n};\nexport const isPointerEvt = (event) => {\n    return (event.kind === InputEvtType.PointerDownEvt ||\n        event.kind === InputEvtType.PointerMoveEvt ||\n        event.kind === InputEvtType.PointerUpEvt);\n};\n","/**\n * The main entrypoint for the NPM package. Everything exported by this file\n * is available through the [`js-draw` package](https://www.npmjs.com/package/js-draw).\n *\n * ## Example\n *\n * [[include:doc-pages/inline-examples/main-js-draw-example.md]]\n *\n * @see\n * - {@link Editor}\n * - {@link Editor.loadFromSVG}\n * - {@link AbstractToolbar.addActionButton }\n * - {@link EditorSettings}\n *\n * @packageDocumentation\n */\nimport  Editor  from './Editor.mjs';\nexport  *  from './image/lib.mjs';\nexport  *  from './types.mjs';\nexport  *  from './inputEvents.mjs';\nexport  { default as getLocalizationTable, matchingLocalizationTable, }  from './localizations/getLocalizationTable.mjs';\nexport  *  from './localization.mjs';\nexport  { default as SVGLoader }  from './SVGLoader/SVGLoader.mjs';\nexport  { default as Viewport }  from './Viewport.mjs';\nexport * from '@js-draw/math';\nexport  *  from './components/lib.mjs';\nexport  *  from './commands/lib.mjs';\nexport  *  from './tools/lib.mjs';\nexport  *  from './toolbar/lib.mjs';\nexport  *  from './rendering/lib.mjs';\nexport  *  from './testing/lib.mjs';\nexport  *  from './shortcuts/lib.mjs';\nexport  { default as EventDispatcher }  from './EventDispatcher.mjs';\nexport  { default as Pointer, PointerDevice }  from './Pointer.mjs';\nexport  { default as UndoRedoHistory }  from './UndoRedoHistory.mjs';\nexport  *  from './util/lib.mjs';\n// @internal\nexport  { default as __js_draw__version }  from './version.mjs';\nimport  AbstractToolbar  from './toolbar/AbstractToolbar.mjs';\nexport { Editor, AbstractToolbar };\n/**\n * Using the HTMLToolbar alias is deprecated. Use\n * `AbstractToolbar` instead.\n * @deprecated\n */\nexport { AbstractToolbar as HTMLToolbar };\nexport default Editor;\n","import  { defaultCommandLocalization }  from './commands/localization.mjs';\nimport  { defaultComponentLocalization, }  from './components/localization.mjs';\nimport  { defaultTextRendererLocalization, }  from './rendering/localization.mjs';\nimport  { defaultToolbarLocalization }  from './toolbar/localization.mjs';\nimport  { defaultToolLocalization }  from './tools/localization.mjs';\nexport const defaultEditorLocalization = {\n    ...defaultToolbarLocalization,\n    ...defaultToolLocalization,\n    ...defaultCommandLocalization,\n    ...defaultComponentLocalization,\n    ...defaultTextRendererLocalization,\n    accessibilityInputInstructions: [\n        'Press \"t\" to read the contents of the viewport as text.',\n        'Use the arrow keys to move the viewport, click and drag to draw strokes.',\n        'Press \"w\" to zoom in and \"s\" to zoom out.',\n    ].join(' '),\n    loading: (percentage) => `Loading ${percentage}%...`,\n    imageEditor: 'Image Editor',\n    doneLoading: 'Done loading',\n    undoAnnouncement: (commandDescription) => `Undid ${commandDescription}`,\n    redoAnnouncement: (commandDescription) => `Redid ${commandDescription}`,\n    softwareLibraries: 'Libraries',\n    developerInformation: 'Developer information',\n};\n","import  { defaultEditorLocalization }  from '../localization.mjs';\n// German localization\nconst localization = {\n    ...defaultEditorLocalization,\n    pen: 'Stift',\n    eraser: 'Radierer',\n    select: 'Auswahl',\n    handTool: 'Verschieben',\n    zoom: 'Vergrößerung',\n    image: 'Bild',\n    inputAltText: 'Alt-Text: ',\n    chooseFile: 'Wähle Datei: ',\n    submit: 'Absenden',\n    cancel: 'Abbrechen',\n    resetView: 'Ansicht zurücksetzen',\n    thicknessLabel: 'Dicke: ',\n    colorLabel: 'Farbe: ',\n    fontLabel: 'Schriftart: ',\n    textSize: 'Größe: ',\n    resizeImageToSelection: 'Bildgröße an Auswahl anpassen',\n    deleteSelection: 'Auswahl löschen',\n    duplicateSelection: 'Auswahl duplizieren',\n    undo: 'Rückgängig',\n    redo: 'Wiederholen',\n    pickColorFromScreen: 'Farbe von Bildschirm auswählen',\n    clickToPickColorAnnouncement: 'Klicke auf den Bildschirm, um eine Farbe auszuwählen',\n    selectionToolKeyboardShortcuts: 'Auswahl-Werkzeug: Verwende die Pfeiltasten, um ausgewählte Elemente zu verschieben und ‚i‘ und ‚o‘, um ihre Größe zu ändern.',\n    touchPanning: 'Ansicht mit Touchscreen verschieben',\n    anyDevicePanning: 'Ansicht mit jedem Eingabegerät verschieben',\n    selectPenType: 'Objekt-Typ: ',\n    roundedTipPen: 'Freihand',\n    flatTipPen: 'Stift (druckempfindlich)',\n    arrowPen: 'Pfeil',\n    linePen: 'Linie',\n    outlinedRectanglePen: 'Umrissenes Rechteck',\n    filledRectanglePen: 'Ausgefülltes Rechteck',\n    lockRotation: 'Sperre Rotation',\n    paste: 'Einfügen',\n    dropdownShown: (toolName) => `Dropdown-Menü für ${toolName} angezeigt`,\n    dropdownHidden: (toolName) => `Dropdown-Menü für ${toolName} versteckt`,\n    zoomLevel: (zoomPercent) => `Vergößerung: ${zoomPercent}%`,\n    colorChangedAnnouncement: (color) => `Farbe zu ${color} geändert`,\n    imageSize: (size, units) => `Bild-Größe: ${size} ${units}`,\n    imageLoadError: (message) => `Fehler beim Laden des Bildes: ${message}`,\n    errorImageHasZeroSize: 'Fehler: Bild hat Größe Null',\n    penTool: (penNumber) => `Stift ${penNumber}`,\n    selectionTool: 'Auswahl',\n    eraserTool: 'Radiergummi',\n    touchPanTool: 'Ansicht mit Touchscreen verschieben',\n    twoFingerPanZoomTool: 'Ansicht verschieben und vergrößern',\n    undoRedoTool: 'Rückgängig/Wiederholen',\n    rightClickDragPanTool: 'Rechtsklick-Ziehen',\n    pipetteTool: 'Farbe von Bildschirm auswählen',\n    keyboardPanZoom: 'Tastaturkürzel zum Verschieben/Vergrößern der Ansicht',\n    textTool: 'Text',\n    enterTextToInsert: 'Einzufügender Text',\n    changeTool: 'Wechsle Werkzeug',\n    pasteHandler: 'Copy-Paste-Handler',\n    findLabel: 'Finde',\n    toNextMatch: 'Nächstes',\n    closeDialog: 'Schließen',\n    findDialogShown: 'Finde-Dialog angezeigt',\n    findDialogHidden: 'Finde-Dialog versteckt',\n    focusedFoundText: (matchIdx, totalMatches) => `Sieh Treffer ${matchIdx} von ${totalMatches} an`,\n    toolEnabledAnnouncement: (toolName) => `${toolName} aktiviert`,\n    toolDisabledAnnouncement: (toolName) => `${toolName} deaktiviert`,\n    updatedViewport: 'Transformierte Ansicht',\n    transformedElements: (elemCount) => `${elemCount} Element${1 === elemCount ? '' : 'e'} transformiert`,\n    resizeOutputCommand: (newSize) => `Bildgröße auf ${newSize.w}x${newSize.h} geändert`,\n    addElementAction: (componentDescription) => `${componentDescription} hinzugefügt`,\n    eraseAction: (elemDescription, countErased) => `${countErased} ${elemDescription} gelöscht`,\n    duplicateAction: (elemDescription, countErased) => `${countErased} ${elemDescription} dupliziert`,\n    inverseOf: (actionDescription) => `${actionDescription} umgekehrt`,\n    elements: 'Elemente',\n    erasedNoElements: 'Nichts entfernt',\n    duplicatedNoElements: 'Nichts dupliziert',\n    rotatedBy: (degrees) => `${Math.abs(degrees)} Grad ${degrees < 0 ? 'im Uhrzeigersinn' : 'gegen den Uhrzeigersinn'} gedreht`,\n    movedLeft: 'Nacht links bewegt',\n    movedUp: 'Nacht oben bewegt',\n    movedDown: 'Nacht unten bewegt',\n    movedRight: 'Nacht rechts bewegt',\n    zoomedOut: 'Ansicht verkleinert',\n    zoomedIn: 'Ansicht vergrößert',\n    selectedElements: (count) => `${count} Element${1 === count ? '' : 'e'} ausgewählt`,\n    stroke: 'Strich',\n    svgObject: 'SVG-Objekt',\n    text: (text) => `Text-Objekt: ${text}`,\n    pathNodeCount: (count) => `Es gibt ${count} sichtbare Pfad-Objekte.`,\n    textNodeCount: (count) => `Es gibt ${count} sichtbare Text-Knotenpunkte.`,\n    textNode: (content) => `Text: ${content}`,\n    imageNodeCount: (nodeCount) => `Es gibt ${nodeCount} sichtbare Bild-Knoten.`,\n    imageNode: (label) => `Bild: ${label}`,\n    unlabeledImageNode: 'Bild ohne Label',\n    rerenderAsText: 'Als Text darstellen',\n    accessibilityInputInstructions: 'Drücke ‚t‘, um den Inhalt des Ansichtsfensters als Text zu lesen. Verwende die Pfeiltasten, um die Ansicht zu verschieben, und klicke und ziehe, um Striche zu zeichnen. Drücke ‚w‘ zum Vergrößern und ‚s‘ zum Verkleinern der Ansicht.',\n    loading: (percentage) => `Laden ${percentage}%...`,\n    doneLoading: 'Laden fertig',\n    imageEditor: 'Bild-Editor',\n    undoAnnouncement: (commandDescription) => `${commandDescription} rückgängig gemacht`,\n    redoAnnouncement: (commandDescription) => `${commandDescription} wiederholt`,\n    reformatSelection: 'Formatiere Auswahl',\n    documentProperties: 'Seite',\n    backgroundColor: 'Hintergrundfarbe: ',\n    imageWidthOption: 'Breite: ',\n    imageHeightOption: 'Höhe: ',\n    useGridOption: 'Gitter: ',\n    toggleOverflow: 'Mehr',\n    selectAllTool: 'Alle auswählen',\n    soundExplorer: 'Klangbasierte Bilderkundung',\n    disableAccessibilityExploreTool: 'Deaktiviere klangbasierte Erkundung',\n    enableAccessibilityExploreTool: 'Aktiviere klangbasierte Erkundung',\n    unionOf: (actionDescription, actionCount) => `Vereinigung: ${actionCount} ${actionDescription}`,\n    emptyBackground: 'Leerer Hintergrund',\n    filledBackgroundWithColor: (color) => `Gefüllter Hintergrund (${color})`,\n    restyledElement: (elementDescription) => `${elementDescription} umgestaltet`,\n};\nexport default localization;\n","import  { defaultEditorLocalization }  from '../localization.mjs';\n// Default localizations are already in English.\nconst localization = {\n    ...defaultEditorLocalization,\n};\nexport default localization;\n","import  { defaultEditorLocalization }  from '../localization.mjs';\n// A partial Spanish localization\nconst localization = {\n    ...defaultEditorLocalization,\n    pen: 'Lapiz',\n    eraser: 'Borrador',\n    select: 'Selecciona',\n    handTool: 'Mover',\n    image: 'Imagen',\n    inputAltText: 'Texto alternativo',\n    resetImage: 'Reiniciar',\n    chooseFile: 'Seleccionar archivo',\n    cancel: 'Cancelar',\n    resetView: 'Reiniciar vista',\n    thicknessLabel: 'Tamaño',\n    fontLabel: 'Fuente:',\n    textSize: 'Tamaño',\n    resizeImageToSelection: 'Redimensionar la imagen a lo que está seleccionado',\n    deleteSelection: 'Borra la selección',\n    duplicateSelection: 'Duplica la selección',\n    exit: 'Salir',\n    save: 'Guardar',\n    undo: 'Deshace',\n    redo: 'Rehace',\n    selectPenType: 'Punta',\n    selectShape: 'Forma',\n    pickColorFromScreen: 'Selecciona un color de la pantalla',\n    clickToPickColorAnnouncement: 'Haga un clic en la pantalla para seleccionar un color',\n    documentProperties: 'Fondo',\n    backgroundColor: 'Color de fondo',\n    imageWidthOption: 'Ancho',\n    imageHeightOption: 'Alto',\n    enableAutoresizeOption: 'Redimensionar automático',\n    toggleOverflow: 'Más',\n    about: 'Acerca de',\n    touchPanning: 'Mover la pantalla con un dedo',\n    roundedTipPen: 'Lapiz Redondeado',\n    arrowPen: 'Flecha',\n    linePen: 'Línea',\n    outlinedRectanglePen: 'Rectángulo delineado',\n    filledRectanglePen: 'Rectángulo sin borde',\n    lockRotation: 'Bloquea rotación',\n    paste: 'Pegar',\n    selectionMenu__paste: 'Pegar',\n    selectionMenu__delete: 'Eliminar',\n    selectionMenu__duplicate: 'Duplicar',\n    closeSidebar: (toolName) => `Close sidebar for ${toolName}`,\n    dropdownShown: (toolName) => `Menú por ${toolName} es visible`,\n    dropdownHidden: (toolName) => {\n        return `Menú por ${toolName} fue ocultado`;\n    },\n    zoomLevel: (zoomPercent) => `Zoom: ${zoomPercent}%`,\n    colorChangedAnnouncement: (color) => {\n        return `Color fue cambiado a ${color}`;\n    },\n    imageSize: (size, units) => `Tamaño del imagen: ${size} ${units}`,\n    imageLoadError: (message) => `Error cargando imagen: ${message}`,\n    penTool: (penId) => `Lapiz ${penId}`,\n    selectionTool: 'Selecciona',\n    eraserTool: 'Borrador',\n    touchPanTool: 'Instrumento de mover la pantalla con un dedo',\n    undoRedoTool: 'Deshace/rehace',\n    pipetteTool: 'Seleccione un color de la pantalla',\n    keyboardPanZoom: 'Mover la pantalla con el teclado',\n    textTool: 'Texto',\n    enterTextToInsert: 'Entra texto',\n    findLabel: 'Buscar',\n    toNextMatch: 'Próxima',\n    closeDialog: 'Cerrar',\n    anyDevicePanning: 'Mover la pantalla con todo dispotivo',\n    copied: (count) => `${count} cosas fueron copiados`,\n    pasted: (count) => (count === 1 ? 'Pegado' : `${count} cosas fueron pegados`),\n    toolEnabledAnnouncement: (toolName) => `${toolName} fue activado`,\n    toolDisabledAnnouncement: (toolName) => `${toolName} fue desactivado`,\n    resizeOutputCommand: (newSize) => `Tamaño de imagen fue cambiado a ${newSize.w}x${newSize.h}`,\n    eraseAction: (componentDescription, numElems) => `Borrado: ${numElems} ${componentDescription}`,\n    rerenderAsText: 'Redibuja la pantalla al texto',\n    loading: (percentage) => `Cargando: ${percentage}%...`,\n    imageEditor: 'Editor de dibujos',\n    doneLoading: 'El cargado terminó',\n    undoAnnouncement: (commandDescription) => `${commandDescription} fue deshecho`,\n    redoAnnouncement: (commandDescription) => `${commandDescription} fue rehecho`,\n};\nexport default localization;\n","import  { defaultEditorLocalization }  from '../localization.mjs';\nimport  de  from './de.mjs';\nimport  en  from './en.mjs';\nimport  es  from './es.mjs';\nexport const allLocales = {\n    de,\n    en,\n    es,\n};\n// [locale]: A string in the format languageCode_Region or just languageCode. For example, en_US.\nconst languageFromLocale = (locale) => {\n    const matches = /^(\\w+)[_-](\\w+)$/.exec(locale);\n    if (!matches) {\n        // If not in languageCode_region format, the locale should be the\n        // languageCode. Return that.\n        return locale;\n    }\n    return matches[1];\n};\n/**\n * Return the localization table in `localizationTables` that best matches\n * the list of `userLocales`. If there is no matching language, returns\n * `defaultLocalizationTable`.\n */\nexport const matchingLocalizationTable = (userLocales, localizationTables, defaultLocalizationTable) => {\n    let prevLanguage;\n    for (const locale of userLocales) {\n        const language = languageFromLocale(locale);\n        // If the specific localization of the language is not available, but\n        // a localization for the language is,\n        if (prevLanguage && language !== prevLanguage) {\n            if (prevLanguage in localizationTables) {\n                return localizationTables[prevLanguage];\n            }\n        }\n        // If the full locale (e.g. en_US) is available,\n        if (locale in localizationTables) {\n            return localizationTables[locale];\n        }\n        prevLanguage = language;\n    }\n    if (prevLanguage && prevLanguage in localizationTables) {\n        return localizationTables[prevLanguage];\n    }\n    else {\n        return defaultLocalizationTable;\n    }\n};\n/**\n * Returns a localization table for the `Editor` that matches\n * the user's current locale.\n *\n * Returns the default localization table if no appropriate localization\n * exists.\n */\nconst getLocalizationTable = (userLocales) => {\n    userLocales ??= navigator.languages;\n    return matchingLocalizationTable(userLocales, allLocales, defaultEditorLocalization);\n};\nexport default getLocalizationTable;\n","import  CanvasRenderer  from './renderers/CanvasRenderer.mjs';\nimport  { EditorEventType }  from '../types.mjs';\nimport  DummyRenderer  from './renderers/DummyRenderer.mjs';\nimport { Vec2, Color4 } from '@js-draw/math';\nimport  RenderingCache  from './caching/RenderingCache.mjs';\nimport  TextOnlyRenderer  from './renderers/TextOnlyRenderer.mjs';\nexport var RenderingMode;\n(function (RenderingMode) {\n    RenderingMode[RenderingMode[\"DummyRenderer\"] = 0] = \"DummyRenderer\";\n    RenderingMode[RenderingMode[\"CanvasRenderer\"] = 1] = \"CanvasRenderer\";\n    // SVGRenderer is not supported by the main display\n})(RenderingMode || (RenderingMode = {}));\n/**\n * Handles `HTMLCanvasElement`s (or other drawing surfaces if being used) used to display the editor's contents.\n *\n * @example\n * ```\n * const editor = new Editor(document.body);\n * const w = editor.display.width;\n * const h = editor.display.height;\n * const center = Vec2.of(w / 2, h / 2);\n * const colorAtCenter = editor.display.getColorAt(center);\n * ```\n */\nexport default class Display {\n    /** @internal */\n    constructor(editor, mode, parent) {\n        this.editor = editor;\n        this.parent = parent;\n        this.textRerenderOutput = null;\n        this.devicePixelRatio = window.devicePixelRatio ?? 1;\n        /**\n         * @returns the color at the given point on the dry ink renderer, or `null` if `screenPos`\n         * \tis not on the display.\n         */\n        this.getColorAt = (_screenPos) => {\n            return null;\n        };\n        if (mode === RenderingMode.CanvasRenderer) {\n            this.initializeCanvasRendering();\n        }\n        else if (mode === RenderingMode.DummyRenderer) {\n            this.dryInkRenderer = new DummyRenderer(editor.viewport);\n            this.wetInkRenderer = new DummyRenderer(editor.viewport);\n        }\n        else {\n            throw new Error(`Unknown rendering mode, ${mode}!`);\n        }\n        this.textRenderer = new TextOnlyRenderer(editor.viewport, editor.localization);\n        this.initializeTextRendering();\n        const cacheBlockResolution = Vec2.of(600, 600);\n        this.cache = new RenderingCache({\n            createRenderer: () => {\n                if (mode === RenderingMode.DummyRenderer) {\n                    return new DummyRenderer(editor.viewport);\n                }\n                else if (mode !== RenderingMode.CanvasRenderer) {\n                    throw new Error('Unspported rendering mode');\n                }\n                // Make the canvas slightly larger than each cache block to prevent\n                // seams.\n                const canvas = document.createElement('canvas');\n                canvas.width = cacheBlockResolution.x + 1;\n                canvas.height = cacheBlockResolution.y + 1;\n                const ctx = canvas.getContext('2d');\n                return new CanvasRenderer(ctx, editor.viewport);\n            },\n            isOfCorrectType: (renderer) => {\n                return this.dryInkRenderer.canRenderFromWithoutDataLoss(renderer);\n            },\n            blockResolution: cacheBlockResolution,\n            cacheSize: 600 * 600 * 4 * 90,\n            // On higher resolution displays, don't scale cache blocks as much to decrease blurriness.\n            // TODO: Decrease the minimum cache scale as well.\n            maxScale: Math.max(1, 1.3 / window.devicePixelRatio),\n            // Require about 20 strokes with 4 parts each to cache an image in one of the\n            // parts of the cache grid.\n            minProportionalRenderTimePerCache: 20 * 4,\n            // Require about 105 strokes with 4 parts each to use the cache at all.\n            minProportionalRenderTimeToUseCache: 105 * 4,\n        });\n        this.editor.notifier.on(EditorEventType.DisplayResized, (event) => {\n            if (event.kind !== EditorEventType.DisplayResized) {\n                throw new Error('Mismatched event.kinds!');\n            }\n            this.resizeSurfacesCallback?.();\n        });\n    }\n    /**\n     * @returns the visible width of the display (e.g. how much\n     * space the display's element takes up in the x direction\n     * in the DOM).\n     */\n    get width() {\n        return this.dryInkRenderer.displaySize().x;\n    }\n    /** @returns the visible height of the display. See {@link width}. */\n    get height() {\n        return this.dryInkRenderer.displaySize().y;\n    }\n    /** @internal */\n    getCache() {\n        return this.cache;\n    }\n    initializeCanvasRendering() {\n        const dryInkCanvas = document.createElement('canvas');\n        const wetInkCanvas = document.createElement('canvas');\n        const dryInkCtx = dryInkCanvas.getContext('2d');\n        const wetInkCtx = wetInkCanvas.getContext('2d');\n        this.dryInkRenderer = new CanvasRenderer(dryInkCtx, this.editor.viewport);\n        this.wetInkRenderer = new CanvasRenderer(wetInkCtx, this.editor.viewport);\n        dryInkCanvas.className = 'dryInkCanvas';\n        wetInkCanvas.className = 'wetInkCanvas';\n        if (this.parent) {\n            this.parent.appendChild(dryInkCanvas);\n            this.parent.appendChild(wetInkCanvas);\n        }\n        this.resizeSurfacesCallback = () => {\n            const expectedWidth = (canvas) => {\n                const widthInPixels = Math.ceil(canvas.clientWidth * this.devicePixelRatio);\n                // Avoid setting the canvas width to zero -- doing so can cause errors when attempting\n                // to use the canvas:\n                return widthInPixels || canvas.width;\n            };\n            const expectedHeight = (canvas) => {\n                const heightInPixels = Math.ceil(canvas.clientHeight * this.devicePixelRatio);\n                return heightInPixels || canvas.height; // Zero-size canvases can cause errors.\n            };\n            const hasSizeMismatch = (canvas) => {\n                return expectedHeight(canvas) !== canvas.height || expectedWidth(canvas) !== canvas.width;\n            };\n            // Ensure that the drawing surfaces sizes match the\n            // canvas' sizes to prevent stretching.\n            if (hasSizeMismatch(dryInkCanvas) || hasSizeMismatch(wetInkCanvas)) {\n                dryInkCanvas.width = expectedWidth(dryInkCanvas);\n                dryInkCanvas.height = expectedHeight(dryInkCanvas);\n                wetInkCanvas.width = expectedWidth(wetInkCanvas);\n                wetInkCanvas.height = expectedHeight(wetInkCanvas);\n                // Ensure correct drawing operations on high-resolution screens.\n                // See\n                // https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas#scaling_for_high_resolution_displays\n                //\n                // This scaling causes the rendering contexts to automatically convert\n                // between screen coordinates and pixel coordinates.\n                wetInkCtx.resetTransform();\n                dryInkCtx.resetTransform();\n                dryInkCtx.scale(this.devicePixelRatio, this.devicePixelRatio);\n                wetInkCtx.scale(this.devicePixelRatio, this.devicePixelRatio);\n                this.editor.notifier.dispatch(EditorEventType.DisplayResized, {\n                    kind: EditorEventType.DisplayResized,\n                    newSize: Vec2.of(this.width, this.height),\n                });\n            }\n        };\n        this.resizeSurfacesCallback();\n        this.flattenCallback = () => {\n            dryInkCtx.save();\n            dryInkCtx.resetTransform();\n            dryInkCtx.drawImage(wetInkCanvas, 0, 0);\n            dryInkCtx.restore();\n        };\n        this.getColorAt = (screenPos) => {\n            // getImageData isn't affected by a transformation matrix -- we need to\n            // pre-transform screenPos to convert it from screen coordinates into pixel\n            // coordinates.\n            const adjustedScreenPos = screenPos.times(this.devicePixelRatio);\n            const pixel = dryInkCtx.getImageData(adjustedScreenPos.x, adjustedScreenPos.y, 1, 1);\n            const data = pixel?.data;\n            if (data) {\n                const color = Color4.ofRGBA(data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255);\n                return color;\n            }\n            return null;\n        };\n    }\n    initializeTextRendering() {\n        const textRendererOutputContainer = document.createElement('div');\n        textRendererOutputContainer.classList.add('textRendererOutputContainer');\n        const rerenderButton = document.createElement('button');\n        rerenderButton.classList.add('rerenderButton');\n        rerenderButton.innerText = this.editor.localization.rerenderAsText;\n        this.textRerenderOutput = document.createElement('div');\n        this.textRerenderOutput.setAttribute('aria-live', 'polite');\n        rerenderButton.onclick = () => {\n            this.rerenderAsText();\n        };\n        textRendererOutputContainer.replaceChildren(rerenderButton, this.textRerenderOutput);\n        this.editor.createHTMLOverlay(textRendererOutputContainer);\n    }\n    /**\n     * Sets the device-pixel-ratio.\n     *\n     * Intended for debugging. Users do not need to call this manually.\n     *\n     * @internal\n     */\n    setDevicePixelRatio(dpr) {\n        const minDpr = 0.001;\n        const maxDpr = 10;\n        if (isFinite(dpr) && dpr >= minDpr && dpr <= maxDpr && dpr !== this.devicePixelRatio) {\n            this.devicePixelRatio = dpr;\n            this.resizeSurfacesCallback?.();\n            return this.editor.queueRerender();\n        }\n        return undefined;\n    }\n    /** @internal */\n    getDevicePixelRatio() {\n        return this.devicePixelRatio;\n    }\n    /**\n     * Rerenders the text-based display.\n     * The text-based display is intended for screen readers and can be navigated to by pressing `tab`.\n     */\n    rerenderAsText() {\n        this.textRenderer.clear();\n        this.editor.image.render(this.textRenderer, this.editor.viewport);\n        if (this.textRerenderOutput) {\n            this.textRerenderOutput.innerText = this.textRenderer.getDescription();\n        }\n    }\n    /**\n     * Clears the main drawing surface and otherwise prepares for a rerender.\n     *\n     * @returns the dry ink renderer.\n     */\n    startRerender() {\n        this.resizeSurfacesCallback?.();\n        this.dryInkRenderer.clear();\n        return this.dryInkRenderer;\n    }\n    /**\n     * If `draftMode`, the dry ink renderer is configured to render\n     * low-quality output.\n     */\n    setDraftMode(draftMode) {\n        this.dryInkRenderer.setDraftMode(draftMode);\n    }\n    /** @internal */\n    getDryInkRenderer() {\n        return this.dryInkRenderer;\n    }\n    /**\n     * @returns The renderer used for showing action previews (e.g. an unfinished stroke).\n     * The `wetInkRenderer`'s surface is stacked above the `dryInkRenderer`'s.\n     */\n    getWetInkRenderer() {\n        return this.wetInkRenderer;\n    }\n    /** Re-renders the contents of the wetInkRenderer onto the dryInkRenderer. */\n    flatten() {\n        this.flattenCallback?.();\n    }\n}\n","import { Color4, Mat33, Path, PathCommandType, Rect2 } from '@js-draw/math';\n/** Converts a renderable path (a path with a `startPoint`, `commands`, and `style`). */\nexport const pathFromRenderable = (renderable) => {\n    if (renderable.path) {\n        return renderable.path;\n    }\n    return new Path(renderable.startPoint, renderable.commands);\n};\n/**\n * Converts `path` into a format that can be rendered (by passing to a {@link Stroke} constructor\n * or directly to an {@link AbstractRenderer.drawPath}).\n */\nexport const pathToRenderable = (path, style) => {\n    return {\n        startPoint: path.startPoint,\n        style,\n        commands: path.parts,\n        path,\n    };\n};\n/**\n * Fills the optional `path` field in `RenderablePathSpec`\n * with `path` if not already filled\n */\nconst pathIncluded = (renderablePath, path) => {\n    if (renderablePath.path) {\n        return renderablePath;\n    }\n    return {\n        ...renderablePath,\n        path,\n    };\n};\n/**\n * Tries to simplify the given path to a fullscreen rectangle.\n * Returns `null` on failure.\n *\n * @internal\n */\nexport const simplifyPathToFullScreenOrEmpty = (renderablePath, visibleRect, options = {\n    fastCheck: true,\n    expensiveCheck: true,\n}) => {\n    const path = pathFromRenderable(renderablePath);\n    const strokeWidth = renderablePath.style.stroke?.width ?? 0;\n    const onlyStroked = strokeWidth > 0 && renderablePath.style.fill.a === 0;\n    const styledPathBBox = path.bbox.grownBy(strokeWidth);\n    // Are we close enough to the path that it fills the entire screen?\n    const isOnlyStrokedAndCouldFillScreen = onlyStroked &&\n        strokeWidth > visibleRect.maxDimension &&\n        styledPathBBox.containsRect(visibleRect);\n    if (options.fastCheck && isOnlyStrokedAndCouldFillScreen && renderablePath.style.stroke) {\n        const strokeRadius = strokeWidth / 2;\n        // Are we completely within the stroke?\n        // Do a fast, but with many false negatives, check.\n        for (const point of path.startEndPoints()) {\n            // If within the strokeRadius of any point\n            if (visibleRect.isWithinRadiusOf(strokeRadius, point)) {\n                return {\n                    rectangle: visibleRect,\n                    path: pathToRenderable(Path.fromRect(visibleRect), {\n                        fill: renderablePath.style.stroke.color,\n                    }),\n                    fullScreen: true,\n                };\n            }\n        }\n    }\n    // Try filtering again, but with slightly more expensive checks\n    if (options.expensiveCheck &&\n        isOnlyStrokedAndCouldFillScreen &&\n        renderablePath.style.stroke &&\n        strokeWidth > visibleRect.maxDimension * 3) {\n        const signedDist = path.signedDistance(visibleRect.center, strokeWidth / 2);\n        const margin = strokeWidth / 6;\n        if (signedDist < -visibleRect.maxDimension / 2 - margin) {\n            return {\n                path: pathToRenderable(Path.fromRect(visibleRect), {\n                    fill: renderablePath.style.stroke.color,\n                }),\n                rectangle: visibleRect,\n                fullScreen: true,\n            };\n        }\n        else if (signedDist > visibleRect.maxDimension / 2 + margin) {\n            return {\n                path: pathToRenderable(Path.empty, { fill: Color4.transparent }),\n                rectangle: Rect2.empty,\n                fullScreen: false,\n            };\n        }\n    }\n    return null;\n};\n/**\n * @returns a Path that, when rendered, looks roughly equivalent to the given path.\n */\nexport const visualEquivalent = (renderablePath, visibleRect) => {\n    const path = pathFromRenderable(renderablePath);\n    const strokeWidth = renderablePath.style.stroke?.width ?? 0;\n    const onlyStroked = strokeWidth > 0 && renderablePath.style.fill.a === 0;\n    const styledPathBBox = path.bbox.grownBy(strokeWidth);\n    let rectangleSimplification = simplifyPathToFullScreenOrEmpty(renderablePath, visibleRect, {\n        fastCheck: true,\n        expensiveCheck: false,\n    });\n    if (rectangleSimplification) {\n        return rectangleSimplification.path;\n    }\n    // Scale the expanded rect --- the visual equivalent is only close for huge strokes.\n    const expandedRect = visibleRect\n        .grownBy(strokeWidth)\n        .transformedBoundingBox(Mat33.scaling2D(4, visibleRect.center));\n    // TODO: Handle simplifying very small paths.\n    if (expandedRect.containsRect(styledPathBBox)) {\n        return pathIncluded(renderablePath, path);\n    }\n    const parts = [];\n    let startPoint = path.startPoint;\n    for (const part of path.parts) {\n        const partBBox = Path.computeBBoxForSegment(startPoint, part).grownBy(strokeWidth);\n        let endPoint;\n        if (part.kind === PathCommandType.LineTo || part.kind === PathCommandType.MoveTo) {\n            endPoint = part.point;\n        }\n        else {\n            endPoint = part.endPoint;\n        }\n        const intersectsVisible = partBBox.intersects(visibleRect);\n        if (intersectsVisible) {\n            // TODO: Can we trim parts of paths that intersect the visible rectangle?\n            parts.push(part);\n        }\n        else if (onlyStroked || part.kind === PathCommandType.MoveTo) {\n            // We're stroking (not filling) and the path doesn't intersect the bounding box.\n            // Don't draw it, but preserve the endpoints.\n            parts.push({\n                kind: PathCommandType.MoveTo,\n                point: endPoint,\n            });\n        }\n        else {\n            // Otherwise, we may be filling. Try to roughly preserve the filled region.\n            parts.push({\n                kind: PathCommandType.LineTo,\n                point: endPoint,\n            });\n        }\n        startPoint = endPoint;\n    }\n    const newPath = new Path(path.startPoint, parts);\n    const newStyle = renderablePath.style;\n    rectangleSimplification = simplifyPathToFullScreenOrEmpty(renderablePath, visibleRect, {\n        fastCheck: false,\n        expensiveCheck: true,\n    });\n    if (rectangleSimplification) {\n        return rectangleSimplification.path;\n    }\n    return pathToRenderable(newPath, newStyle);\n};\n","import { Color4 } from '@js-draw/math';\nexport const cloneStyle = (style) => {\n    return {\n        fill: style.fill,\n        stroke: style.stroke\n            ? {\n                ...style.stroke,\n            }\n            : undefined,\n    };\n};\nexport const stylesEqual = (a, b) => {\n    const result = a === b ||\n        (a.fill.eq(b.fill) &&\n            (a.stroke == undefined) === (b.stroke == undefined) &&\n            (a.stroke?.color?.eq(b.stroke?.color) ?? true) &&\n            a.stroke?.width === b.stroke?.width);\n    // Map undefined/null -> false\n    return result ?? false;\n};\n// Returns an object that can be converted to a JSON string with\n// JSON.stringify.\nexport const styleToJSON = (style) => {\n    const stroke = !style.stroke\n        ? undefined\n        : {\n            color: style.stroke.color.toHexString(),\n            width: style.stroke.width,\n        };\n    return {\n        fill: style.fill.toHexString(),\n        stroke,\n    };\n};\nexport const styleFromJSON = (json) => {\n    const stroke = json.stroke\n        ? {\n            color: Color4.fromHex(json.stroke.color),\n            width: json.stroke.width,\n        }\n        : undefined;\n    return {\n        fill: Color4.fromHex(json.fill),\n        stroke,\n    };\n};\n","import  { cloneStyle, styleFromJSON, styleToJSON }  from './RenderingStyle.mjs';\nexport const cloneTextStyle = (style) => {\n    return {\n        ...style,\n        renderingStyle: cloneStyle(style.renderingStyle),\n    };\n};\n/** `json` can either be a `string` or an `object`. */\nexport const textStyleFromJSON = (json) => {\n    if (typeof json === 'string') {\n        json = JSON.parse(json);\n    }\n    if (typeof json.fontFamily !== 'string') {\n        throw new Error('Serialized textStyle missing string fontFamily attribute!');\n    }\n    const style = {\n        renderingStyle: styleFromJSON(json.renderingStyle),\n        size: json.size,\n        fontWeight: json.fontWeight,\n        fontVariant: json.fontVariant,\n        fontFamily: json.fontFamily,\n    };\n    return style;\n};\nexport const textStyleToJSON = (style) => {\n    return {\n        ...style,\n        renderingStyle: styleToJSON(style.renderingStyle),\n    };\n};\n","import { Mat33 } from '@js-draw/math';\n// Represents a cached renderer/canvas\n// This is not a [CacheNode] -- it handles cached renderers and does not have sub-renderers.\nexport default class CacheRecord {\n    constructor(onBeforeDeallocCallback, cacheState) {\n        this.onBeforeDeallocCallback = onBeforeDeallocCallback;\n        this.cacheState = cacheState;\n        this.allocd = false;\n        // For debugging\n        this.allocCount = 0;\n        this.renderer = cacheState.props.createRenderer();\n        this.lastUsedCycle = -1;\n        this.allocd = true;\n    }\n    startRender() {\n        this.lastUsedCycle = this.cacheState.currentRenderingCycle;\n        if (!this.allocd) {\n            throw new Error(\"Only alloc'd canvases can be rendered to\");\n        }\n        return this.renderer;\n    }\n    dealloc() {\n        this.onBeforeDeallocCallback?.();\n        this.allocd = false;\n        this.onBeforeDeallocCallback = null;\n        this.lastUsedCycle = 0;\n    }\n    isAllocd() {\n        return this.allocd;\n    }\n    realloc(newDeallocCallback) {\n        if (this.allocd) {\n            this.dealloc();\n        }\n        this.allocd = true;\n        this.onBeforeDeallocCallback = newDeallocCallback;\n        this.lastUsedCycle = this.cacheState.currentRenderingCycle;\n        this.allocCount++;\n    }\n    getLastUsedCycle() {\n        return this.lastUsedCycle;\n    }\n    // Returns the transformation that maps [drawTo] to this' renderable region\n    // (i.e. a [cacheProps.blockResolution]-sized rectangle with top left at (0, 0))\n    getTransform(drawTo) {\n        const transform = Mat33.scaling2D(this.cacheState.props.blockResolution.x / drawTo.size.x).rightMul(Mat33.translation(drawTo.topLeft.times(-1)));\n        return transform;\n    }\n    setRenderingRegion(drawTo) {\n        const transform = this.getTransform(drawTo);\n        this.renderer.setTransform(transform);\n        // The visible region may be slightly larger than where we're actually drawing\n        // to (because of rounding).\n        this.renderer.overrideVisibleRect(drawTo.grownBy(1 / transform.getScaleFactor()));\n    }\n}\n","import  CacheRecord  from './CacheRecord.mjs';\nexport class CacheRecordManager {\n    constructor(cacheProps) {\n        // Fixed-size array: Cache blocks are assigned indicies into [cachedCanvases].\n        this.cacheRecords = [];\n        this.maxCanvases = Math.ceil(\n        // Assuming four components per pixel:\n        cacheProps.cacheSize / 4 / cacheProps.blockResolution.x / cacheProps.blockResolution.y);\n    }\n    setSharedState(state) {\n        this.cacheState = state;\n    }\n    allocCanvas(drawTo, onDealloc) {\n        if (this.cacheRecords.length < this.maxCanvases) {\n            const record = new CacheRecord(onDealloc, this.cacheState);\n            record.setRenderingRegion(drawTo);\n            this.cacheRecords.push(record);\n            if (this.cacheState.debugMode) {\n                console.log('[Cache] Cache spaces used: ', this.cacheRecords.length, ' of ', this.maxCanvases);\n            }\n            return record;\n        }\n        else {\n            const lru = this.getLeastRecentlyUsedRecord();\n            if (this.cacheState.debugMode) {\n                console.log('[Cache] Re-alloc. Times allocated: ', lru.allocCount, '\\nLast used cycle: ', lru.getLastUsedCycle(), '\\nCurrent cycle: ', this.cacheState.currentRenderingCycle);\n            }\n            lru.realloc(onDealloc);\n            lru.setRenderingRegion(drawTo);\n            if (this.cacheState.debugMode) {\n                console.log(\"[Cache] Now re-alloc'd. Last used cycle: \", lru.getLastUsedCycle());\n                console.assert(lru['cacheState'] === this.cacheState, '[Cache] Unequal cache states! cacheState should be a shared object!');\n            }\n            return lru;\n        }\n    }\n    // Returns null if there are no cache records. Returns an unalloc'd record if one exists.\n    getLeastRecentlyUsedRecord() {\n        this.cacheRecords.sort((a, b) => a.getLastUsedCycle() - b.getLastUsedCycle());\n        return this.cacheRecords[0];\n    }\n    // Returns information to (hopefully) help debug performance issues\n    getDebugInfo() {\n        let numberAllocd = 0;\n        let averageReassignedCount = 0;\n        for (const cacheRecord of this.cacheRecords) {\n            averageReassignedCount += cacheRecord.allocCount;\n            if (cacheRecord.isAllocd()) {\n                numberAllocd++;\n            }\n        }\n        averageReassignedCount /= Math.max(this.cacheRecords.length, 1);\n        const debugInfo = [\n            `${this.cacheRecords.length} cache records (max ${this.maxCanvases})`,\n            `${numberAllocd} assigned to screen regions`,\n            `Average number of times reassigned: ${Math.round(averageReassignedCount * 100) / 100}`,\n        ];\n        return debugInfo.join('\\n');\n    }\n}\n","import { Rect2 } from '@js-draw/math';\nimport  RenderingCacheNode  from './RenderingCacheNode.mjs';\nimport  { CacheRecordManager }  from './CacheRecordManager.mjs';\nexport default class RenderingCache {\n    constructor(cacheProps) {\n        this.recordManager = new CacheRecordManager(cacheProps);\n        this.sharedState = {\n            props: cacheProps,\n            currentRenderingCycle: 0,\n            recordManager: this.recordManager,\n            debugMode: false,\n        };\n        this.recordManager.setSharedState(this.sharedState);\n    }\n    render(screenRenderer, image, viewport) {\n        const visibleRect = viewport.visibleRect;\n        this.sharedState.currentRenderingCycle++;\n        // If we can't use the cache,\n        if (!this.sharedState.props.isOfCorrectType(screenRenderer)) {\n            image.render(screenRenderer, visibleRect);\n            return;\n        }\n        if (!this.rootNode) {\n            // Adjust the node so that it has the correct aspect ratio\n            const res = this.sharedState.props.blockResolution;\n            const topLeft = visibleRect.topLeft;\n            this.rootNode = new RenderingCacheNode(new Rect2(topLeft.x, topLeft.y, res.x, res.y), this.sharedState);\n        }\n        while (!this.rootNode.region.containsRect(visibleRect)) {\n            this.rootNode = this.rootNode.generateParent();\n        }\n        this.rootNode = this.rootNode.smallestChildContaining(visibleRect) ?? this.rootNode;\n        const visibleLeaves = image.getLeavesIntersectingRegion(viewport.visibleRect, (rect) => screenRenderer.isTooSmallToRender(rect));\n        let approxVisibleRenderTime = 0;\n        for (const leaf of visibleLeaves) {\n            approxVisibleRenderTime += leaf.getContent().getProportionalRenderingTime();\n        }\n        if (approxVisibleRenderTime > this.sharedState.props.minProportionalRenderTimeToUseCache) {\n            this.rootNode.renderItems(screenRenderer, [image], viewport);\n        }\n        else {\n            image.render(screenRenderer, visibleRect);\n        }\n    }\n    getDebugInfo() {\n        return this.recordManager.getDebugInfo();\n    }\n    setIsDebugMode(debugMode) {\n        this.sharedState.debugMode = debugMode;\n    }\n}\n","// A cache record with sub-nodes.\nimport  { computeFirstIndexToRender, sortLeavesByZIndex }  from '../../image/EditorImage.mjs';\nimport { Rect2, Color4 } from '@js-draw/math';\n// 3x3 divisions for each node.\nconst cacheDivisionSize = 3;\nexport default class RenderingCacheNode {\n    constructor(region, cacheState) {\n        this.region = region;\n        this.cacheState = cacheState;\n        // invariant: instantiatedChildren.length === 9\n        this.instantiatedChildren = [];\n        this.parent = null;\n        this.cachedRenderer = null;\n        // invariant: sortedInAscendingOrder(renderedIds)\n        this.renderedIds = [];\n        this.renderedMaxZIndex = null;\n    }\n    // Creates a previous layer of the cache tree and adds this as a child near the\n    // center of the previous layer's children.\n    // Returns this' parent if it already exists.\n    generateParent() {\n        if (this.parent) {\n            return this.parent;\n        }\n        const parentRegion = Rect2.fromCorners(this.region.topLeft.minus(this.region.size), this.region.bottomRight.plus(this.region.size));\n        const parent = new RenderingCacheNode(parentRegion, this.cacheState);\n        parent.generateChildren();\n        // Ensure the new node is matches the middle child's region.\n        const checkTolerance = this.region.maxDimension / 100;\n        const middleChildIdx = (parent.instantiatedChildren.length - 1) / 2;\n        if (!parent.instantiatedChildren[middleChildIdx].region.eq(this.region, checkTolerance)) {\n            console.error(parent.instantiatedChildren[middleChildIdx].region, '≠', this.region);\n            throw new Error(\"Logic error: [this] is not contained within its parent's center child\");\n        }\n        // Replace the middle child\n        parent.instantiatedChildren[middleChildIdx] = this;\n        this.parent = parent;\n        return parent;\n    }\n    // Generates children, if missing.\n    generateChildren() {\n        if (this.instantiatedChildren.length === 0) {\n            if (this.region.size.x / cacheDivisionSize === 0 ||\n                this.region.size.y / cacheDivisionSize === 0) {\n                console.warn('Cache element has zero size! Not generating children.');\n                return;\n            }\n            const childRects = this.region.divideIntoGrid(cacheDivisionSize, cacheDivisionSize);\n            console.assert(childRects.length === cacheDivisionSize * cacheDivisionSize, 'Warning: divideIntoGrid created the wrong number of subrectangles!');\n            for (const rect of childRects) {\n                const child = new RenderingCacheNode(rect, this.cacheState);\n                child.parent = this;\n                this.instantiatedChildren.push(child);\n            }\n        }\n        this.checkRep();\n    }\n    // Returns CacheNodes directly contained within this.\n    getChildren() {\n        this.checkRep();\n        this.generateChildren();\n        return this.instantiatedChildren;\n    }\n    smallestChildContaining(rect) {\n        const largerThanChildren = rect.maxDimension > this.region.maxDimension / cacheDivisionSize;\n        if (!this.region.containsRect(rect) || largerThanChildren) {\n            return null;\n        }\n        for (const child of this.getChildren()) {\n            if (child.region.containsRect(rect)) {\n                return child.smallestChildContaining(rect) ?? child;\n            }\n        }\n        return null;\n    }\n    // => [true] iff [this] can be rendered without too much scaling\n    renderingWouldBeHighEnoughResolution(viewport) {\n        // Determine how 1px in this corresponds to 1px on the canvas.\n        //  this.region.w is in canvas units. Thus,\n        const sizeOfThisPixelOnCanvas = this.region.w / this.cacheState.props.blockResolution.x;\n        const sizeOfThisPixelOnScreen = viewport.getScaleFactor() * sizeOfThisPixelOnCanvas;\n        if (sizeOfThisPixelOnScreen > this.cacheState.props.maxScale) {\n            return false;\n        }\n        return true;\n    }\n    // => [true] if all children of this can be rendered from their caches.\n    allChildrenCanRender(viewport, leavesSortedById) {\n        if (this.instantiatedChildren.length === 0) {\n            return false;\n        }\n        for (const child of this.instantiatedChildren) {\n            if (!child.region.intersects(viewport.visibleRect)) {\n                continue;\n            }\n            if (!child.renderingIsUpToDate(this.idsOfIntersecting(leavesSortedById))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    computeSortedByLeafIds(leaves) {\n        const ids = leaves.slice();\n        ids.sort((a, b) => a.getId() - b.getId());\n        return ids;\n    }\n    // Returns a list of the ids of the nodes intersecting this\n    idsOfIntersecting(nodes) {\n        const result = [];\n        for (const node of nodes) {\n            if (node.getBBox().intersects(this.region)) {\n                result.push(node.getId());\n            }\n        }\n        return result;\n    }\n    // Returns true iff all elems of this.renderedIds are in sortedIds.\n    // sortedIds should be sorted by z-index (or some other order, so long as they are\n    // sorted by the same thing as this.renderedIds.)\n    allRenderedIdsIn(sortedIds) {\n        if (this.renderedIds.length > sortedIds.length) {\n            return false;\n        }\n        for (let i = 0; i < this.renderedIds.length; i++) {\n            if (sortedIds[i] !== this.renderedIds[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    renderingIsUpToDate(sortedIds) {\n        if (this.cachedRenderer === null || sortedIds.length !== this.renderedIds.length) {\n            return false;\n        }\n        return this.allRenderedIdsIn(sortedIds);\n    }\n    // Render all [items] within [viewport]\n    renderItems(screenRenderer, items, viewport) {\n        if (!viewport.visibleRect.intersects(this.region) || items.length === 0) {\n            return;\n        }\n        // Divide [items] until nodes are smaller than this, or are leaves.\n        const divideUntilSmallerThanThis = (itemsToDivide) => {\n            const newItems = [];\n            for (const item of itemsToDivide) {\n                const bbox = item.getBBox();\n                if (!bbox.intersects(this.region)) {\n                    continue;\n                }\n                if (bbox.maxDimension >= this.region.maxDimension) {\n                    newItems.push(...item.getChildrenOrSelfIntersectingRegion(this.region));\n                }\n                else {\n                    newItems.push(item);\n                }\n            }\n            return newItems;\n        };\n        items = divideUntilSmallerThanThis(items);\n        // Can we cache at all?\n        if (!this.cacheState.props.isOfCorrectType(screenRenderer)) {\n            for (const item of items) {\n                item.render(screenRenderer, viewport.visibleRect);\n            }\n            return;\n        }\n        if (this.cacheState.debugMode) {\n            screenRenderer.drawRect(this.region, viewport.getSizeOfPixelOnCanvas(), {\n                fill: Color4.yellow,\n            });\n        }\n        // Could we render direclty from [this] or do we need to recurse?\n        const couldRender = this.renderingWouldBeHighEnoughResolution(viewport);\n        if (!couldRender) {\n            for (const child of this.getChildren()) {\n                child.renderItems(screenRenderer, items.filter((item) => {\n                    return item.getBBox().intersects(child.region);\n                }), viewport);\n            }\n        }\n        else {\n            // Determine whether we already have rendered the items\n            const tooSmallToRender = (rect) => rect.w / this.region.w < 1 / this.cacheState.props.blockResolution.x;\n            const leaves = [];\n            for (const item of items) {\n                leaves.push(...item.getLeavesIntersectingRegion(this.region, tooSmallToRender));\n            }\n            sortLeavesByZIndex(leaves);\n            const leavesByIds = this.computeSortedByLeafIds(leaves);\n            // No intersecting leaves? No need to render\n            if (leavesByIds.length === 0) {\n                return;\n            }\n            const leafIds = leavesByIds.map((leaf) => leaf.getId());\n            let thisRenderer;\n            if (!this.renderingIsUpToDate(leafIds)) {\n                if (this.allChildrenCanRender(viewport, leavesByIds)) {\n                    for (const child of this.getChildren()) {\n                        child.renderItems(screenRenderer, items, viewport);\n                    }\n                    return;\n                }\n                let leafApproxRenderTime = 0;\n                for (const leaf of leavesByIds) {\n                    if (!tooSmallToRender(leaf.getBBox())) {\n                        leafApproxRenderTime += leaf.getContent().getProportionalRenderingTime();\n                    }\n                }\n                // Is it worth it to render the items?\n                if (leafApproxRenderTime > this.cacheState.props.minProportionalRenderTimePerCache) {\n                    let fullRerenderNeeded = true;\n                    if (!this.cachedRenderer) {\n                        this.cachedRenderer = this.cacheState.recordManager.allocCanvas(this.region, () => this.onRegionDealloc());\n                    }\n                    else if (leavesByIds.length > this.renderedIds.length &&\n                        this.allRenderedIdsIn(leafIds) &&\n                        this.renderedMaxZIndex !== null) {\n                        // We often don't need to do a full re-render even if something's changed.\n                        // Check whether we can just draw on top of the existing cache.\n                        const newLeaves = [];\n                        let minNewZIndex = null;\n                        for (let i = 0; i < leavesByIds.length; i++) {\n                            const leaf = leavesByIds[i];\n                            const content = leaf.getContent();\n                            const zIndex = content.getZIndex();\n                            if (i >= this.renderedIds.length || leaf.getId() !== this.renderedIds[i]) {\n                                newLeaves.push(leaf);\n                                if (minNewZIndex === null || zIndex < minNewZIndex) {\n                                    minNewZIndex = zIndex;\n                                }\n                            }\n                        }\n                        if (minNewZIndex !== null && minNewZIndex > this.renderedMaxZIndex) {\n                            fullRerenderNeeded = false;\n                            thisRenderer = this.cachedRenderer.startRender();\n                            // Looping is faster than re-sorting.\n                            for (let i = 0; i < leaves.length; i++) {\n                                const leaf = leaves[i];\n                                const zIndex = leaf.getContent().getZIndex();\n                                if (zIndex > this.renderedMaxZIndex) {\n                                    leaf.render(thisRenderer, this.region);\n                                    this.renderedMaxZIndex = zIndex;\n                                }\n                            }\n                            if (this.cacheState.debugMode) {\n                                // Clay for adding new elements\n                                screenRenderer.drawRect(this.region, 2 * viewport.getSizeOfPixelOnCanvas(), {\n                                    fill: Color4.clay,\n                                });\n                            }\n                        }\n                    }\n                    else if (this.cacheState.debugMode) {\n                        console.log('Decided on a full re-render. Reason: At least one of the following is false:', '\\n leafIds.length > this.renderedIds.length: ', leafIds.length > this.renderedIds.length, '\\n this.allRenderedIdsIn(leafIds): ', this.allRenderedIdsIn(leafIds), '\\n this.renderedMaxZIndex !== null: ', this.renderedMaxZIndex !== null, '\\n\\nthis.rerenderedIds: ', this.renderedIds, ', leafIds: ', leafIds);\n                    }\n                    if (fullRerenderNeeded) {\n                        thisRenderer = this.cachedRenderer.startRender();\n                        thisRenderer.clear();\n                        this.renderedMaxZIndex = null;\n                        const startIndex = computeFirstIndexToRender(leaves, this.region);\n                        for (let i = startIndex; i < leaves.length; i++) {\n                            const leaf = leaves[i];\n                            const content = leaf.getContent();\n                            this.renderedMaxZIndex ??= content.getZIndex();\n                            this.renderedMaxZIndex = Math.max(this.renderedMaxZIndex, content.getZIndex());\n                            leaf.render(thisRenderer, this.region);\n                        }\n                        if (this.cacheState.debugMode) {\n                            // Red for full rerender\n                            screenRenderer.drawRect(this.region, 3 * viewport.getSizeOfPixelOnCanvas(), {\n                                fill: Color4.red,\n                            });\n                        }\n                    }\n                    this.renderedIds = leafIds;\n                }\n                else {\n                    this.cachedRenderer?.dealloc();\n                    // Slightly increase the clip region to prevent seams.\n                    // Divide by two because grownBy expands the rectangle on all sides.\n                    const pixelSize = viewport.getSizeOfPixelOnCanvas();\n                    const expandedRegion = new Rect2(this.region.x, this.region.y, this.region.w + pixelSize, this.region.h + pixelSize);\n                    const clip = true;\n                    screenRenderer.startObject(expandedRegion, clip);\n                    for (const leaf of leaves) {\n                        leaf.render(screenRenderer, this.region.intersection(viewport.visibleRect));\n                    }\n                    screenRenderer.endObject();\n                    if (this.cacheState.debugMode) {\n                        // Green for no cache needed render\n                        screenRenderer.drawRect(this.region, 2 * viewport.getSizeOfPixelOnCanvas(), {\n                            fill: Color4.green,\n                        });\n                    }\n                }\n            }\n            else {\n                thisRenderer = this.cachedRenderer.startRender();\n            }\n            if (thisRenderer) {\n                const transformMat = this.cachedRenderer.getTransform(this.region).inverse();\n                screenRenderer.renderFromOtherOfSameType(transformMat, thisRenderer);\n            }\n            // Can we clean up this' children? (Are they unused?)\n            if (this.instantiatedChildren.every((child) => child.isEmpty())) {\n                this.instantiatedChildren = [];\n            }\n        }\n        this.checkRep();\n    }\n    // Returns true iff this/its children have no cached state.\n    isEmpty() {\n        if (this.cachedRenderer !== null) {\n            return false;\n        }\n        return this.instantiatedChildren.every((child) => child.isEmpty());\n    }\n    onRegionDealloc() {\n        this.cachedRenderer = null;\n        if (this.isEmpty()) {\n            this.instantiatedChildren = [];\n        }\n    }\n    checkRep() {\n        if (this.instantiatedChildren.length !== cacheDivisionSize * cacheDivisionSize &&\n            this.instantiatedChildren.length !== 0) {\n            throw new Error(`Repcheck: Wrong number of children. Got ${this.instantiatedChildren.length}`);\n        }\n        if (this.renderedIds[1] !== undefined && this.renderedIds[0] >= this.renderedIds[1]) {\n            console.error(this.renderedIds);\n            throw new Error('Repcheck: First two ids are not in ascending order!');\n        }\n        for (const child of this.instantiatedChildren) {\n            if (child.parent !== this) {\n                throw new Error('Children should be linked to their parents!');\n            }\n        }\n        if (this.cachedRenderer && !this.cachedRenderer.isAllocd()) {\n            throw new Error(\"this' cachedRenderer != null, but is dealloc'd\");\n        }\n    }\n}\n","export  { default as AbstractRenderer }  from './renderers/AbstractRenderer.mjs';\nexport  { default as DummyRenderer }  from './renderers/DummyRenderer.mjs';\nexport  { default as SVGRenderer }  from './renderers/SVGRenderer.mjs';\nexport  { default as CanvasRenderer }  from './renderers/CanvasRenderer.mjs';\nexport  { default as Display, RenderingMode }  from './Display.mjs';\nexport  { pathToRenderable, pathFromRenderable, visualEquivalent as pathVisualEquivalent, }  from './RenderablePathSpec.mjs';\n","export const defaultTextRendererLocalization = {\n    pathNodeCount: (count) => `There are ${count} visible path objects.`,\n    textNodeCount: (count) => `There are ${count} visible text nodes.`,\n    imageNodeCount: (nodeCount) => `There are ${nodeCount} visible image nodes.`,\n    textNode: (content) => `Text: ${content}`,\n    imageNode: (label) => `Image: ${label}`,\n    unlabeledImageNode: 'Unlabeled image',\n    rerenderAsText: 'Re-render as text',\n};\n","import { Vec2, Path, PathCommandType } from '@js-draw/math';\nimport  { stylesEqual }  from '../RenderingStyle.mjs';\nimport  { pathToRenderable }  from '../RenderablePathSpec.mjs';\n/**\n * Abstract base class for renderers.\n *\n * @see {@link EditorImage.render}\n */\nexport default class AbstractRenderer {\n    constructor(viewport) {\n        this.viewport = viewport;\n        // If null, this' transformation is linked to the Viewport\n        this.selfTransform = null;\n        this.transformStack = [];\n        this.objectLevel = 0;\n        this.currentPaths = null;\n    }\n    /**\n     * this.canvasToScreen, etc. should be used instead of the corresponding\n     * methods on `Viewport`, because the viewport may not accurately reflect\n     * what is rendered.\n     */\n    getViewport() {\n        return this.viewport;\n    }\n    setDraftMode(_draftMode) { }\n    flushPath() {\n        if (!this.currentPaths) {\n            return;\n        }\n        let lastStyle = null;\n        for (const path of this.currentPaths) {\n            const { startPoint, commands, style } = path;\n            if (!lastStyle || !stylesEqual(lastStyle, style)) {\n                if (lastStyle) {\n                    this.endPath(lastStyle);\n                }\n                this.beginPath(startPoint);\n                lastStyle = style;\n            }\n            else {\n                this.moveTo(startPoint);\n            }\n            for (const command of commands) {\n                if (command.kind === PathCommandType.LineTo) {\n                    this.lineTo(command.point);\n                }\n                else if (command.kind === PathCommandType.MoveTo) {\n                    this.moveTo(command.point);\n                }\n                else if (command.kind === PathCommandType.CubicBezierTo) {\n                    this.traceCubicBezierCurve(command.controlPoint1, command.controlPoint2, command.endPoint);\n                }\n                else if (command.kind === PathCommandType.QuadraticBezierTo) {\n                    this.traceQuadraticBezierCurve(command.controlPoint, command.endPoint);\n                }\n            }\n        }\n        if (lastStyle) {\n            this.endPath(lastStyle);\n        }\n        this.currentPaths = [];\n    }\n    /**\n     * Draws a styled path. If within an object started by {@link startObject},\n     * the resultant path may not be visible until {@link endObject} is called.\n     */\n    drawPath(path) {\n        // If we're being called outside of an object,\n        // we can't delay rendering\n        if (this.objectLevel === 0 || this.currentPaths === null) {\n            this.currentPaths = [path];\n            this.flushPath();\n            this.currentPaths = null;\n        }\n        else {\n            // Otherwise, don't render paths all at once. This prevents faint lines between\n            // segments of the same stroke from being visible.\n            this.currentPaths.push(path);\n        }\n    }\n    // Strokes a rectangle. Boundary lines have width [lineWidth] and are filled with [lineFill].\n    // This is equivalent to `drawPath(Path.fromRect(...).toRenderable(...))`.\n    drawRect(rect, lineWidth, lineFill) {\n        const path = Path.fromRect(rect, lineWidth);\n        this.drawPath(pathToRenderable(path, lineFill));\n    }\n    /** Draws a filled rectangle. */\n    fillRect(rect, fill) {\n        const path = Path.fromRect(rect);\n        this.drawPath(pathToRenderable(path, { fill }));\n    }\n    /**\n     * This should be called whenever a new object is being drawn.\n     *\n     * @param _boundingBox The bounding box of the object to be drawn.\n     * @param _clip Whether content outside `_boundingBox` should be drawn. Renderers\n     *              that override this method are not required to support `_clip`.\n     */\n    startObject(_boundingBox, _clip) {\n        if (this.objectLevel > 0) {\n            this.flushPath();\n        }\n        this.currentPaths = [];\n        this.objectLevel++;\n    }\n    /**\n     * Notes the end of an object.\n     * @param _loaderData - a map from strings to JSON-ifyable objects\n     * and contains properties attached to the object by whatever loader loaded the image. This\n     * is used to preserve attributes not supported by js-draw when loading/saving an image.\n     * Renderers may ignore this.\n     *\n     * @param _objectTags - a list of labels (e.g. `className`s) to be attached to the object.\n     * Renderers may ignore this.\n     */\n    endObject(_loaderData, _objectTags) {\n        // Render the paths all at once\n        this.flushPath();\n        this.currentPaths = null;\n        this.objectLevel--;\n        if (this.objectLevel < 0) {\n            throw new Error('More objects have ended than have been started (negative object nesting level)!');\n        }\n    }\n    getNestingLevel() {\n        return this.objectLevel;\n    }\n    // Returns true iff other can be rendered onto this without data loss.\n    canRenderFromWithoutDataLoss(_other) {\n        return false;\n    }\n    // MUST throw if other and this are not of the same base class.\n    renderFromOtherOfSameType(_renderTo, other) {\n        throw new Error(`Unable to render from ${other}: Not implemented`);\n    }\n    // Set a transformation to apply to things before rendering,\n    // replacing the viewport's transform.\n    setTransform(transform) {\n        this.selfTransform = transform;\n    }\n    pushTransform(transform) {\n        this.transformStack.push(this.selfTransform);\n        this.setTransform(this.getCanvasToScreenTransform().rightMul(transform));\n    }\n    popTransform() {\n        if (this.transformStack.length === 0) {\n            throw new Error('Unable to pop more transforms than have been pushed!');\n        }\n        this.setTransform(this.transformStack.pop() ?? null);\n    }\n    // Get the matrix that transforms a vector on the canvas to a vector on this'\n    // rendering target.\n    getCanvasToScreenTransform() {\n        if (this.selfTransform) {\n            return this.selfTransform;\n        }\n        return this.viewport.canvasToScreenTransform;\n    }\n    canvasToScreen(vec) {\n        return this.getCanvasToScreenTransform().transformVec2(vec);\n    }\n    getSizeOfCanvasPixelOnScreen() {\n        return this.getCanvasToScreenTransform().transformVec3(Vec2.unitX).length();\n    }\n    /**\n     * @internal\n     */\n    overrideVisibleRect(rect) {\n        this.visibleRectOverride = rect;\n    }\n    // Returns the region in canvas space that is visible within the viewport this\n    // canvas is rendering to.\n    //\n    // Note that in some cases this might not be the same as the `visibleRect` given\n    // to components in their `render` method.\n    getVisibleRect() {\n        return this.visibleRectOverride ?? this.viewport.visibleRect;\n    }\n}\n","import  TextComponent  from '../../components/TextComponent.mjs';\nimport { Vec2, Color4 } from '@js-draw/math';\nimport  AbstractRenderer  from './AbstractRenderer.mjs';\nimport  { visualEquivalent }  from '../RenderablePathSpec.mjs';\n/**\n * Renders onto a `CanvasRenderingContext2D`.\n *\n * **Example**:\n * [[include:doc-pages/inline-examples/canvas-renderer.md]]\n */\nexport default class CanvasRenderer extends AbstractRenderer {\n    /**\n     * Creates a new `CanvasRenderer` that renders to the given rendering context.\n     * The `viewport` is used to determine the translation/rotation/scaling of the content\n     * to draw.\n     */\n    constructor(ctx, viewport) {\n        super(viewport);\n        this.ctx = ctx;\n        this.ignoreObjectsAboveLevel = null;\n        this.ignoringObject = false;\n        this.currentObjectBBox = null;\n        this.clipLevels = [];\n        this.setDraftMode(false);\n    }\n    transformBy(transformBy) {\n        // From MDN, transform(a,b,c,d,e,f)\n        // takes input such that\n        // ⎡ a c e ⎤\n        // ⎢ b d f ⎥ transforms content drawn to [ctx].\n        // ⎣ 0 0 1 ⎦\n        this.ctx.transform(transformBy.a1, transformBy.b1, // a, b\n        transformBy.a2, transformBy.b2, // c, d\n        transformBy.a3, transformBy.b3);\n    }\n    canRenderFromWithoutDataLoss(other) {\n        return other instanceof CanvasRenderer;\n    }\n    renderFromOtherOfSameType(transformBy, other) {\n        if (!(other instanceof CanvasRenderer)) {\n            throw new Error(`${other} cannot be rendered onto ${this}`);\n        }\n        transformBy = this.getCanvasToScreenTransform().rightMul(transformBy);\n        this.ctx.save();\n        this.transformBy(transformBy);\n        this.ctx.drawImage(other.ctx.canvas, 0, 0);\n        this.ctx.restore();\n    }\n    // Set parameters for lower/higher quality rendering\n    setDraftMode(draftMode) {\n        if (draftMode) {\n            this.minSquareCurveApproxDist = 9;\n            this.minRenderSizeBothDimens = 1;\n            this.minRenderSizeAnyDimen = 0.1;\n        }\n        else {\n            this.minSquareCurveApproxDist = 0.5;\n            this.minRenderSizeBothDimens = 0.1;\n            this.minRenderSizeAnyDimen = 1e-6;\n        }\n    }\n    displaySize() {\n        return Vec2.of(this.ctx.canvas.clientWidth, this.ctx.canvas.clientHeight);\n    }\n    clear() {\n        this.ctx.save();\n        this.ctx.resetTransform();\n        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n        this.ctx.restore();\n    }\n    beginPath(startPoint) {\n        startPoint = this.canvasToScreen(startPoint);\n        this.ctx.beginPath();\n        this.ctx.moveTo(startPoint.x, startPoint.y);\n    }\n    endPath(style) {\n        // Saving and restoring can be slow in some browsers\n        // (e.g. 0.50ms). Avoid.\n        //this.ctx.save();\n        // If not a transparent fill\n        if (style.fill.a > 0) {\n            this.ctx.fillStyle = style.fill.toHexString();\n            this.ctx.fill();\n        }\n        if (style.stroke) {\n            this.ctx.strokeStyle = style.stroke.color.toHexString();\n            this.ctx.lineWidth = this.getSizeOfCanvasPixelOnScreen() * style.stroke.width;\n            this.ctx.lineCap = 'round';\n            this.ctx.lineJoin = 'round';\n            this.ctx.stroke();\n            this.ctx.lineWidth = 1;\n        }\n        this.ctx.closePath();\n        //this.ctx.restore();\n    }\n    lineTo(point) {\n        point = this.canvasToScreen(point);\n        this.ctx.lineTo(point.x, point.y);\n    }\n    moveTo(point) {\n        point = this.canvasToScreen(point);\n        this.ctx.moveTo(point.x, point.y);\n    }\n    traceCubicBezierCurve(p1, p2, p3) {\n        p1 = this.canvasToScreen(p1);\n        p2 = this.canvasToScreen(p2);\n        p3 = this.canvasToScreen(p3);\n        // Approximate the curve if small enough.\n        const delta1 = p2.minus(p1);\n        const delta2 = p3.minus(p2);\n        if (delta1.magnitudeSquared() < this.minSquareCurveApproxDist &&\n            delta2.magnitudeSquared() < this.minSquareCurveApproxDist) {\n            this.ctx.lineTo(p3.x, p3.y);\n        }\n        else {\n            this.ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);\n        }\n    }\n    traceQuadraticBezierCurve(controlPoint, endPoint) {\n        controlPoint = this.canvasToScreen(controlPoint);\n        endPoint = this.canvasToScreen(endPoint);\n        // Approximate the curve with a line if small enough\n        const delta = controlPoint.minus(endPoint);\n        if (delta.magnitudeSquared() < this.minSquareCurveApproxDist) {\n            this.ctx.lineTo(endPoint.x, endPoint.y);\n        }\n        else {\n            this.ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, endPoint.x, endPoint.y);\n        }\n    }\n    drawPath(path) {\n        if (this.ignoringObject) {\n            return;\n        }\n        // If part of a huge object, it might be worth trimming the path\n        const visibleRect = this.getVisibleRect();\n        if (this.currentObjectBBox?.containsRect(visibleRect)) {\n            // Try to trim/remove parts of the path outside of the bounding box.\n            path = visualEquivalent(path, visibleRect);\n        }\n        super.drawPath(path);\n    }\n    drawText(text, transform, style) {\n        this.ctx.save();\n        transform = this.getCanvasToScreenTransform().rightMul(transform);\n        this.transformBy(transform);\n        TextComponent.applyTextStyles(this.ctx, style);\n        if (style.renderingStyle.fill.a !== 0) {\n            this.ctx.fillStyle = style.renderingStyle.fill.toHexString();\n            this.ctx.fillText(text, 0, 0);\n        }\n        if (style.renderingStyle.stroke) {\n            this.ctx.strokeStyle = style.renderingStyle.stroke.color.toHexString();\n            this.ctx.lineWidth = style.renderingStyle.stroke.width;\n            this.ctx.strokeText(text, 0, 0);\n        }\n        this.ctx.restore();\n    }\n    drawImage(image) {\n        // .drawImage can fail for zero-size images.\n        if (image.image.width === 0 || image.image.height === 0) {\n            return;\n        }\n        this.ctx.save();\n        const transform = this.getCanvasToScreenTransform().rightMul(image.transform);\n        this.transformBy(transform);\n        this.ctx.drawImage(image.image, 0, 0);\n        this.ctx.restore();\n    }\n    startObject(boundingBox, clip) {\n        if (this.isTooSmallToRender(boundingBox)) {\n            this.ignoreObjectsAboveLevel = this.getNestingLevel();\n            this.ignoringObject = true;\n        }\n        super.startObject(boundingBox);\n        this.currentObjectBBox = boundingBox;\n        if (!this.ignoringObject && clip) {\n            // Don't clip if it would only remove content already trimmed by\n            // the edge of the screen.\n            const clippedIsOutsideScreen = boundingBox.containsRect(this.getVisibleRect());\n            if (!clippedIsOutsideScreen) {\n                this.clipLevels.push(this.objectLevel);\n                this.ctx.save();\n                this.ctx.beginPath();\n                for (const corner of boundingBox.corners) {\n                    const screenCorner = this.canvasToScreen(corner);\n                    this.ctx.lineTo(screenCorner.x, screenCorner.y);\n                }\n                this.ctx.clip();\n            }\n        }\n    }\n    endObject() {\n        // Cache this.objectLevel — it may be decremented by super.endObject.\n        const objectLevel = this.objectLevel;\n        this.currentObjectBBox = null;\n        super.endObject();\n        if (!this.ignoringObject && this.clipLevels.length > 0) {\n            if (this.clipLevels[this.clipLevels.length - 1] === objectLevel) {\n                this.ctx.restore();\n                this.clipLevels.pop();\n            }\n        }\n        // If exiting an object with a too-small-to-draw bounding box,\n        if (this.ignoreObjectsAboveLevel !== null &&\n            this.getNestingLevel() <= this.ignoreObjectsAboveLevel) {\n            this.ignoreObjectsAboveLevel = null;\n            this.ignoringObject = false;\n        }\n    }\n    // @internal\n    drawPoints(...points) {\n        const pointRadius = 10;\n        for (let i = 0; i < points.length; i++) {\n            const point = this.canvasToScreen(points[i]);\n            this.ctx.beginPath();\n            this.ctx.arc(point.x, point.y, pointRadius, 0, Math.PI * 2);\n            this.ctx.fillStyle = Color4.ofRGBA(0.5 + Math.sin(i) / 2, 1.0, 0.5 + Math.cos(i * 0.2) / 4, 0.5).toHexString();\n            this.ctx.lineWidth = 2;\n            this.ctx.fill();\n            this.ctx.stroke();\n            this.ctx.closePath();\n            this.ctx.textAlign = 'center';\n            this.ctx.textBaseline = 'middle';\n            this.ctx.fillStyle = 'black';\n            this.ctx.fillText(`${i}`, point.x, point.y, pointRadius * 2);\n        }\n    }\n    // @internal\n    isTooSmallToRender(rect) {\n        // Should we ignore all objects within this object's bbox?\n        const diagonal = rect.size.times(this.getSizeOfCanvasPixelOnScreen());\n        const bothDimenMinSize = this.minRenderSizeBothDimens;\n        const bothTooSmall = Math.abs(diagonal.x) < bothDimenMinSize && Math.abs(diagonal.y) < bothDimenMinSize;\n        const anyDimenMinSize = this.minRenderSizeAnyDimen;\n        const anyTooSmall = Math.abs(diagonal.x) < anyDimenMinSize || Math.abs(diagonal.y) < anyDimenMinSize;\n        return bothTooSmall || anyTooSmall;\n    }\n    // @internal\n    static fromViewport(exportViewport, options = {}) {\n        const canvas = document.createElement('canvas');\n        const exportRectSize = exportViewport.getScreenRectSize();\n        let canvasSize = options.canvasSize ?? exportRectSize;\n        if (options.maxCanvasDimen && canvasSize.maximumEntryMagnitude() > options.maxCanvasDimen) {\n            canvasSize = canvasSize.times(options.maxCanvasDimen / canvasSize.maximumEntryMagnitude());\n        }\n        canvas.width = canvasSize.x;\n        canvas.height = canvasSize.y;\n        const ctx = canvas.getContext('2d');\n        // Scale to ensure that the entire output is visible.\n        const scaleFactor = Math.min(canvasSize.x / exportRectSize.x, canvasSize.y / exportRectSize.y);\n        ctx.scale(scaleFactor, scaleFactor);\n        return { renderer: new CanvasRenderer(ctx, exportViewport), element: canvas };\n    }\n}\n","import { Vec2 } from '@js-draw/math';\nimport  AbstractRenderer  from './AbstractRenderer.mjs';\n// Renderer that outputs almost nothing. Useful for automated tests.\nexport default class DummyRenderer extends AbstractRenderer {\n    constructor(viewport) {\n        super(viewport);\n        // Variables that track the state of what's been rendered\n        this.clearedCount = 0;\n        this.renderedPathCount = 0;\n        this.lastFillStyle = null;\n        this.lastPoint = null;\n        this.objectNestingLevel = 0;\n        this.lastText = null;\n        this.lastImage = null;\n        // List of points drawn since the last clear.\n        this.pointBuffer = [];\n    }\n    displaySize() {\n        // Do we have a stored viewport size?\n        const viewportSize = this.getViewport().getScreenRectSize();\n        // Don't use a 0x0 viewport — DummyRenderer is often used\n        // for tests that run without a display, so pretend we have a\n        // reasonable-sized display.\n        if (viewportSize.x === 0 || viewportSize.y === 0) {\n            return Vec2.of(640, 480);\n        }\n        return viewportSize;\n    }\n    clear() {\n        this.clearedCount++;\n        this.renderedPathCount = 0;\n        this.pointBuffer = [];\n        this.lastText = null;\n        this.lastImage = null;\n        // Ensure all objects finished rendering\n        if (this.objectNestingLevel > 0) {\n            throw new Error(`Within an object while clearing! Nesting level: ${this.objectNestingLevel}`);\n        }\n    }\n    beginPath(startPoint) {\n        this.lastPoint = startPoint;\n        this.pointBuffer.push(startPoint);\n    }\n    endPath(style) {\n        this.renderedPathCount++;\n        this.lastFillStyle = style;\n    }\n    lineTo(point) {\n        point = this.canvasToScreen(point);\n        this.lastPoint = point;\n        this.pointBuffer.push(point);\n    }\n    moveTo(point) {\n        point = this.canvasToScreen(point);\n        this.lastPoint = point;\n        this.pointBuffer.push(point);\n    }\n    traceCubicBezierCurve(p1, p2, p3) {\n        p1 = this.canvasToScreen(p1);\n        p2 = this.canvasToScreen(p2);\n        p3 = this.canvasToScreen(p3);\n        this.lastPoint = p3;\n        this.pointBuffer.push(p1, p2, p3);\n    }\n    traceQuadraticBezierCurve(controlPoint, endPoint) {\n        controlPoint = this.canvasToScreen(controlPoint);\n        endPoint = this.canvasToScreen(endPoint);\n        this.lastPoint = endPoint;\n        this.pointBuffer.push(controlPoint, endPoint);\n    }\n    drawPoints(..._points) {\n        // drawPoints is intended for debugging.\n        // As such, it is unlikely to be the target of automated tests.\n    }\n    drawText(text, _transform, _style) {\n        this.lastText = text;\n    }\n    drawImage(image) {\n        this.lastImage = image;\n    }\n    startObject(boundingBox, _clip) {\n        super.startObject(boundingBox);\n        this.objectNestingLevel += 1;\n    }\n    endObject() {\n        super.endObject();\n        this.objectNestingLevel -= 1;\n    }\n    isTooSmallToRender(_rect) {\n        return false;\n    }\n    canRenderFromWithoutDataLoss(other) {\n        return other instanceof DummyRenderer;\n    }\n    renderFromOtherOfSameType(transform, other) {\n        if (!(other instanceof DummyRenderer)) {\n            throw new Error(`${other} cannot be rendered onto ${this}`);\n        }\n        this.renderedPathCount += other.renderedPathCount;\n        this.lastFillStyle = other.lastFillStyle;\n        this.lastPoint = other.lastPoint;\n        this.pointBuffer.push(...other.pointBuffer.map((point) => {\n            return transform.transformVec2(point);\n        }));\n    }\n    toString() {\n        return '[DummyRenderer]';\n    }\n}\n","import { Mat33, Vec2, toRoundedString } from '@js-draw/math';\nimport  { svgAttributesDataKey, svgLoaderAttributeContainerID, svgStyleAttributesDataKey, }  from '../../SVGLoader/SVGLoader.mjs';\nimport  { stylesEqual }  from '../RenderingStyle.mjs';\nimport  AbstractRenderer  from './AbstractRenderer.mjs';\nimport  { pathFromRenderable }  from '../RenderablePathSpec.mjs';\nimport  listPrefixMatch  from '../../util/listPrefixMatch.mjs';\nexport const renderedStylesheetId = 'js-draw-style-sheet';\nconst svgNameSpace = 'http://www.w3.org/2000/svg';\nconst defaultTextStyle = {\n    fontWeight: '400',\n    fontStyle: 'normal',\n};\n/**\n * Renders onto an `SVGElement`.\n *\n * @see {@link Editor.toSVG}\n */\nexport default class SVGRenderer extends AbstractRenderer {\n    /**\n     * Creates a renderer that renders onto `elem`. If `sanitize`, don't render potentially untrusted data.\n     *\n     * `viewport` is used to determine the translation/rotation/scaling/output size of the rendered\n     * data.\n     */\n    constructor(elem, viewport, sanitize = false) {\n        super(viewport);\n        this.elem = elem;\n        this.sanitize = sanitize;\n        this.lastPathStyle = null;\n        this.lastPathString = [];\n        this.lastContainerIDList = [];\n        // Elements that make up the current object (as created by startObject)\n        // if any.\n        this.objectElems = null;\n        this.overwrittenAttrs = {};\n        this.textContainer = null;\n        this.textContainerTransform = null;\n        this.textParentStyle = defaultTextStyle;\n        this.clear();\n        this.addStyleSheet();\n    }\n    addStyleSheet() {\n        if (!this.elem.querySelector(`#${renderedStylesheetId}`)) {\n            // Default to rounded strokes.\n            const styleSheet = document.createElementNS('http://www.w3.org/2000/svg', 'style');\n            styleSheet.appendChild(document.createTextNode(`\n\t\t\t\tpath {\n\t\t\t\t\tstroke-linecap: round;\n\t\t\t\t\tstroke-linejoin: round;\n\t\t\t\t}\n\n\t\t\t\ttext {\n\t\t\t\t\twhite-space: pre;\n\t\t\t\t}\n\t\t\t`.replace(/\\s+/g, '')));\n            styleSheet.setAttribute('id', renderedStylesheetId);\n            this.elem.appendChild(styleSheet);\n        }\n    }\n    // Sets an attribute on the root SVG element.\n    setRootSVGAttribute(name, value) {\n        if (this.sanitize) {\n            return;\n        }\n        // Make the original value of the attribute restorable on clear\n        if (!(name in this.overwrittenAttrs)) {\n            this.overwrittenAttrs[name] = this.elem.getAttribute(name);\n        }\n        if (value !== null) {\n            this.elem.setAttribute(name, value);\n        }\n        else {\n            this.elem.removeAttribute(name);\n        }\n    }\n    displaySize() {\n        return Vec2.of(this.elem.clientWidth, this.elem.clientHeight);\n    }\n    clear() {\n        this.lastPathString = [];\n        this.lastContainerIDList = [];\n        if (!this.sanitize) {\n            // Restore all all attributes\n            for (const attrName in this.overwrittenAttrs) {\n                const value = this.overwrittenAttrs[attrName];\n                if (value) {\n                    this.elem.setAttribute(attrName, value);\n                }\n                else {\n                    this.elem.removeAttribute(attrName);\n                }\n            }\n            this.overwrittenAttrs = {};\n        }\n    }\n    // Push `this.fullPath` to the SVG. Returns the path added to the SVG, if any.\n    // @internal\n    addPathToSVG() {\n        if (!this.lastPathStyle || this.lastPathString.length === 0) {\n            return null;\n        }\n        const pathElem = document.createElementNS(svgNameSpace, 'path');\n        pathElem.setAttribute('d', this.lastPathString.join(' '));\n        const style = this.lastPathStyle;\n        if (style.fill.a > 0) {\n            pathElem.setAttribute('fill', style.fill.toHexString());\n        }\n        else {\n            pathElem.setAttribute('fill', 'none');\n        }\n        if (style.stroke) {\n            pathElem.setAttribute('stroke', style.stroke.color.toHexString());\n            pathElem.setAttribute('stroke-width', toRoundedString(style.stroke.width * this.getSizeOfCanvasPixelOnScreen()));\n        }\n        this.elem.appendChild(pathElem);\n        this.objectElems?.push(pathElem);\n        return pathElem;\n    }\n    drawPath(pathSpec) {\n        const style = pathSpec.style;\n        const path = pathFromRenderable(pathSpec).transformedBy(this.getCanvasToScreenTransform());\n        // Try to extend the previous path, if possible\n        if (this.lastPathString.length === 0 ||\n            !this.lastPathStyle ||\n            !stylesEqual(this.lastPathStyle, style)) {\n            this.addPathToSVG();\n            this.lastPathStyle = style;\n            this.lastPathString = [];\n        }\n        this.lastPathString.push(path.toString());\n    }\n    // Apply [elemTransform] to [elem]. Uses both a `matrix` and `.x`, `.y` properties if `setXY` is true.\n    // Otherwise, just uses a `matrix`.\n    transformFrom(elemTransform, elem, inCanvasSpace = false) {\n        const transform = !inCanvasSpace\n            ? this.getCanvasToScreenTransform().rightMul(elemTransform)\n            : elemTransform;\n        if (!transform.eq(Mat33.identity)) {\n            const matrixString = transform.toCSSMatrix();\n            elem.style.transform = matrixString;\n            // Most browsers round the components of CSS transforms.\n            // Include a higher precision copy of the element's transform.\n            elem.setAttribute('data-highp-transform', matrixString);\n        }\n        else {\n            elem.style.transform = '';\n        }\n    }\n    drawText(text, transform, style) {\n        const applyTextStyles = (elem, style) => {\n            if (style.fontFamily !== this.textParentStyle?.fontFamily) {\n                elem.style.fontFamily = style.fontFamily;\n            }\n            if (style.fontVariant !== this.textParentStyle?.fontVariant) {\n                elem.style.fontVariant = style.fontVariant ?? '';\n            }\n            if (style.fontWeight !== this.textParentStyle?.fontWeight) {\n                elem.style.fontWeight = style.fontWeight ?? '';\n            }\n            if (style.fontStyle !== this.textParentStyle?.fontStyle) {\n                elem.style.fontStyle = style.fontStyle ?? '';\n            }\n            if (style.size !== this.textParentStyle?.size) {\n                elem.style.fontSize = style.size + 'px';\n            }\n            const fillString = style.renderingStyle.fill.toHexString();\n            // TODO: Uncomment at some future major version release --- currently causes incompatibility due\n            //       to an SVG parsing bug in older versions.\n            //const parentFillString = this.textParentStyle?.renderingStyle?.fill?.toHexString();\n            //if (fillString !== parentFillString) {\n            elem.style.fill = fillString;\n            //}\n            if (style.renderingStyle.stroke) {\n                const strokeStyle = style.renderingStyle.stroke;\n                elem.style.stroke = strokeStyle.color.toHexString();\n                elem.style.strokeWidth = strokeStyle.width + 'px';\n            }\n        };\n        transform = this.getCanvasToScreenTransform().rightMul(transform);\n        if (!this.textContainer) {\n            const container = document.createElementNS(svgNameSpace, 'text');\n            container.appendChild(document.createTextNode(text));\n            this.transformFrom(transform, container, true);\n            applyTextStyles(container, style);\n            this.elem.appendChild(container);\n            this.objectElems?.push(container);\n            if (this.objectLevel > 0) {\n                this.textContainer = container;\n                this.textContainerTransform = transform;\n                this.textParentStyle = { ...defaultTextStyle, ...style };\n            }\n        }\n        else {\n            const elem = document.createElementNS(svgNameSpace, 'tspan');\n            elem.appendChild(document.createTextNode(text));\n            this.textContainer.appendChild(elem);\n            // Make .x/.y relative to the parent.\n            transform = this.textContainerTransform.inverse().rightMul(transform);\n            // .style.transform does nothing to tspan elements. As such, we need to set x/y:\n            const translation = transform.transformVec2(Vec2.zero);\n            elem.setAttribute('x', `${toRoundedString(translation.x)}`);\n            elem.setAttribute('y', `${toRoundedString(translation.y)}`);\n            applyTextStyles(elem, style);\n        }\n    }\n    drawImage(image) {\n        let label = image.label ?? image.image.getAttribute('aria-label') ?? '';\n        if (label === '') {\n            label = image.image.getAttribute('alt') ?? '';\n        }\n        const svgImgElem = document.createElementNS(svgNameSpace, 'image');\n        svgImgElem.setAttribute('href', image.base64Url);\n        svgImgElem.setAttribute('width', image.image.getAttribute('width') ?? '');\n        svgImgElem.setAttribute('height', image.image.getAttribute('height') ?? '');\n        svgImgElem.setAttribute('aria-label', label);\n        this.transformFrom(image.transform, svgImgElem);\n        this.elem.appendChild(svgImgElem);\n        this.objectElems?.push(svgImgElem);\n    }\n    startObject(boundingBox) {\n        super.startObject(boundingBox);\n        // Only accumulate a path within an object\n        this.lastPathString = [];\n        this.lastPathStyle = null;\n        this.textContainer = null;\n        this.textParentStyle = defaultTextStyle;\n        this.objectElems = [];\n    }\n    endObject(loaderData, elemClassNames) {\n        super.endObject(loaderData);\n        // Don't extend paths across objects\n        this.addPathToSVG();\n        // If empty/not an object, stop.\n        if (!this.objectElems) {\n            return;\n        }\n        if (loaderData && !this.sanitize) {\n            // Restore any attributes unsupported by the app.\n            for (const elem of this.objectElems) {\n                const attrs = loaderData[svgAttributesDataKey];\n                const styleAttrs = loaderData[svgStyleAttributesDataKey];\n                if (attrs) {\n                    for (const [attr, value] of attrs) {\n                        elem.setAttribute(attr, value);\n                    }\n                }\n                if (styleAttrs) {\n                    for (const attr of styleAttrs) {\n                        elem.style.setProperty(attr.key, attr.value, attr.priority);\n                    }\n                }\n            }\n            // Update the parent\n            const containerIDData = loaderData[svgLoaderAttributeContainerID];\n            let containerIDList = [];\n            if (containerIDData && containerIDData[0]) {\n                // If a string list,\n                if (containerIDData[0].length) {\n                    containerIDList = containerIDData[0];\n                }\n            }\n            if (containerIDList.length > 0 &&\n                // containerIDList must share a prefix with the last ID list\n                // otherwise, the z order of elements may have been changed from\n                // the original image.\n                // In the case that the z order has been changed, keep the current\n                // element as a child of the root to preserve z order.\n                listPrefixMatch(this.lastContainerIDList, containerIDList) &&\n                // The component can add at most one more parent than the previous item.\n                this.lastContainerIDList.length >= containerIDList.length - 1) {\n                // Select the last\n                const containerID = containerIDList[containerIDList.length - 1];\n                const containerCandidates = this.elem.querySelectorAll(`g#${containerID}`);\n                if (containerCandidates.length >= 1) {\n                    const container = containerCandidates[0];\n                    // If this is the first time we're entering the group, the\n                    // group should be empty.\n                    // Otherwise, this may be a case that would break z-ordering.\n                    if (container.children.length === 0 ||\n                        this.lastContainerIDList.length >= containerIDList.length) {\n                        // Move all objectElems to the found container\n                        for (const elem of this.objectElems) {\n                            elem.remove();\n                            container.appendChild(elem);\n                        }\n                    }\n                    else {\n                        containerIDList = [];\n                    }\n                }\n            }\n            else {\n                containerIDList = [];\n            }\n            this.lastContainerIDList = containerIDList;\n        }\n        // Add class names to the object, if given.\n        if (elemClassNames && this.objectElems) {\n            if (this.objectElems.length === 1) {\n                this.objectElems[0].classList.add(...elemClassNames);\n            }\n            else {\n                const wrapper = document.createElementNS(svgNameSpace, 'g');\n                wrapper.classList.add(...elemClassNames);\n                for (const elem of this.objectElems) {\n                    elem.remove();\n                    wrapper.appendChild(elem);\n                }\n                this.elem.appendChild(wrapper);\n            }\n        }\n    }\n    // Not implemented -- use drawPath instead.\n    unimplementedMessage() {\n        throw new Error('Not implemenented!');\n    }\n    beginPath(_startPoint) {\n        this.unimplementedMessage();\n    }\n    endPath(_style) {\n        this.unimplementedMessage();\n    }\n    lineTo(_point) {\n        this.unimplementedMessage();\n    }\n    moveTo(_point) {\n        this.unimplementedMessage();\n    }\n    traceCubicBezierCurve(_controlPoint1, _controlPoint2, _endPoint) {\n        this.unimplementedMessage();\n    }\n    traceQuadraticBezierCurve(_controlPoint, _endPoint) {\n        this.unimplementedMessage();\n    }\n    drawPoints(...points) {\n        points.map((point) => {\n            const elem = document.createElementNS(svgNameSpace, 'circle');\n            elem.setAttribute('cx', `${point.x}`);\n            elem.setAttribute('cy', `${point.y}`);\n            elem.setAttribute('r', '15');\n            this.elem.appendChild(elem);\n        });\n    }\n    // Renders a **copy** of the given element.\n    drawSVGElem(elem) {\n        if (this.sanitize) {\n            return;\n        }\n        // Don't add multiple copies of the default stylesheet.\n        if (elem.tagName.toLowerCase() === 'style' &&\n            elem.getAttribute('id') === renderedStylesheetId) {\n            return;\n        }\n        const elemToDraw = elem.cloneNode(true);\n        this.elem.appendChild(elemToDraw);\n        this.objectElems?.push(elemToDraw);\n    }\n    isTooSmallToRender(_rect) {\n        return false;\n    }\n    /**\n     * Creates a new SVG element and `SVGRenerer` with `width`, `height`, `viewBox`,\n     * and other metadata attributes set for the given `Viewport`.\n     *\n     * If `options` is a `boolean`, it is interpreted as whether to sanitize (not add unknown\n     * SVG entities to) the output.\n     */\n    static fromViewport(viewport, options = true) {\n        let sanitize;\n        let useViewBoxForPositioning;\n        if (typeof options === 'boolean') {\n            sanitize = options;\n            useViewBoxForPositioning = false;\n        }\n        else {\n            sanitize = options.sanitize ?? true;\n            useViewBoxForPositioning = options.useViewBoxForPositioning ?? false;\n        }\n        const svgNameSpace = 'http://www.w3.org/2000/svg';\n        const result = document.createElementNS(svgNameSpace, 'svg');\n        const screenRectSize = viewport.getScreenRectSize();\n        const visibleRect = viewport.visibleRect;\n        let viewBoxComponents;\n        if (useViewBoxForPositioning) {\n            const exportRect = viewport.visibleRect;\n            viewBoxComponents = [exportRect.x, exportRect.y, exportRect.w, exportRect.h];\n            // Replace the viewport with a copy that has a modified transform.\n            // (Avoids modifying the original viewport).\n            viewport = viewport.getTemporaryClone();\n            // TODO: This currently discards any rotation information.\n            // Render with (0,0) at (0,0) -- the translation is handled by the viewBox.\n            viewport.resetTransform(Mat33.identity);\n        }\n        else {\n            viewBoxComponents = [0, 0, screenRectSize.x, screenRectSize.y];\n        }\n        // rect.x -> size of rect in x direction, rect.y -> size of rect in y direction.\n        result.setAttribute('viewBox', viewBoxComponents.map((part) => toRoundedString(part)).join(' '));\n        result.setAttribute('width', toRoundedString(screenRectSize.x));\n        result.setAttribute('height', toRoundedString(screenRectSize.y));\n        // Ensure the image can be identified as an SVG if downloaded.\n        // See https://jwatt.org/svg/authoring/\n        result.setAttribute('version', '1.1');\n        result.setAttribute('baseProfile', 'full');\n        result.setAttribute('xmlns', svgNameSpace);\n        const renderer = new SVGRenderer(result, viewport, sanitize);\n        if (!visibleRect.eq(viewport.visibleRect)) {\n            renderer.overrideVisibleRect(visibleRect);\n        }\n        return { element: result, renderer };\n    }\n}\n","import { Vec2 } from '@js-draw/math';\nimport  AbstractRenderer  from './AbstractRenderer.mjs';\n// Outputs a description of what was rendered.\nexport default class TextOnlyRenderer extends AbstractRenderer {\n    constructor(viewport, localizationTable) {\n        super(viewport);\n        this.localizationTable = localizationTable;\n        this.descriptionBuilder = [];\n        this.pathCount = 0;\n        this.textNodeCount = 0;\n        this.imageNodeCount = 0;\n    }\n    displaySize() {\n        // We don't have a graphical display, export a reasonable size.\n        return Vec2.of(500, 500);\n    }\n    clear() {\n        this.descriptionBuilder = [];\n        this.pathCount = 0;\n        this.textNodeCount = 0;\n        this.imageNodeCount = 0;\n    }\n    getDescription() {\n        return [\n            this.localizationTable.pathNodeCount(this.pathCount),\n            ...(this.textNodeCount > 0 ? [this.localizationTable.textNodeCount(this.textNodeCount)] : []),\n            ...(this.imageNodeCount > 0\n                ? [this.localizationTable.imageNodeCount(this.imageNodeCount)]\n                : []),\n            ...this.descriptionBuilder,\n        ].join('\\n');\n    }\n    beginPath(_startPoint) { }\n    endPath(_style) {\n        this.pathCount++;\n    }\n    lineTo(_point) { }\n    moveTo(_point) { }\n    traceCubicBezierCurve(_p1, _p2, _p3) { }\n    traceQuadraticBezierCurve(_controlPoint, _endPoint) { }\n    drawText(text, _transform, _style) {\n        this.descriptionBuilder.push(this.localizationTable.textNode(text));\n        this.textNodeCount++;\n    }\n    drawImage(image) {\n        const label = image.label\n            ? this.localizationTable.imageNode(image.label)\n            : this.localizationTable.unlabeledImageNode;\n        this.descriptionBuilder.push(label);\n        this.imageNodeCount++;\n    }\n    isTooSmallToRender(rect) {\n        return rect.maxDimension < 15 / this.getSizeOfCanvasPixelOnScreen();\n    }\n    drawPoints(..._points) { }\n}\n","const isUppercaseLetter = (text) => {\n    return text.toUpperCase() === text && text.toLowerCase() !== text && text.length === 1;\n};\nconst isLowercaseLetter = (text) => {\n    return text.toLowerCase() === text && text.toUpperCase() !== text && text.length === 1;\n};\n/** Represents a key combination that can trigger a keyboard shortcut. */\nexport default class KeyBinding {\n    constructor(trigger) {\n        this.key = trigger.key;\n        this.shiftKey = trigger.shiftKey;\n        this.ctrlKey = trigger.ctrlKey;\n        this.altKey = trigger.altKey;\n        this.metaKey = trigger.metaKey;\n        this.controlOrMeta = trigger.controlOrMeta;\n    }\n    /** Returns true if and only if `keyEvent` should trigger this shortcut. */\n    matchesEvent(keyEvent) {\n        const lowercaseKey = keyEvent.key?.toLowerCase();\n        // Determine whether the input is an upper case letter or not.\n        const isUpperCaseKey = isUppercaseLetter(keyEvent.key ?? '');\n        const isLowercaseKey = isLowercaseLetter(keyEvent.key ?? '');\n        const ctrlKey = (keyEvent.ctrlKey ?? false) || lowercaseKey === 'control';\n        const altKey = (keyEvent.altKey ?? false) || lowercaseKey === 'alt';\n        const metaKey = (keyEvent.metaKey ?? false) || lowercaseKey === 'meta';\n        const shiftKey = (keyEvent.shiftKey ?? isUpperCaseKey) || lowercaseKey === 'shift';\n        const keyEventHasCtrlOrMeta = keyEvent.controlOrMeta || keyEvent.ctrlKey || keyEvent.metaKey || false;\n        // If we're not working with key codes,\n        if (this.key !== keyEvent.code) {\n            // Different keys entirely? They don't match.\n            if (this.key.toLowerCase() !== lowercaseKey) {\n                return false;\n            }\n            // If a case where the ASCII case of the given key might matter,\n            // compare.\n            if ((isUpperCaseKey || isLowercaseKey) && this.key !== keyEvent.key) {\n                // this.shiftKey may be interpreted as allowing this shortcut to be uppercased.\n                // If so, try making this.key uppercase and matching the shortcut.\n                const uppercaseKeyMatches = this.shiftKey === true && this.key.toUpperCase() === keyEvent.key;\n                if (!uppercaseKeyMatches) {\n                    return false;\n                }\n            }\n        }\n        const shortcutControlOrMeta = this.controlOrMeta;\n        // Match ctrl/meta if the shortcut doesn't have controlOrMeta specified\n        // (controlOrMeta should match either).\n        const ctrlAndMetaMatches = ctrlKey === this.ctrlKey && metaKey === this.metaKey && !shortcutControlOrMeta;\n        const matches = (ctrlAndMetaMatches || (shortcutControlOrMeta && keyEventHasCtrlOrMeta)) &&\n            altKey === this.altKey &&\n            (shiftKey === this.shiftKey || this.shiftKey === undefined);\n        return matches;\n    }\n    /**\n     * Returns a string representation of this shortcut in the same format accepted by\n     * {@link fromString}.\n     */\n    toString() {\n        const result = [];\n        if (this.ctrlKey && this.key !== 'control') {\n            result.push('Ctrl');\n        }\n        if (this.controlOrMeta) {\n            result.push('CtrlOrMeta');\n        }\n        if (this.altKey && this.key !== 'alt') {\n            result.push('Alt');\n        }\n        if (this.metaKey && this.key !== 'meta') {\n            result.push('Meta');\n        }\n        if (this.shiftKey && this.key !== 'shift') {\n            result.push('Shift');\n        }\n        result.push(this.key);\n        return result.join('+');\n    }\n    /**\n     * Accepts a string in the form `modifier1+modifier2+...+key` (e.g. `Ctrl+Shift+a`)\n     * and returns the corresponding `KeyboardShortcut`.\n     */\n    static fromString(shortcutStr) {\n        const getDefaultModifiers = (key) => {\n            // Unless a letter, as long as the given key matches, it shouldn't matter whether\n            // the shift key is pressed.\n            let shiftKey = undefined;\n            if (isUppercaseLetter(key)) {\n                shiftKey = true;\n            }\n            else if (isLowercaseLetter(key)) {\n                shiftKey = false;\n            }\n            // If not just a single character (e.g. a key code like KeyA), shift must\n            // be specified manually.\n            else if (key.length > 1) {\n                shiftKey = false;\n            }\n            const lowercaseKey = key.toLowerCase();\n            // shiftKey should always be true if the key is 'shift'\n            if (lowercaseKey === 'shift') {\n                shiftKey = true;\n            }\n            return {\n                shiftKey,\n                ctrlKey: lowercaseKey === 'control' || lowercaseKey === 'ctrl',\n                altKey: lowercaseKey === 'alt',\n                metaKey: lowercaseKey === 'meta',\n                controlOrMeta: lowercaseKey === 'control or meta' || lowercaseKey === 'ctrlormeta',\n            };\n        };\n        const hasNoModifiers = shortcutStr.search(/[-+]/) === -1 || shortcutStr.length === 1;\n        if (hasNoModifiers) {\n            const modifiers = getDefaultModifiers(shortcutStr);\n            return new KeyBinding({\n                key: shortcutStr,\n                ...modifiers,\n            });\n        }\n        const keyModifiersExp = /^(.*[-+])?(.+)$/g;\n        const match = keyModifiersExp.exec(shortcutStr);\n        if (!match) {\n            throw new Error(`Invalid shortcut expression, ${shortcutStr}!`);\n        }\n        const key = match[2];\n        const defaultModifiers = getDefaultModifiers(key);\n        const modifierStrings = (match[1] ?? '').split(/[-+]/);\n        let shiftKey = defaultModifiers.shiftKey;\n        let ctrlKey = defaultModifiers.ctrlKey;\n        let altKey = defaultModifiers.altKey;\n        let metaKey = defaultModifiers.metaKey;\n        let controlOrMeta = defaultModifiers.controlOrMeta;\n        for (const modifier of modifierStrings) {\n            if (modifier === '') {\n                continue;\n            }\n            switch (modifier.toLowerCase()) {\n                case 'shift':\n                    shiftKey = true;\n                    break;\n                case 'anyshift':\n                    shiftKey = undefined;\n                    break;\n                case 'ctrl':\n                case 'control':\n                    ctrlKey = true;\n                    break;\n                case 'meta':\n                    metaKey = true;\n                    break;\n                case 'ctrlormeta':\n                case 'ctrl or meta':\n                case 'controlormeta':\n                    controlOrMeta = true;\n                    break;\n                case 'alt':\n                    altKey = true;\n                    break;\n                default:\n                    throw new Error(`Unknown modifier: \"${modifier}\" in shortcut ${shortcutStr}.`);\n            }\n        }\n        const shortcut = new KeyBinding({\n            key,\n            shiftKey,\n            ctrlKey,\n            altKey,\n            metaKey,\n            controlOrMeta,\n        });\n        return shortcut;\n    }\n}\n","import  { matchingLocalizationTable }  from '../localizations/getLocalizationTable.mjs';\nimport  KeyBinding  from './KeyBinding.mjs';\n/**\n * Allows adding/changing keyboard shortcuts. This class provides static methods for registering\n * default shortcuts. An instance of this class must be used to access or change keyboard shortcuts.\n */\nclass KeyboardShortcutManager {\n    /**\n     * Creates a new `ShortcutManager` with an initial set of shortcut overrides.\n     *\n     * @internal\n     */\n    constructor(initialOverrides) {\n        this.shortcutOverrides = Object.create(null);\n        for (const id in initialOverrides) {\n            this.overrideShortcut(id, initialOverrides[id]);\n        }\n    }\n    /**\n     * Override an existing shortcut with a custom set of triggers.\n     * @internal\n     */\n    overrideShortcut(shortcutId, overrideWith) {\n        this.shortcutOverrides[shortcutId] = [...overrideWith];\n    }\n    /** Returns true if `keyEvent` matches the shortcut with `shortcutId`. @internal */\n    matchesShortcut(shortcutId, keyEvent) {\n        // Get all shortcucts associated with `shortcutId`.\n        let shortcutList = this.shortcutOverrides[shortcutId];\n        if (!shortcutList) {\n            if (shortcutId in KeyboardShortcutManager.shortcuts) {\n                shortcutList = KeyboardShortcutManager.shortcuts[shortcutId];\n            }\n            else {\n                throw new Error(`No shortcut with ID ${shortcutId} exists!`);\n            }\n        }\n        // return true if keyEvent matches *any* shortcuts in shortcutList\n        for (const shortcut of shortcutList) {\n            if (shortcut.matchesEvent(keyEvent)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Registers a default keyboard shortcut that can be overridden by individual instances\n     * of `ShortcutManager`. Note that `id` should be a globally unique identifier.\n     *\n     * Only the first call to this method for a given `id` has an effect.\n     *\n     * @example\n     * ```ts\n     * const shortcutId = 'io.github.personalizedrefrigerator.js-draw.select-all';\n     *\n     * // Associate two shortcuts with the same ID\n     * const shortcut1 = KeyBinding.fromString('ctrlOrMeta+a');\n     * const shortcut2 = KeyBinding.fromString('ctrlOrMeta+shift+a');\n     * KeyboardShortcutManager.registerDefaultKeyboardShortcut(\n     * \tshortcutId,\n     * \t[ shortcut1, shortcut2 ],\n     * \t\"Select All\",\n     * );\n     *\n     * // Provide a localized description\n     * KeyboardShortcutManager.provideShortcutDescription(\n     * \tshotcutId,\n     * \t'es',\n     * \t'Seleccionar todo',\n     * );\n     * ```\n     *\n     * @internal\n     */\n    static registerDefaultKeyboardShortcut(id, shortcuts, defaultDescription) {\n        if (id in KeyboardShortcutManager.shortcuts) {\n            return false;\n        }\n        // Convert the strings to shortcut maps.\n        const shortcutsAsShortcuts = shortcuts.map((shortcut) => {\n            if (typeof shortcut === 'string') {\n                return KeyBinding.fromString(shortcut);\n            }\n            return shortcut;\n        });\n        KeyboardShortcutManager.shortcuts[id] = [...shortcutsAsShortcuts];\n        KeyboardShortcutManager.shortcutDefaultDescriptions[id] = defaultDescription;\n        return true;\n    }\n    /** Provides a localized description of a keyboard shortcut. @internal */\n    static provideShortcutDescription(id, locale, description) {\n        if (!(locale in KeyboardShortcutManager.shortcutLocalizedDescriptions)) {\n            KeyboardShortcutManager.shortcutLocalizedDescriptions[locale] = Object.create(null);\n        }\n        KeyboardShortcutManager.shortcutLocalizedDescriptions[locale][id] = description;\n    }\n    /**\n     * Gets all registered keyboard shortcut IDs.\n     *\n     * @see {@link getShortcutDescription}\n     */\n    static getAllShortcutIds() {\n        const ids = [];\n        for (const id in this.shortcuts) {\n            ids.push(id);\n        }\n        return ids;\n    }\n    /**\n     * Get the default keybindings associated with a keyboard shortcut.\n     *\n     * Any keybinding in the resultant list, by default, can trigger the function associated\n     * with the shortcut.\n     */\n    static getShortcutDefaultKeybindings(shortcutId) {\n        if (!(shortcutId in KeyboardShortcutManager.shortcuts)) {\n            throw new Error(`No shortcut with ID ${shortcutId} exists!`);\n        }\n        return KeyboardShortcutManager.shortcuts[shortcutId];\n    }\n    /**\n     * Get a description of a keyboard shortcut.\n     *\n     * `localeList`, if given, attempts to\n     */\n    static getShortcutDescription(id, localeList) {\n        const localizationTable = matchingLocalizationTable(localeList ?? [], this.shortcutLocalizedDescriptions, this.shortcutDefaultDescriptions);\n        return localizationTable[id] ?? this.shortcutDefaultDescriptions[id] ?? null;\n    }\n}\nKeyboardShortcutManager.shortcuts = Object.create(null);\nKeyboardShortcutManager.shortcutDefaultDescriptions = Object.create(null);\nKeyboardShortcutManager.shortcutLocalizedDescriptions = Object.create(null);\nexport default KeyboardShortcutManager;\n","export  { default as KeyboardShortcutManager }  from './KeyboardShortcutManager.mjs';\nexport  { default as KeyBinding }  from './KeyBinding.mjs';\n","/** Returns the smallest ID not used by the pointers in the given list. */\nconst getUniquePointerId = (pointers) => {\n    let ptrId = 0;\n    const pointerIds = pointers.map((ptr) => ptr.id);\n    pointerIds.sort();\n    for (const pointerId of pointerIds) {\n        if (ptrId === pointerId) {\n            ptrId = pointerId + 1;\n        }\n    }\n    return ptrId;\n};\nexport default getUniquePointerId;\n","export  { default as sendPenEvent }  from './sendPenEvent.mjs';\nexport  { default as sendTouchEvent }  from './sendTouchEvent.mjs';\n","import  Pointer, { PointerDevice }  from '../Pointer.mjs';\nimport  { InputEvtType }  from '../inputEvents.mjs';\nimport  getUniquePointerId  from './getUniquePointerId.mjs';\n/**\n * Dispatch a pen event to the currently selected tool.\n * Intended for unit tests.\n *\n * @see {@link sendTouchEvent}\n */\nconst sendPenEvent = (editor, eventType, point, allPointers, deviceType = PointerDevice.Pen) => {\n    const id = getUniquePointerId(allPointers ?? []);\n    const mainPointer = Pointer.ofCanvasPoint(point, eventType !== InputEvtType.PointerUpEvt, editor.viewport, id, deviceType);\n    editor.toolController.dispatchInputEvent({\n        kind: eventType,\n        allPointers: allPointers ?? [mainPointer],\n        current: mainPointer,\n    });\n    return mainPointer;\n};\nexport default sendPenEvent;\n","import  Pointer, { PointerDevice }  from '../Pointer.mjs';\nimport  { InputEvtType }  from '../inputEvents.mjs';\nimport  getUniquePointerId  from './getUniquePointerId.mjs';\n/**\n * Dispatch a touch event to the currently selected tool. Intended for unit tests.\n *\n * @see {@link sendPenEvent}\n *\n * @example\n * **Simulating a horizontal swipe gesture:**\n * ```ts\n * sendTouchEvent(editor, InputEvtType.PointerDownEvt, Vec2.of(0, 0));\n * for (let i = 1; i <= 10; i++) {\n *   jest.advanceTimersByTime(10);\n *   sendTouchEvent(editor, InputEvtType.PointerMoveEvt, Vec2.of(i * 10, 0));\n * }\n * ```\n *\n * @example\n * **Simulating a pinch gesture.** This example assumes that you're using [Jest with timer mocks enabled](https://jestjs.io/docs/timer-mocks).\n * ```ts\n * let firstPointer = sendTouchEvent(editor, InputEvtType.PointerDownEvt, Vec2.of(0, 0));\n * let secondPointer = sendTouchEvent(editor, InputEvtType.PointerDownEvt, Vec2.of(100, 0), [ firstPointer ]);\n *\n * // Simulate a pinch\n * const maxIterations = 10;\n * for (let i = 0; i < maxIterations; i++) {\n *   // Use the unit testing framework's tool for increasing the current time\n *   // returned by (new Date()).getTime(), etc.\n *   jest.advanceTimersByTime(100);\n *\n *   const point1 = Vec2.of(-i * 5, 0);\n *   const point2 = Vec2.of(i * 5 + 100, 0);\n *\n *   firstPointer = sendTouchEvent(editor, InputEvtType.PointerMoveEvt, point1, [ secondPointer ]);\n *   secondPointer = sendTouchEvent(editor, InputEvtType.PointerMoveEvt, point2, [ firstPointer ]);\n * }\n * ```\n */\nconst sendTouchEvent = (editor, eventType, screenPos, allOtherPointers) => {\n    const canvasPos = editor.viewport.screenToCanvas(screenPos);\n    // Get a unique ID for the main pointer\n    // (try to use id=0, but don't use it if it's already in use).\n    const ptrId = getUniquePointerId(allOtherPointers ?? []);\n    const mainPointer = Pointer.ofCanvasPoint(canvasPos, eventType !== InputEvtType.PointerUpEvt, editor.viewport, ptrId, PointerDevice.Touch);\n    editor.toolController.dispatchInputEvent({\n        kind: eventType,\n        allPointers: [...(allOtherPointers ?? []), mainPointer],\n        current: mainPointer,\n    });\n    return mainPointer;\n};\nexport default sendTouchEvent;\n","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _AbstractToolbar_listeners, _AbstractToolbar_widgetsById, _AbstractToolbar_widgetList, _AbstractToolbar_updateColoris;\nimport  { EditorEventType }  from '../types.mjs';\nimport { coloris, close as closeColoris, init as colorisInit } from '@melloware/coloris';\nimport  { defaultToolbarLocalization }  from './localization.mjs';\nimport  SelectionTool  from '../tools/SelectionTool/SelectionTool.mjs';\nimport  PanZoomTool  from '../tools/PanZoom.mjs';\nimport  TextTool  from '../tools/TextTool.mjs';\nimport  EraserTool  from '../tools/Eraser.mjs';\nimport  PenTool  from '../tools/Pen.mjs';\nimport  PenToolWidget  from './widgets/PenToolWidget.mjs';\nimport  EraserWidget  from './widgets/EraserToolWidget.mjs';\nimport  SelectionToolWidget  from './widgets/SelectionToolWidget.mjs';\nimport  TextToolWidget  from './widgets/TextToolWidget.mjs';\nimport  HandToolWidget  from './widgets/HandToolWidget.mjs';\nimport  { ToolbarWidgetTag }  from './widgets/BaseWidget.mjs';\nimport  ActionButtonWidget  from './widgets/ActionButtonWidget.mjs';\nimport  InsertImageWidget  from './widgets/InsertImageWidget/InsertImageWidget.mjs';\nimport  DocumentPropertiesWidget  from './widgets/DocumentPropertiesWidget.mjs';\nimport { Color4 } from '@js-draw/math';\nimport  { toolbarCSSPrefix }  from './constants.mjs';\nimport  SaveActionWidget  from './widgets/SaveActionWidget.mjs';\nimport  ExitActionWidget  from './widgets/ExitActionWidget.mjs';\nimport  { assertIsObject, assertTruthy }  from '../util/assertions.mjs';\n/**\n * Abstract base class for js-draw editor toolbars.\n *\n * See {@link Editor.addToolbar}, {@link makeDropdownToolbar}, and {@link makeEdgeToolbar}.\n */\nclass AbstractToolbar {\n    /** @internal */\n    constructor(editor, localizationTable = defaultToolbarLocalization) {\n        this.editor = editor;\n        this.localizationTable = localizationTable;\n        _AbstractToolbar_listeners.set(this, []);\n        _AbstractToolbar_widgetsById.set(this, {});\n        _AbstractToolbar_widgetList.set(this, []);\n        _AbstractToolbar_updateColoris.set(this, null);\n        this.closeColorPickerOverlay = null;\n        if (!AbstractToolbar.colorisStarted) {\n            colorisInit();\n            AbstractToolbar.colorisStarted = true;\n        }\n        this.setupColorPickers();\n    }\n    setupCloseColorPickerOverlay() {\n        if (this.closeColorPickerOverlay)\n            return;\n        this.closeColorPickerOverlay = document.createElement('div');\n        this.closeColorPickerOverlay.className = `${toolbarCSSPrefix}closeColorPickerOverlay`;\n        this.editor.createHTMLOverlay(this.closeColorPickerOverlay);\n        // Hide the color picker when attempting to draw on the overlay.\n        __classPrivateFieldGet(this, _AbstractToolbar_listeners, \"f\").push(this.editor.handlePointerEventsExceptClicksFrom(this.closeColorPickerOverlay, (eventName) => {\n            if (eventName === 'pointerdown') {\n                closeColoris();\n            }\n            // Transfer focus to the editor to allow keyboard events to be handled.\n            if (eventName === 'pointerup') {\n                this.editor.focus();\n            }\n            // Send the event to the editor\n            return true;\n        }));\n    }\n    // @internal\n    setupColorPickers() {\n        // Much of the setup only needs to be done once.\n        if (__classPrivateFieldGet(this, _AbstractToolbar_updateColoris, \"f\")) {\n            __classPrivateFieldGet(this, _AbstractToolbar_updateColoris, \"f\").call(this);\n            return;\n        }\n        this.setupCloseColorPickerOverlay();\n        const maxSwatchLen = 12;\n        const swatches = [\n            Color4.red.toHexString(),\n            Color4.purple.toHexString(),\n            Color4.blue.toHexString(),\n            Color4.clay.toHexString(),\n            Color4.black.toHexString(),\n            Color4.white.toHexString(),\n        ];\n        const presetColorEnd = swatches.length;\n        // Keeps track of whether a Coloris initialization is scheduled.\n        let colorisInitScheduled = false;\n        // (Re)init Coloris -- update the swatches list.\n        const initColoris = () => {\n            try {\n                coloris({\n                    el: '.coloris_input',\n                    format: 'hex',\n                    selectInput: false,\n                    focusInput: false,\n                    themeMode: 'auto',\n                    swatches,\n                });\n            }\n            catch (err) {\n                console.warn('Failed to initialize Coloris. Error: ', err);\n                // Try again --- a known issue is that Coloris fails to load if the document\n                // isn't ready.\n                if (!colorisInitScheduled) {\n                    colorisInitScheduled = true;\n                    // Wait to initialize after the document has loaded\n                    document.addEventListener('load', () => {\n                        initColoris();\n                    }, { once: true });\n                }\n            }\n        };\n        initColoris();\n        __classPrivateFieldSet(this, _AbstractToolbar_updateColoris, initColoris, \"f\");\n        const addColorToSwatch = (newColor) => {\n            let alreadyPresent = false;\n            for (const color of swatches) {\n                if (color === newColor) {\n                    alreadyPresent = true;\n                }\n            }\n            if (!alreadyPresent) {\n                swatches.push(newColor);\n                if (swatches.length > maxSwatchLen) {\n                    swatches.splice(presetColorEnd, 1);\n                }\n                initColoris();\n            }\n        };\n        __classPrivateFieldGet(this, _AbstractToolbar_listeners, \"f\").push(this.editor.notifier.on(EditorEventType.ColorPickerToggled, (event) => {\n            if (event.kind !== EditorEventType.ColorPickerToggled) {\n                return;\n            }\n            // Show/hide the overlay. Making the overlay visible gives users a surface to click\n            // on that shows/hides the color picker.\n            if (this.closeColorPickerOverlay) {\n                this.closeColorPickerOverlay.style.display = event.open ? 'block' : 'none';\n            }\n        }));\n        // Add newly-selected colors to the swatch.\n        __classPrivateFieldGet(this, _AbstractToolbar_listeners, \"f\").push(this.editor.notifier.on(EditorEventType.ColorPickerColorSelected, (event) => {\n            if (event.kind === EditorEventType.ColorPickerColorSelected) {\n                addColorToSwatch(event.color.toHexString());\n            }\n        }));\n    }\n    closeColorPickers() {\n        closeColoris?.();\n    }\n    getWidgetUniqueId(widget) {\n        return widget.getUniqueIdIn(__classPrivateFieldGet(this, _AbstractToolbar_widgetsById, \"f\"));\n    }\n    getWidgetFromId(id) {\n        return __classPrivateFieldGet(this, _AbstractToolbar_widgetsById, \"f\")[id];\n    }\n    /** Do **not** modify the return value. */\n    getAllWidgets() {\n        return __classPrivateFieldGet(this, _AbstractToolbar_widgetList, \"f\");\n    }\n    /**\n     * Adds an `ActionButtonWidget` or `BaseToolWidget`. The widget should not have already have a parent\n     * (i.e. its `addTo` method should not have been called).\n     *\n     * @example\n     * ```ts\n     * const toolbar = editor.addToolbar();\n     * const insertImageWidget = new InsertImageWidget(editor);\n     * toolbar.addWidget(insertImageWidget);\n     * ```\n     */\n    addWidget(widget) {\n        // Prevent name collisions\n        const id = widget.getUniqueIdIn(__classPrivateFieldGet(this, _AbstractToolbar_widgetsById, \"f\"));\n        // Add the widget\n        __classPrivateFieldGet(this, _AbstractToolbar_widgetsById, \"f\")[id] = widget;\n        __classPrivateFieldGet(this, _AbstractToolbar_widgetList, \"f\").push(widget);\n        this.addWidgetInternal(widget);\n        this.setupColorPickers();\n    }\n    /** Removes the given `widget` from this toolbar. */\n    removeWidget(widget) {\n        const id = widget.getUniqueIdIn(__classPrivateFieldGet(this, _AbstractToolbar_widgetsById, \"f\"));\n        this.removeWidgetInternal(widget);\n        delete __classPrivateFieldGet(this, _AbstractToolbar_widgetsById, \"f\")[id];\n        __classPrivateFieldSet(this, _AbstractToolbar_widgetList, __classPrivateFieldGet(this, _AbstractToolbar_widgetList, \"f\").filter((otherWidget) => otherWidget !== widget), \"f\");\n    }\n    /** Returns a snapshot of the state of widgets in the toolbar. */\n    serializeState() {\n        const result = {};\n        for (const widgetId in __classPrivateFieldGet(this, _AbstractToolbar_widgetsById, \"f\")) {\n            result[widgetId] = __classPrivateFieldGet(this, _AbstractToolbar_widgetsById, \"f\")[widgetId].serializeState();\n        }\n        result[AbstractToolbar.rootToolbarId] = this.serializeInternal();\n        return JSON.stringify(result);\n    }\n    /**\n     * Deserialize toolbar widgets from the given state.\n     * Assumes that toolbar widgets are in the same order as when state was serialized.\n     */\n    deserializeState(state) {\n        const data = JSON.parse(state);\n        assertIsObject(data);\n        assertTruthy(data);\n        const rootId = AbstractToolbar.rootToolbarId;\n        if (rootId in data && typeof data[rootId] !== 'undefined') {\n            this.deserializeInternal(data[rootId]);\n        }\n        for (const widgetId in data) {\n            if (widgetId === rootId) {\n                continue;\n            }\n            if (!(widgetId in __classPrivateFieldGet(this, _AbstractToolbar_widgetsById, \"f\"))) {\n                console.warn(`Unable to deserialize widget ${widgetId} ­— no such widget.`);\n                continue;\n            }\n            if (typeof data[widgetId] === 'object' && data[widgetId]) {\n                __classPrivateFieldGet(this, _AbstractToolbar_widgetsById, \"f\")[widgetId].deserializeFrom(data[widgetId]);\n            }\n        }\n    }\n    /**\n     * Called by `serializeState` to attach any additional JSONifyable data\n     * to the serialized result.\n     *\n     * @returns an object that can be converted to JSON with `JSON.stringify`.\n     */\n    serializeInternal() { }\n    /**\n     * Called by `deserializeState` with a version of the JSON outputted\n     * previously by `serializeInternal`.\n     */\n    deserializeInternal(_json) { }\n    /**\n     * Creates, but does not add, an action button to this container.\n     *\n     * @see\n     * {@link addActionButton}\n     */\n    makeActionButton(title, command, options = true) {\n        // Parse options\n        if (typeof options === 'boolean') {\n            options = {\n                mustBeToplevel: options,\n            };\n        }\n        const mustBeToplevel = options.mustBeToplevel ?? true;\n        const autoDisableInReadOnlyEditors = options.autoDisableInReadOnlyEditors ?? true;\n        const titleString = typeof title === 'string' ? title : title.label;\n        const widgetId = 'action-button';\n        const makeIcon = () => {\n            if (typeof title === 'string') {\n                return null;\n            }\n            return title.icon;\n        };\n        const widget = new ActionButtonWidget(this.editor, widgetId, makeIcon, titleString, command, this.editor.localization, mustBeToplevel, autoDisableInReadOnlyEditors);\n        return widget;\n    }\n    /**\n     * Adds an action button with `title` to this toolbar (or to the given `parent` element).\n     *\n     * `options` can either be an object with properties `mustBeToplevel` and/or\n     * `autoDisableInReadOnlyEditors` or a boolean value. If a boolean, it is interpreted\n     * as being the value of `mustBeToplevel`.\n     *\n     * @return The added button.\n     *\n     * **Example**:\n     * ```ts,runnable\n     * import { Editor } from 'js-draw';\n     * const editor = new Editor(document.body);\n     * const toolbar = editor.addToolbar();\n     *\n     * function makeTrashIcon() {\n     *   const container = document.createElement('div');\n     *   container.textContent = '🗑️';\n     *   return container;\n     * }\n     *\n     * toolbar.addActionButton({\n     *   icon: makeTrashIcon(), // can be any Element not in the DOM\n     *   label: 'Delete all',\n     * }, () => {\n     *   alert('to-do!');\n     * });\n     */\n    addActionButton(title, command, options = true) {\n        const widget = this.makeActionButton(title, command, options);\n        this.addWidget(widget);\n        return widget;\n    }\n    /**\n     * Like {@link addActionButton}, except associates `tags` with the button that allow\n     * different toolbar styles to give the button tag-dependent styles.\n     */\n    addTaggedActionButton(tags, title, command, options = true) {\n        const widget = this.makeActionButton(title, command, options);\n        widget.setTags(tags);\n        this.addWidget(widget);\n        return widget;\n    }\n    /**\n     * Adds a save button that, when clicked, calls `saveCallback`.\n     *\n     * @example\n     * ```ts,runnable\n     * import { Editor, makeDropdownToolbar } from 'js-draw';\n     *\n     * const editor = new Editor(document.body);\n     * const toolbar = makeDropdownToolbar(editor);\n     *\n     * toolbar.addDefaults();\n     * toolbar.addSaveButton(() => alert('save clicked!'));\n     * ```\n     *\n     * `labelOverride` can optionally be used to change the `label` or `icon` of the button.\n     */\n    addSaveButton(saveCallback, labelOverride = {}) {\n        const widget = new SaveActionWidget(this.editor, this.localizationTable, saveCallback, labelOverride);\n        this.addWidget(widget);\n        return widget;\n    }\n    /**\n     * Adds an \"Exit\" button that, when clicked, calls `exitCallback`.\n     *\n     * **Note**: This is *roughly* equivalent to\n     * ```ts\n     * toolbar.addTaggedActionButton([ ToolbarWidgetTag.Exit ], {\n     *   label: this.editor.localization.exit,\n     *   icon: this.editor.icons.makeCloseIcon(),\n     *\n     *   // labelOverride can be used to override label or icon.\n     *   ...labelOverride,\n     * }, () => {\n     *   exitCallback();\n     * });\n     * ```\n     * with some additional configuration.\n     *\n     * @final\n     */\n    addExitButton(exitCallback, labelOverride = {}) {\n        const widget = new ExitActionWidget(this.editor, this.localizationTable, exitCallback, labelOverride);\n        this.addWidget(widget);\n        return widget;\n    }\n    /**\n     * Adds undo and redo buttons that trigger the editor's built-in undo and redo\n     * functionality.\n     */\n    addUndoRedoButtons(undoFirst = true) {\n        const makeUndo = () => {\n            return this.addTaggedActionButton([ToolbarWidgetTag.Undo], {\n                label: this.localizationTable.undo,\n                icon: this.editor.icons.makeUndoIcon(),\n            }, () => {\n                this.editor.history.undo();\n            });\n        };\n        const makeRedo = () => {\n            return this.addTaggedActionButton([ToolbarWidgetTag.Redo], {\n                label: this.localizationTable.redo,\n                icon: this.editor.icons.makeRedoIcon(),\n            }, () => {\n                this.editor.history.redo();\n            });\n        };\n        let undoButton;\n        let redoButton;\n        if (undoFirst) {\n            undoButton = makeUndo();\n            redoButton = makeRedo();\n        }\n        else {\n            redoButton = makeRedo();\n            undoButton = makeUndo();\n        }\n        undoButton.setDisabled(true);\n        redoButton.setDisabled(true);\n        this.editor.notifier.on(EditorEventType.UndoRedoStackUpdated, (event) => {\n            if (event.kind !== EditorEventType.UndoRedoStackUpdated) {\n                throw new Error('Wrong event type!');\n            }\n            undoButton.setDisabled(event.undoStackSize === 0);\n            redoButton.setDisabled(event.redoStackSize === 0);\n        });\n    }\n    /**\n     * Adds widgets for pen/eraser/selection/text/pan-zoom primary tools.\n     *\n     * If `filter` returns `false` for a tool, no widget is added for that tool.\n     * See {@link addDefaultToolWidgets}\n     */\n    addWidgetsForPrimaryTools(filter) {\n        for (const tool of this.editor.toolController.getPrimaryTools()) {\n            if (filter && !filter?.(tool)) {\n                continue;\n            }\n            if (tool instanceof PenTool) {\n                const widget = new PenToolWidget(this.editor, tool, this.localizationTable);\n                this.addWidget(widget);\n            }\n            else if (tool instanceof EraserTool) {\n                this.addWidget(new EraserWidget(this.editor, tool, this.localizationTable));\n            }\n            else if (tool instanceof SelectionTool) {\n                this.addWidget(new SelectionToolWidget(this.editor, tool, this.localizationTable));\n            }\n            else if (tool instanceof TextTool) {\n                this.addWidget(new TextToolWidget(this.editor, tool, this.localizationTable));\n            }\n            else if (tool instanceof PanZoomTool) {\n                this.addWidget(new HandToolWidget(this.editor, tool, this.localizationTable));\n            }\n        }\n    }\n    /**\n     * Adds toolbar widgets based on the enabled tools, and additional tool-like\n     * buttons (e.g. {@link DocumentPropertiesWidget} and {@link InsertImageWidget}).\n     */\n    addDefaultToolWidgets() {\n        this.addWidgetsForPrimaryTools();\n        this.addDefaultEditorControlWidgets();\n    }\n    /**\n     * Adds widgets that don't correspond to tools, but do allow the user to control\n     * the editor in some way.\n     *\n     * By default, this includes {@link DocumentPropertiesWidget} and {@link InsertImageWidget}.\n     */\n    addDefaultEditorControlWidgets() {\n        this.addWidget(new DocumentPropertiesWidget(this.editor, this.localizationTable));\n        this.addWidget(new InsertImageWidget(this.editor, this.localizationTable));\n    }\n    addDefaultActionButtons() {\n        this.addUndoRedoButtons();\n    }\n    /**\n     * Remove this toolbar from its container and clean up listeners.\n     * This should only be called **once** for a given toolbar.\n     */\n    remove() {\n        this.closeColorPickerOverlay?.remove();\n        for (const listener of __classPrivateFieldGet(this, _AbstractToolbar_listeners, \"f\")) {\n            listener.remove();\n        }\n        __classPrivateFieldSet(this, _AbstractToolbar_listeners, [], \"f\");\n        this.onRemove();\n        for (const widget of __classPrivateFieldGet(this, _AbstractToolbar_widgetList, \"f\")) {\n            widget.remove();\n        }\n    }\n    /**\n     * Removes `listener` when {@link remove} is called.\n     */\n    manageListener(listener) {\n        __classPrivateFieldGet(this, _AbstractToolbar_listeners, \"f\").push(listener);\n    }\n}\n_AbstractToolbar_listeners = new WeakMap(), _AbstractToolbar_widgetsById = new WeakMap(), _AbstractToolbar_widgetList = new WeakMap(), _AbstractToolbar_updateColoris = new WeakMap();\nAbstractToolbar.colorisStarted = false;\nAbstractToolbar.rootToolbarId = 'root-toolbar--';\nexport default AbstractToolbar;\n","import  { defaultToolbarLocalization }  from './localization.mjs';\nimport  OverflowWidget  from './widgets/OverflowWidget.mjs';\nimport  AbstractToolbar  from './AbstractToolbar.mjs';\nimport  { toolbarCSSPrefix }  from './constants.mjs';\n/**\n * @example\n *\n * ```ts,runnable\n * import { makeDropdownToolbar, Editor } from 'js-draw';\n *\n * const editor = new Editor(document.body);\n * const toolbar = makeDropdownToolbar(editor);\n * toolbar.addDefaults();\n *\n * toolbar.addExitButton(editor => {\n *   // TODO\n * });\n *\n * toolbar.addSaveButton(editor => {\n *   // TODO\n * });\n * ```\n *\n * Returns a subclass of {@link AbstractToolbar}.\n *\n * @see\n * - {@link makeEdgeToolbar}\n * - {@link AbstractToolbar.addSaveButton}\n * - {@link AbstractToolbar.addExitButton}\n */\nexport const makeDropdownToolbar = (editor) => {\n    return new DropdownToolbar(editor, editor.getRootElement());\n};\nexport default class DropdownToolbar extends AbstractToolbar {\n    /** @internal */\n    constructor(editor, parent, localizationTable = defaultToolbarLocalization) {\n        super(editor, localizationTable);\n        // Flex-order of the next widget to be added.\n        this.widgetOrderCounter = 0;\n        // Widget to toggle overflow menu.\n        this.overflowWidget = null;\n        this.reLayoutQueued = false;\n        this.container = document.createElement('div');\n        this.container.classList.add(`${toolbarCSSPrefix}root`);\n        this.container.classList.add(`${toolbarCSSPrefix}element`);\n        this.container.classList.add(`${toolbarCSSPrefix}dropdown-toolbar`);\n        this.container.setAttribute('role', 'toolbar');\n        parent.appendChild(this.container);\n        if ('ResizeObserver' in window) {\n            this.resizeObserver = new ResizeObserver((_entries) => {\n                this.reLayout();\n            });\n            this.resizeObserver.observe(this.container);\n        }\n        else {\n            console.warn('ResizeObserver not supported. Toolbar will not resize.');\n        }\n    }\n    queueReLayout() {\n        if (!this.reLayoutQueued) {\n            this.reLayoutQueued = true;\n            requestAnimationFrame(() => this.reLayout());\n        }\n    }\n    reLayout() {\n        this.reLayoutQueued = false;\n        if (!this.overflowWidget) {\n            return;\n        }\n        const getTotalWidth = (widgetList) => {\n            let totalWidth = 0;\n            for (const widget of widgetList) {\n                if (!widget.isHidden()) {\n                    totalWidth += widget.getButtonWidth();\n                }\n            }\n            return totalWidth;\n        };\n        // Returns true if there is enough empty space to move the first child\n        // from the overflow menu to the main menu.\n        const canRemoveFirstChildFromOverflow = (freeSpaceInMainMenu) => {\n            const overflowChildren = this.overflowWidget?.getChildWidgets() ?? [];\n            if (overflowChildren.length === 0) {\n                return false;\n            }\n            return overflowChildren[0].getButtonWidth() <= freeSpaceInMainMenu;\n        };\n        const allWidgets = this.getAllWidgets();\n        let overflowWidgetsWidth = getTotalWidth(this.overflowWidget.getChildWidgets());\n        let shownWidgetWidth = getTotalWidth(allWidgets) - overflowWidgetsWidth;\n        let availableWidth = this.container.clientWidth * 0.87;\n        // If on a device that has enough vertical space, allow\n        // showing two rows of buttons.\n        // TODO: Fix magic numbers\n        if (window.innerHeight > availableWidth * 1.75) {\n            availableWidth *= 1.75;\n        }\n        let updatedChildren = false;\n        // If we can remove at least one child from the overflow menu,\n        if (canRemoveFirstChildFromOverflow(availableWidth - shownWidgetWidth)) {\n            // Move widgets to the main menu.\n            const overflowChildren = this.overflowWidget.clearChildren();\n            for (const child of overflowChildren) {\n                child.addTo(this.container);\n                child.setIsToplevel(true);\n                if (!child.isHidden()) {\n                    shownWidgetWidth += child.getButtonWidth();\n                }\n            }\n            overflowWidgetsWidth = 0;\n            updatedChildren = true;\n        }\n        if (shownWidgetWidth >= availableWidth) {\n            // Move widgets to the overflow menu.\n            // Start with the rightmost widget, move to the leftmost\n            for (let i = allWidgets.length - 1; i >= 0 && shownWidgetWidth >= availableWidth; i--) {\n                const child = allWidgets[i];\n                if (this.overflowWidget.hasAsChild(child)) {\n                    continue;\n                }\n                if (child.canBeInOverflowMenu()) {\n                    shownWidgetWidth -= child.getButtonWidth();\n                    this.overflowWidget.addToOverflow(child);\n                }\n            }\n            updatedChildren = true;\n        }\n        // Hide/show the overflow widget.\n        this.overflowWidget.setHidden(this.overflowWidget.getChildWidgets().length === 0);\n        if (updatedChildren) {\n            this.setupColorPickers();\n        }\n    }\n    addWidgetInternal(widget) {\n        const container = widget.addTo(this.container);\n        // Ensure that the widget gets displayed in the correct\n        // place in the toolbar, even if it's removed and re-added.\n        container.style.order = `${this.widgetOrderCounter++}`;\n        this.queueReLayout();\n    }\n    removeWidgetInternal(widget) {\n        widget.remove();\n        this.queueReLayout();\n    }\n    addSpacer(options = {}) {\n        const spacer = document.createElement('div');\n        spacer.classList.add(`${toolbarCSSPrefix}spacer`);\n        if (options.grow) {\n            spacer.style.flexGrow = `${options.grow}`;\n        }\n        if (options.minSize) {\n            spacer.style.minWidth = options.minSize;\n        }\n        if (options.maxSize) {\n            spacer.style.maxWidth = options.maxSize;\n        }\n        spacer.style.order = `${this.widgetOrderCounter++}`;\n        this.container.appendChild(spacer);\n    }\n    /**\n     * Adds a widget that toggles the overflow menu. Call `addOverflowWidget` to ensure\n     * that this widget is in the correct space (if shown).\n     *\n     * @example\n     * ```ts\n     * toolbar.addDefaultToolWidgets();\n     * toolbar.addOverflowWidget();\n     * toolbar.addDefaultActionButtons();\n     * ```\n     * shows the overflow widget between the default tool widgets and the default action buttons,\n     * if shown.\n     */\n    addOverflowWidget() {\n        this.overflowWidget = new OverflowWidget(this.editor, this.localizationTable);\n        this.addWidget(this.overflowWidget);\n    }\n    /**\n     * Adds both the default tool widgets and action buttons. Equivalent to\n     * ```ts\n     * toolbar.addDefaultToolWidgets();\n     * toolbar.addOverflowWidget();\n     * toolbar.addDefaultActionButtons();\n     * ```\n     */\n    addDefaults() {\n        this.addDefaultToolWidgets();\n        this.addOverflowWidget();\n        this.addDefaultActionButtons();\n    }\n    onRemove() {\n        this.container.remove();\n        this.resizeObserver.disconnect();\n    }\n}\n","import  { ToolbarWidgetTag }  from './widgets/BaseWidget.mjs';\nimport  { toolbarCSSPrefix }  from './constants.mjs';\nimport  EdgeToolbarLayoutManager  from './widgets/layout/EdgeToolbarLayoutManager.mjs';\nimport  { MutableReactiveValue, ReactiveValue }  from '../util/ReactiveValue.mjs';\nimport  AbstractToolbar  from './AbstractToolbar.mjs';\nimport  stopPropagationOfScrollingWheelEvents  from '../util/stopPropagationOfScrollingWheelEvents.mjs';\nimport  makeDraggable  from './utils/makeDraggable.mjs';\n/**\n * Creates an `EdgeToolbar`.\n *\n * [Credit for the original design of this UI](https://www.figma.com/file/NA5F2AMWO3wUuaoDfUaAb8/Material-3-wireframes?type=design&node-id=54490%3A1103&mode=design&t=Ee0UwnPnQ2bNC2uM-1).\n *\n * @example\n *\n * ```ts,runnable\n * import { makeEdgeToolbar, Editor } from 'js-draw';\n *\n * const editor = new Editor(document.body);\n * const toolbar = makeEdgeToolbar(editor);\n * toolbar.addDefaults();\n *\n * toolbar.addSaveButton(editor => {\n *   // TODO\n * });\n *\n * toolbar.addExitButton(editor => {\n *   // TODO\n * });\n * ```\n *\n * @see\n * - {@link makeDropdownToolbar}\n * - {@link AbstractToolbar.addSaveButton}\n * - {@link AbstractToolbar.addExitButton}\n */\nexport const makeEdgeToolbar = (editor) => {\n    return new EdgeToolbar(editor, editor.getRootElement(), editor.localization);\n};\nexport default class EdgeToolbar extends AbstractToolbar {\n    /** @internal */\n    constructor(editor, parent, localizationTable) {\n        super(editor, localizationTable);\n        this.clearDragListeners = null;\n        this.toolbarContainer = document.createElement('div');\n        this.toolbarContainer.classList.add(`${toolbarCSSPrefix}root`);\n        this.toolbarContainer.classList.add(`${toolbarCSSPrefix}element`);\n        this.toolbarContainer.classList.add(`${toolbarCSSPrefix}edge-toolbar`);\n        this.toolbarContainer.setAttribute('role', 'toolbar');\n        this.toolbarActionRow = document.createElement('div');\n        this.toolbarActionRow.classList.add('toolbar-element', 'toolbar-action-row');\n        this.toolbarToolRow = document.createElement('div');\n        this.toolbarToolRow.classList.add('toolbar-element', 'toolbar-tool-row');\n        stopPropagationOfScrollingWheelEvents(this.toolbarToolRow);\n        if ('ResizeObserver' in window) {\n            this.toolRowResizeObserver = new ResizeObserver((_entries) => {\n                this.onToolbarRowResize();\n            });\n            this.toolRowResizeObserver.observe(this.toolbarToolRow);\n        }\n        else {\n            console.warn('ResizeObserver not supported. Toolbar will not resize.');\n        }\n        this.toolbarContainer.replaceChildren(this.toolbarActionRow, this.toolbarToolRow);\n        parent.appendChild(this.toolbarContainer);\n        this.sidebarVisible = ReactiveValue.fromInitialValue(false);\n        this.sidebarY = ReactiveValue.fromInitialValue(0);\n        // Create the container elements\n        this.menuContainer = document.createElement('div');\n        this.menuContainer.classList.add(`${toolbarCSSPrefix}edgemenu-container`);\n        this.sidebarContainer = document.createElement('div');\n        this.sidebarContainer.classList.add(`${toolbarCSSPrefix}edgemenu`, `${toolbarCSSPrefix}element`);\n        this.sidebarContainer.classList.add(`${toolbarCSSPrefix}tool-properties`);\n        this.sidebarContent = document.createElement('div');\n        // Setup resizing/dragging\n        this.sidebarY.onUpdateAndNow((y) => {\n            const belowEdgeClassName = 'dropdown-below-edge';\n            if (y > 0) {\n                this.sidebarContainer.style.transform = `translate(0, ${y}px)`;\n                this.sidebarContainer.style.paddingBottom = '';\n                this.menuContainer.classList.add(belowEdgeClassName);\n            }\n            else {\n                this.sidebarContainer.style.transform = '';\n                this.sidebarContainer.style.paddingBottom = `${-y}px`;\n                this.menuContainer.classList.remove(belowEdgeClassName);\n            }\n        });\n        this.closeButton = document.createElement('button');\n        this.closeButton.classList.add('drag-elem');\n        // The close button has default focus -- forward its events to the main editor so that keyboard\n        // shortcuts still work.\n        this.editor.handleKeyEventsFrom(this.closeButton, (event) => {\n            // Don't send\n            return event.code !== 'Space' && event.code !== 'Enter' && event.code !== 'Tab';\n        });\n        // Close the sidebar when pressing escape\n        this.sidebarContainer.addEventListener('keyup', (event) => {\n            if (!event.defaultPrevented && event.code === 'Escape') {\n                this.sidebarVisible.set(false);\n                event.preventDefault();\n            }\n        });\n        this.initDragListeners();\n        // Initialize the layout manager\n        const setSidebarContent = (...content) => {\n            this.sidebarContent.replaceChildren(...content);\n            this.setupColorPickers();\n        };\n        this.sidebarTitle = MutableReactiveValue.fromInitialValue('');\n        this.layoutManager = new EdgeToolbarLayoutManager(setSidebarContent, this.sidebarTitle, this.sidebarVisible, editor.announceForAccessibility.bind(editor), localizationTable);\n        this.sidebarTitle.onUpdateAndNow((title) => {\n            this.closeButton.setAttribute('aria-label', localizationTable.closeSidebar(title));\n        });\n        // Make things visible/keep hidden.\n        this.listenForVisibilityChanges();\n        this.sidebarContainer.replaceChildren(this.closeButton, this.sidebarContent);\n        this.menuContainer.replaceChildren(this.sidebarContainer);\n        parent.appendChild(this.menuContainer);\n    }\n    listenForVisibilityChanges() {\n        let animationTimeout = null;\n        const animationDuration = 170;\n        if (!this.sidebarVisible.get()) {\n            this.menuContainer.style.display = 'none';\n            // Set the initial opacity to 0 to allow the `transition` property\n            // to animate it to 1.\n            this.menuContainer.style.opacity = '0';\n        }\n        const prefersReduceMotion = window.matchMedia?.('(prefers-reduced-motion: reduce)') ?? '';\n        this.sidebarVisible.onUpdate((visible) => {\n            const animationProperties = `${animationDuration}ms ease`;\n            // We need to use different animations when reducing motion.\n            const reduceMotion = prefersReduceMotion.matches ? '-reduce-motion' : '';\n            if (visible) {\n                this.sidebarY.set(this.snappedSidebarY());\n                if (animationTimeout) {\n                    clearTimeout(animationTimeout);\n                    animationTimeout = null;\n                }\n                this.menuContainer.style.display = '';\n                this.sidebarContainer.style.animation = `${animationProperties} ${toolbarCSSPrefix}-edgemenu-transition-in${reduceMotion}`;\n                this.menuContainer.style.animation = `${animationProperties} ${toolbarCSSPrefix}-edgemenu-container-transition-in${reduceMotion}`;\n                this.menuContainer.style.opacity = '1';\n                // Focus the close button when first shown, but prevent scroll because the button\n                // is likely at the bottom of the screen (and we want the full sidebar to remain\n                // visible).\n                this.closeButton.focus({ preventScroll: true });\n            }\n            else {\n                this.closeColorPickers();\n                if (animationTimeout === null) {\n                    this.sidebarContainer.style.animation = `${animationProperties} ${toolbarCSSPrefix}-edgemenu-transition-out${reduceMotion}`;\n                    this.menuContainer.style.animation = `${animationProperties} ${toolbarCSSPrefix}-edgemenu-container-transition-out${reduceMotion}`;\n                    // Manually set the container's opacity to prevent flickering when closing\n                    // the toolbar.\n                    this.menuContainer.style.opacity = '0';\n                    // Hide overflow -- don't show the part of the edge toolbar that's outside of\n                    // the editor.\n                    //this.menuContainer.style.overflowY = 'hidden';\n                    this.editor.announceForAccessibility(this.localizationTable.dropdownHidden(this.sidebarTitle.get()));\n                    animationTimeout = setTimeout(() => {\n                        this.menuContainer.style.display = 'none';\n                        this.menuContainer.style.overflowY = '';\n                        animationTimeout = null;\n                    }, animationDuration);\n                }\n            }\n        });\n    }\n    onToolbarRowResize() {\n        const setExtraPadding = () => {\n            const visibleWidth = this.toolbarToolRow.clientWidth;\n            // Determine whether extra spacing needs to be added so that one button is cut\n            // in half. Ideally, when there is scroll, one button will be cut in half to show\n            // that scrolling is possible.\n            let currentWidth = 0;\n            let extraPadding = 0;\n            let numVisibleButtons = 0;\n            for (const child of this.toolbarToolRow.children) {\n                // Use the first child -- padding is applied around that child. Assumes\n                // that the button's width is its height plus some padding.\n                const buttonBaseSize = child.clientHeight;\n                currentWidth += buttonBaseSize;\n                numVisibleButtons++;\n                if (currentWidth > visibleWidth) {\n                    // We want extraPadding + (currentWidth - buttonWidth / 2) = visibleWidth.\n                    // Thus, extraPadding = visibleWidth - currentWidth + buttonWidth / 2;\n                    extraPadding = visibleWidth - currentWidth + buttonBaseSize / 2;\n                    // Ensure that the padding is positive\n                    if (extraPadding < 0) {\n                        extraPadding += buttonBaseSize;\n                    }\n                    break;\n                }\n            }\n            const perButtonPadding = Math.round((extraPadding / numVisibleButtons) * 10) / 10;\n            this.toolbarToolRow.style.setProperty('--extra-left-right-padding', `${perButtonPadding}px`);\n        };\n        const actionRowBBox = this.toolbarActionRow.getBoundingClientRect();\n        const toolbarRowBBox = this.toolbarToolRow.getBoundingClientRect();\n        const onDifferentRows = actionRowBBox.y + actionRowBBox.height <= toolbarRowBBox.y;\n        if (onDifferentRows) {\n            this.toolbarContainer.classList.remove('one-row');\n        }\n        else {\n            this.toolbarContainer.classList.add('one-row');\n        }\n        if (this.toolbarToolRow.clientWidth < this.toolbarToolRow.scrollWidth) {\n            this.toolbarToolRow.classList.add('has-scroll');\n            // Note: This can potentially change the size of the tool row.\n            // Because this is run inside of a ResizeObserver callback, special\n            // care must be taken to ensure that this change doesn't re-trigger\n            // the resize observer.\n            setExtraPadding();\n        }\n        else {\n            this.toolbarToolRow.classList.remove('has-scroll', 'extra-padding');\n        }\n    }\n    addSpacer(_options) {\n        //throw new Error('Method not implemented.');\n        // Unused for this toolbar.\n    }\n    addUndoRedoButtons() {\n        super.addUndoRedoButtons(false);\n    }\n    addDefaults() {\n        this.addDefaultActionButtons();\n        this.addDefaultToolWidgets();\n    }\n    updateWidgetCSSClasses(widget) {\n        const tags = widget.getTags();\n        widget.removeCSSClassFromContainer('label-inline');\n        widget.removeCSSClassFromContainer('label-left');\n        widget.removeCSSClassFromContainer('label-right');\n        if (tags.includes(ToolbarWidgetTag.Save)) {\n            widget.addCSSClassToContainer('label-inline');\n            widget.addCSSClassToContainer('label-left');\n        }\n        if (tags.includes(ToolbarWidgetTag.Exit)) {\n            widget.addCSSClassToContainer('label-inline');\n            widget.addCSSClassToContainer('label-right');\n        }\n    }\n    addWidgetInternal(widget) {\n        this.updateWidgetCSSClasses(widget);\n        widget.setLayoutManager(this.layoutManager);\n        if (widget.mustBeInToplevelMenu()) {\n            widget.addTo(this.toolbarActionRow);\n        }\n        else {\n            widget.addTo(this.toolbarToolRow);\n        }\n    }\n    removeWidgetInternal(widget) {\n        widget.remove();\n    }\n    onRemove() {\n        this.toolbarContainer.remove();\n        this.menuContainer.remove();\n        this.toolRowResizeObserver.disconnect();\n        this.clearDragListeners?.();\n    }\n    initDragListeners() {\n        const dragElements = [this.closeButton, this.sidebarContainer, this.sidebarContent];\n        // Forward longer touch events from the menu background to the\n        // editor (and close the sidebar).\n        this.manageListener(this.editor.handlePointerEventsExceptClicksFrom(this.menuContainer, (eventName, event) => {\n            if (event.target === this.menuContainer) {\n                if (eventName === 'pointerdown') {\n                    this.sidebarVisible.set(false);\n                    // A delay seems necessary for the editor\n                    setTimeout(() => this.editor.focus(), 0);\n                }\n                return true;\n            }\n            if (!this.sidebarVisible.get()) {\n                return true;\n            }\n            // Don't send pointer events that don't directly target mainContainer\n            // to the editor\n            return false;\n        }, (_eventName, event) => {\n            return event.target === this.menuContainer;\n        }));\n        // Set lastGestureWasRoughlyClick to `true` initially because on page load\n        // performance.now() is zero.\n        let lastGestureWasRoughlyClick = true;\n        let gestureEndTimestamp = 0;\n        const dragController = makeDraggable(this.sidebarContainer, {\n            draggableChildElements: dragElements,\n            onDrag: (deltaX, deltaY) => this.handleDrag(deltaX, deltaY),\n            onDragEnd: (dragStatistics) => {\n                gestureEndTimestamp = dragStatistics.endTimestamp;\n                lastGestureWasRoughlyClick = dragStatistics.roughlyClick;\n                this.finalizeDrag();\n            },\n        });\n        this.clearDragListeners = () => dragController.removeListeners();\n        this.closeButton.onclick = () => {\n            const wasJustDragging = performance.now() - gestureEndTimestamp < 100;\n            // Ignore the click event if it was caused by dragging the button.\n            if ((wasJustDragging && lastGestureWasRoughlyClick) || !wasJustDragging) {\n                this.sidebarVisible.set(false);\n            }\n        };\n    }\n    /**\n     * Updates the position of this menu **during** a drag. After a drag ends,\n     * {@link finalizeDrag} should be called.\n     */\n    handleDrag(_deltaX, deltaY) {\n        this.sidebarContainer.style.transition = 'none';\n        this.sidebarY.set(this.sidebarY.get() + deltaY);\n    }\n    /** Returns `this.sidebarY` rounded to a valid value. */\n    snappedSidebarY(sidebarY) {\n        const y = sidebarY ?? this.sidebarY.get();\n        const snapYs = [-100, 0];\n        // Allow some amount of scrolling if the sidebar is too tall to fit entirely\n        // in the window.\n        if (this.sidebarContainer.clientHeight > window.innerHeight) {\n            snapYs.push(100);\n        }\n        let closestSnap = snapYs[0];\n        for (const snapY of snapYs) {\n            if (Math.abs(snapY - y) < Math.abs(closestSnap - y)) {\n                closestSnap = snapY;\n            }\n        }\n        return closestSnap;\n    }\n    /**\n     * Moves the menu to a valid location or closes it, depending on\n     * the position set by the drag.\n     */\n    finalizeDrag() {\n        this.sidebarContainer.style.transition = '';\n        if (this.sidebarY.get() > this.sidebarContainer.clientHeight / 2) {\n            this.sidebarVisible.set(false);\n        }\n        else {\n            // Snap to the closest valid Y.\n            this.sidebarY.set(this.snappedSidebarY());\n        }\n    }\n    serializeInternal() {\n        return {\n            menuSizeY: this.snappedSidebarY(),\n        };\n    }\n    deserializeInternal(json) {\n        if (typeof json === 'object' && typeof json['menuSizeY'] === 'number') {\n            // Load the y-position of the sidebar  -- call snappedSidebarY to ensure validity.\n            this.sidebarY.set(this.snappedSidebarY(json['menuSizeY']));\n        }\n    }\n}\n","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _IconProvider_instances, _IconProvider_makeXIcon;\nimport { Vec2, Color4 } from '@js-draw/math';\nimport  SVGRenderer  from '../rendering/renderers/SVGRenderer.mjs';\nimport  Viewport  from '../Viewport.mjs';\nimport  { makeFreehandLineBuilder }  from '../components/builders/FreehandLineBuilder.mjs';\nimport  { makePolylineBuilder }  from '../components/builders/PolylineBuilder.mjs';\nimport  { EraserMode }  from '../tools/Eraser.mjs';\nimport  { createSvgElement, createSvgElements, createSvgPaths }  from '../util/createElement.mjs';\nconst svgNamespace = 'http://www.w3.org/2000/svg';\nlet checkerboardIdCounter = 0;\nconst makeCheckerboardPattern = () => {\n    const id = `checkerboard-${checkerboardIdCounter++}`;\n    const patternElement = createSvgElement('pattern', {\n        id: id,\n        viewBox: '0,0,10,10',\n        width: '20%',\n        height: '20%',\n        patternUnits: 'userSpaceOnUse',\n        children: createSvgElements('rect', [\n            { x: 0, y: 0, width: 10, height: 10, fill: 'white' },\n            { x: 0, y: 0, width: 5, height: 5, fill: 'gray' },\n            { x: 5, y: 5, width: 5, height: 5, fill: 'gray' },\n        ]),\n    });\n    const patternRef = `url(#${id})`;\n    return {\n        patternDefElement: patternElement,\n        // @deprecated use patternDefElement\n        get patternDef() {\n            return patternElement.innerHTML;\n        },\n        patternRef,\n    };\n};\nconst makeRedoIcon = (mirror) => {\n    const icon = document.createElementNS(svgNamespace, 'svg');\n    icon.innerHTML = `\n\t\t<style>\n\t\t\t.toolbar-svg-undo-redo-icon {\n\t\t\t\tstroke: var(--icon-color);\n\t\t\t\tstroke-width: 12;\n\t\t\t\tstroke-linejoin: round;\n\t\t\t\tstroke-linecap: round;\n\t\t\t\tfill: none;\n\n\t\t\t\ttransform-origin: center;\n\t\t\t}\n\t\t</style>\n\t`;\n    const path = document.createElementNS(svgNamespace, 'path');\n    path.setAttribute('d', 'M20,20 A15,15 0 0 1 70,80 L80,90 L60,70 L65,90 L87,90 L65,80');\n    path.classList.add('toolbar-svg-undo-redo-icon');\n    if (mirror) {\n        path.style.transform = 'scale(-1, 1)';\n    }\n    icon.appendChild(path);\n    icon.setAttribute('viewBox', '0 0 100 100');\n    return icon;\n};\n/**\n * Provides icons that can be used in the toolbar and other locations.\n *\n * To customize the icons used by the editor, extend this class and override methods.\n *\n * @example\n * ```ts,runnable\n * import * as jsdraw from 'js-draw';\n *\n * class CustomIconProvider extends jsdraw.IconProvider {\n *     // Use '☺' instead of the default dropdown symbol.\n *     public override makeDropdownIcon() {\n *         const icon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n *         icon.innerHTML = `\n *             <text x='5' y='55' style='fill: var(--icon-color); font-size: 50pt;'>☺</text>\n *         `;\n *         icon.setAttribute('viewBox', '0 0 100 100');\n *         return icon;\n *     }\n * }\n *\n * const icons = new CustomIconProvider();\n * const editor = new jsdraw.Editor(document.body, {\n *     // The icon pack to use is specified through the editor's initial\n *     // configuration object:\n *     iconProvider: icons,\n * });\n *\n * // Add a toolbar that uses these icons\n * jsdraw.makeDropdownToolbar(editor).addDefaults();\n * ```\n */\nclass IconProvider {\n    constructor() {\n        _IconProvider_instances.add(this);\n    }\n    makeUndoIcon() {\n        return makeRedoIcon(true);\n    }\n    // @returns a redo icon.\n    makeRedoIcon() {\n        return makeRedoIcon(false);\n    }\n    makeDropdownIcon() {\n        const icon = this.makeIconFromPath('M5,10 L50,90 L95,10 Z');\n        icon.setAttribute('viewBox', '-10 -10 110 110');\n        return icon;\n    }\n    makeEraserIcon(eraserSize, mode) {\n        eraserSize ??= 10;\n        const scaledSize = eraserSize / 4;\n        const eraserColor = '#ff70af';\n        // Draw an eraser-like shape. Created with Inkscape\n        const icon = createSvgElement('svg', {\n            viewBox: '0 0 120 120',\n            children: [\n                createSvgElement('defs', {\n                    children: [\n                        createSvgElement('linearGradient', {\n                            id: 'dash-pattern',\n                            children: createSvgElements('stop', [\n                                { offset: '80%', 'stop-color': eraserColor },\n                                { offset: '85%', 'stop-color': 'white' },\n                                { offset: '90%', 'stop-color': eraserColor },\n                            ]),\n                        }),\n                    ],\n                }),\n                createSvgElement('path', {\n                    fill: mode === EraserMode.PartialStroke ? 'url(#dash-pattern)' : eraserColor,\n                    stroke: 'black',\n                    transform: 'rotate(41.35)',\n                    d: `\n\t\t\t\t\t\tM 52.5 27\n\t\t\t\t\t\tC 50 28.9 48.9 31.7 48.9 34.8\n\t\t\t\t\t\tL 48.9 39.8\n\t\t\t\t\t\tC 48.9 45.3 53.4 49.8 58.9 49.8\n\t\t\t\t\t\tL 103.9 49.8\n\t\t\t\t\t\tC 105.8 49.8 107.6 49.2 109.1 48.3\n\t\t\t\t\t\tL 110.2 ${scaledSize + 49.5} L 159.7 ${scaledSize + 5}\n\t\t\t\t\t\tL 157.7 ${-scaledSize + 5.2} L 112.4 ${49.5 - scaledSize}\n\t\t\t\t\t\tC 113.4 43.5 113.9 41.7 113.9 39.8\n\t\t\t\t\t\tL 113.9 34.8\n\t\t\t\t\t\tC 113.9 29.3 109.4 24.8 103.9 24.8\n\t\t\t\t\t\tL 58.9 24.8\n\t\t\t\t\t\tC 56.5 24.8 54.3 25.7 52.5 27\n\t\t\t\t\t\tz\n\t\t\t\t\t`,\n                }),\n                createSvgElement('rect', {\n                    stroke: '#cc8077',\n                    fill: 'var(--icon-color)',\n                    width: 65,\n                    height: 75,\n                    x: 48.9,\n                    y: -38.7,\n                    transform: 'rotate(41.35)',\n                }),\n            ],\n        });\n        return icon;\n    }\n    makeSelectionIcon() {\n        const icon = document.createElementNS(svgNamespace, 'svg');\n        // Draw a cursor-like shape\n        icon.innerHTML = `\n\t\t<g>\n\t\t\t<rect x=\"10\" y=\"10\" width=\"70\" height=\"70\" fill=\"pink\" stroke=\"black\"/>\n\t\t\t<rect x=\"75\" y=\"75\" width=\"10\" height=\"10\" fill=\"white\" stroke=\"black\"/>\n\t\t</g>\n\t\t`;\n        icon.setAttribute('viewBox', '0 0 100 100');\n        return icon;\n    }\n    makeRotateIcon() {\n        const icon = document.createElementNS(svgNamespace, 'svg');\n        icon.innerHTML = `\n\t\t\t<defs>\n\t\t\t\t<marker\n\t\t\t\t\tid=\"arrow-marker\"\n\t\t\t\t\tviewBox=\"0 0 10 10\"\n\t\t\t\t\trefX=\"3\" refY=\"5\"\n\t\t\t\t\tmarkerWidth=\"3\" markerHeight=\"3\"\n\t\t\t\t\torient=\"auto-start-reverse\"\n\t\t\t\t>\n\t\t\t\t\t<path\n\t\t\t\t\t\td=\"M0,0 L8,5 L0,10z\"\n\t\t\t\t\t\tfill=\"var(--icon-color)\"\n\t\t\t\t\t/>\n\t\t\t\t</marker>\n\t\t\t</defs>\n\n\t\t\t<path\n\t\t\t\tmarker-start=\"url(#arrow-marker)\"\n\t\t\t\td=\"\n\t\t\t\t\tM20,20\n\t\t\t\t\tA30,30 0 1 1 80 80\n\t\t\t\t\"\n\t\t\t\tfill=\"none\"\n\t\t\t\tstroke=\"var(--icon-color)\"\n\t\t\t\tstroke-width=\"12\"\n\t\t\t/>\n\t\t\t<path\n\t\t\t\td=\"\n\t\t\t\t\tM80,80\n\t\t\t\t\tA30,30 0 1 1 20 20\n\t\t\t\t\"\n\t\t\t\tfill=\"none\"\n\t\t\t\tstroke=\"var(--icon-color)\"\n\t\t\t\tstroke-width=\"12\"\n\t\t\t\tstroke-dasharray=\"30 10 20 10 20 10 10\"\n\t\t\t\tstyle=\"stroke-linecap: butt;\"\n\t\t\t/>\n\t\t`;\n        icon.setAttribute('viewBox', '-5 -5 110 110');\n        return icon;\n    }\n    makeHandToolIcon() {\n        const fill = 'none';\n        const strokeColor = 'var(--icon-color)';\n        const strokeWidth = '3';\n        // Draw a cursor-like shape\n        return this.makeIconFromPath(`\n\t\t\tm 10,60\n\t\t\t\t5,30\n\t\t\tH 90\n\t\t\tV 30\n\t\t\tC 90,20 75,20 75,30\n\t\t\tV 60\n\t\t\t\t20\n\t\t\tC 75,10 60,10 60,20\n\t\t\tV 60\n\t\t\t\t15\n\t\t\tC 60,5 45,5 45,15\n\t\t\tV 60\n\t\t\t\t25\n\t\t\tC 45,15 30,15 30,25\n\t\t\tV 60\n\t\t\t\t75\n\t\t\tL 25,60\n\t\t\tC 20,45 10,50 10,60\n\t\t\tZ\n\t\t`, fill, strokeColor, strokeWidth);\n    }\n    makeTouchPanningIcon() {\n        const fill = 'none';\n        const strokeColor = 'var(--icon-color)';\n        const strokeWidth = '3';\n        return this.makeIconFromPath(`\n\t\t\tM 5,5.5\n\t\t\tV 17.2\n\t\t\tL 16.25,5.46\n\t\t\tZ\n\t\n\t\t\tm 33.75,0\n\t\t\tL 50,17\n\t\t\tV 5.5\n\t\t\tZ\n\t\n\t\t\tM 5,40.7\n\t\t\tv 11.7\n\t\t\th 11.25\n\t\t\tz\n\t\n\t\t\tM 26,19\n\t\t\tC 19.8,19.4 17.65,30.4 21.9,34.8\n\t\t\tL 50,70\n\t\t\tH 27.5\n\t\t\tc -11.25,0 -11.25,17.6 0,17.6\n\t\t\tH 61.25\n\t\t\tC 94.9,87.8 95,87.6 95,40.7 78.125,23 67,29 55.6,46.5\n\t\t\tL 33.1,23\n\t\t\tC 30.3125,20.128192 27.9,19 25.830078,19.119756\n\t\t\tZ\n\t\t`, fill, strokeColor, strokeWidth);\n    }\n    /** Unused by js-draw. @deprecated */\n    makeAllDevicePanningIcon() {\n        const fill = 'none';\n        const strokeColor = 'var(--icon-color)';\n        const strokeWidth = '3';\n        return this.makeIconFromPath(`\n\t\t\tM 5 5\n\t\t\tL 5 17.5\n\t\t\t\t17.5 5\n\t\t\t\t5 5\n\t\t\tz\n\t\n\t\t\tM 42.5 5\n\t\t\tL 55 17.5\n\t\t\t\t55 5\n\t\t\t\t42.5 5\n\t\t\tz\n\t\n\t\t\tM 70 10\n\t\t\tL 70 21\n\t\t\t\t61 15\n\t\t\t\t55.5 23\n\t\t\t\t66 30\n\t\t\t\t56 37\n\t\t\t\t61 45\n\t\t\t\t70 39\n\t\t\t\t70 50\n\t\t\t\t80 50\n\t\t\t\t80 39\n\t\t\t\t89 45\n\t\t\t\t95 36\n\t\t\t\t84 30\n\t\t\t\t95 23\n\t\t\t\t89 15\n\t\t\t\t80 21\n\t\t\t\t80 10\n\t\t\t\t70 10\n\t\t\tz\n\t\n\t\t\tM 27.5 26.25\n\t\t\tL 27.5 91.25\n\t\t\tL 43.75 83.125\n\t\t\tL 52 99\n\t\t\tL 68 91\n\t\t\tL 60 75\n\t\t\tL 76.25 66.875\n\t\t\tL 27.5 26.25\n\t\t\tz\n\t\n\t\t\tM 5 42.5\n\t\t\tL 5 55\n\t\t\tL 17.5 55\n\t\t\tL 5 42.5\n\t\t\tz\n\t\t`, fill, strokeColor, strokeWidth);\n    }\n    makeZoomIcon() {\n        const icon = document.createElementNS(svgNamespace, 'svg');\n        icon.setAttribute('viewBox', '0 0 100 100');\n        const addTextNode = (text, x, y) => {\n            const textNode = document.createElementNS(svgNamespace, 'text');\n            textNode.appendChild(document.createTextNode(text));\n            textNode.setAttribute('x', x.toString());\n            textNode.setAttribute('y', y.toString());\n            textNode.style.textAlign = 'center';\n            textNode.style.textAnchor = 'middle';\n            textNode.style.fontSize = '55px';\n            textNode.style.fill = 'var(--icon-color)';\n            textNode.style.fontFamily = 'monospace';\n            icon.appendChild(textNode);\n        };\n        addTextNode('+', 40, 45);\n        addTextNode('-', 70, 75);\n        return icon;\n    }\n    makeRotationLockIcon() {\n        const icon = this.makeIconFromPath(`\n\t\t\tM 40.1 25.1 \n\t\t\tC 32.5 25 27.9 34.1 27.9 34.1 \n\t\t\tL 25.7 30 \n\t\t\tL 28 44.7 \n\t\t\tL 36.6 40.3 \n\t\t\tL 32.3 38.3 \n\t\t\tC 33.6 28 38.1 25.2 45.1 31.8 \n\t\t\tL 49.4 29.6 \n\t\t\tC 45.9 26.3 42.8 25.1 40.1 25.1 \n\t\t\tz\n\n\t\t\tM 51.7 34.2 \n\t\t\tL 43.5 39.1 \n\t\t\tL 48 40.8 \n\t\t\tC 47.4 51.1 43.1 54.3 35.7 48.2 \n\t\t\tL 31.6 50.7 \n\t\t\tC 45.5 62.1 52.6 44.6 52.6 44.6 \n\t\t\tL 55.1 48.6 \n\t\t\tL 51.7 34.2 \n\t\t\tz\n\n\t\t\tM 56.9 49.9 \n\t\t\tC 49.8 49.9 49.2 57.3 49.3 60.9 \n\t\t\tL 47.6 60.9 \n\t\t\tL 47.6 73.7 \n\t\t\tL 66.1 73.7 \n\t\t\tL 66.1 60.9 \n\t\t\tL 64.4 60.9 \n\t\t\tC 64.5 57.3 63.9 49.9 56.9 49.9 \n\t\t\tz\n\n\t\t\tM 56.9 53.5 \n\t\t\tC 60.8 53.5 61 58.2 60.8 60.9 \n\t\t\tL 52.9 60.9 \n\t\t\tC 52.7 58.2 52.9 53.5 56.9 53.5 \n\t\t\tz\n\t\t`);\n        icon.setAttribute('viewBox', '10 10 70 70');\n        return icon;\n    }\n    makeInsertImageIcon() {\n        return this.makeIconFromPath(`\n\t\t\tM 5 10 L 5 90 L 95 90 L 95 10 L 5 10 z\n\t\t\tM 10 15 L 90 15 L 90 50 L 70 75 L 40 50 L 10 75 L 10 15 z\n\t\t\tM 22.5 25 A 7.5 7.5 0 0 0 15 32.5 A 7.5 7.5 0 0 0 22.5 40 A 7.5 7.5 0 0 0 30 32.5 A 7.5 7.5 0 0 0 22.5 25 z \n\t\t`);\n    }\n    makeUploadFileIcon() {\n        return this.makeIconFromPath(`\n\t\t\tM 48,10 32,34 43,33 42,68\n\t\t\tH 54\n\t\t\tL 53,33 64,34 Z\n\t\n\t\t\tM 8,66 V 86 H 88 V 66 H 78 V 76 H 18 V 66 Z\n\t\t`);\n    }\n    makeTextIcon(textStyle) {\n        const icon = document.createElementNS(svgNamespace, 'svg');\n        icon.setAttribute('viewBox', '0 0 100 100');\n        const textNode = document.createElementNS(svgNamespace, 'text');\n        textNode.appendChild(document.createTextNode('T'));\n        textNode.style.fontFamily = textStyle.fontFamily;\n        textNode.style.fontWeight = textStyle.fontWeight ?? '';\n        textNode.style.fontVariant = textStyle.fontVariant ?? '';\n        textNode.style.fill = textStyle.renderingStyle.fill.toHexString();\n        textNode.style.textAnchor = 'middle';\n        textNode.setAttribute('x', '50');\n        textNode.setAttribute('y', '75');\n        textNode.style.fontSize = '65px';\n        textNode.style.filter = 'drop-shadow(0px 0px 10px var(--shadow-color))';\n        icon.appendChild(textNode);\n        return icon;\n    }\n    makePenIcon(penStyle) {\n        // Use a square-root scale to prevent the pen's tip from overflowing.\n        const strokeSize = Math.round(Math.sqrt(penStyle.thickness) * 4);\n        const color = penStyle.color;\n        const rounded = this.isRoundedTipPen(penStyle);\n        const tipThickness = strokeSize / 2;\n        const inkTipPath = `\n\t\t\tM ${15 - tipThickness},${80 - tipThickness}\n\t\t\t  ${15 - tipThickness},${80 + tipThickness}\n\t\t\t  30,83\n\t\t\t  15,65\n\t\t\tZ\n\t\t`;\n        const trailStartEndY = 80 + tipThickness;\n        const inkTrailPath = `\n\t\t\tm ${15 - tipThickness * 1.1},${trailStartEndY}\n\t\t\tc 35,10 55,15 60,30\n\t\t\tl ${35 + tipThickness * 1.2},${-10 - tipThickness}\n\t\t\tC 80.47,98.32 50.5,${90 + tipThickness} 20,${trailStartEndY} Z\n\t\t`;\n        const colorBubblePath = `\n\t\t\tM 72.45,35.67\n\t\t\tA 10,15 41.8 0 1 55,40.2 10,15 41.8 0 1 57.55,22.3 10,15 41.8 0 1 75,17.8 10,15 41.8 0 1 72.5,35.67\n\t\t\tZ\n\t\t`;\n        let gripMainPath = 'M 85,-25 25,35 h 10 v 10 h 10 v 10 h 10 v 10 h 10 l -5,10 60,-60 z';\n        let gripShadow1Path = 'M 25,35 H 35 L 90,-15 85,-25 Z';\n        let gripShadow2Path = 'M 60,75 65,65 H 55 l 55,-55 10,5 z';\n        if (rounded) {\n            gripMainPath = 'M 85,-25 25,35 c 15,0 40,30 35,40 l 60,-60 z';\n            gripShadow1Path = 'm 25,35 c 3.92361,0.384473 7.644275,0.980572 10,3 l 55,-53 -5,-10 z';\n            gripShadow2Path = 'M 60,75 C 61,66 59,65 56,59 l 54,-54 10,10 z';\n        }\n        const penTipPath = `M 25,35 ${10 - tipThickness / 4},${70 - tipThickness / 2} 20,75 25,85 60,75 70,55 45,25 Z`;\n        const pencilTipColor = Color4.fromHex('#f4d7d7');\n        const tipColor = pencilTipColor.mix(color, tipThickness / 40 - 0.1).toHexString();\n        const checkerboardPattern = makeCheckerboardPattern();\n        const colorString = color.toHexString();\n        const ink = createSvgPaths({\n            fill: checkerboardPattern.patternRef,\n            d: inkTipPath,\n        }, {\n            fill: checkerboardPattern.patternRef,\n            d: inkTrailPath,\n        }, {\n            fill: colorString,\n            d: inkTipPath,\n        }, {\n            fill: colorString,\n            d: inkTrailPath,\n        });\n        const penTip = createSvgPaths({ fill: checkerboardPattern.patternRef, d: penTipPath }, { fill: tipColor, stroke: colorString, d: penTipPath });\n        const grip = createSvgPaths({ fill: 'var(--icon-color)', stroke: 'var(--icon-color)', d: gripMainPath }, \n        // Shadows\n        { fill: 'rgba(150, 150, 150, 0.3)', d: gripShadow1Path }, { fill: 'rgba(100, 100, 100, 0.2)', d: gripShadow2Path }, \n        // Color bubble\n        { fill: checkerboardPattern.patternRef, d: colorBubblePath }, { fill: colorString, d: colorBubblePath });\n        const icon = document.createElementNS(svgNamespace, 'svg');\n        icon.setAttribute('viewBox', '0 0 100 100');\n        const iconMainContent = createSvgElement('g', {\n            children: [ink, penTip, grip].flat(),\n        });\n        const defs = createSvgElement('defs', {\n            children: [checkerboardPattern.patternDefElement],\n        });\n        icon.replaceChildren(defs, iconMainContent);\n        return icon;\n    }\n    makeIconFromFactory(penStyle) {\n        // Increase the thickness we use to generate the icon less with larger actual thicknesses.\n        // We want the icon to be recognisable with a large range of thicknesses.\n        const thickness = Math.sqrt(penStyle.thickness) * 3;\n        const nowTime = performance.now();\n        const startPoint = {\n            pos: Vec2.of(10, 10),\n            width: thickness,\n            color: penStyle.color,\n            time: nowTime - 100,\n        };\n        const endPoint = {\n            pos: Vec2.of(90, 90),\n            width: thickness,\n            color: penStyle.color,\n            time: nowTime,\n        };\n        const viewport = new Viewport(() => { });\n        const builder = penStyle.factory(startPoint, viewport);\n        builder.addPoint(endPoint);\n        const icon = document.createElementNS(svgNamespace, 'svg');\n        icon.setAttribute('viewBox', '0 0 100 100');\n        viewport.updateScreenSize(Vec2.of(100, 100));\n        let renderer;\n        // Any transparency? Include a checkerboard grid.\n        const includeTransparencyGrid = penStyle.color.a < 1;\n        if (includeTransparencyGrid) {\n            const checkerboardPattern = makeCheckerboardPattern();\n            const defs = document.createElementNS(svgNamespace, 'defs');\n            defs.appendChild(checkerboardPattern.patternDefElement);\n            icon.appendChild(defs);\n            const background = document.createElementNS(svgNamespace, 'g');\n            icon.appendChild(background);\n            renderer = new (class extends SVGRenderer {\n                constructor() {\n                    super(icon, viewport);\n                }\n                addPathToSVG() {\n                    const addedPath = super.addPathToSVG();\n                    if (addedPath) {\n                        // Add a copy of the path on the background\n                        const copy = addedPath.cloneNode(true);\n                        copy.style.zIndex = '-1';\n                        if (copy.hasAttribute('stroke')) {\n                            copy.setAttribute('stroke', checkerboardPattern.patternRef);\n                        }\n                        // Note: Assumes that the component wouldn't normally be both stroked\n                        // and filled.\n                        else if (copy.hasAttribute('fill')) {\n                            copy.setAttribute('fill', checkerboardPattern.patternRef);\n                        }\n                        background.appendChild(copy);\n                    }\n                    return addedPath;\n                }\n            })();\n        }\n        else {\n            renderer = new SVGRenderer(icon, viewport);\n        }\n        builder.preview(renderer);\n        // If only a single path was rendered, try to give it a checkerboard background to\n        // emphasize transparency. TODO: This is very fragile\n        const bbox = builder.getBBox();\n        icon.setAttribute('viewBox', `${bbox.x} ${bbox.y} ${bbox.w} ${bbox.h}`);\n        return icon;\n    }\n    makePipetteIcon(color) {\n        const icon = document.createElementNS(svgNamespace, 'svg');\n        const mainGroup = document.createElementNS(svgNamespace, 'g');\n        mainGroup.style.rotate = '45deg';\n        mainGroup.style.transformOrigin = 'center';\n        const pipette = document.createElementNS(svgNamespace, 'g');\n        pipette.innerHTML = `\n\t\t<path\n\t\t\tstyle=\"fill: var(--icon-color); stroke-linecap:round; stroke-linejoin:round;\"\n\t\t\td=\"\n\t\t\t\tm 32,12 v 68\n\t\t\t\tc 0,1 0.5,2 1.33,2.5 1.67,1.15 3.67,2.1 5.17,3.2 1.4,1.1 2.3,2.1 2.5,3.1 0.6,2.1 1,4.6 1,6.2 0,3.7 5.45,4.1 6,0.4 l 0.9,-6.8\n\t\t\t\tc 0.3,-0.9 1.1,-1.9 2.6,-2.9 1.5,-1.1 3.4,-2 5.1,-3.2\n\t\t\t\tC 57.5,82 58,81 58,80\n\t\t\t\tV 12 Z m 20,25 v 41.3\n\t\t\t\tc 0,1.7 -2.5,1.6 -4,2.7 -1,0.76 -2.1,1.5 -3,2.6\n\t\t\t\tC 44,82.5 43.02,81.75 42,81 40.51,79.92 38,80 38,78.34\n\t\t\t\tV 51 Z\n\t\t\t\"\n\t\t/>\n\t\t<rect\n\t\t\tstyle=\"fill: var(--icon-color);\"\n\t\t\twidth=\"32\"\n\t\t\theight=\"9\"\n\t\t\tx=\"29\"\n\t\t\ty=\"2\"\n\t\t\try=\"4.5\"\n\t\t/>\n\t\t<path\n\t\t\tstyle=\"fill: var(--icon-color);\"\n\t\t\td=\"m 45,-25 c -5.54,0 -11,4.26 -11,9 V 0 h 22 v -16 c 0,-4.74 -5.46,-9 -11,-9 z\"\n\t\t/>\n\t\t`;\n        if (color) {\n            const checkerboardPattern = makeCheckerboardPattern();\n            const defs = document.createElementNS(svgNamespace, 'defs');\n            defs.appendChild(checkerboardPattern.patternDefElement);\n            icon.appendChild(defs);\n            const fluidBackground = document.createElementNS(svgNamespace, 'path');\n            const fluid = document.createElementNS(svgNamespace, 'path');\n            const fluidPathData = `\n\t\t\t\tM 35,36 H 55 V 78.678012 83 L 45,87 35,83 Z\n\t\t\t`;\n            fluid.setAttribute('d', fluidPathData);\n            fluidBackground.setAttribute('d', fluidPathData);\n            fluid.style.fill = color.toHexString();\n            fluidBackground.style.fill = checkerboardPattern.patternRef;\n            mainGroup.appendChild(fluidBackground);\n            mainGroup.appendChild(fluid);\n        }\n        mainGroup.appendChild(pipette);\n        icon.appendChild(mainGroup);\n        icon.setAttribute('viewBox', '5 -40 140 140');\n        return icon;\n    }\n    makeShapeAutocorrectIcon() {\n        const fill = 'none';\n        const strokeColor = 'var(--icon-color)';\n        return this.makeIconFromPath(`\n\t\t\tm 79.129476,33.847107 9.967823,-0.03218 v 55 h -55 l 0.03218,-9.96782\n\t\t\tM 71.1,40.8 a 30,30 0 0 1 -30,30 30,30 0 0 1 -30,-30 30,30 0 0 1 30,-30 30,30 0 0 1 30,30 L 71.1,40.8\n\t\t\tM 34.1,58.8 v -25 h 25 v 0\n\t\t`, fill, strokeColor, '7px');\n    }\n    makeStrokeSmoothingIcon() {\n        const fill = 'none';\n        const strokeColor = 'var(--icon-color)';\n        return this.makeIconFromPath(`\n\t\t\tm 31,83.2 c -50,0 30,-65 -20,-65\n\t\t\tM 75,17.3 40,59.7 38.2,77.6 55.5,72.4 90.5,30 Z\n\t\t`, fill, strokeColor, '7px');\n    }\n    /** Unused. @deprecated */\n    makeFormatSelectionIcon() {\n        return this.makeIconFromPath(`\n\t\t\tM 5 10\n\t\t\tL 5 20 L 10 20 L 10 15 L 20 15 L 20 40 L 15 40 L 15 45 L 35 45 L 35 40 L 30 40 L 30 15 L 40 15 L 40 20 L 45 20 L 45 15 L 45 10 L 5 10 z\n\t\t\tM 90 10 C 90 10 86.5 13.8 86 14 C 86 14 76.2 24.8 76 25 L 60 25 L 60 65 C 75 70 85 70 90 65 L 90 25 L 80 25 L 76.7 25 L 90 10 z\n\t\t\tM 60 25 L 55 25 L 50 30 L 60 25 z\n\t\t\tM 10 55 L 10 90 L 41 90 L 41 86 L 45 86 L 45 55 L 10 55 z\n\t\t\tM 42 87 L 42 93 L 48 93 L 48 87 L 42 87 z \n\t\t`);\n    }\n    makeResizeImageToSelectionIcon() {\n        return this.makeIconFromPath(`\n\t\t\tM 75 5 75 10 90 10 90 25 95 25 95 5 75 5 z\n\t\t\tM 15 15 15 30 20 30 20 20 30 20 30 15 15 15 z\n\t\t\tM 84 15 82 17 81 16 81 20 85 20 84 19 86 17 84 15 z\n\t\t\tM 26 24 24 26 26 28 25 29 29 29 29 25 28 26 26 24 z\n\t\t\tM 25 71 26 72 24 74 26 76 28 74 29 75 29 71 25 71 z\n\t\t\tM 15 75 15 85 25 85 25 80 20 80 20 75 15 75 z\n\t\t\tM 90 75 90 90 75 90 75 95 95 95 95 75 90 75 z\n\t\t\tM 81 81 81 85 82 84 84 86 86 84 84 82 85 81 81 81 z\n\t\t`);\n    }\n    /** Renamed to {@link makeResizeImageToSelectionIcon} @deprecated */\n    makeResizeViewportIcon() {\n        return this.makeResizeImageToSelectionIcon();\n    }\n    makeDuplicateSelectionIcon() {\n        return this.makeIconFromPath(`\n\t\t\tM 45,10 45,55 90,55 90,10 45,10 z\n\t\t\tM 10,25 10,90 70,90 70,60 40,60 40,25 10,25 z \n\t\t`);\n    }\n    makeCopyIcon() {\n        return this.makeIconFromPath(`\n\t\t\tM 45,10 45,55 90,55 90,10 45,10 z\n\t\t\tM 10,25 10,90 70,90 70,60 40,60 40,25 10,25 z \n\t\t`);\n    }\n    makePasteIcon() {\n        const icon = this.makeIconFromPath(`\n\t\t\tM 50 0 L 50 5 L 35 5 L 40 24.75 L 20 25 L 20 100 L 85 100 L 100 90 L 100 24 L 75.1 24.3 L 80 5 L 65 5 L 65 0 L 50 0 z\n\t\t\tM 10 15 L 10 115 L 110 115 L 110 15 L 85 15 L 83 20 L 105 20 L 105 110 L 15 110 L 15 20 L 32 20 L 30 15 L 10 15 z\n\t\t\tM 25 35 L 90 35 L 90 40 L 25 40 L 25 35 z\n\t\t\tM 25 45 L 90 45 L 90 50 L 25 50 L 25 45 z\n\t\t\tM 25 55 L 85 55 L 85 60 L 25 60 L 25 55 z\n\t\t\tM 25 65 L 90 65 L 90 70 L 25 70 L 25 65 z \n\t\t`);\n        icon.setAttribute('viewBox', '0 0 120 120');\n        return icon;\n    }\n    makeDeleteSelectionIcon() {\n        return __classPrivateFieldGet(this, _IconProvider_instances, \"m\", _IconProvider_makeXIcon).call(this);\n    }\n    makeCloseIcon() {\n        return __classPrivateFieldGet(this, _IconProvider_instances, \"m\", _IconProvider_makeXIcon).call(this);\n    }\n    makeSaveIcon() {\n        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        svg.innerHTML = `\n\t\t\t<style>\n\t\t\t\t.toolbar-save-icon {\n\t\t\t\t\tstroke: var(--icon-color);\n\t\t\t\t\tstroke-width: 6;\n\t\t\t\t\tstroke-linejoin: round;\n\t\t\t\t\tstroke-linecap: round;\n\t\t\t\t\tfill: none;\n\t\t\t\t}\n\t\t\t</style>\n\t\t\t<path\n\t\t\t\td='\n\t\t\t\t\tM 15,55 30,70 85,20\n\t\t\t\t'\n\t\t\t\tclass='toolbar-save-icon'\n\t\t\t/>\n\t\t`;\n        svg.setAttribute('viewBox', '0 0 100 100');\n        return svg;\n    }\n    makeConfigureDocumentIcon() {\n        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        svg.innerHTML = `\n\t\t\t<path\n\t\t\t\td='\n\t\t\t\t\tM 5,5 V 95 H 95 V 5 Z m 5,5 H 90 V 90 H 10 Z\n\t\t\t\t\tm 5,10 V 30 H 50 V 25 H 20 v -5 z\n\t\t\t\t\tm 40,0 V 50 H 85 V 20 Z\n\t\t\t\t\tm 2,2 H 83 V 39 L 77,28 70,42 64,35 57,45 Z\n\t\t\t\t\tm 8.5,5 C 64.67,27 64,27.67 64,28.5 64,29.33 64.67,30 65.5,30 66.33,30 67,29.33 67,28.5 67,27.67 66.33,27 65.5,27 Z\n\t\t\t\t\tM 15,40 v 5 h 35 v -5 z\n\t\t\t\t\tm 0,15 v 5 h 70 v -5 z\n\t\t\t\t\tm 0,15 v 5 h 70 v -5 z\n\t\t\t\t'\n\t\t\t\tstyle='fill: var(--icon-color);'\n\t\t\t/>\n\t\t`;\n        svg.setAttribute('viewBox', '0 0 100 100');\n        return svg;\n    }\n    makeOverflowIcon() {\n        return this.makeIconFromPath(`\n\t\t\tM 15 40\n\t\t\tA 12.5 12.5 0 0 0 2.5 52.5\n\t\t\tA 12.5 12.5 0 0 0 15 65\n\t\t\tA 12.5 12.5 0 0 0 27.5 52.5\n\t\t\tA 12.5 12.5 0 0 0 15 40\n\t\t\tz\n\t\n\t\t\tM 50 40\n\t\t\tA 12.5 12.5 0 0 0 37.5 52.5\n\t\t\tA 12.5 12.5 0 0 0 50 65\n\t\t\tA 12.5 12.5 0 0 0 62.5 52.5\n\t\t\tA 12.5 12.5 0 0 0 50 40\n\t\t\tz\n\t\t\t\n\t\t\tM 85 40\n\t\t\tA 12.5 12.5 0 0 0 72.5 52.5\n\t\t\tA 12.5 12.5 0 0 0 85 65\n\t\t\tA 12.5 12.5 0 0 0 97.5 52.5\n\t\t\tA 12.5 12.5 0 0 0 85 40\n\t\t\tz\n\t\t`);\n    }\n    makeHelpIcon() {\n        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        svg.innerHTML = `\n\t\t\t<circle\n\t\t\t\tstyle=\"stroke-width:1.587; stroke: var(--icon-color);\"\n\t\t\t\tfill=\"none\"\n\t\t\t\tcx=\"13.23\"\n\t\t\t\tcy=\"13.23\"\n\t\t\t\tr=\"11.9\"\n\t\t\t/>\n\t\t\t<path\n\t\t\t\tstyle=\"stroke-width: 3; stroke-linecap: butt; stroke: var(--icon-color);\"\n\t\t\t\tfill=\"none\"\n\t\t\t\td=\"M 9.26,6.61 C 18.7,3.25 19.95,10.4 14.3,13.4 c -1.15,0.61 -1.32,1.32 -1.32,2.65 v 2.12\"\n\t\t\t/>\n\t\t\t<circle\n\t\t\t\tstyle=\"fill: var(--icon-color);\"\n\t\t\t\tcx=\"13\"\n\t\t\t\tcy=\"21.32\"\n\t\t\t\tr=\"1.9\"\n\t\t\t/>\n\t\t`;\n        svg.setAttribute('viewBox', '0 0 26.46 26.46');\n        svg.setAttribute('width', '100');\n        svg.setAttribute('height', '100');\n        return svg;\n    }\n    /**\n     * @param pathData - SVG path data (e.g. `m10,10l30,30z`)\n     * @param fill - A valid CSS color (e.g. `var(--icon-color)` or `#f0f`). This can be `none`.\n     */\n    makeIconFromPath(pathData, fill = 'var(--icon-color)', strokeColor = 'none', strokeWidth = '0px') {\n        const icon = document.createElementNS(svgNamespace, 'svg');\n        const path = document.createElementNS(svgNamespace, 'path');\n        path.setAttribute('d', pathData);\n        path.style.fill = fill;\n        path.style.stroke = strokeColor;\n        path.style.strokeWidth = strokeWidth;\n        icon.appendChild(path);\n        icon.setAttribute('viewBox', '0 0 100 100');\n        return icon;\n    }\n    /**\n     * @returns An object with both the definition of a checkerboard pattern and the syntax to\n     * reference that pattern. The defs provided by this function should be wrapped within a\n     * `<defs></defs>` element.\n     *\n     * **Note**: This function's return value includes both `patternDefElement` (which returns\n     * an Element) and a (deprecated) `patternDef` string. Avoid using the `patternDef` result.\n     */\n    makeCheckerboardPattern() {\n        return makeCheckerboardPattern();\n    }\n    /**\n     * @returns true if the given `penStyle` is known to match a rounded tip type of pen.\n     */\n    isRoundedTipPen(penStyle) {\n        return penStyle.factory === makeFreehandLineBuilder || penStyle.factory === makePolylineBuilder;\n    }\n    isPolylinePen(penStyle) {\n        return penStyle.factory === makePolylineBuilder;\n    }\n    /** Must be overridden by icon packs that need attribution. */\n    licenseInfo() {\n        return null;\n    }\n}\n_IconProvider_instances = new WeakSet(), _IconProvider_makeXIcon = function _IconProvider_makeXIcon() {\n    const strokeWidth = '6px';\n    const strokeColor = 'var(--icon-color)';\n    const fillColor = 'none';\n    return this.makeIconFromPath(`\n\t\t\tM 15,15 85,85\n\t\t\tM 15,85 85,15\n\t\t`, fillColor, strokeColor, strokeWidth);\n};\nexport default IconProvider;\n","export const toolbarCSSPrefix = 'toolbar-';\n","export  *  from './widgets/lib.mjs';\nexport  *  from './widgets/components/makeColorInput.mjs';\nexport  { default as IconProvider }  from './IconProvider.mjs';\nexport  { makeDropdownToolbar }  from './DropdownToolbar.mjs';\nexport  { makeEdgeToolbar }  from './EdgeToolbar.mjs';\n","import  { defaultToolbarUtilsLocalization }  from './utils/localization.mjs';\nexport const defaultToolbarLocalization = {\n    ...defaultToolbarUtilsLocalization,\n    pen: 'Pen',\n    eraser: 'Eraser',\n    select: 'Select',\n    handTool: 'Pan',\n    zoom: 'Zoom',\n    image: 'Image',\n    reformatSelection: 'Format selection',\n    inputAltText: 'Alt text',\n    decreaseImageSize: 'Decrease size',\n    resetImage: 'Reset',\n    chooseFile: 'Choose file',\n    dragAndDropHereOrBrowse: 'Drag and drop here\\nor\\n{{browse}}',\n    submit: 'Submit',\n    addAll: 'Add all',\n    cancel: 'Cancel',\n    resetView: 'Reset view',\n    thicknessLabel: 'Thickness',\n    colorLabel: 'Color',\n    fontLabel: 'Font',\n    textSize: 'Size',\n    resizeImageToSelection: 'Resize image to selection',\n    deleteSelection: 'Delete selection',\n    duplicateSelection: 'Duplicate selection',\n    exit: 'Exit',\n    save: 'Save',\n    undo: 'Undo',\n    redo: 'Redo',\n    fullStrokeEraser: 'Full stroke eraser',\n    selectPenType: 'Pen type',\n    selectShape: 'Shape',\n    pickColorFromScreen: 'Pick color from screen',\n    clickToPickColorAnnouncement: 'Click on the screen to pick a color',\n    colorSelectionCanceledAnnouncement: 'Color selection canceled',\n    selectionToolKeyboardShortcuts: 'Selection tool: Use arrow keys to move selected items, lowercase/uppercase ‘i’ and ‘o’ to resize.',\n    documentProperties: 'Page',\n    backgroundColor: 'Background color',\n    imageWidthOption: 'Width',\n    imageHeightOption: 'Height',\n    useGridOption: 'Grid',\n    enableAutoresizeOption: 'Auto-resize',\n    toggleOverflow: 'More',\n    about: 'About',\n    inputStabilization: 'Stabilization',\n    strokeAutocorrect: 'Autocorrect',\n    touchPanning: 'Scroll with touch',\n    roundedTipPen: 'Round',\n    roundedTipPen2: 'Polyline',\n    flatTipPen: 'Flat',\n    arrowPen: 'Arrow',\n    linePen: 'Line',\n    outlinedRectanglePen: 'Outlined rectangle',\n    filledRectanglePen: 'Filled rectangle',\n    outlinedCirclePen: 'Outlined circle',\n    lockRotation: 'Lock rotation',\n    paste: 'Paste',\n    errorImageHasZeroSize: 'Error: Image has zero size',\n    describeTheImage: 'Image description',\n    fileInput__loading: 'Loading...',\n    fileInput__andNMoreFiles: (n) => `(...${n} more)`,\n    // Help text\n    penDropdown__baseHelpText: 'This tool draws shapes or freehand lines.',\n    penDropdown__colorHelpText: \"Changes the pen's color\",\n    penDropdown__thicknessHelpText: 'Changes the thickness of strokes drawn by the pen.',\n    penDropdown__penTypeHelpText: 'Changes the pen style.\\n\\nEither a “pen” style or “shape” can be chosen. Choosing a “pen” style draws freehand lines. Choosing a “shape” draws shapes.',\n    penDropdown__autocorrectHelpText: 'Converts approximate freehand lines and rectangles to perfect ones.\\n\\nThe pen must be held stationary at the end of a stroke to trigger a correction.',\n    penDropdown__stabilizationHelpText: 'Draws smoother strokes.\\n\\nThis also adds a short delay between the mouse/stylus and the stroke.',\n    handDropdown__baseHelpText: 'This tool is responsible for scrolling, rotating, and zooming the editor.',\n    handDropdown__zoomInHelpText: 'Zooms in.',\n    handDropdown__zoomOutHelpText: 'Zooms out.',\n    handDropdown__resetViewHelpText: 'Resets the zoom level to 100% and resets scroll.',\n    handDropdown__zoomDisplayHelpText: 'Shows the current zoom level. 100% shows the image at its actual size.',\n    handDropdown__touchPanningHelpText: 'When enabled, touchscreen gestures move the image rather than select or draw.',\n    handDropdown__lockRotationHelpText: 'When enabled, prevents touch gestures from rotating the screen.',\n    eraserDropdown__baseHelpText: 'This tool removes strokes, images, and text under the cursor.',\n    eraserDropdown__thicknessHelpText: 'Changes the size of the eraser.',\n    eraserDropdown__fullStrokeEraserHelpText: 'When in full-stroke mode, entire shapes are erased.\\n\\nWhen not in full-stroke mode, shapes can be partially erased.',\n    selectionDropdown__baseHelpText: 'Selects content and manipulates the selection',\n    selectionDropdown__resizeToHelpText: \"Crops the drawing to the size of what's currently selected.\\n\\nIf auto-resize is enabled, it will be disabled.\",\n    selectionDropdown__deleteHelpText: 'Erases selected items.',\n    selectionDropdown__duplicateHelpText: 'Makes a copy of selected items.',\n    selectionDropdown__changeColorHelpText: 'Changes the color of selected items.',\n    pageDropdown__baseHelpText: \"Controls the drawing canvas' background color, pattern, and size.\",\n    pageDropdown__backgroundColorHelpText: 'Changes the background color of the drawing canvas.',\n    pageDropdown__gridCheckboxHelpText: 'Enables/disables a background grid pattern.',\n    pageDropdown__autoresizeCheckboxHelpText: 'When checked, the page grows to fit the drawing.\\n\\nWhen unchecked, the page is visible and its size can be set manually.',\n    pageDropdown__aboutButtonHelpText: 'Shows version, debug, and other information.',\n    colorPickerPipetteHelpText: 'Picks a color from the screen.',\n    colorPickerToggleHelpText: 'Opens/closes the color picker.',\n    closeSidebar: (toolName) => `Close sidebar for ${toolName}`,\n    dropdownShown: (toolName) => `Menu for ${toolName} shown`,\n    dropdownHidden: (toolName) => `Menu for ${toolName} hidden`,\n    zoomLevel: (zoomPercent) => `Zoom: ${zoomPercent}%`,\n    colorChangedAnnouncement: (color) => `Color changed to ${color}`,\n    imageSize: (size, units) => `Image size: ${size} ${units}`,\n    imageLoadError: (message) => `Error loading image: ${message}`,\n};\n","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _HelpDisplay_helpData;\nimport { Rect2 } from '@js-draw/math';\nimport  makeDraggable  from './makeDraggable.mjs';\nimport  { MutableReactiveValue }  from '../../util/ReactiveValue.mjs';\nimport  cloneElementWithStyles  from '../../util/cloneElementWithStyles.mjs';\nimport  addLongPressOrHoverCssClasses  from '../../util/addLongPressOrHoverCssClasses.mjs';\n/**\n * Creates the main content of the help overlay.\n *\n * Shows the label for a `HelpRecord` and a highlighted copy\n * of that label's `targetElements`.\n */\nconst createHelpPage = (helpItems, onItemClick, onBackgroundClick, context) => {\n    const container = document.createElement('div');\n    container.classList.add('help-page-container');\n    const textLabel = document.createElement('div');\n    textLabel.classList.add('label', '-space-above');\n    textLabel.setAttribute('aria-live', 'polite');\n    // The current active item in helpItems.\n    // (Only one item is active at a time, but each item can have multiple HTMLElements).\n    let currentItemIndex = 0;\n    let currentItem = helpItems[0] ?? null;\n    // Each help item can have multiple associated elements. We store clones of each\n    // of these elements in their own container.\n    //\n    // clonedElementContainers maps from help item indicies to **arrays** of containers.\n    //\n    // For example, clonedElementContainers would be\n    //   [ [ Container1, Container2 ], [ Container3 ], [ Container4 ]]\n    //       ↑                            ↑              ↑\n    //       HelpItem 1                   HelpItem 2     HelpItem 3\n    // if the first help item had two elements (and thus two cloned element containers).\n    //\n    // We also store the original bounding box -- the bounding box of the clones can change\n    // while dragging to switch pages.\n    let clonedElementContainers = [];\n    // Clicking on the background of the help area should send an event (e.g. to allow the\n    // help container to be closed).\n    container.addEventListener('click', (event) => {\n        // If clicking directly on the container (and not on a child)\n        if (event.target === container) {\n            onBackgroundClick();\n        }\n    });\n    // Returns the combined bounding box of all elements associated with the currentItem\n    // (all active help items).\n    const getCombinedBBox = () => {\n        if (!currentItem) {\n            return Rect2.empty;\n        }\n        const itemBoundingBoxes = currentItem.targetElements.map((element) => Rect2.of(element.getBoundingClientRect()));\n        return Rect2.union(...itemBoundingBoxes);\n    };\n    // Updates each cloned element's click listener and CSS classes based on whether\n    // that element is the current focused element.\n    const updateClonedElementStates = () => {\n        const currentItemBBox = getCombinedBBox();\n        for (let index = 0; index < clonedElementContainers.length; index++) {\n            for (const { container, bbox: containerBBox } of clonedElementContainers[index]) {\n                if (index === currentItemIndex) {\n                    container.classList.add('-active');\n                    container.classList.remove('-clickable', '-background');\n                    container.onclick = () => { };\n                }\n                // Otherwise, if not containing the current element\n                else {\n                    if (!containerBBox.containsRect(currentItemBBox)) {\n                        container.classList.add('-clickable');\n                        container.classList.remove('-active', '-background');\n                    }\n                    else {\n                        container.classList.add('-background');\n                        container.classList.remove('-active', '-clickable');\n                    }\n                    const containerIndex = index;\n                    container.onclick = () => {\n                        onItemClick(containerIndex);\n                    };\n                }\n            }\n        }\n    };\n    // Ensures that the item label doesn't overlap the current help item's cloned element.\n    const updateLabelPosition = () => {\n        const labelBBox = Rect2.of(textLabel.getBoundingClientRect());\n        const combinedBBox = getCombinedBBox();\n        if (labelBBox.intersects(combinedBBox)) {\n            const containerBBox = Rect2.of(container.getBoundingClientRect());\n            const spaceAboveCombined = combinedBBox.topLeft.y;\n            const spaceBelowCombined = containerBBox.bottomLeft.y - combinedBBox.bottomLeft.y;\n            if (spaceAboveCombined > spaceBelowCombined && spaceAboveCombined > labelBBox.height / 3) {\n                // Push to the very top\n                textLabel.classList.remove('-small-space-above', '-large-space-above');\n                textLabel.classList.add('-large-space-below');\n            }\n            if (spaceAboveCombined < spaceBelowCombined && spaceBelowCombined > labelBBox.height) {\n                // Push to the very bottom\n                textLabel.classList.add('-large-space-above');\n                textLabel.classList.remove('-large-space-below');\n            }\n        }\n    };\n    const refreshContent = () => {\n        container.replaceChildren();\n        // Add the text label first so that screen readers will visit it first.\n        textLabel.classList.remove('-large-space-above');\n        textLabel.classList.add('-small-space-above', '-large-space-below');\n        container.appendChild(textLabel);\n        const screenBBox = new Rect2(0, 0, window.innerWidth, window.innerHeight);\n        clonedElementContainers = [];\n        for (let itemIndex = 0; itemIndex < helpItems.length; itemIndex++) {\n            const item = helpItems[itemIndex];\n            const itemCloneContainers = [];\n            for (const targetElement of item.targetElements) {\n                let targetBBox = Rect2.of(targetElement.getBoundingClientRect());\n                // Move the element onto the screen if not visible\n                if (!screenBBox.intersects(targetBBox)) {\n                    const screenBottomCenter = screenBBox.bottomLeft.lerp(screenBBox.bottomRight, 0.5);\n                    const targetBottomCenter = targetBBox.bottomLeft.lerp(targetBBox.bottomRight, 0.5);\n                    const delta = screenBottomCenter.minus(targetBottomCenter);\n                    targetBBox = targetBBox.translatedBy(delta);\n                }\n                const clonedElement = cloneElementWithStyles(targetElement);\n                // Interacting with the clone won't trigger event listeners, so disable\n                // all inputs.\n                for (const input of clonedElement.querySelectorAll('input')) {\n                    input.disabled = true;\n                }\n                clonedElement.style.margin = '0';\n                const clonedElementContainer = document.createElement('div');\n                clonedElementContainer.classList.add('cloned-element-container');\n                clonedElementContainer.style.position = 'absolute';\n                clonedElementContainer.style.left = `${targetBBox.topLeft.x}px`;\n                clonedElementContainer.style.top = `${targetBBox.topLeft.y}px`;\n                clonedElementContainer.replaceChildren(clonedElement);\n                addLongPressOrHoverCssClasses(clonedElementContainer, { timeout: 0 });\n                itemCloneContainers.push({ container: clonedElementContainer, bbox: targetBBox });\n                container.appendChild(clonedElementContainer);\n            }\n            clonedElementContainers.push(itemCloneContainers);\n        }\n        updateClonedElementStates();\n    };\n    const refresh = () => {\n        refreshContent();\n        updateLabelPosition();\n    };\n    const onItemChange = () => {\n        const helpTextElement = document.createElement('div');\n        helpTextElement.innerText = currentItem?.helpText ?? '';\n        // For tests\n        helpTextElement.classList.add('current-item-help');\n        const navigationHelpElement = document.createElement('div');\n        navigationHelpElement.innerText = context.localization.helpScreenNavigationHelp;\n        navigationHelpElement.classList.add('navigation-help');\n        textLabel.replaceChildren(helpTextElement, ...(currentItemIndex === 0 ? [navigationHelpElement] : []));\n        updateClonedElementStates();\n    };\n    onItemChange();\n    return {\n        addToParent: (parent) => {\n            refreshContent();\n            parent.appendChild(container);\n            updateLabelPosition();\n        },\n        refresh,\n        setPageIndex: (pageIndex) => {\n            currentItemIndex = pageIndex;\n            currentItem = helpItems[pageIndex];\n            onItemChange();\n        },\n    };\n};\n/**\n * Creates and manages an overlay that shows help text for a set of\n * `HTMLElement`s.\n *\n * @see {@link BaseWidget.fillDropdown}.\n */\nclass HelpDisplay {\n    /** Constructed internally by BaseWidget. @internal */\n    constructor(createOverlay, context) {\n        this.createOverlay = createOverlay;\n        this.context = context;\n        _HelpDisplay_helpData.set(this, []);\n    }\n    /** @internal */\n    showHelpOverlay() {\n        const overlay = document.createElement('dialog');\n        overlay.setAttribute('autofocus', 'true');\n        overlay.classList.add('toolbar-help-overlay');\n        // Closes the overlay with a closing animation\n        const closing = false;\n        const closeOverlay = () => {\n            if (closing)\n                return;\n            // If changing animationDelay, be sure to also update the CSS.\n            const animationDelay = 250; // ms\n            overlay.classList.add('-hiding');\n            setTimeout(() => overlay.close(), animationDelay);\n        };\n        let lastDragTimestamp = 0;\n        const onBackgroundClick = () => {\n            const wasJustDragging = performance.now() - lastDragTimestamp < 100;\n            if (!wasJustDragging) {\n                closeOverlay();\n            }\n        };\n        const makeCloseButton = () => {\n            const closeButton = document.createElement('button');\n            closeButton.classList.add('close-button');\n            closeButton.appendChild(this.context.icons.makeCloseIcon());\n            const label = this.context.localization.close;\n            closeButton.setAttribute('aria-label', label);\n            closeButton.setAttribute('title', label);\n            closeButton.onclick = () => {\n                closeOverlay();\n            };\n            return closeButton;\n        };\n        // Wraps the label and clickable help elements\n        const makeNavigationContent = () => {\n            const currentPage = MutableReactiveValue.fromInitialValue(0);\n            const content = document.createElement('div');\n            content.classList.add('navigation-content');\n            const helpPage = createHelpPage(__classPrivateFieldGet(this, _HelpDisplay_helpData, \"f\"), (newPageIndex) => currentPage.set(newPageIndex), onBackgroundClick, this.context);\n            helpPage.addToParent(content);\n            const showPage = (pageIndex) => {\n                if (pageIndex >= __classPrivateFieldGet(this, _HelpDisplay_helpData, \"f\").length || pageIndex < 0) {\n                    // Hide if out of bounds\n                    console.warn('Help screen: Navigated to out-of-bounds page', pageIndex);\n                    content.style.display = 'none';\n                }\n                else {\n                    content.style.display = '';\n                    helpPage.setPageIndex(pageIndex);\n                }\n            };\n            currentPage.onUpdateAndNow(showPage);\n            const navigationControl = {\n                content,\n                currentPage,\n                toNext: () => {\n                    if (navigationControl.hasNext()) {\n                        currentPage.set(currentPage.get() + 1);\n                    }\n                },\n                toPrevious: () => {\n                    if (navigationControl.hasPrevious()) {\n                        currentPage.set(currentPage.get() - 1);\n                    }\n                },\n                hasNext: () => {\n                    return currentPage.get() + 1 < __classPrivateFieldGet(this, _HelpDisplay_helpData, \"f\").length;\n                },\n                hasPrevious: () => {\n                    return currentPage.get() > 0;\n                },\n                refreshCurrent: () => {\n                    helpPage.refresh();\n                },\n            };\n            return navigationControl;\n        };\n        // Creates next/previous buttons.\n        const makeNavigationButtons = (navigation) => {\n            const navigationButtonContainer = document.createElement('div');\n            navigationButtonContainer.classList.add('navigation-buttons');\n            const nextButton = document.createElement('button');\n            const previousButton = document.createElement('button');\n            nextButton.innerText = this.context.localization.next;\n            previousButton.innerText = this.context.localization.previous;\n            nextButton.classList.add('next');\n            previousButton.classList.add('previous');\n            const updateButtonVisibility = () => {\n                navigationButtonContainer.classList.remove('-has-next', '-has-previous');\n                if (navigation.hasNext()) {\n                    navigationButtonContainer.classList.add('-has-next');\n                    nextButton.disabled = false;\n                }\n                else {\n                    navigationButtonContainer.classList.remove('-has-next');\n                    nextButton.disabled = true;\n                }\n                if (navigation.hasPrevious()) {\n                    navigationButtonContainer.classList.add('-has-previous');\n                    previousButton.disabled = false;\n                }\n                else {\n                    navigationButtonContainer.classList.remove('-has-previous');\n                    previousButton.disabled = true;\n                }\n            };\n            navigation.currentPage.onUpdateAndNow(updateButtonVisibility);\n            nextButton.onclick = () => {\n                navigation.toNext();\n            };\n            previousButton.onclick = () => {\n                navigation.toPrevious();\n            };\n            navigationButtonContainer.replaceChildren(previousButton, nextButton);\n            return navigationButtonContainer;\n        };\n        const navigation = makeNavigationContent();\n        const navigationButtons = makeNavigationButtons(navigation);\n        overlay.replaceChildren(makeCloseButton(), navigationButtons, navigation.content);\n        this.createOverlay(overlay);\n        overlay.showModal();\n        const minDragOffsetToTransition = 30;\n        const setDragOffset = (offset) => {\n            if (offset > 0 && !navigation.hasPrevious()) {\n                offset = 0;\n            }\n            if (offset < 0 && !navigation.hasNext()) {\n                offset = 0;\n            }\n            // Clamp offset\n            if (offset > minDragOffsetToTransition || offset < -minDragOffsetToTransition) {\n                offset = minDragOffsetToTransition * Math.sign(offset);\n            }\n            overlay.style.transform = `translate(${offset}px, 0px)`;\n            if (offset >= minDragOffsetToTransition) {\n                navigationButtons.classList.add('-highlight-previous');\n            }\n            else {\n                navigationButtons.classList.remove('-highlight-previous');\n            }\n            if (offset <= -minDragOffsetToTransition) {\n                navigationButtons.classList.add('-highlight-next');\n            }\n            else {\n                navigationButtons.classList.remove('-highlight-next');\n            }\n        };\n        // Listeners\n        const dragListener = makeDraggable(overlay, {\n            draggableChildElements: [navigation.content],\n            onDrag: (_deltaX, _deltaY, totalDisplacement) => {\n                overlay.classList.add('-dragging');\n                setDragOffset(totalDisplacement.x);\n            },\n            onDragEnd: (dragStatistics) => {\n                overlay.classList.remove('-dragging');\n                setDragOffset(0);\n                if (!dragStatistics.roughlyClick) {\n                    const xDisplacement = dragStatistics.displacement.x;\n                    if (xDisplacement > minDragOffsetToTransition) {\n                        navigation.toPrevious();\n                    }\n                    else if (xDisplacement < -minDragOffsetToTransition) {\n                        navigation.toNext();\n                    }\n                    lastDragTimestamp = dragStatistics.endTimestamp;\n                }\n            },\n        });\n        let resizeObserver;\n        if (window.ResizeObserver) {\n            resizeObserver = new ResizeObserver(() => {\n                navigation.refreshCurrent();\n            });\n            resizeObserver.observe(overlay);\n        }\n        const onMediaChangeListener = () => {\n            // Refresh the cloned elements and their styles after a delay.\n            // This is necessary because styles are cloned, in addition to elements.\n            requestAnimationFrame(() => navigation.refreshCurrent());\n        };\n        // matchMedia is unsupported by jsdom\n        const mediaQueryList = window.matchMedia?.('(prefers-color-scheme: dark)');\n        mediaQueryList?.addEventListener('change', onMediaChangeListener);\n        // Close the overlay when clicking on the background (*directly* on any of the\n        // elements in closeOverlayTriggers).\n        const closeOverlayTriggers = [navigation.content, navigationButtons, overlay];\n        overlay.onclick = (event) => {\n            if (closeOverlayTriggers.includes(event.target)) {\n                onBackgroundClick();\n            }\n        };\n        overlay.onkeyup = (event) => {\n            if (event.code === 'Escape') {\n                closeOverlay();\n                event.preventDefault();\n            }\n            else if (event.code === 'ArrowRight') {\n                navigation.toNext();\n                event.preventDefault();\n            }\n            else if (event.code === 'ArrowLeft') {\n                navigation.toPrevious();\n                event.preventDefault();\n            }\n        };\n        overlay.addEventListener('close', () => {\n            this.context.announceForAccessibility(this.context.localization.helpHidden);\n            mediaQueryList?.removeEventListener('change', onMediaChangeListener);\n            dragListener.removeListeners();\n            resizeObserver?.disconnect();\n            overlay.remove();\n        });\n    }\n    /** Marks `helpText` as associated with a single `targetElement`. */\n    registerTextHelpForElement(targetElement, helpText) {\n        this.registerTextHelpForElements([targetElement], helpText);\n    }\n    /** Marks `helpText` as associated with all elements in `targetElements`. */\n    registerTextHelpForElements(targetElements, helpText) {\n        __classPrivateFieldGet(this, _HelpDisplay_helpData, \"f\").push({ targetElements: [...targetElements], helpText });\n    }\n    /** Returns true if any help text has been registered. */\n    hasHelpText() {\n        return __classPrivateFieldGet(this, _HelpDisplay_helpData, \"f\").length > 0;\n    }\n    /**\n     * Creates and returns a button that toggles the help display.\n     */\n    createToggleButton() {\n        const buttonContainer = document.createElement('div');\n        buttonContainer.classList.add('toolbar-help-overlay-button');\n        const helpButton = document.createElement('button');\n        helpButton.classList.add('button');\n        const icon = this.context.icons.makeHelpIcon();\n        icon.classList.add('icon');\n        helpButton.appendChild(icon);\n        helpButton.setAttribute('aria-label', this.context.localization.help);\n        helpButton.onclick = () => {\n            this.showHelpOverlay();\n        };\n        buttonContainer.appendChild(helpButton);\n        return buttonContainer;\n    }\n}\n_HelpDisplay_helpData = new WeakMap();\nexport default HelpDisplay;\n","export const defaultToolbarUtilsLocalization = {\n    help: 'Help',\n    helpHidden: 'Help hidden',\n    next: 'Next',\n    previous: 'Previous',\n    close: 'Close',\n    helpScreenNavigationHelp: 'Click on a control for more information.',\n};\n","import { Vec2 } from '@js-draw/math';\nconst makeDraggable = (dragElement, options) => {\n    const dragElements = [...options.draggableChildElements, dragElement];\n    let lastX = 0;\n    let lastY = 0;\n    let startX = 0;\n    let startY = 0;\n    let pointerDown = false;\n    let capturedPointerId = null;\n    const isDraggableElement = (element) => {\n        if (!element) {\n            return false;\n        }\n        if (dragElements.includes(element)) {\n            return true;\n        }\n        // Some inputs handle dragging themselves. Don't also interpret such gestures\n        // as dragging the dropdown.\n        const undraggableElementTypes = ['INPUT', 'SELECT', 'IMG'];\n        let hasSuitableAncestors = false;\n        let ancestor = element.parentElement;\n        while (ancestor) {\n            if (undraggableElementTypes.includes(ancestor.tagName)) {\n                break;\n            }\n            if (dragElements.includes(ancestor)) {\n                hasSuitableAncestors = true;\n                break;\n            }\n            ancestor = ancestor.parentElement;\n        }\n        return !undraggableElementTypes.includes(element.tagName) && hasSuitableAncestors;\n    };\n    const removeEventListenerCallbacks = [];\n    const addEventListener = (listenerType, listener, options) => {\n        dragElement.addEventListener(listenerType, listener, options);\n        removeEventListenerCallbacks.push(() => {\n            dragElement.removeEventListener(listenerType, listener);\n        });\n    };\n    const clickThreshold = 5;\n    // Returns whether the current (or if no current, **the last**) gesture is roughly a click.\n    // Because this can be called **after** a gesture has just ended, it should not require\n    // the gesture to be in progress.\n    const isRoughlyClick = () => {\n        return Math.hypot(lastX - startX, lastY - startY) < clickThreshold;\n    };\n    let startedDragging = false;\n    addEventListener('pointerdown', (event) => {\n        if (event.defaultPrevented || !isDraggableElement(event.target)) {\n            return;\n        }\n        if (event.isPrimary) {\n            startedDragging = false;\n            lastX = event.clientX;\n            lastY = event.clientY;\n            startX = event.clientX;\n            startY = event.clientY;\n            capturedPointerId = null;\n            pointerDown = true;\n        }\n    }, { passive: true });\n    const onGestureEnd = (_event) => {\n        // If the pointerup/pointercancel event was for a pointer not being tracked,\n        if (!pointerDown) {\n            return;\n        }\n        if (capturedPointerId !== null) {\n            dragElement.releasePointerCapture(capturedPointerId);\n            capturedPointerId = null;\n        }\n        options.onDragEnd({\n            roughlyClick: isRoughlyClick(),\n            endTimestamp: performance.now(),\n            displacement: Vec2.of(lastX - startX, lastY - startY),\n        });\n        pointerDown = false;\n        startedDragging = false;\n    };\n    addEventListener('pointermove', (event) => {\n        if (!event.isPrimary || !pointerDown) {\n            return undefined;\n        }\n        // Mouse event and no buttons pressed? Cancel the event.\n        // This can happen if the event was canceled by a focus change (e.g. by opening a\n        // right-click menu).\n        if (event.pointerType === 'mouse' && event.buttons === 0) {\n            onGestureEnd(event);\n            return undefined;\n        }\n        // Only capture after motion -- capturing early prevents click events in Chrome.\n        if (capturedPointerId === null && !isRoughlyClick()) {\n            dragElement.setPointerCapture(event.pointerId);\n            capturedPointerId = event.pointerId;\n        }\n        const x = event.clientX;\n        const y = event.clientY;\n        const dx = x - lastX;\n        const dy = y - lastY;\n        const isClick = Math.abs(x - startX) <= clickThreshold && Math.abs(y - startY) <= clickThreshold;\n        if (!isClick || startedDragging) {\n            options.onDrag(dx, dy, Vec2.of(x - startX, y - startY));\n            lastX = x;\n            lastY = y;\n            startedDragging = true;\n        }\n    });\n    addEventListener('pointerleave', (event) => {\n        // Capture the pointer if it exits the container while dragging.\n        if (capturedPointerId === null && pointerDown && event.isPrimary) {\n            dragElement.setPointerCapture(event.pointerId);\n            capturedPointerId = event.pointerId;\n        }\n    });\n    addEventListener('pointerup', onGestureEnd);\n    addEventListener('pointercancel', onGestureEnd);\n    return {\n        removeListeners: () => {\n            for (const removeListenerCallback of removeEventListenerCallbacks) {\n                removeListenerCallback();\n            }\n        },\n    };\n};\nexport default makeDraggable;\n","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ActionButtonWidget_autoDisableInReadOnlyEditors, _ActionButtonWidget_helpText;\nimport  BaseWidget  from './BaseWidget.mjs';\nclass ActionButtonWidget extends BaseWidget {\n    constructor(editor, id, makeIcon, title, clickAction, localizationTable, mustBeToplevel = false, autoDisableInReadOnlyEditors = true) {\n        super(editor, id, localizationTable);\n        this.makeIcon = makeIcon;\n        this.title = title;\n        this.clickAction = clickAction;\n        this.mustBeToplevel = mustBeToplevel;\n        _ActionButtonWidget_autoDisableInReadOnlyEditors.set(this, void 0);\n        _ActionButtonWidget_helpText.set(this, undefined);\n        __classPrivateFieldSet(this, _ActionButtonWidget_autoDisableInReadOnlyEditors, autoDisableInReadOnlyEditors, \"f\");\n    }\n    /**\n     * Sets the text shown in a help overlay for this button.\n     *\n     * See {@link getHelpText}.\n     */\n    setHelpText(helpText) {\n        __classPrivateFieldSet(this, _ActionButtonWidget_helpText, helpText, \"f\");\n    }\n    getHelpText() {\n        return __classPrivateFieldGet(this, _ActionButtonWidget_helpText, \"f\");\n    }\n    shouldAutoDisableInReadOnlyEditor() {\n        return __classPrivateFieldGet(this, _ActionButtonWidget_autoDisableInReadOnlyEditors, \"f\");\n    }\n    handleClick() {\n        this.clickAction();\n    }\n    getTitle() {\n        return this.title;\n    }\n    createIcon() {\n        return this.makeIcon();\n    }\n    fillDropdown(_dropdown) {\n        return false;\n    }\n    mustBeInToplevelMenu() {\n        return this.mustBeToplevel;\n    }\n}\n_ActionButtonWidget_autoDisableInReadOnlyEditors = new WeakMap(), _ActionButtonWidget_helpText = new WeakMap();\nexport default ActionButtonWidget;\n","import  BaseWidget  from './BaseWidget.mjs';\nimport  { toolbarCSSPrefix }  from '../constants.mjs';\nconst isToolWidgetFocused = () => {\n    const currentFocus = [...document.querySelectorAll('*:focus')];\n    return (currentFocus.length &&\n        currentFocus.some((elem) => elem.classList.contains(`${toolbarCSSPrefix}button`)));\n};\nexport default class BaseToolWidget extends BaseWidget {\n    constructor(editor, targetTool, id, localizationTable) {\n        super(editor, id, localizationTable);\n        this.targetTool = targetTool;\n        this.targetTool.enabledValue().onUpdateAndNow((enabled) => {\n            if (enabled) {\n                this.setSelected(true);\n                // Transfer focus to the current button, only if another toolbar button is\n                // focused.\n                // This prevents pressing \"space\" from triggering a different action when\n                // the current is selected.\n                if (isToolWidgetFocused()) {\n                    this.focus();\n                }\n            }\n            else {\n                this.setSelected(false);\n                this.setDropdownVisible(false);\n            }\n        });\n    }\n    shouldAutoDisableInReadOnlyEditor() {\n        return !this.targetTool.canReceiveInputInReadOnlyEditor();\n    }\n    handleClick() {\n        if (this.hasDropdown) {\n            if (!this.targetTool.isEnabled()) {\n                this.targetTool.setEnabled(true);\n                this.activateDropdown();\n            }\n            else {\n                this.setDropdownVisible(!this.isDropdownVisible());\n            }\n        }\n        else {\n            this.targetTool.setEnabled(!this.targetTool.isEnabled());\n        }\n    }\n    onKeyPress(event) {\n        if (this.isSelected() && event.code === 'Space' && this.hasDropdown) {\n            this.handleClick();\n            return true;\n        }\n        return false;\n    }\n    addTo(parent) {\n        const result = super.addTo(parent);\n        this.setSelected(this.targetTool.isEnabled());\n        return result;\n    }\n}\n","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _BaseWidget_instances, _a, _BaseWidget_hasDropdown, _BaseWidget_disabledDueToReadOnlyEditor, _BaseWidget_tags, _BaseWidget_removeEditorListeners, _BaseWidget_addEditorListeners;\nimport  ToolbarShortcutHandler  from '../../tools/ToolbarShortcutHandler.mjs';\nimport  { keyPressEventFromHTMLEvent, keyUpEventFromHTMLEvent, }  from '../../inputEvents.mjs';\nimport  { toolbarCSSPrefix }  from '../constants.mjs';\nimport  DropdownLayoutManager  from './layout/DropdownLayoutManager.mjs';\nimport  addLongPressOrHoverCssClasses  from '../../util/addLongPressOrHoverCssClasses.mjs';\nimport  HelpDisplay  from '../utils/HelpDisplay.mjs';\nimport  { assertIsObject }  from '../../util/assertions.mjs';\n/**\n * A set of labels that allow toolbar themes to treat buttons differently.\n */\nexport var ToolbarWidgetTag;\n(function (ToolbarWidgetTag) {\n    ToolbarWidgetTag[\"Save\"] = \"save\";\n    ToolbarWidgetTag[\"Exit\"] = \"exit\";\n    ToolbarWidgetTag[\"Undo\"] = \"undo\";\n    ToolbarWidgetTag[\"Redo\"] = \"redo\";\n})(ToolbarWidgetTag || (ToolbarWidgetTag = {}));\n/**\n * The `abstract` base class for items that can be shown in a `js-draw` toolbar. See also {@link AbstractToolbar.addWidget}.\n *\n * See [the custom tool example](https://github.com/personalizedrefrigerator/js-draw/blob/main/docs/examples/example-custom-tools/example.ts)\n * for how to create a custom toolbar widget for a tool.\n *\n * For custom action buttons, {@link AbstractToolbar.addActionButton} may be sufficient for most use cases.\n */\nclass BaseWidget {\n    constructor(editor, id, localizationTable) {\n        _BaseWidget_instances.add(this);\n        this.editor = editor;\n        this.id = id;\n        this.dropdown = null;\n        _BaseWidget_hasDropdown.set(this, void 0);\n        // True iff this widget is disabled.\n        this.disabled = false;\n        // True iff this widget is currently disabled because the editor is read only\n        _BaseWidget_disabledDueToReadOnlyEditor.set(this, false);\n        _BaseWidget_tags.set(this, []);\n        // Maps subWidget IDs to subWidgets.\n        this.subWidgets = {};\n        this.toplevel = true;\n        _BaseWidget_removeEditorListeners.set(this, null);\n        this.localizationTable = localizationTable ?? editor.localization;\n        // Default layout manager\n        const defaultLayoutManager = new DropdownLayoutManager((text) => this.editor.announceForAccessibility(text), this.localizationTable);\n        defaultLayoutManager.connectToEditorNotifier(editor.notifier);\n        this.layoutManager = defaultLayoutManager;\n        this.icon = null;\n        this.container = document.createElement('div');\n        this.container.classList.add(`${toolbarCSSPrefix}toolContainer`, `${toolbarCSSPrefix}toolButtonContainer`, `${toolbarCSSPrefix}internalWidgetId--${id.replace(/[^a-zA-Z0-9_]/g, '-')}`);\n        this.dropdownContent = document.createElement('div');\n        __classPrivateFieldSet(this, _BaseWidget_hasDropdown, false, \"f\");\n        this.button = document.createElement('div');\n        this.button.classList.add(`${toolbarCSSPrefix}button`);\n        this.label = document.createElement('label');\n        this.button.setAttribute('role', 'button');\n        this.button.tabIndex = 0;\n        // Disable the context menu. This allows long-press gestures to trigger the button's\n        // tooltip instead.\n        this.button.oncontextmenu = (event) => {\n            event.preventDefault();\n        };\n        addLongPressOrHoverCssClasses(this.button);\n    }\n    /**\n     * Should return a constant true or false value. If true (the default),\n     * this widget must be automatically disabled when its editor is read-only.\n     */\n    shouldAutoDisableInReadOnlyEditor() {\n        return true;\n    }\n    getId() {\n        return this.id;\n    }\n    /**\n     * Note: Tags should be set *before* a tool widget is added to a toolbar.\n     *\n     *\n     * Associates tags with this widget that can be used by toolbar themes\n     * to customize the layout/appearance of this button. Prefer tags in\n     * the `ToolbarWidgetTag` enum, where possible.\n     *\n     * In addition to being readable from the {@link getTags} method, tags are\n     * added to a button's main container as CSS classes with the `toolwidget-tag--` prefix.\n     *\n     * For example, the `undo` tag would result in `toolwidget-tag--undo`\n     * being added to the button's container's class list.\n     *\n     */\n    setTags(tags) {\n        const toClassName = (tag) => {\n            return `toolwidget-tag--${tag}`;\n        };\n        // Remove CSS classes associated with old tags\n        for (const tag of __classPrivateFieldGet(this, _BaseWidget_tags, \"f\")) {\n            this.container.classList.remove(toClassName(tag));\n        }\n        __classPrivateFieldSet(this, _BaseWidget_tags, [...tags], \"f\");\n        // Add new CSS classes\n        for (const tag of __classPrivateFieldGet(this, _BaseWidget_tags, \"f\")) {\n            this.container.classList.add(toClassName(tag));\n        }\n    }\n    getTags() {\n        return [...__classPrivateFieldGet(this, _BaseWidget_tags, \"f\")];\n    }\n    /**\n     * Returns the ID of this widget in `container`. Adds a suffix to this' ID\n     * if an item in `container` already has this' ID.\n     *\n     * For example, if `this` has ID `foo` and if\n     * `container = { 'foo': somethingNotThis, 'foo-1': somethingElseNotThis }`, this method\n     * returns `foo-2` because elements with IDs `foo` and `foo-1` are already present in\n     * `container`.\n     *\n     * If `this` is already in `container`, returns the id given to `this` in the container.\n     */\n    getUniqueIdIn(container) {\n        let id = this.getId();\n        let idCounter = 0;\n        while (id in container && container[id] !== this) {\n            id = this.getId() + '-' + idCounter.toString();\n            idCounter++;\n        }\n        return id;\n    }\n    // Add content to the widget's associated dropdown menu.\n    // Returns true if such a menu should be created, false otherwise.\n    fillDropdown(dropdown, helpDisplay) {\n        if (Object.keys(this.subWidgets).length === 0) {\n            return false;\n        }\n        for (const widgetId in this.subWidgets) {\n            const widget = this.subWidgets[widgetId];\n            const widgetElement = widget.addTo(dropdown);\n            widget.setIsToplevel(false);\n            // Add help information\n            const helpText = widget.getHelpText();\n            if (helpText) {\n                helpDisplay?.registerTextHelpForElement(widgetElement, helpText);\n            }\n        }\n        return true;\n    }\n    /**\n     * Should return a 1-2 sentence description of the widget.\n     *\n     * At present, this is only used if this widget has an associated dropdown.\n     */\n    getHelpText() {\n        return undefined;\n    }\n    /** @deprecated Renamed to `setUpButtonEventListeners`. */\n    setupActionBtnClickListener(button) {\n        return this.setUpButtonEventListeners(button);\n    }\n    setUpButtonEventListeners(button) {\n        const clickTriggers = { Enter: true, ' ': true };\n        button.onkeydown = (evt) => {\n            let handled = false;\n            if (evt.key in clickTriggers) {\n                if (!this.disabled) {\n                    this.handleClick();\n                    handled = true;\n                }\n            }\n            // If we didn't do anything with the event, send it to the editor.\n            if (!handled) {\n                const editorEvent = keyPressEventFromHTMLEvent(evt);\n                handled = this.editor.toolController.dispatchInputEvent(editorEvent);\n            }\n            if (handled) {\n                evt.preventDefault();\n            }\n        };\n        button.onkeyup = (htmlEvent) => {\n            if (htmlEvent.key in clickTriggers) {\n                return;\n            }\n            const event = keyUpEventFromHTMLEvent(htmlEvent);\n            const handled = this.editor.toolController.dispatchInputEvent(event);\n            if (handled) {\n                htmlEvent.preventDefault();\n            }\n        };\n        button.onclick = () => {\n            if (!this.disabled) {\n                this.handleClick();\n            }\n        };\n        // Prevent double-click zoom on some devices.\n        button.ondblclick = (event) => {\n            event.preventDefault();\n        };\n    }\n    // Add a listener that is triggered when a key is pressed.\n    // Listeners will fire regardless of whether this widget is selected and require that\n    // {@link Editor.toolController} to have an enabled {@link ToolbarShortcutHandler} tool.\n    onKeyPress(_event) {\n        return false;\n    }\n    get hasDropdown() {\n        return __classPrivateFieldGet(this, _BaseWidget_hasDropdown, \"f\");\n    }\n    // Add a widget to this' dropdown. Must be called before this.addTo.\n    addSubWidget(widget) {\n        // Generate a unique ID for the widget.\n        const id = widget.getUniqueIdIn(this.subWidgets);\n        this.subWidgets[id] = widget;\n    }\n    setLayoutManager(manager) {\n        if (manager === this.layoutManager) {\n            return;\n        }\n        this.layoutManager = manager;\n        if (this.container.parentElement) {\n            // Trigger a re-creation of this' content\n            this.addTo(this.container.parentElement);\n        }\n    }\n    /**\n     * Adds this to `parent`.\n     * Returns the element that was just added to `parent`.\n     * @internal\n     */\n    addTo(parent) {\n        // Update title and icon\n        this.icon = null;\n        this.updateIcon();\n        this.label.innerText = this.getTitle();\n        const longLabelCSSClass = 'long-label';\n        if (this.label.innerText.length > 7) {\n            this.label.classList.add(longLabelCSSClass);\n        }\n        else {\n            this.label.classList.remove(longLabelCSSClass);\n        }\n        // Click functionality\n        this.setUpButtonEventListeners(this.button);\n        // Clear anything already in this.container.\n        this.container.replaceChildren();\n        this.button.replaceChildren(this.icon, this.label);\n        this.container.appendChild(this.button);\n        const helpDisplay = new HelpDisplay((content) => this.editor.createHTMLOverlay(content), this.editor);\n        const helpText = this.getHelpText();\n        if (helpText) {\n            helpDisplay.registerTextHelpForElement(this.dropdownContent, [this.getTitle(), helpText].join('\\n\\n'));\n        }\n        // Clear the dropdownContainer in case this element is being moved to another\n        // parent.\n        this.dropdownContent.replaceChildren();\n        __classPrivateFieldSet(this, _BaseWidget_hasDropdown, this.fillDropdown(this.dropdownContent, helpDisplay), \"f\");\n        if (__classPrivateFieldGet(this, _BaseWidget_hasDropdown, \"f\")) {\n            this.button.classList.add('has-dropdown');\n            // We're re-creating the dropdown.\n            this.dropdown?.destroy();\n            this.dropdownIcon = this.createDropdownIcon();\n            this.button.appendChild(this.dropdownIcon);\n            this.dropdown = this.layoutManager.createToolMenu({\n                target: this.button,\n                getTitle: () => this.getTitle(),\n                isToplevel: () => this.toplevel,\n            });\n            this.dropdown.visible.onUpdate((visible) => {\n                if (visible) {\n                    this.container.classList.add('dropdownVisible');\n                }\n                else {\n                    this.container.classList.remove('dropdownVisible');\n                }\n                // Auto-focus this component's button when the dropdown hides --\n                // this ensures that keyboard focus goes to a reasonable location when\n                // the user closes a menu.\n                if (!visible) {\n                    this.focus();\n                }\n            });\n            if (helpDisplay.hasHelpText()) {\n                this.dropdown.appendChild(helpDisplay.createToggleButton());\n            }\n            this.dropdown.appendChild(this.dropdownContent);\n        }\n        this.setDropdownVisible(false);\n        if (this.container.parentElement) {\n            this.container.remove();\n        }\n        __classPrivateFieldGet(this, _BaseWidget_instances, \"m\", _BaseWidget_addEditorListeners).call(this);\n        parent.appendChild(this.container);\n        return this.container;\n    }\n    /**\n     * Remove this. This allows the widget to be added to a toolbar again\n     * in the future using `addTo`.\n     */\n    remove() {\n        this.container.remove();\n        __classPrivateFieldGet(this, _BaseWidget_removeEditorListeners, \"f\")?.call(this);\n    }\n    focus() {\n        this.button.focus();\n    }\n    /**\n     * @internal\n     */\n    addCSSClassToContainer(className) {\n        this.container.classList.add(className);\n    }\n    removeCSSClassFromContainer(className) {\n        this.container.classList.remove(className);\n    }\n    updateIcon() {\n        let newIcon = this.createIcon();\n        if (!newIcon) {\n            newIcon = document.createElement('div');\n            this.container.classList.add('no-icon');\n        }\n        else {\n            this.container.classList.remove('no-icon');\n        }\n        this.icon?.replaceWith(newIcon);\n        this.icon = newIcon;\n        this.icon.classList.add(`${toolbarCSSPrefix}icon`);\n    }\n    setDisabled(disabled) {\n        this.disabled = disabled;\n        __classPrivateFieldSet(this, _BaseWidget_disabledDueToReadOnlyEditor, false, \"f\");\n        if (this.disabled) {\n            this.button.classList.add('disabled');\n            this.button.setAttribute('aria-disabled', 'true');\n        }\n        else {\n            this.button.classList.remove('disabled');\n            this.button.removeAttribute('aria-disabled');\n        }\n    }\n    setSelected(selected) {\n        const currentlySelected = this.isSelected();\n        if (currentlySelected === selected) {\n            return;\n        }\n        // Ensure that accessibility tools check and read the value of\n        // aria-checked.\n        // TODO: Ensure that 'role' is set to 'switch' by default for selectable\n        //       buttons.\n        this.button.setAttribute('role', 'switch');\n        if (selected) {\n            this.container.classList.add('selected');\n            this.button.setAttribute('aria-checked', 'true');\n        }\n        else {\n            this.container.classList.remove('selected');\n            this.button.setAttribute('aria-checked', 'false');\n        }\n    }\n    setDropdownVisible(visible) {\n        if (visible) {\n            this.dropdown?.requestShow();\n        }\n        else {\n            this.dropdown?.requestHide();\n        }\n    }\n    /**\n     * Only used by some layout managers.\n     * In those layout managers, makes this dropdown visible.\n     */\n    activateDropdown() {\n        this.dropdown?.onActivated();\n    }\n    /**\n     * Returns `true` if this widget must always be in a toplevel menu and not\n     * in a scrolling/overflow menu.\n     *\n     * This method can be overidden to override the default of `true`.\n     */\n    mustBeInToplevelMenu() {\n        return false;\n    }\n    /**\n     * Returns true iff this widget can be in a nontoplevel menu.\n     *\n     * @deprecated Use `!mustBeInToplevelMenu()` instead.\n     */\n    canBeInOverflowMenu() {\n        return !this.mustBeInToplevelMenu();\n    }\n    getButtonWidth() {\n        return this.button.clientWidth;\n    }\n    isHidden() {\n        return this.container.style.display === 'none';\n    }\n    setHidden(hidden) {\n        this.container.style.display = hidden ? 'none' : '';\n    }\n    /** Set whether the widget is contained within another. @internal */\n    setIsToplevel(toplevel) {\n        this.toplevel = toplevel;\n    }\n    /** Returns true if the menu for this widget is open. */\n    isDropdownVisible() {\n        return this.dropdown?.visible?.get() ?? false;\n    }\n    isSelected() {\n        return this.container.classList.contains('selected');\n    }\n    createDropdownIcon() {\n        const icon = this.editor.icons.makeDropdownIcon();\n        icon.classList.add(`${toolbarCSSPrefix}showHideDropdownIcon`);\n        return icon;\n    }\n    /**\n     * Serialize state associated with this widget.\n     * Override this method to allow saving/restoring from state on application load.\n     *\n     * Overriders should call `super` and include the output of `super.serializeState` in\n     * the output dictionary.\n     *\n     * Clients should not rely on the output from `saveState` being in any particular\n     * format.\n     */\n    serializeState() {\n        const subwidgetState = {};\n        // Save all subwidget state.\n        for (const subwidgetId in this.subWidgets) {\n            subwidgetState[subwidgetId] = this.subWidgets[subwidgetId].serializeState();\n        }\n        return {\n            subwidgetState,\n        };\n    }\n    /**\n     * Restore widget state from serialized data. See also `saveState`.\n     *\n     * Overriders must call `super`.\n     */\n    deserializeFrom(state) {\n        if (state.subwidgetState) {\n            assertIsObject(state.subwidgetState);\n            // Deserialize all subwidgets.\n            for (const subwidgetId in state.subwidgetState) {\n                if (subwidgetId in this.subWidgets) {\n                    const serializedSubwidgetState = state.subwidgetState[subwidgetId];\n                    if (serializedSubwidgetState) {\n                        this.subWidgets[subwidgetId].deserializeFrom(serializedSubwidgetState);\n                    }\n                }\n            }\n        }\n    }\n}\n_a = BaseWidget, _BaseWidget_hasDropdown = new WeakMap(), _BaseWidget_disabledDueToReadOnlyEditor = new WeakMap(), _BaseWidget_tags = new WeakMap(), _BaseWidget_removeEditorListeners = new WeakMap(), _BaseWidget_instances = new WeakSet(), _BaseWidget_addEditorListeners = function _BaseWidget_addEditorListeners() {\n    __classPrivateFieldGet(this, _BaseWidget_removeEditorListeners, \"f\")?.call(this);\n    const toolbarShortcutHandlers = this.editor.toolController.getMatchingTools(ToolbarShortcutHandler);\n    let removeKeyPressListener = null;\n    // If the onKeyPress function has been extended and the editor is configured to send keypress events to\n    // toolbar widgets,\n    if (toolbarShortcutHandlers.length > 0 && this.onKeyPress !== _a.prototype.onKeyPress) {\n        const keyPressListener = (event) => this.onKeyPress(event);\n        const handler = toolbarShortcutHandlers[0];\n        handler.registerListener(keyPressListener);\n        removeKeyPressListener = () => {\n            handler.removeListener(keyPressListener);\n        };\n    }\n    const readOnlyListener = this.editor.isReadOnlyReactiveValue().onUpdateAndNow((readOnly) => {\n        if (readOnly && this.shouldAutoDisableInReadOnlyEditor() && !this.disabled) {\n            this.setDisabled(true);\n            __classPrivateFieldSet(this, _BaseWidget_disabledDueToReadOnlyEditor, true, \"f\");\n            if (__classPrivateFieldGet(this, _BaseWidget_hasDropdown, \"f\")) {\n                this.dropdown?.requestHide();\n            }\n        }\n        else if (!readOnly && __classPrivateFieldGet(this, _BaseWidget_disabledDueToReadOnlyEditor, \"f\")) {\n            __classPrivateFieldSet(this, _BaseWidget_disabledDueToReadOnlyEditor, false, \"f\");\n            this.setDisabled(false);\n        }\n    });\n    __classPrivateFieldSet(this, _BaseWidget_removeEditorListeners, () => {\n        readOnlyListener.remove();\n        removeKeyPressListener?.();\n        __classPrivateFieldSet(this, _BaseWidget_removeEditorListeners, null, \"f\");\n    }, \"f\");\n};\nexport default BaseWidget;\n","import  Erase  from '../../commands/Erase.mjs';\nimport  uniteCommands  from '../../commands/uniteCommands.mjs';\nimport  BackgroundComponent, { BackgroundType }  from '../../components/BackgroundComponent.mjs';\nimport  { EditorImageEventType }  from '../../image/EditorImage.mjs';\nimport { Rect2 } from '@js-draw/math';\nimport  { EditorEventType }  from '../../types.mjs';\nimport  { toolbarCSSPrefix }  from '../constants.mjs';\nimport  makeColorInput  from './components/makeColorInput.mjs';\nimport  BaseWidget  from './BaseWidget.mjs';\nclass DocumentPropertiesWidget extends BaseWidget {\n    constructor(editor, localizationTable) {\n        super(editor, 'document-properties-widget', localizationTable);\n        this.updateDropdownContent = () => { };\n        this.dropdownUpdateQueued = false;\n        // Make it possible to open the dropdown, even if this widget isn't selected.\n        this.container.classList.add('dropdownShowable');\n        this.editor.notifier.on(EditorEventType.UndoRedoStackUpdated, () => {\n            this.queueDropdownUpdate();\n        });\n        this.editor.image.notifier.on(EditorImageEventType.ExportViewportChanged, () => {\n            this.queueDropdownUpdate();\n        });\n    }\n    getTitle() {\n        return this.localizationTable.documentProperties;\n    }\n    createIcon() {\n        return this.editor.icons.makeConfigureDocumentIcon();\n    }\n    handleClick() {\n        this.setDropdownVisible(!this.isDropdownVisible());\n        this.queueDropdownUpdate();\n    }\n    queueDropdownUpdate() {\n        if (!this.dropdownUpdateQueued) {\n            requestAnimationFrame(() => this.updateDropdown());\n            this.dropdownUpdateQueued = true;\n        }\n    }\n    updateDropdown() {\n        this.dropdownUpdateQueued = false;\n        if (this.isDropdownVisible()) {\n            this.updateDropdownContent();\n        }\n    }\n    setBackgroundColor(color) {\n        this.editor.dispatch(this.editor.setBackgroundColor(color));\n    }\n    getBackgroundColor() {\n        return this.editor.estimateBackgroundColor();\n    }\n    removeBackgroundComponents() {\n        const previousBackgrounds = [];\n        for (const component of this.editor.image.getBackgroundComponents()) {\n            if (component instanceof BackgroundComponent) {\n                previousBackgrounds.push(component);\n            }\n        }\n        return new Erase(previousBackgrounds);\n    }\n    /** Replace existing background components with a background of the given type. */\n    setBackgroundType(backgroundType) {\n        const prevBackgroundColor = this.editor.estimateBackgroundColor();\n        const newBackground = new BackgroundComponent(backgroundType, prevBackgroundColor);\n        const addBackgroundCommand = this.editor.image.addElement(newBackground);\n        return uniteCommands([this.removeBackgroundComponents(), addBackgroundCommand]);\n    }\n    /** Returns the type of the topmost background component */\n    getBackgroundType() {\n        const backgroundComponents = this.editor.image.getBackgroundComponents();\n        for (let i = backgroundComponents.length - 1; i >= 0; i--) {\n            const component = backgroundComponents[i];\n            if (component instanceof BackgroundComponent) {\n                return component.getBackgroundType();\n            }\n        }\n        return BackgroundType.None;\n    }\n    updateImportExportRectSize(size) {\n        const filterDimension = (dim) => {\n            if (dim !== undefined && (!isFinite(dim) || dim <= 0)) {\n                dim = 100;\n            }\n            return dim;\n        };\n        const width = filterDimension(size.width);\n        const height = filterDimension(size.height);\n        const currentRect = this.editor.getImportExportRect();\n        const newRect = new Rect2(currentRect.x, currentRect.y, width ?? currentRect.w, height ?? currentRect.h);\n        this.editor.dispatch(this.editor.image.setImportExportRect(newRect));\n        this.editor.queueRerender();\n    }\n    getHelpText() {\n        return this.localizationTable.pageDropdown__baseHelpText;\n    }\n    fillDropdown(dropdown, helpDisplay) {\n        const container = document.createElement('div');\n        container.classList.add(`${toolbarCSSPrefix}spacedList`, `${toolbarCSSPrefix}nonbutton-controls-main-list`, `${toolbarCSSPrefix}document-properties-widget`);\n        // Background color input\n        const makeBackgroundColorInput = () => {\n            const backgroundColorRow = document.createElement('div');\n            const backgroundColorLabel = document.createElement('label');\n            backgroundColorLabel.innerText = this.localizationTable.backgroundColor;\n            const { input: colorInput, container: backgroundColorInputContainer, setValue: setBgColorInputValue, registerWithHelpTextDisplay: registerHelpForInputs, } = makeColorInput(this.editor, (color) => {\n                if (!color.eq(this.getBackgroundColor())) {\n                    this.setBackgroundColor(color);\n                }\n            });\n            colorInput.id = `${toolbarCSSPrefix}docPropertiesColorInput-${DocumentPropertiesWidget.idCounter++}`;\n            backgroundColorLabel.htmlFor = colorInput.id;\n            backgroundColorRow.replaceChildren(backgroundColorLabel, backgroundColorInputContainer);\n            const registerWithHelp = (helpDisplay) => {\n                if (!helpDisplay) {\n                    return;\n                }\n                helpDisplay?.registerTextHelpForElement(backgroundColorRow, this.localizationTable.pageDropdown__backgroundColorHelpText);\n                registerHelpForInputs(helpDisplay);\n            };\n            return { setBgColorInputValue, backgroundColorRow, registerWithHelp };\n        };\n        const { backgroundColorRow, setBgColorInputValue, registerWithHelp: registerBackgroundRowWithHelp, } = makeBackgroundColorInput();\n        const makeCheckboxRow = (labelText, onChange) => {\n            const rowContainer = document.createElement('div');\n            const labelElement = document.createElement('label');\n            const checkboxElement = document.createElement('input');\n            checkboxElement.id = `${toolbarCSSPrefix}docPropertiesCheckbox-${DocumentPropertiesWidget.idCounter++}`;\n            labelElement.htmlFor = checkboxElement.id;\n            checkboxElement.type = 'checkbox';\n            labelElement.innerText = labelText;\n            checkboxElement.oninput = () => {\n                onChange(checkboxElement.checked);\n            };\n            rowContainer.replaceChildren(labelElement, checkboxElement);\n            return { container: rowContainer, checkbox: checkboxElement };\n        };\n        // Background style selector\n        const { container: useGridRow, checkbox: useGridCheckbox } = makeCheckboxRow(this.localizationTable.useGridOption, (checked) => {\n            const prevBackgroundType = this.getBackgroundType();\n            const wasGrid = prevBackgroundType === BackgroundType.Grid;\n            if (wasGrid === checked) {\n                // Already the requested background type.\n                return;\n            }\n            let newBackgroundType = BackgroundType.SolidColor;\n            if (checked) {\n                newBackgroundType = BackgroundType.Grid;\n            }\n            this.editor.dispatch(this.setBackgroundType(newBackgroundType));\n        });\n        // Adds a width/height input\n        const addDimensionRow = (labelContent, onChange) => {\n            const row = document.createElement('div');\n            const label = document.createElement('label');\n            const input = document.createElement('input');\n            label.innerText = labelContent;\n            input.type = 'number';\n            input.min = '0';\n            input.id = `${toolbarCSSPrefix}docPropertiesDimensionRow-${DocumentPropertiesWidget.idCounter++}`;\n            label.htmlFor = input.id;\n            input.style.flexGrow = '2';\n            input.style.width = '25px';\n            input.oninput = () => {\n                onChange(parseFloat(input.value));\n            };\n            row.classList.add('js-draw-size-input-row');\n            row.replaceChildren(label, input);\n            return {\n                setValue: (value) => {\n                    // Slightly improve the case where the user tries to change the\n                    // first digit of a dimension like 600.\n                    //\n                    // As changing the value also gives the image zero size (which is unsupported,\n                    // .setValue is called immediately). We work around this by trying to select\n                    // the added/changed digits.\n                    //\n                    // See https://github.com/personalizedrefrigerator/js-draw/issues/58.\n                    if (document.activeElement === input && input.value.match(/^0*$/)) {\n                        // We need to switch to type=\"text\" and back to type=\"number\" because\n                        // number inputs don't support selection.\n                        //\n                        // See https://stackoverflow.com/q/22381837\n                        const originalValue = input.value;\n                        input.type = 'text';\n                        input.value = value.toString();\n                        // Select the added digits\n                        const lengthToSelect = Math.max(1, input.value.length - originalValue.length);\n                        input.setSelectionRange(0, lengthToSelect);\n                        input.type = 'number';\n                    }\n                    else {\n                        input.value = value.toString();\n                    }\n                },\n                setIsAutomaticSize: (automatic) => {\n                    input.disabled = automatic;\n                    const automaticSizeClass = 'size-input-row--automatic-size';\n                    if (automatic) {\n                        row.classList.add(automaticSizeClass);\n                    }\n                    else {\n                        row.classList.remove(automaticSizeClass);\n                    }\n                },\n                element: row,\n            };\n        };\n        const imageWidthRow = addDimensionRow(this.localizationTable.imageWidthOption, (value) => {\n            this.updateImportExportRectSize({ width: value });\n        });\n        const imageHeightRow = addDimensionRow(this.localizationTable.imageHeightOption, (value) => {\n            this.updateImportExportRectSize({ height: value });\n        });\n        // The autoresize checkbox\n        const { container: auroresizeRow, checkbox: autoresizeCheckbox } = makeCheckboxRow(this.localizationTable.enableAutoresizeOption, (checked) => {\n            const image = this.editor.image;\n            this.editor.dispatch(image.setAutoresizeEnabled(checked));\n        });\n        // The \"About...\" button\n        const aboutButton = document.createElement('button');\n        aboutButton.classList.add('about-button');\n        aboutButton.innerText = this.localizationTable.about;\n        aboutButton.onclick = () => {\n            this.editor.showAboutDialog();\n        };\n        // Add help text\n        registerBackgroundRowWithHelp(helpDisplay);\n        helpDisplay?.registerTextHelpForElement(useGridRow, this.localizationTable.pageDropdown__gridCheckboxHelpText);\n        helpDisplay?.registerTextHelpForElement(auroresizeRow, this.localizationTable.pageDropdown__autoresizeCheckboxHelpText);\n        helpDisplay?.registerTextHelpForElement(aboutButton, this.localizationTable.pageDropdown__aboutButtonHelpText);\n        this.updateDropdownContent = () => {\n            setBgColorInputValue(this.getBackgroundColor());\n            const autoresize = this.editor.image.getAutoresizeEnabled();\n            const importExportRect = this.editor.getImportExportRect();\n            imageWidthRow.setValue(importExportRect.width);\n            imageHeightRow.setValue(importExportRect.height);\n            autoresizeCheckbox.checked = autoresize;\n            imageWidthRow.setIsAutomaticSize(autoresize);\n            imageHeightRow.setIsAutomaticSize(autoresize);\n            useGridCheckbox.checked = this.getBackgroundType() === BackgroundType.Grid;\n        };\n        this.updateDropdownContent();\n        container.replaceChildren(backgroundColorRow, useGridRow, imageWidthRow.element, imageHeightRow.element, auroresizeRow, aboutButton);\n        dropdown.replaceChildren(container);\n        return true;\n    }\n}\nDocumentPropertiesWidget.idCounter = 0;\nexport default DocumentPropertiesWidget;\n","import  { EraserMode }  from '../../tools/Eraser.mjs';\nimport  { EditorEventType }  from '../../types.mjs';\nimport  { toolbarCSSPrefix }  from '../constants.mjs';\nimport  BaseToolWidget  from './BaseToolWidget.mjs';\nimport  makeThicknessSlider  from './components/makeThicknessSlider.mjs';\nclass EraserToolWidget extends BaseToolWidget {\n    constructor(editor, tool, localizationTable) {\n        super(editor, tool, 'eraser-tool-widget', localizationTable);\n        this.tool = tool;\n        this.updateInputs = () => { };\n        this.editor.notifier.on(EditorEventType.ToolUpdated, (toolEvt) => {\n            if (toolEvt.kind === EditorEventType.ToolUpdated && toolEvt.tool === this.tool) {\n                this.updateInputs();\n                this.updateIcon();\n            }\n        });\n    }\n    getHelpText() {\n        return this.localizationTable.eraserDropdown__baseHelpText;\n    }\n    getTitle() {\n        return this.localizationTable.eraser;\n    }\n    makeIconForType(mode) {\n        return this.editor.icons.makeEraserIcon(this.tool.getThickness(), mode);\n    }\n    createIcon() {\n        return this.makeIconForType(this.tool.getModeValue().get());\n    }\n    makeEraserTypeSelector(helpDisplay) {\n        const container = document.createElement('div');\n        const labelElement = document.createElement('label');\n        const checkboxElement = document.createElement('input');\n        checkboxElement.id = `${toolbarCSSPrefix}eraserToolWidget-${EraserToolWidget.idCounter++}`;\n        labelElement.htmlFor = checkboxElement.id;\n        labelElement.innerText = this.localizationTable.fullStrokeEraser;\n        checkboxElement.type = 'checkbox';\n        checkboxElement.oninput = () => {\n            this.tool\n                .getModeValue()\n                .set(checkboxElement.checked ? EraserMode.FullStroke : EraserMode.PartialStroke);\n        };\n        const updateValue = () => {\n            checkboxElement.checked = this.tool.getModeValue().get() === EraserMode.FullStroke;\n        };\n        container.replaceChildren(labelElement, checkboxElement);\n        helpDisplay?.registerTextHelpForElement(container, this.localizationTable.eraserDropdown__fullStrokeEraserHelpText);\n        return {\n            addTo: (parent) => {\n                parent.appendChild(container);\n            },\n            updateValue,\n        };\n    }\n    fillDropdown(dropdown, helpDisplay) {\n        const container = document.createElement('div');\n        container.classList.add(`${toolbarCSSPrefix}spacedList`, `${toolbarCSSPrefix}nonbutton-controls-main-list`);\n        const thicknessSlider = makeThicknessSlider(this.editor, (thickness) => {\n            this.tool.setThickness(thickness);\n        });\n        thicknessSlider.setBounds(10, 55);\n        helpDisplay?.registerTextHelpForElement(thicknessSlider.container, this.localizationTable.eraserDropdown__thicknessHelpText);\n        const modeSelector = this.makeEraserTypeSelector(helpDisplay);\n        this.updateInputs = () => {\n            thicknessSlider.setValue(this.tool.getThickness());\n            modeSelector.updateValue();\n        };\n        this.updateInputs();\n        container.replaceChildren(thicknessSlider.container);\n        modeSelector.addTo(container);\n        dropdown.replaceChildren(container);\n        return true;\n    }\n    serializeState() {\n        return {\n            ...super.serializeState(),\n            thickness: this.tool.getThickness(),\n            mode: this.tool.getModeValue().get(),\n        };\n    }\n    deserializeFrom(state) {\n        super.deserializeFrom(state);\n        if (state.thickness) {\n            const parsedThickness = parseFloat(state.thickness);\n            if (typeof parsedThickness !== 'number' || !isFinite(parsedThickness)) {\n                throw new Error(`Deserializing property ${parsedThickness} is not a number or is not finite.`);\n            }\n            this.tool.setThickness(parsedThickness);\n        }\n        if (state.mode) {\n            const mode = state.mode;\n            if (Object.values(EraserMode).includes(mode)) {\n                this.tool.getModeValue().set(mode);\n            }\n        }\n    }\n}\nEraserToolWidget.idCounter = 0;\nexport default EraserToolWidget;\n","import  ActionButtonWidget  from './ActionButtonWidget.mjs';\nimport  { ToolbarWidgetTag }  from './BaseWidget.mjs';\nimport  { exitKeyboardShortcut }  from './keybindings.mjs';\nclass ExitActionWidget extends ActionButtonWidget {\n    constructor(editor, localization, saveCallback, labelOverride = {}) {\n        super(editor, 'exit-button', \n        // Creates an icon\n        () => {\n            return labelOverride.icon ?? editor.icons.makeCloseIcon();\n        }, labelOverride.label ?? localization.exit, saveCallback);\n        this.setTags([ToolbarWidgetTag.Exit]);\n    }\n    shouldAutoDisableInReadOnlyEditor() {\n        return false;\n    }\n    onKeyPress(event) {\n        if (this.editor.shortcuts.matchesShortcut(exitKeyboardShortcut, event)) {\n            this.clickAction();\n            return true;\n        }\n        return super.onKeyPress(event);\n    }\n    mustBeInToplevelMenu() {\n        return true;\n    }\n}\nexport default ExitActionWidget;\n","import { Mat33 } from '@js-draw/math';\nimport  PanZoom, { PanZoomMode }  from '../../tools/PanZoom.mjs';\nimport  { EditorEventType }  from '../../types.mjs';\nimport  Viewport  from '../../Viewport.mjs';\nimport  { toolbarCSSPrefix }  from '../constants.mjs';\nimport  BaseToolWidget  from './BaseToolWidget.mjs';\nimport  BaseWidget  from './BaseWidget.mjs';\nimport  makeSeparator  from './components/makeSeparator.mjs';\nconst makeZoomControl = (localizationTable, editor, helpDisplay) => {\n    const zoomLevelRow = document.createElement('div');\n    const increaseButton = document.createElement('button');\n    const decreaseButton = document.createElement('button');\n    const resetViewButton = document.createElement('button');\n    const zoomLevelDisplay = document.createElement('span');\n    increaseButton.innerText = '+';\n    decreaseButton.innerText = '-';\n    resetViewButton.innerText = localizationTable.resetView;\n    zoomLevelRow.replaceChildren(zoomLevelDisplay, increaseButton, decreaseButton, resetViewButton);\n    zoomLevelRow.classList.add(`${toolbarCSSPrefix}zoomLevelEditor`);\n    zoomLevelDisplay.classList.add('zoomDisplay');\n    let lastZoom;\n    const updateZoomDisplay = () => {\n        let zoomLevel = editor.viewport.getScaleFactor() * 100;\n        if (zoomLevel > 0.1) {\n            zoomLevel = Math.round(zoomLevel * 10) / 10;\n        }\n        else {\n            zoomLevel = Math.round(zoomLevel * 1000) / 1000;\n        }\n        if (zoomLevel !== lastZoom) {\n            zoomLevelDisplay.textContent = localizationTable.zoomLevel(zoomLevel);\n            lastZoom = zoomLevel;\n        }\n    };\n    updateZoomDisplay();\n    editor.notifier.on(EditorEventType.ViewportChanged, (event) => {\n        if (event.kind === EditorEventType.ViewportChanged) {\n            updateZoomDisplay();\n            // Can't reset if already reset.\n            resetViewButton.disabled = event.newTransform.eq(Mat33.identity);\n        }\n    });\n    const zoomBy = (factor) => {\n        const screenCenter = editor.viewport.visibleRect.center;\n        const transformUpdate = Mat33.scaling2D(factor, screenCenter);\n        editor.dispatch(Viewport.transformBy(transformUpdate), false);\n    };\n    increaseButton.onclick = () => {\n        zoomBy(5.0 / 4);\n    };\n    decreaseButton.onclick = () => {\n        zoomBy(4.0 / 5);\n    };\n    resetViewButton.onclick = () => {\n        const addToHistory = false;\n        editor.dispatch(Viewport.transformBy(editor.viewport.canvasToScreenTransform.inverse()), addToHistory);\n    };\n    helpDisplay?.registerTextHelpForElement(increaseButton, localizationTable.handDropdown__zoomInHelpText);\n    helpDisplay?.registerTextHelpForElement(decreaseButton, localizationTable.handDropdown__zoomOutHelpText);\n    helpDisplay?.registerTextHelpForElement(resetViewButton, localizationTable.handDropdown__resetViewHelpText);\n    helpDisplay?.registerTextHelpForElement(zoomLevelDisplay, localizationTable.handDropdown__zoomDisplayHelpText);\n    return zoomLevelRow;\n};\nclass HandModeWidget extends BaseWidget {\n    constructor(editor, tool, flag, makeIcon, title, helpText, localizationTable) {\n        super(editor, `pan-mode-${flag}`, localizationTable);\n        this.tool = tool;\n        this.flag = flag;\n        this.makeIcon = makeIcon;\n        this.title = title;\n        this.helpText = helpText;\n        editor.notifier.on(EditorEventType.ToolUpdated, (toolEvt) => {\n            if (toolEvt.kind === EditorEventType.ToolUpdated && toolEvt.tool === tool) {\n                const allEnabled = !!(tool.getMode() & PanZoomMode.SinglePointerGestures);\n                this.setSelected(!!(tool.getMode() & flag) || allEnabled);\n                // Unless this widget toggles all single pointer gestures, toggling while\n                // single pointer gestures are enabled should have no effect\n                this.setDisabled(allEnabled && flag !== PanZoomMode.SinglePointerGestures);\n            }\n        });\n        this.setSelected(false);\n    }\n    shouldAutoDisableInReadOnlyEditor() {\n        return false;\n    }\n    setModeFlag(enabled) {\n        this.tool.setModeEnabled(this.flag, enabled);\n    }\n    handleClick() {\n        this.setModeFlag(!this.isSelected());\n    }\n    getTitle() {\n        return this.title;\n    }\n    createIcon() {\n        return this.makeIcon();\n    }\n    fillDropdown(_dropdown) {\n        return false;\n    }\n    getHelpText() {\n        return this.helpText;\n    }\n}\n/** This toolbar widget allows controlling the editor's {@link PanZoom} tool(s). */\nexport default class HandToolWidget extends BaseToolWidget {\n    constructor(editor, \n    // Can either be the primary pan/zoom tool (in the primary tools list) or\n    // the override pan/zoom tool.\n    // If the override pan/zoom tool, the primary will be gotten from the editor's\n    // tool controller.\n    // If the primary, the override will be gotten from the editor's tool controller.\n    tool, localizationTable) {\n        const isGivenToolPrimary = editor.toolController.getPrimaryTools().includes(tool);\n        const primaryTool = (isGivenToolPrimary ? tool : HandToolWidget.getPrimaryHandTool(editor.toolController)) ??\n            tool;\n        super(editor, primaryTool, 'hand-tool-widget', localizationTable);\n        this.overridePanZoomTool =\n            (isGivenToolPrimary ? HandToolWidget.getOverrideHandTool(editor.toolController) : tool) ??\n                tool;\n        // Only allow toggling a hand tool if we're using the primary hand tool and not the override\n        // hand tool for this button.\n        this.allowTogglingBaseTool = primaryTool !== null;\n        // Allow showing/hiding the dropdown, even if `overridePanZoomTool` isn't enabled.\n        if (!this.allowTogglingBaseTool) {\n            this.container.classList.add('dropdownShowable');\n        }\n        // Controls for the overriding hand tool.\n        const touchPanningWidget = new HandModeWidget(editor, this.overridePanZoomTool, PanZoomMode.OneFingerTouchGestures, () => this.editor.icons.makeTouchPanningIcon(), localizationTable.touchPanning, localizationTable.handDropdown__touchPanningHelpText, localizationTable);\n        const rotationLockWidget = new HandModeWidget(editor, this.overridePanZoomTool, PanZoomMode.RotationLocked, () => this.editor.icons.makeRotationLockIcon(), localizationTable.lockRotation, localizationTable.handDropdown__lockRotationHelpText, localizationTable);\n        this.addSubWidget(touchPanningWidget);\n        this.addSubWidget(rotationLockWidget);\n    }\n    static getPrimaryHandTool(toolController) {\n        const primaryPanZoomToolList = toolController\n            .getPrimaryTools()\n            .filter((tool) => tool instanceof PanZoom);\n        const primaryPanZoomTool = primaryPanZoomToolList[0];\n        return primaryPanZoomTool;\n    }\n    static getOverrideHandTool(toolController) {\n        const panZoomToolList = toolController.getMatchingTools(PanZoom);\n        const panZoomTool = panZoomToolList[0];\n        return panZoomTool;\n    }\n    shouldAutoDisableInReadOnlyEditor() {\n        return false;\n    }\n    getTitle() {\n        return this.localizationTable.handTool;\n    }\n    createIcon() {\n        return this.editor.icons.makeHandToolIcon();\n    }\n    handleClick() {\n        if (this.allowTogglingBaseTool) {\n            super.handleClick();\n        }\n        else {\n            this.setDropdownVisible(!this.isDropdownVisible());\n        }\n    }\n    getHelpText() {\n        return this.localizationTable.handDropdown__baseHelpText;\n    }\n    fillDropdown(dropdown, helpDisplay) {\n        super.fillDropdown(dropdown, helpDisplay);\n        // The container for all actions that come after the toolbar buttons.\n        const nonbuttonActionContainer = document.createElement('div');\n        nonbuttonActionContainer.classList.add(`${toolbarCSSPrefix}nonbutton-controls-main-list`);\n        makeSeparator().addTo(nonbuttonActionContainer);\n        const zoomControl = makeZoomControl(this.localizationTable, this.editor, helpDisplay);\n        nonbuttonActionContainer.appendChild(zoomControl);\n        dropdown.appendChild(nonbuttonActionContainer);\n        return true;\n    }\n    setSelected(selected) {\n        if (this.allowTogglingBaseTool) {\n            super.setSelected(selected);\n        }\n    }\n    serializeState() {\n        const toolMode = this.overridePanZoomTool.getMode();\n        return {\n            ...super.serializeState(),\n            touchPanning: toolMode & PanZoomMode.OneFingerTouchGestures,\n            rotationLocked: toolMode & PanZoomMode.RotationLocked,\n        };\n    }\n    deserializeFrom(state) {\n        if (state.touchPanning !== undefined) {\n            this.overridePanZoomTool.setModeEnabled(PanZoomMode.OneFingerTouchGestures, !!state.touchPanning);\n        }\n        if (state.rotationLocked !== undefined) {\n            this.overridePanZoomTool.setModeEnabled(PanZoomMode.RotationLocked, !!state.rotationLocked);\n        }\n        super.deserializeFrom(state);\n    }\n}\n","/** Handles filtering and other operations on an image. */\nexport class ImageWrapper {\n    constructor(imageBase64Url, preview, onUrlUpdate) {\n        this.imageBase64Url = imageBase64Url;\n        this.preview = preview;\n        this.onUrlUpdate = onUrlUpdate;\n        this.originalSrc = imageBase64Url;\n        preview.src = imageBase64Url;\n    }\n    updateImageData(base64DataUrl) {\n        this.preview.src = base64DataUrl;\n        this.imageBase64Url = base64DataUrl;\n        this.onUrlUpdate();\n    }\n    decreaseSize(resizeFactor = 3 / 4) {\n        const canvas = document.createElement('canvas');\n        canvas.width = this.preview.naturalWidth * resizeFactor;\n        canvas.height = this.preview.naturalHeight * resizeFactor;\n        const ctx = canvas.getContext('2d');\n        ctx?.drawImage(this.preview, 0, 0, canvas.width, canvas.height);\n        // JPEG can be much smaller than PNG for the same image size. Prefer it if\n        // the image is already a JPEG.\n        const format = this.originalSrc?.startsWith('data:image/jpeg;') ? 'image/jpeg' : 'image/png';\n        this.updateImageData(canvas.toDataURL(format));\n    }\n    reset() {\n        this.updateImageData(this.originalSrc);\n    }\n    isChanged() {\n        return this.imageBase64Url !== this.originalSrc;\n    }\n    // Returns true if the current image is large enough to display a \"decrease size\"\n    // option.\n    isLarge() {\n        const largeImageThreshold = 0.12 * 1024 * 1024; // 0.12 MiB\n        return this.getBase64Url().length > largeImageThreshold;\n    }\n    getBase64Url() {\n        return this.imageBase64Url;\n    }\n    getAltText() {\n        return this.altText;\n    }\n    setAltText(text) {\n        this.altText = text;\n        this.preview.alt = text;\n    }\n    static fromSrcAndPreview(initialBase64Src, preview, onUrlUpdate) {\n        return new ImageWrapper(initialBase64Src, preview, onUrlUpdate);\n    }\n    static fromRenderable(renderable, onUrlUpdate) {\n        const preview = new Image();\n        preview.src = renderable.base64Url;\n        const result = new ImageWrapper(renderable.base64Url, preview, onUrlUpdate);\n        const altText = renderable.label ?? renderable.image.getAttribute('alt');\n        if (altText) {\n            result.setAltText(altText);\n        }\n        return { wrapper: result, preview };\n    }\n}\n","import  ImageComponent  from '../../../components/ImageComponent.mjs';\nimport  Erase  from '../../../commands/Erase.mjs';\nimport  EditorImage  from '../../../image/EditorImage.mjs';\nimport  uniteCommands  from '../../../commands/uniteCommands.mjs';\nimport  SelectionTool  from '../../../tools/SelectionTool/SelectionTool.mjs';\nimport { Mat33, Vec2 } from '@js-draw/math';\nimport  BaseWidget  from '../BaseWidget.mjs';\nimport  { EditorEventType }  from '../../../types.mjs';\nimport  { toolbarCSSPrefix }  from '../../constants.mjs';\nimport  makeFileInput  from '../components/makeFileInput.mjs';\nimport  { MutableReactiveValue }  from '../../../util/ReactiveValue.mjs';\nimport  bytesToSizeString  from '../../../util/bytesToSizeString.mjs';\nimport  { ImageWrapper }  from './ImageWrapper.mjs';\nimport  makeSnappedList  from '../components/makeSnappedList.mjs';\nimport  fileToImages  from './fileToImages.mjs';\n/**\n * Provides a widget that allows inserting or modifying raster images.\n *\n * It's possible to customize the file picker used by this widget through {@link EditorSettings.image}.\n *\n * @example\n * ```ts,runnable\n * import { Editor, makeEdgeToolbar, InsertImageWidget } from 'js-draw';\n *\n * const editor = new Editor(document.body);\n * const toolbar = makeEdgeToolbar(editor);\n *\n * toolbar.addWidget(new InsertImageWidget(editor));\n * ```\n */\nclass InsertImageWidget extends BaseWidget {\n    constructor(editor, localization) {\n        localization ??= editor.localization;\n        super(editor, 'insert-image-widget', localization);\n        // Make the dropdown showable\n        this.container.classList.add('dropdownShowable');\n        editor.notifier.on(EditorEventType.SelectionUpdated, (event) => {\n            if (event.kind === EditorEventType.SelectionUpdated && this.isDropdownVisible()) {\n                this.updateInputs();\n            }\n        });\n        this.images = MutableReactiveValue.fromInitialValue([]);\n        this.images.onUpdateAndNow(() => {\n            this.onImageDataUpdate();\n        });\n    }\n    getTitle() {\n        return this.localizationTable.image;\n    }\n    createIcon() {\n        return this.editor.icons.makeInsertImageIcon();\n    }\n    setDropdownVisible(visible) {\n        super.setDropdownVisible(visible);\n        // Update the dropdown just before showing.\n        if (this.isDropdownVisible()) {\n            this.updateInputs();\n        }\n        else {\n            // Allow any previously-selected files to be freed.\n            this.selectedFiles?.set([]);\n        }\n    }\n    handleClick() {\n        this.setDropdownVisible(!this.isDropdownVisible());\n    }\n    fillDropdown(dropdown) {\n        const container = document.createElement('div');\n        container.classList.add('insert-image-widget-dropdown-content', `${toolbarCSSPrefix}spacedList`, `${toolbarCSSPrefix}nonbutton-controls-main-list`);\n        const { container: chooseImageRow, selectedFiles } = makeFileInput(this.localizationTable.chooseFile, this.editor, {\n            accepts: 'image/*',\n            allowMultiSelect: true,\n            customPickerAction: this.editor.getCurrentSettings().image?.showImagePicker,\n        });\n        const altTextRow = document.createElement('div');\n        this.imagesPreview = makeSnappedList(this.images);\n        this.statusView = document.createElement('div');\n        const actionButtonRow = document.createElement('div');\n        actionButtonRow.classList.add('action-button-row');\n        this.statusView.classList.add('insert-image-image-status-view');\n        this.submitButton = document.createElement('button');\n        this.selectedFiles = selectedFiles;\n        this.imageAltTextInput = document.createElement('input');\n        // Label the alt text input\n        const imageAltTextLabel = document.createElement('label');\n        const altTextInputId = `insert-image-alt-text-input-${InsertImageWidget.nextInputId++}`;\n        this.imageAltTextInput.setAttribute('id', altTextInputId);\n        imageAltTextLabel.htmlFor = altTextInputId;\n        imageAltTextLabel.innerText = this.localizationTable.inputAltText;\n        this.imageAltTextInput.type = 'text';\n        this.imageAltTextInput.placeholder = this.localizationTable.describeTheImage;\n        this.statusView.setAttribute('aria-live', 'polite');\n        this.submitButton.innerText = this.localizationTable.submit;\n        this.imagesPreview.visibleItem.onUpdateAndNow(() => this.onImageDataUpdate());\n        this.imageAltTextInput.oninput = () => {\n            const currentImage = this.imagesPreview.visibleItem.get();\n            if (currentImage) {\n                currentImage.setAltText(this.imageAltTextInput.value);\n                this.submitButton.style.display = '';\n            }\n        };\n        this.selectedFiles.onUpdateAndNow(async (files) => {\n            if (files.length === 0) {\n                this.images.set([]);\n                return;\n            }\n            const previews = (await Promise.all(files.map(async (imageFile) => {\n                let renderableImages;\n                try {\n                    renderableImages = await fileToImages(imageFile);\n                }\n                catch (error) {\n                    console.error('Image load error', error);\n                    const errorMessage = this.localizationTable.imageLoadError(error);\n                    this.statusView.innerText = errorMessage;\n                    return [];\n                }\n                return renderableImages.map((image) => {\n                    const { wrapper, preview } = ImageWrapper.fromRenderable(image, () => this.onImageDataUpdate());\n                    return {\n                        data: wrapper,\n                        element: preview,\n                    };\n                });\n            }))).flat();\n            this.images.set(previews);\n        });\n        altTextRow.replaceChildren(imageAltTextLabel, this.imageAltTextInput);\n        actionButtonRow.replaceChildren(this.submitButton);\n        container.replaceChildren(chooseImageRow, altTextRow, this.imagesPreview.container, this.statusView, actionButtonRow);\n        dropdown.replaceChildren(container);\n        return true;\n    }\n    onImageDataUpdate() {\n        if (!this.imagesPreview)\n            return;\n        const currentImage = this.imagesPreview.visibleItem.get();\n        const base64Data = currentImage?.getBase64Url();\n        this.imageAltTextInput.value = currentImage?.getAltText() ?? '';\n        if (base64Data) {\n            this.submitButton.disabled = false;\n            this.submitButton.style.display = '';\n            this.updateImageSizeDisplay();\n        }\n        else {\n            this.submitButton.disabled = true;\n            this.submitButton.style.display = 'none';\n            this.statusView.innerText = '';\n            this.submitButton.disabled = true;\n        }\n        if (this.images.get().length <= 1) {\n            this.submitButton.innerText = this.localizationTable.submit;\n        }\n        else {\n            this.submitButton.innerText = this.localizationTable.addAll;\n        }\n    }\n    hideDialog() {\n        this.setDropdownVisible(false);\n    }\n    updateImageSizeDisplay() {\n        const currentImage = this.imagesPreview.visibleItem.get();\n        const imageData = currentImage?.getBase64Url() ?? '';\n        const { size, units } = bytesToSizeString(imageData.length);\n        const sizeText = document.createElement('span');\n        sizeText.innerText = this.localizationTable.imageSize(Math.round(size), units);\n        // Add a button to allow decreasing the size of large images.\n        const decreaseSizeButton = document.createElement('button');\n        decreaseSizeButton.innerText = this.localizationTable.decreaseImageSize;\n        decreaseSizeButton.onclick = () => {\n            currentImage?.decreaseSize();\n        };\n        const resetSizeButton = document.createElement('button');\n        resetSizeButton.innerText = this.localizationTable.resetImage;\n        resetSizeButton.onclick = () => {\n            currentImage?.reset();\n        };\n        this.statusView.replaceChildren(sizeText);\n        if (currentImage?.isLarge()) {\n            this.statusView.appendChild(decreaseSizeButton);\n        }\n        else if (currentImage?.isChanged()) {\n            this.statusView.appendChild(resetSizeButton);\n        }\n        else {\n            const hasLargeOrChangedImages = this.images\n                .get()\n                .some((image) => image.data?.isChanged() || image.data?.isLarge());\n            if (hasLargeOrChangedImages) {\n                // Still show the button -- prevents the layout from readjusting while\n                // scrolling through the image list\n                decreaseSizeButton.disabled = true;\n                this.statusView.appendChild(decreaseSizeButton);\n            }\n        }\n    }\n    updateInputs() {\n        const resetInputs = () => {\n            this.selectedFiles?.set([]);\n            this.imageAltTextInput.value = '';\n            this.submitButton.disabled = true;\n            this.statusView.innerText = '';\n            this.submitButton.style.display = '';\n        };\n        resetInputs();\n        const selectionTools = this.editor.toolController.getMatchingTools(SelectionTool);\n        const selectedObjects = selectionTools.map((tool) => tool.getSelectedObjects()).flat();\n        // Check: Is there a selected image that can be edited?\n        let editingImage = null;\n        if (selectedObjects.length === 1 && selectedObjects[0] instanceof ImageComponent) {\n            editingImage = selectedObjects[0];\n            const image = new Image();\n            const imageWrapper = ImageWrapper.fromSrcAndPreview(editingImage.getURL(), image, () => this.onImageDataUpdate());\n            imageWrapper.setAltText(editingImage.getAltText() ?? '');\n            this.images.set([{ data: imageWrapper, element: image }]);\n        }\n        else if (selectedObjects.length > 0) {\n            // If not, clear the selection.\n            selectionTools.forEach((tool) => tool.clearSelection());\n        }\n        // Show the submit button only when there is data to submit.\n        this.submitButton.style.display = 'none';\n        this.submitButton.onclick = async () => {\n            const newComponents = [];\n            let transform = Mat33.identity;\n            let fullBBox = null;\n            for (const { data: imageWrapper } of this.images.get()) {\n                if (!imageWrapper) {\n                    continue;\n                }\n                const image = new Image();\n                image.src = imageWrapper.getBase64Url();\n                const altText = imageWrapper.getAltText();\n                if (altText) {\n                    image.setAttribute('alt', altText);\n                }\n                let component;\n                try {\n                    component = await ImageComponent.fromImage(image, transform);\n                }\n                catch (error) {\n                    console.error('Error loading image', error);\n                    this.statusView.innerText = this.localizationTable.imageLoadError(error);\n                    return;\n                }\n                const componentBBox = component.getBBox();\n                if (componentBBox.area === 0) {\n                    this.statusView.innerText = this.localizationTable.errorImageHasZeroSize;\n                    return;\n                }\n                newComponents.push(component);\n                fullBBox ??= componentBBox;\n                fullBBox.union(componentBBox);\n                // Update the transform for the next item.\n                const shift = Vec2.of(0, componentBBox.height);\n                transform = transform.rightMul(Mat33.translation(shift));\n            }\n            if (newComponents.length) {\n                if (!fullBBox) {\n                    throw new Error('Logic error: Full bounding box must be calculated when components are to be added.');\n                }\n                this.hideDialog();\n                if (editingImage) {\n                    const eraseCommand = new Erase([editingImage]);\n                    // Try to preserve the original width\n                    const originalTransform = editingImage.getTransformation();\n                    // || 1: Prevent division by zero\n                    const originalWidth = editingImage.getBBox().width || 1;\n                    const newWidth = fullBBox.transformedBoundingBox(originalTransform).width || 1;\n                    const widthAdjustTransform = Mat33.scaling2D(originalWidth / newWidth);\n                    const commands = [];\n                    for (const component of newComponents) {\n                        commands.push(EditorImage.addElement(component), component.transformBy(originalTransform.rightMul(widthAdjustTransform)), component.setZIndex(editingImage.getZIndex()));\n                    }\n                    this.editor.dispatch(uniteCommands([...commands, eraseCommand]));\n                    selectionTools[0]?.setSelection(newComponents);\n                }\n                else {\n                    await this.editor.addAndCenterComponents(newComponents);\n                }\n            }\n        };\n    }\n}\nInsertImageWidget.nextInputId = 0;\nexport default InsertImageWidget;\n","import  fileToBase64Url  from '../../../util/fileToBase64Url.mjs';\nimport { Mat33 } from '@js-draw/math';\nconst fileToImages = async (imageFile) => {\n    const result = [];\n    const imageElement = new Image();\n    const base64Url = await fileToBase64Url(imageFile);\n    if (base64Url) {\n        result.push({\n            image: imageElement,\n            base64Url: base64Url,\n            transform: Mat33.identity,\n        });\n    }\n    return result;\n};\nexport default fileToImages;\n","import  BaseWidget  from './BaseWidget.mjs';\nexport default class OverflowWidget extends BaseWidget {\n    constructor(editor, localizationTable) {\n        super(editor, 'overflow-widget', localizationTable);\n        this.overflowChildren = [];\n        this.container.classList.add('toolbar-overflow-widget');\n        // Make the dropdown openable\n        this.container.classList.add('dropdownShowable');\n        this.overflowContainer ??= document.createElement('div');\n    }\n    shouldAutoDisableInReadOnlyEditor() {\n        return false;\n    }\n    getTitle() {\n        return this.localizationTable.toggleOverflow;\n    }\n    createIcon() {\n        return this.editor.icons.makeOverflowIcon();\n    }\n    handleClick() {\n        this.setDropdownVisible(!this.isDropdownVisible());\n    }\n    fillDropdown(dropdown) {\n        this.overflowContainer ??= document.createElement('div');\n        if (this.overflowContainer.parentElement) {\n            this.overflowContainer.remove();\n        }\n        this.overflowContainer.classList.add('toolbar-overflow-widget-overflow-list');\n        dropdown.appendChild(this.overflowContainer);\n        return true;\n    }\n    /**\n     * Removes all `BaseWidget`s from this and returns them.\n     */\n    clearChildren() {\n        this.overflowContainer.replaceChildren();\n        this.container.classList.remove('horizontal');\n        const overflowChildren = this.overflowChildren;\n        this.overflowChildren = [];\n        return overflowChildren;\n    }\n    getChildWidgets() {\n        return [...this.overflowChildren];\n    }\n    hasAsChild(widget) {\n        for (const otherWidget of this.overflowChildren) {\n            if (widget === otherWidget) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Adds `widget` to this.\n     * `widget`'s previous parent is still responsible\n     * for serializing/deserializing its state.\n     */\n    addToOverflow(widget) {\n        this.overflowChildren.push(widget);\n        widget.addTo(this.overflowContainer);\n        widget.setIsToplevel(false);\n        // Switch to a horizontal layout if enough children\n        if (this.overflowChildren.length > 2) {\n            this.container.classList.add('horizontal');\n        }\n    }\n    // This always returns false.\n    // Don't try to move the overflow menu to itself.\n    canBeInOverflowMenu() {\n        return false;\n    }\n}\n","import  { makeArrowBuilder }  from '../../components/builders/ArrowBuilder.mjs';\nimport  { makeFreehandLineBuilder }  from '../../components/builders/FreehandLineBuilder.mjs';\nimport  { makePressureSensitiveFreehandLineBuilder }  from '../../components/builders/PressureSensitiveFreehandLineBuilder.mjs';\nimport  { makeLineBuilder }  from '../../components/builders/LineBuilder.mjs';\nimport  { makeFilledRectangleBuilder, makeOutlinedRectangleBuilder, }  from '../../components/builders/RectangleBuilder.mjs';\nimport  { makeOutlinedCircleBuilder }  from '../../components/builders/CircleBuilder.mjs';\nimport  { EditorEventType }  from '../../types.mjs';\nimport  makeColorInput  from './components/makeColorInput.mjs';\nimport  BaseToolWidget  from './BaseToolWidget.mjs';\nimport { Color4 } from '@js-draw/math';\nimport  { selectStrokeTypeKeyboardShortcutIds }  from './keybindings.mjs';\nimport  { toolbarCSSPrefix }  from '../constants.mjs';\nimport  makeThicknessSlider  from './components/makeThicknessSlider.mjs';\nimport  makeGridSelector  from './components/makeGridSelector.mjs';\nimport  { makePolylineBuilder }  from '../../components/builders/PolylineBuilder.mjs';\n/**\n * This toolbar widget allows a user to control a single {@link Pen} tool.\n *\n * See also {@link AbstractToolbar.addDefaultToolWidgets}.\n */\nclass PenToolWidget extends BaseToolWidget {\n    constructor(editor, tool, localization) {\n        super(editor, tool, 'pen', localization);\n        this.tool = tool;\n        this.updateInputs = () => { };\n        // Pen types that correspond to\n        this.shapelikeIDs = ['pressure-sensitive-pen', 'freehand-pen'];\n        // Additional client-specified pens.\n        const additionalPens = editor.getCurrentSettings().pens?.additionalPenTypes ?? [];\n        const filterPens = editor.getCurrentSettings().pens?.filterPenTypes ?? (() => true);\n        // Default pen types\n        this.penTypes = [\n            // Non-shape pens\n            {\n                name: this.localizationTable.flatTipPen,\n                id: 'pressure-sensitive-pen',\n                factory: makePressureSensitiveFreehandLineBuilder,\n            },\n            {\n                name: this.localizationTable.roundedTipPen,\n                id: 'freehand-pen',\n                factory: makeFreehandLineBuilder,\n            },\n            {\n                name: this.localizationTable.roundedTipPen2,\n                id: 'polyline-pen',\n                factory: makePolylineBuilder,\n            },\n            ...additionalPens.filter((pen) => !pen.isShapeBuilder),\n            // Shape pens\n            {\n                name: this.localizationTable.arrowPen,\n                id: 'arrow',\n                isShapeBuilder: true,\n                factory: makeArrowBuilder,\n            },\n            {\n                name: this.localizationTable.linePen,\n                id: 'line',\n                isShapeBuilder: true,\n                factory: makeLineBuilder,\n            },\n            {\n                name: this.localizationTable.filledRectanglePen,\n                id: 'filled-rectangle',\n                isShapeBuilder: true,\n                factory: makeFilledRectangleBuilder,\n            },\n            {\n                name: this.localizationTable.outlinedRectanglePen,\n                id: 'outlined-rectangle',\n                isShapeBuilder: true,\n                factory: makeOutlinedRectangleBuilder,\n            },\n            {\n                name: this.localizationTable.outlinedCirclePen,\n                id: 'outlined-circle',\n                isShapeBuilder: true,\n                factory: makeOutlinedCircleBuilder,\n            },\n            ...additionalPens.filter((pen) => pen.isShapeBuilder),\n        ].filter(filterPens);\n        this.editor.notifier.on(EditorEventType.ToolUpdated, (toolEvt) => {\n            if (toolEvt.kind !== EditorEventType.ToolUpdated) {\n                throw new Error('Invalid event type!');\n            }\n            // The button icon may depend on tool properties.\n            if (toolEvt.tool === this.tool) {\n                this.updateIcon();\n                this.updateInputs();\n            }\n        });\n    }\n    getTitle() {\n        return this.targetTool.description;\n    }\n    // Return the index of this tool's stroke factory in the list of\n    // all stroke factories.\n    //\n    // Returns -1 if the stroke factory is not in the list of all stroke factories.\n    getCurrentPenTypeIdx() {\n        const currentFactory = this.tool.getStrokeFactory();\n        for (let i = 0; i < this.penTypes.length; i++) {\n            if (this.penTypes[i].factory === currentFactory) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    getCurrentPenType() {\n        for (const penType of this.penTypes) {\n            if (penType.factory === this.tool.getStrokeFactory()) {\n                return penType;\n            }\n        }\n        return null;\n    }\n    createIconForRecord(record) {\n        const style = {\n            ...this.tool.getStyleValue().get(),\n        };\n        if (record?.factory) {\n            style.factory = record.factory;\n        }\n        const strokeFactory = record?.factory;\n        if (!strokeFactory ||\n            strokeFactory === makeFreehandLineBuilder ||\n            strokeFactory === makePressureSensitiveFreehandLineBuilder ||\n            strokeFactory === makePolylineBuilder) {\n            return this.editor.icons.makePenIcon(style);\n        }\n        else {\n            return this.editor.icons.makeIconFromFactory(style);\n        }\n    }\n    createIcon() {\n        return this.createIconForRecord(this.getCurrentPenType());\n    }\n    // Creates a widget that allows selecting different pen types\n    createPenTypeSelector(helpOverlay) {\n        const allChoices = this.penTypes.map((penType, index) => {\n            return {\n                id: index,\n                makeIcon: () => this.createIconForRecord(penType),\n                title: penType.name,\n                isShapeBuilder: penType.isShapeBuilder ?? false,\n            };\n        });\n        const penItems = allChoices.filter((choice) => !choice.isShapeBuilder);\n        const penSelector = makeGridSelector(this.localizationTable.selectPenType, this.getCurrentPenTypeIdx(), penItems);\n        const shapeItems = allChoices.filter((choice) => choice.isShapeBuilder);\n        const shapeSelector = makeGridSelector(this.localizationTable.selectShape, this.getCurrentPenTypeIdx(), shapeItems);\n        const onSelectorUpdate = (newPenTypeIndex) => {\n            this.tool.setStrokeFactory(this.penTypes[newPenTypeIndex].factory);\n        };\n        penSelector.value.onUpdate(onSelectorUpdate);\n        shapeSelector.value.onUpdate(onSelectorUpdate);\n        helpOverlay?.registerTextHelpForElements([penSelector.getRootElement(), shapeSelector.getRootElement()], this.localizationTable.penDropdown__penTypeHelpText);\n        return {\n            setValue: (penTypeIndex) => {\n                penSelector.value.set(penTypeIndex);\n                shapeSelector.value.set(penTypeIndex);\n            },\n            updateIcons: () => {\n                penSelector.updateIcons();\n                shapeSelector.updateIcons();\n            },\n            addTo: (parent) => {\n                if (penItems.length) {\n                    penSelector.addTo(parent);\n                }\n                if (shapeItems.length) {\n                    shapeSelector.addTo(parent);\n                }\n            },\n        };\n    }\n    createStrokeCorrectionOptions(helpOverlay) {\n        const container = document.createElement('div');\n        container.classList.add('action-button-row', `${toolbarCSSPrefix}-pen-tool-toggle-buttons`);\n        const addToggleButton = (labelText, icon) => {\n            const button = document.createElement('button');\n            button.classList.add(`${toolbarCSSPrefix}-toggle-button`);\n            const iconElement = icon.cloneNode(true);\n            iconElement.classList.add('icon');\n            const label = document.createElement('span');\n            label.innerText = labelText;\n            button.replaceChildren(iconElement, label);\n            button.setAttribute('role', 'switch');\n            container.appendChild(button);\n            let checked = false;\n            let onChangeListener = (_checked) => { };\n            const result = {\n                setChecked(newChecked) {\n                    checked = newChecked;\n                    button.setAttribute('aria-checked', `${checked}`);\n                    onChangeListener(checked);\n                },\n                setOnInputListener(listener) {\n                    onChangeListener = listener;\n                },\n                addHelpText(text) {\n                    helpOverlay?.registerTextHelpForElement(button, text);\n                },\n            };\n            button.onclick = () => {\n                result.setChecked(!checked);\n            };\n            return result;\n        };\n        const stabilizationOption = addToggleButton(this.localizationTable.inputStabilization, this.editor.icons.makeStrokeSmoothingIcon());\n        stabilizationOption.setOnInputListener((enabled) => {\n            this.tool.setHasStabilization(enabled);\n        });\n        const autocorrectOption = addToggleButton(this.localizationTable.strokeAutocorrect, this.editor.icons.makeShapeAutocorrectIcon());\n        autocorrectOption.setOnInputListener((enabled) => {\n            this.tool.setStrokeAutocorrectEnabled(enabled);\n        });\n        // Help text\n        autocorrectOption.addHelpText(this.localizationTable.penDropdown__autocorrectHelpText);\n        stabilizationOption.addHelpText(this.localizationTable.penDropdown__stabilizationHelpText);\n        return {\n            update: () => {\n                stabilizationOption.setChecked(!!this.tool.getInputMapper());\n                autocorrectOption.setChecked(this.tool.getStrokeAutocorrectionEnabled());\n            },\n            addTo: (parent) => {\n                parent.appendChild(container);\n            },\n        };\n    }\n    getHelpText() {\n        return this.localizationTable.penDropdown__baseHelpText;\n    }\n    fillDropdown(dropdown, helpDisplay) {\n        const container = document.createElement('div');\n        container.classList.add(`${toolbarCSSPrefix}spacedList`, `${toolbarCSSPrefix}nonbutton-controls-main-list`);\n        // Thickness: Value of the input is squared to allow for finer control/larger values.\n        const { container: thicknessRow, setValue: setThickness } = makeThicknessSlider(this.editor, (thickness) => {\n            this.tool.setThickness(thickness);\n        });\n        const colorRow = document.createElement('div');\n        const colorLabel = document.createElement('label');\n        const colorInputControl = makeColorInput(this.editor, (color) => {\n            this.tool.setColor(color);\n        });\n        const { input: colorInput, container: colorInputContainer } = colorInputControl;\n        colorInput.id = `${toolbarCSSPrefix}colorInput${PenToolWidget.idCounter++}`;\n        colorLabel.innerText = this.localizationTable.colorLabel;\n        colorLabel.setAttribute('for', colorInput.id);\n        colorRow.appendChild(colorLabel);\n        colorRow.appendChild(colorInputContainer);\n        // Autocorrect and stabilization options\n        const toggleButtonRow = this.createStrokeCorrectionOptions(helpDisplay);\n        const penTypeSelect = this.createPenTypeSelector(helpDisplay);\n        // Add help text for color and thickness last, as these are likely to be\n        // features users are least interested in.\n        helpDisplay?.registerTextHelpForElement(colorRow, this.localizationTable.penDropdown__colorHelpText);\n        if (helpDisplay) {\n            colorInputControl.registerWithHelpTextDisplay(helpDisplay);\n        }\n        helpDisplay?.registerTextHelpForElement(thicknessRow, this.localizationTable.penDropdown__thicknessHelpText);\n        this.updateInputs = () => {\n            colorInputControl.setValue(this.tool.getColor());\n            setThickness(this.tool.getThickness());\n            penTypeSelect.updateIcons();\n            // Update the selected stroke factory.\n            penTypeSelect.setValue(this.getCurrentPenTypeIdx());\n            toggleButtonRow.update();\n        };\n        this.updateInputs();\n        container.replaceChildren(colorRow, thicknessRow);\n        penTypeSelect.addTo(container);\n        dropdown.replaceChildren(container);\n        // Add the toggle button row *outside* of the main content (use different\n        // spacing with respect to the sides of the container).\n        toggleButtonRow.addTo(dropdown);\n        return true;\n    }\n    onKeyPress(event) {\n        if (!this.isSelected()) {\n            return false;\n        }\n        for (let i = 0; i < selectStrokeTypeKeyboardShortcutIds.length; i++) {\n            const shortcut = selectStrokeTypeKeyboardShortcutIds[i];\n            if (this.editor.shortcuts.matchesShortcut(shortcut, event)) {\n                const penTypeIdx = i;\n                if (penTypeIdx < this.penTypes.length) {\n                    this.tool.setStrokeFactory(this.penTypes[penTypeIdx].factory);\n                    return true;\n                }\n            }\n        }\n        // Run any default actions registered by the parent class.\n        if (super.onKeyPress(event)) {\n            return true;\n        }\n        return false;\n    }\n    serializeState() {\n        return {\n            ...super.serializeState(),\n            color: this.tool.getColor().toHexString(),\n            thickness: this.tool.getThickness(),\n            strokeFactoryId: this.getCurrentPenType()?.id,\n            inputStabilization: !!this.tool.getInputMapper(),\n            strokeAutocorrect: this.tool.getStrokeAutocorrectionEnabled(),\n        };\n    }\n    deserializeFrom(state) {\n        super.deserializeFrom(state);\n        const verifyPropertyType = (propertyName, expectedType) => {\n            const actualType = typeof state[propertyName];\n            if (actualType !== expectedType) {\n                throw new Error(`Deserializing property ${propertyName}: Invalid type. Expected ${expectedType},` +\n                    ` was ${actualType}.`);\n            }\n        };\n        if (state.color) {\n            verifyPropertyType('color', 'string');\n            this.tool.setColor(Color4.fromHex(state.color));\n        }\n        if (state.thickness) {\n            verifyPropertyType('thickness', 'number');\n            this.tool.setThickness(state.thickness);\n        }\n        if (state.strokeFactoryId) {\n            verifyPropertyType('strokeFactoryId', 'string');\n            const factoryId = state.strokeFactoryId;\n            for (const penType of this.penTypes) {\n                if (factoryId === penType.id) {\n                    this.tool.setStrokeFactory(penType.factory);\n                    break;\n                }\n            }\n        }\n        if (state.inputStabilization !== undefined) {\n            this.tool.setHasStabilization(!!state.inputStabilization);\n        }\n        if (state.strokeAutocorrect !== undefined) {\n            this.tool.setStrokeAutocorrectEnabled(!!state.strokeAutocorrect);\n        }\n    }\n}\n// A counter variable that ensures different HTML elements are given unique names/ids.\nPenToolWidget.idCounter = 0;\nexport default PenToolWidget;\n","import  ActionButtonWidget  from './ActionButtonWidget.mjs';\nimport  { ToolbarWidgetTag }  from './BaseWidget.mjs';\nimport  { saveKeyboardShortcut }  from './keybindings.mjs';\nclass SaveActionWidget extends ActionButtonWidget {\n    constructor(editor, localization, saveCallback, labelOverride = {}) {\n        super(editor, 'save-button', \n        // Creates an icon\n        () => {\n            return labelOverride.icon ?? editor.icons.makeSaveIcon();\n        }, labelOverride.label ?? localization.save, saveCallback);\n        this.setTags([ToolbarWidgetTag.Save]);\n    }\n    shouldAutoDisableInReadOnlyEditor() {\n        return false;\n    }\n    onKeyPress(event) {\n        if (this.editor.shortcuts.matchesShortcut(saveKeyboardShortcut, event)) {\n            this.clickAction();\n            return true;\n        }\n        // Run any default actions registered by the parent class.\n        return super.onKeyPress(event);\n    }\n    mustBeInToplevelMenu() {\n        return true;\n    }\n}\nexport default SaveActionWidget;\n","import { Color4 } from '@js-draw/math';\nimport  { isRestylableComponent }  from '../../components/RestylableComponent.mjs';\nimport  uniteCommands  from '../../commands/uniteCommands.mjs';\nimport  { EditorEventType }  from '../../types.mjs';\nimport  makeColorInput  from './components/makeColorInput.mjs';\nimport  ActionButtonWidget  from './ActionButtonWidget.mjs';\nimport  BaseToolWidget  from './BaseToolWidget.mjs';\nimport  { resizeImageToSelectionKeyboardShortcut }  from './keybindings.mjs';\nimport  makeSeparator  from './components/makeSeparator.mjs';\nimport  { toolbarCSSPrefix }  from '../constants.mjs';\nconst makeFormatMenu = (editor, selectionTool, localizationTable) => {\n    const container = document.createElement('div');\n    container.classList.add('selection-format-menu', `${toolbarCSSPrefix}spacedList`, `${toolbarCSSPrefix}indentedList`);\n    const colorRow = document.createElement('div');\n    const colorLabel = document.createElement('label');\n    const colorInputControl = makeColorInput(editor, (color) => {\n        const selection = selectionTool.getSelection();\n        if (selection) {\n            const updateStyleCommands = [];\n            for (const elem of selection.getSelectedObjects()) {\n                if (isRestylableComponent(elem)) {\n                    updateStyleCommands.push(elem.updateStyle({ color }));\n                }\n            }\n            const unitedCommand = uniteCommands(updateStyleCommands);\n            editor.dispatch(unitedCommand);\n        }\n    });\n    const { input: colorInput, container: colorInputContainer } = colorInputControl;\n    colorLabel.innerText = localizationTable.colorLabel;\n    const update = () => {\n        const selection = selectionTool.getSelection();\n        if (selection && selection.getSelectedItemCount() > 0) {\n            colorInput.disabled = false;\n            container.classList.remove('disabled');\n            const colors = [];\n            for (const elem of selection.getSelectedObjects()) {\n                if (isRestylableComponent(elem)) {\n                    const color = elem.getStyle().color;\n                    if (color) {\n                        colors.push(color);\n                    }\n                }\n            }\n            colorInputControl.setValue(Color4.average(colors));\n        }\n        else {\n            colorInput.disabled = true;\n            container.classList.add('disabled');\n            colorInputControl.setValue(Color4.transparent);\n        }\n    };\n    colorRow.replaceChildren(colorLabel, colorInputContainer);\n    container.replaceChildren(colorRow);\n    return {\n        addTo: (parent) => {\n            parent.appendChild(container);\n        },\n        update,\n        registerHelpText: (helpDisplay) => {\n            helpDisplay.registerTextHelpForElement(colorRow, localizationTable.selectionDropdown__changeColorHelpText);\n            colorInputControl.registerWithHelpTextDisplay(helpDisplay);\n        },\n    };\n};\nexport default class SelectionToolWidget extends BaseToolWidget {\n    constructor(editor, tool, localization) {\n        super(editor, tool, 'selection-tool-widget', localization);\n        this.tool = tool;\n        this.updateFormatMenu = () => { };\n        const resizeButton = new ActionButtonWidget(editor, 'resize-btn', () => editor.icons.makeResizeImageToSelectionIcon(), this.localizationTable.resizeImageToSelection, () => {\n            this.resizeImageToSelection();\n        }, localization);\n        resizeButton.setHelpText(this.localizationTable.selectionDropdown__resizeToHelpText);\n        const deleteButton = new ActionButtonWidget(editor, 'delete-btn', () => editor.icons.makeDeleteSelectionIcon(), this.localizationTable.deleteSelection, () => {\n            const selection = this.tool.getSelection();\n            this.editor.dispatch(selection.deleteSelectedObjects());\n            this.tool.clearSelection();\n        }, localization);\n        deleteButton.setHelpText(this.localizationTable.selectionDropdown__deleteHelpText);\n        const duplicateButton = new ActionButtonWidget(editor, 'duplicate-btn', () => editor.icons.makeDuplicateSelectionIcon(), this.localizationTable.duplicateSelection, async () => {\n            const selection = this.tool.getSelection();\n            this.editor.dispatch(await selection.duplicateSelectedObjects());\n            this.setDropdownVisible(false);\n        }, localization);\n        duplicateButton.setHelpText(this.localizationTable.selectionDropdown__duplicateHelpText);\n        this.addSubWidget(resizeButton);\n        this.addSubWidget(deleteButton);\n        this.addSubWidget(duplicateButton);\n        const updateDisabled = (disabled) => {\n            resizeButton.setDisabled(disabled);\n            deleteButton.setDisabled(disabled);\n            duplicateButton.setDisabled(disabled);\n        };\n        updateDisabled(true);\n        // Enable/disable actions based on whether items are selected\n        this.editor.notifier.on(EditorEventType.ToolUpdated, (toolEvt) => {\n            if (toolEvt.kind !== EditorEventType.ToolUpdated) {\n                throw new Error('Invalid event type!');\n            }\n            if (toolEvt.tool === this.tool) {\n                const selection = this.tool.getSelection();\n                const hasSelection = selection && selection.getSelectedItemCount() > 0;\n                updateDisabled(!hasSelection);\n                this.updateFormatMenu();\n            }\n        });\n    }\n    resizeImageToSelection() {\n        const selection = this.tool.getSelection();\n        if (selection) {\n            this.editor.dispatch(this.editor.setImportExportRect(selection.region));\n        }\n    }\n    onKeyPress(event) {\n        const shortcuts = this.editor.shortcuts;\n        // Resize image to selection:\n        // Other keys are handled directly by the selection tool.\n        if (shortcuts.matchesShortcut(resizeImageToSelectionKeyboardShortcut, event)) {\n            this.resizeImageToSelection();\n            return true;\n        }\n        // If we didn't handle the event, allow the superclass to handle it.\n        if (super.onKeyPress(event)) {\n            return true;\n        }\n        return false;\n    }\n    getTitle() {\n        return this.localizationTable.select;\n    }\n    createIcon() {\n        return this.editor.icons.makeSelectionIcon();\n    }\n    getHelpText() {\n        return this.localizationTable.selectionDropdown__baseHelpText;\n    }\n    fillDropdown(dropdown, helpDisplay) {\n        super.fillDropdown(dropdown, helpDisplay);\n        const controlsContainer = document.createElement('div');\n        controlsContainer.classList.add(`${toolbarCSSPrefix}nonbutton-controls-main-list`);\n        dropdown.appendChild(controlsContainer);\n        makeSeparator(this.localizationTable.reformatSelection).addTo(controlsContainer);\n        const formatMenu = makeFormatMenu(this.editor, this.tool, this.localizationTable);\n        formatMenu.addTo(controlsContainer);\n        this.updateFormatMenu = () => formatMenu.update();\n        if (helpDisplay) {\n            formatMenu.registerHelpText(helpDisplay);\n        }\n        formatMenu.update();\n        return true;\n    }\n}\n","import { Color4 } from '@js-draw/math';\nimport  { EditorEventType }  from '../../types.mjs';\nimport  { toolbarCSSPrefix }  from '../constants.mjs';\nimport  makeColorInput  from './components/makeColorInput.mjs';\nimport  BaseToolWidget  from './BaseToolWidget.mjs';\nclass TextToolWidget extends BaseToolWidget {\n    constructor(editor, tool, localization) {\n        super(editor, tool, 'text-tool-widget', localization);\n        this.tool = tool;\n        this.updateDropdownInputs = null;\n        editor.notifier.on(EditorEventType.ToolUpdated, (evt) => {\n            if (evt.kind === EditorEventType.ToolUpdated && evt.tool === tool) {\n                this.updateIcon();\n                this.updateDropdownInputs?.();\n            }\n        });\n    }\n    getTitle() {\n        return this.targetTool.description;\n    }\n    createIcon() {\n        const textStyle = this.tool.getTextStyle();\n        return this.editor.icons.makeTextIcon(textStyle);\n    }\n    fillDropdown(dropdown) {\n        const container = document.createElement('div');\n        container.classList.add(`${toolbarCSSPrefix}spacedList`, `${toolbarCSSPrefix}nonbutton-controls-main-list`);\n        const fontRow = document.createElement('div');\n        const colorRow = document.createElement('div');\n        const sizeRow = document.createElement('div');\n        const fontInput = document.createElement('select');\n        const fontLabel = document.createElement('label');\n        const sizeInput = document.createElement('input');\n        const sizeLabel = document.createElement('label');\n        const { input: colorInput, container: colorInputContainer, setValue: setColorInputValue, } = makeColorInput(this.editor, (color) => {\n            this.tool.setColor(color);\n        });\n        const colorLabel = document.createElement('label');\n        const fontsInInput = new Set();\n        const addFontToInput = (fontName) => {\n            const option = document.createElement('option');\n            option.value = fontName;\n            option.textContent = fontName;\n            fontInput.appendChild(option);\n            fontsInInput.add(fontName);\n        };\n        sizeInput.setAttribute('type', 'number');\n        sizeInput.min = '1';\n        sizeInput.max = '128';\n        fontLabel.innerText = this.localizationTable.fontLabel;\n        colorLabel.innerText = this.localizationTable.colorLabel;\n        sizeLabel.innerText = this.localizationTable.textSize;\n        colorInput.id = `${toolbarCSSPrefix}-text-color-input-${TextToolWidget.idCounter++}`;\n        colorLabel.setAttribute('for', colorInput.id);\n        sizeInput.id = `${toolbarCSSPrefix}-text-size-input-${TextToolWidget.idCounter++}`;\n        sizeLabel.setAttribute('for', sizeInput.id);\n        const defaultFonts = this.editor.getCurrentSettings().text?.fonts ?? [];\n        for (const font of defaultFonts) {\n            addFontToInput(font);\n        }\n        fontInput.classList.add('font-selector');\n        fontInput.id = `${toolbarCSSPrefix}-text-font-input-${TextToolWidget.idCounter++}`;\n        fontLabel.setAttribute('for', fontInput.id);\n        fontInput.onchange = () => {\n            this.tool.setFontFamily(fontInput.value);\n        };\n        sizeInput.onchange = () => {\n            const size = parseInt(sizeInput.value);\n            if (!isNaN(size) && size > 0) {\n                this.tool.setFontSize(size);\n            }\n        };\n        colorRow.appendChild(colorLabel);\n        colorRow.appendChild(colorInputContainer);\n        fontRow.appendChild(fontLabel);\n        fontRow.appendChild(fontInput);\n        sizeRow.appendChild(sizeLabel);\n        sizeRow.appendChild(sizeInput);\n        this.updateDropdownInputs = () => {\n            const style = this.tool.getTextStyle();\n            setColorInputValue(style.renderingStyle.fill);\n            if (!fontsInInput.has(style.fontFamily)) {\n                addFontToInput(style.fontFamily);\n            }\n            fontInput.value = style.fontFamily;\n            sizeInput.value = `${style.size}`;\n        };\n        this.updateDropdownInputs();\n        container.replaceChildren(colorRow, sizeRow, fontRow);\n        dropdown.appendChild(container);\n        return true;\n    }\n    serializeState() {\n        const textStyle = this.tool.getTextStyle();\n        return {\n            ...super.serializeState(),\n            fontFamily: textStyle.fontFamily,\n            textSize: textStyle.size,\n            color: textStyle.renderingStyle.fill.toHexString(),\n        };\n    }\n    deserializeFrom(state) {\n        if (state.fontFamily && typeof state.fontFamily === 'string') {\n            this.tool.setFontFamily(state.fontFamily);\n        }\n        if (state.color && typeof state.color === 'string') {\n            this.tool.setColor(Color4.fromHex(state.color));\n        }\n        if (state.textSize && typeof state.textSize === 'number') {\n            this.tool.setFontSize(state.textSize);\n        }\n        super.deserializeFrom(state);\n    }\n}\nTextToolWidget.idCounter = 0;\nexport default TextToolWidget;\n","import { Color4 } from '@js-draw/math';\nimport  PipetteTool  from '../../../tools/PipetteTool.mjs';\nimport  { EditorEventType }  from '../../../types.mjs';\n// Returns [ color input, input container, callback to change the color value ].\nexport const makeColorInput = (editor, onColorChange) => {\n    const container = document.createElement('span');\n    const inputWrapper = document.createElement('span');\n    const colorInput = document.createElement('input');\n    colorInput.type = 'button';\n    colorInput.classList.add('coloris_input');\n    container.classList.add('color-input-container');\n    inputWrapper.classList.add('color-input-wrapper');\n    inputWrapper.appendChild(colorInput);\n    container.appendChild(inputWrapper);\n    const pipetteController = addPipetteTool(editor, container, (color) => {\n        colorInput.value = color.toHexString();\n        onInputEnd();\n        // Update the color preview, if it exists (may be managed by Coloris).\n        const parentElem = colorInput.parentElement;\n        if (parentElem && parentElem.classList.contains('clr-field')) {\n            parentElem.style.color = colorInput.value;\n        }\n    });\n    let currentColor;\n    const handleColorInput = () => {\n        currentColor = Color4.fromHex(colorInput.value);\n    };\n    // Only change the pen color when we finish sending input (this limits the number of\n    // editor events triggered and accessibility announcements).\n    const onInputEnd = () => {\n        handleColorInput();\n        if (currentColor) {\n            editor.announceForAccessibility(editor.localization.colorChangedAnnouncement(currentColor.toHexString()));\n            onColorChange(currentColor);\n            editor.notifier.dispatch(EditorEventType.ColorPickerColorSelected, {\n                kind: EditorEventType.ColorPickerColorSelected,\n                color: currentColor,\n            });\n        }\n    };\n    colorInput.oninput = handleColorInput;\n    let isOpen = false;\n    colorInput.addEventListener('open', () => {\n        isOpen = true;\n        editor.notifier.dispatch(EditorEventType.ColorPickerToggled, {\n            kind: EditorEventType.ColorPickerToggled,\n            open: true,\n        });\n        pipetteController.cancel();\n        container.classList.add('picker-open');\n        // Focus the Coloris color picker, if it exists.\n        // Don't focus the text input within the color picker, however,\n        // as this displays a keyboard on mobile devices.\n        const colorPickerElem = document.querySelector('#clr-picker #clr-hue-slider');\n        colorPickerElem?.focus();\n    });\n    const onClose = () => {\n        isOpen = false;\n        editor.notifier.dispatch(EditorEventType.ColorPickerToggled, {\n            kind: EditorEventType.ColorPickerToggled,\n            open: false,\n        });\n        onInputEnd();\n        // Restore focus to the input that opened the color picker\n        colorInput.focus();\n        container.classList.remove('picker-open');\n    };\n    colorInput.addEventListener('close', () => {\n        onClose();\n    });\n    const setColorInputValue = (color) => {\n        if (typeof color === 'object') {\n            color = color.toHexString();\n        }\n        colorInput.value = color;\n        // Fire all color event listeners. See\n        // https://github.com/mdbassit/Coloris#manually-updating-the-thumbnail\n        colorInput.dispatchEvent(new Event('input', { bubbles: true }));\n    };\n    return {\n        input: colorInput,\n        container,\n        setValue: setColorInputValue,\n        closePicker: () => {\n            if (isOpen) {\n                onInputEnd();\n            }\n        },\n        registerWithHelpTextDisplay: (helpDisplay) => {\n            helpDisplay.registerTextHelpForElement(inputWrapper, editor.localization.colorPickerToggleHelpText);\n            pipetteController.registerWithHelpTextDisplay(helpDisplay);\n        },\n    };\n};\nconst addPipetteTool = (editor, container, onColorChange) => {\n    const pipetteButton = document.createElement('button');\n    pipetteButton.classList.add('pipetteButton');\n    pipetteButton.title = editor.localization.pickColorFromScreen;\n    pipetteButton.setAttribute('alt', pipetteButton.title);\n    const pickColorLabel = document.createElement('span');\n    pickColorLabel.classList.add('pickColorInstructions');\n    pickColorLabel.innerText = editor.localization.clickToPickColorAnnouncement;\n    const updatePipetteButtonContent = (color) => {\n        pipetteButton.replaceChildren(editor.icons.makePipetteIcon(color), pickColorLabel);\n    };\n    updatePipetteButtonContent();\n    const pipetteTool = editor.toolController.getMatchingTools(PipetteTool)[0];\n    const endColorSelectMode = () => {\n        pipetteTool?.clearColorListener();\n        updatePipetteButtonContent();\n        pipetteButton.classList.remove('active');\n    };\n    const pipetteColorSelect = (color) => {\n        endColorSelectMode();\n        if (color) {\n            onColorChange(color);\n        }\n    };\n    const pipetteColorPreview = (color) => {\n        if (color) {\n            updatePipetteButtonContent(color);\n        }\n        else {\n            updatePipetteButtonContent();\n        }\n    };\n    pipetteButton.onclick = () => {\n        // If already picking, cancel it.\n        if (pipetteButton.classList.contains('active')) {\n            endColorSelectMode();\n            editor.announceForAccessibility(editor.localization.colorSelectionCanceledAnnouncement);\n            return;\n        }\n        pipetteTool?.setColorListener(pipetteColorPreview, pipetteColorSelect);\n        if (pipetteTool) {\n            pipetteButton.classList.add('active');\n            editor.announceForAccessibility(editor.localization.clickToPickColorAnnouncement);\n        }\n    };\n    container.appendChild(pipetteButton);\n    return {\n        // Cancel a pipette color selection if one is in progress.\n        cancel: () => {\n            endColorSelectMode();\n        },\n        registerWithHelpTextDisplay: (helpDisplay) => {\n            helpDisplay.registerTextHelpForElement(pipetteButton, editor.localization.colorPickerPipetteHelpText);\n        },\n    };\n};\nexport default makeColorInput;\n","import  ReactiveValue  from '../../../util/ReactiveValue.mjs';\nlet idCounter = 0;\n/**\n * Creates a stylized file input. This file input can either use the system file picker, or a custom\n * one specified by `customPickerAction`.\n */\nconst makeFileInput = (labelText, context, { accepts = '*', allowMultiSelect = false, customPickerAction } = {}) => {\n    const container = document.createElement('div');\n    const label = document.createElement('label');\n    const input = document.createElement('input');\n    const descriptionBox = document.createElement('div');\n    descriptionBox.classList.add('toolbar--file-input-description');\n    const descriptionText = document.createElement('span');\n    container.classList.add('toolbar--file-input-container');\n    label.appendChild(document.createTextNode(labelText));\n    input.accept = accepts;\n    input.type = customPickerAction ? 'button' : 'file';\n    input.classList.add('file-input');\n    input.multiple = allowMultiSelect;\n    // Associate the label with the input\n    const inputId = `js-draw-file-input-${idCounter++}`;\n    input.setAttribute('id', inputId);\n    label.htmlFor = inputId;\n    const icon = context.icons.makeUploadFileIcon();\n    icon.classList.add('icon');\n    descriptionBox.replaceChildren(icon, descriptionText);\n    label.appendChild(descriptionBox);\n    container.replaceChildren(label, input);\n    const selectedFiles = ReactiveValue.fromInitialValue([]);\n    let loading = false;\n    let cancelLoading = null;\n    const updateStatusText = () => {\n        const files = selectedFiles.get();\n        if (loading) {\n            descriptionText.textContent = context.localization.fileInput__loading;\n            if (cancelLoading) {\n                const cancelText = document.createElement('b');\n                cancelText.textContent = context.localization.cancel;\n                cancelText.classList.add('cancel-button');\n                descriptionText.appendChild(cancelText);\n            }\n            icon.style.display = 'none';\n        }\n        else if (files.length > 0) {\n            const fileNames = files.map((file) => file.name);\n            const maxNames = 5;\n            if (fileNames.length <= maxNames) {\n                descriptionText.textContent = fileNames.join('\\n');\n            }\n            else {\n                const fileNamesToShow = fileNames.slice(0, maxNames - 1);\n                descriptionText.textContent = [\n                    ...fileNamesToShow,\n                    context.localization.fileInput__andNMoreFiles(fileNames.length - fileNamesToShow.length),\n                ].join('\\n');\n            }\n            // Only show the icon when there are files\n            icon.style.display = 'none';\n        }\n        else {\n            // Show the icon\n            icon.style.display = '';\n            const text = context.localization.dragAndDropHereOrBrowse;\n            // Split into regions surrounded by {{curly braces}} and regions that are\n            // not.\n            // When given a regular expression, `.split` outputs an array. For example,\n            //    \"a test __of__ split\".split(/__(.*)__/)\n            // results in\n            //    ['a test ', 'of', ' split'].\n            const segments = text.split(/[{]{2}(.*)[}]{2}/g);\n            descriptionText.replaceChildren();\n            for (let i = 0; i < segments.length; i++) {\n                // Inside a {{pair of curly braces}}?\n                if (i % 2 === 1) {\n                    const boldedText = document.createElement('b');\n                    boldedText.textContent = segments[i];\n                    descriptionText.appendChild(boldedText);\n                }\n                else {\n                    descriptionText.appendChild(document.createTextNode(segments[i]));\n                }\n            }\n        }\n    };\n    const addFileEventListeners = () => {\n        // Support dropping files\n        label.addEventListener('dragover', (event) => {\n            event.preventDefault();\n            label.classList.add('drag-target');\n        });\n        label.addEventListener('dragenter', (event) => {\n            event.preventDefault();\n            label.classList.add('drag-target');\n        });\n        label.addEventListener('dragleave', (event) => {\n            event.preventDefault();\n            // Ensure the event wasn't targeting a child.\n            // See https://stackoverflow.com/a/54271161 and\n            //     https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/relatedTarget\n            const enteringElement = event.relatedTarget;\n            if (!enteringElement || !label.contains(enteringElement)) {\n                label.classList.remove('drag-target');\n            }\n        });\n        // See https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/File_drag_and_drop#process_the_drop\n        label.addEventListener('drop', (event) => {\n            event.preventDefault();\n            label.classList.remove('drag-target');\n            const fileList = [];\n            if (event.dataTransfer) {\n                fileList.push(...event.dataTransfer.files);\n            }\n            selectedFiles.set(fileList);\n        });\n        input.addEventListener('change', () => {\n            const fileList = input.files ?? [];\n            selectedFiles.set([...fileList]);\n        });\n    };\n    addFileEventListeners();\n    // Support for custom file pickers\n    if (customPickerAction) {\n        const promptForFiles = async () => {\n            if (loading) {\n                cancelLoading?.();\n                return;\n            }\n            container.classList.add('-loading');\n            loading = true;\n            updateStatusText();\n            try {\n                const data = await customPickerAction({\n                    setOnCancelCallback: (onCancel) => {\n                        if (!loading) {\n                            throw new Error(\"Task already completed. Can't register cancel handler.\");\n                        }\n                        cancelLoading = () => {\n                            cancelLoading = null;\n                            updateStatusText();\n                            onCancel();\n                        };\n                        updateStatusText();\n                    },\n                });\n                if (data) {\n                    selectedFiles.set(data);\n                }\n            }\n            finally {\n                container.classList.remove('-loading');\n                loading = false;\n                updateStatusText();\n            }\n        };\n        input.onclick = promptForFiles;\n    }\n    selectedFiles.onUpdate((files) => {\n        if (files.length === 0 && input.files && input.files.length > 0) {\n            input.value = '';\n        }\n        cancelLoading?.();\n    });\n    // Update the status text and hide/show the icon.\n    selectedFiles.onUpdateAndNow(updateStatusText);\n    return {\n        container,\n        input,\n        selectedFiles,\n        addTo: (parent) => {\n            parent.appendChild(container);\n        },\n    };\n};\nexport default makeFileInput;\n","import  { MutableReactiveValue }  from '../../../util/ReactiveValue.mjs';\nimport  stopPropagationOfScrollingWheelEvents  from '../../../util/stopPropagationOfScrollingWheelEvents.mjs';\nimport  addLongPressOrHoverCssClasses  from '../../../util/addLongPressOrHoverCssClasses.mjs';\nimport  { toolbarCSSPrefix }  from '../../constants.mjs';\nlet idCounter = 0;\n/**\n * Creates a widget that allows users to select one of serveral items from a list.\n *\n * `ChoiceIdType` should be `string`, a `number`, or an `enum` (or similar).\n *\n * If this input is set to an ID that is not in `choices`, no item is selected.\n */\nconst makeGridSelector = (\n// Text before the grid selector used as a label\nlabelText, defaultId, choices) => {\n    const outerContainer = document.createElement('div');\n    outerContainer.classList.add(`${toolbarCSSPrefix}grid-selector`);\n    const selectedValue = MutableReactiveValue.fromInitialValue(defaultId);\n    const menuContainer = document.createElement('div');\n    menuContainer.setAttribute('role', 'menu');\n    menuContainer.id = `${toolbarCSSPrefix}-grid-select-id-${idCounter++}`;\n    stopPropagationOfScrollingWheelEvents(menuContainer);\n    const label = document.createElement('label');\n    label.textContent = labelText;\n    label.htmlFor = menuContainer.id;\n    outerContainer.appendChild(label);\n    // All buttons in a radiogroup need the same name attribute.\n    let radiogroupName = `${toolbarCSSPrefix}-grid-selector-${idCounter++}`;\n    const createChoiceButton = (record) => {\n        const buttonContainer = document.createElement('div');\n        buttonContainer.classList.add('choice-button');\n        const button = document.createElement('input');\n        button.type = 'radio';\n        button.id = `${toolbarCSSPrefix}-grid-select-button-${idCounter++}`;\n        // Some toolbars only show the label on hover. Having long press or hover\n        // CSS classes are helpful here.\n        addLongPressOrHoverCssClasses(buttonContainer);\n        // Clicking any part of labelContainer triggers the radio button.\n        const labelContainer = document.createElement('label');\n        const rebuildLabel = () => {\n            labelContainer.setAttribute('title', record.title);\n            const labelText = document.createElement('span');\n            labelText.classList.add('button-label-text');\n            const icon = record.makeIcon();\n            icon.classList.add('icon');\n            // The title of the record\n            labelText.innerText = record.title;\n            labelContainer.htmlFor = button.id;\n            labelContainer.replaceChildren(icon, labelText);\n        };\n        rebuildLabel();\n        // Mark the button as belonging to the current group (causes\n        // other buttons in the same group to automatically uncheck\n        // when this button is checked).\n        const updateButtonRadiogroupName = () => {\n            button.name = radiogroupName;\n        };\n        updateButtonRadiogroupName();\n        const updateButtonCSS = () => {\n            if (button.checked) {\n                buttonContainer.classList.add('checked');\n            }\n            else {\n                buttonContainer.classList.remove('checked');\n            }\n        };\n        button.oninput = () => {\n            // Setting the selected value fires an event that causes the value\n            // of this button to be set.\n            if (button.checked) {\n                selectedValue.set(record.id);\n            }\n            updateButtonCSS();\n        };\n        button.onfocus = () => {\n            if (buttonContainer.querySelector(':focus-visible')) {\n                buttonContainer.classList.add('focus-visible');\n            }\n        };\n        button.onblur = () => {\n            buttonContainer.classList.remove('focus-visible');\n        };\n        // Prevent the right-click menu from being shown on long-press\n        // (important for some toolbars that use long-press gestures to\n        // show grid selector labels).\n        buttonContainer.oncontextmenu = (event) => {\n            event.preventDefault();\n        };\n        buttonContainer.replaceChildren(button, labelContainer);\n        menuContainer.appendChild(buttonContainer);\n        // Set whether the current button is checked\n        const setChecked = (checked) => {\n            button.checked = checked;\n            updateButtonCSS();\n        };\n        setChecked(false);\n        // Updates the factory's icon based on the current style of the tool.\n        const updateIcon = () => {\n            rebuildLabel();\n        };\n        return {\n            choiceRecord: record,\n            setChecked,\n            updateIcon,\n            updateButtonRadiogroupName,\n        };\n    };\n    const buttons = [];\n    for (const choice of choices) {\n        buttons.push(createChoiceButton(choice));\n    }\n    // invariant: buttons.length = choices.length\n    // However, it is still possible that selectedValue does not correspond\n    // to a choice in `choices`. This is acceptable.\n    outerContainer.appendChild(menuContainer);\n    selectedValue.onUpdateAndNow((choiceId) => {\n        for (let i = 0; i < buttons.length; i++) {\n            buttons[i].setChecked(buttons[i].choiceRecord.id === choiceId);\n        }\n    });\n    const result = {\n        value: selectedValue,\n        _radiogroupName: radiogroupName,\n        linkWith: (other) => {\n            result._radiogroupName = other._radiogroupName;\n            radiogroupName = other._radiogroupName;\n            for (const button of buttons) {\n                button.updateButtonRadiogroupName();\n            }\n        },\n        updateIcons: () => {\n            buttons.forEach((button) => button.updateIcon());\n        },\n        getRootElement() {\n            return outerContainer;\n        },\n        addTo: (parent) => {\n            parent.appendChild(outerContainer);\n        },\n    };\n    return result;\n};\nexport default makeGridSelector;\n","/**\n * Creates a separator element that renders a line and, optionally, a header.\n */\nconst makeSeparator = (header = '') => {\n    const container = document.createElement('div');\n    container.classList.add('tool-dropdown-separator');\n    container.innerText = header;\n    return {\n        addTo: (parent) => {\n            parent.appendChild(container);\n        },\n    };\n};\nexport default makeSeparator;\n","import  stopPropagationOfScrollingWheelEvents  from '../../../util/stopPropagationOfScrollingWheelEvents.mjs';\nimport  { MutableReactiveValue, ReactiveValue }  from '../../../util/ReactiveValue.mjs';\n/**\n * Creates a list that snaps to each item and reports the selected item.\n */\nconst makeSnappedList = (itemsValue) => {\n    const container = document.createElement('div');\n    container.classList.add('toolbar-snapped-scroll-list');\n    const scroller = document.createElement('div');\n    scroller.classList.add('scroller');\n    const visibleIndex = MutableReactiveValue.fromInitialValue(0);\n    let observer = null;\n    const makePageMarkers = () => {\n        const markerContainer = document.createElement('div');\n        markerContainer.classList.add('page-markers');\n        // Keyboard focus should go to the main scrolling list.\n        // TODO: Does it make sense for the page marker list to be focusable?\n        markerContainer.setAttribute('tabindex', '-1');\n        const markers = [];\n        const pairedItems = ReactiveValue.union([\n            visibleIndex,\n            itemsValue,\n        ]);\n        pairedItems.onUpdateAndNow(([currentVisibleIndex, items]) => {\n            let addedOrRemovedMarkers = false;\n            // Items may have been removed from the list of pages. Make the markers reflect that.\n            while (items.length < markers.length) {\n                markers.pop();\n                addedOrRemovedMarkers = true;\n            }\n            let activeMarker;\n            for (let i = 0; i < items.length; i++) {\n                let marker;\n                if (i >= markers.length) {\n                    marker = document.createElement('div');\n                    // Use a separate content element to increase the clickable size of\n                    // the marker.\n                    const content = document.createElement('div');\n                    content.classList.add('content');\n                    marker.replaceChildren(content);\n                    markers.push(marker);\n                    addedOrRemovedMarkers = true;\n                }\n                else {\n                    marker = markers[i];\n                }\n                marker.classList.add('marker');\n                if (i === currentVisibleIndex) {\n                    marker.classList.add('-active');\n                    activeMarker = marker;\n                }\n                else {\n                    marker.classList.remove('-active');\n                }\n                const markerIndex = i;\n                marker.onclick = () => {\n                    wrappedItems\n                        .get()[markerIndex]?.element?.scrollIntoView({ block: 'nearest', behavior: 'smooth' });\n                };\n            }\n            // Only call .replaceChildren when necessary -- doing so on every change would\n            // break transitions.\n            if (addedOrRemovedMarkers) {\n                markerContainer.replaceChildren(...markers);\n            }\n            // Handles the case where there are many markers and the current is offscreen\n            if (activeMarker && markerContainer.scrollHeight > container.clientHeight) {\n                activeMarker.scrollIntoView({ block: 'nearest' });\n            }\n            if (markers.length === 1) {\n                markerContainer.classList.add('-one-element');\n            }\n            else {\n                markerContainer.classList.remove('-one-element');\n            }\n        });\n        return markerContainer;\n    };\n    const createObserver = () => {\n        observer = new IntersectionObserver((entries) => {\n            for (const entry of entries) {\n                if (entry.isIntersecting && entry.intersectionRatio > 0.7) {\n                    const indexString = entry.target.getAttribute('data-item-index');\n                    if (indexString === null)\n                        throw new Error('Could not find attribute data-item-index');\n                    const index = Number(indexString);\n                    visibleIndex.set(index);\n                    break;\n                }\n            }\n        }, {\n            // Element to use as the boudning box with which to intersect.\n            // See https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\n            root: scroller,\n            // Fraction of an element that must be visible to trigger the callback:\n            threshold: 0.9,\n        });\n    };\n    const destroyObserver = () => {\n        if (observer) {\n            observer.disconnect();\n            visibleIndex.set(0);\n            observer = null;\n        }\n    };\n    const wrappedItems = ReactiveValue.map(itemsValue, (items) => {\n        return items.map((item, index) => {\n            const wrapper = document.createElement('div');\n            if (item.element.parentElement)\n                item.element.remove();\n            wrapper.appendChild(item.element);\n            wrapper.classList.add('item');\n            wrapper.setAttribute('data-item-index', `${index}`);\n            return {\n                element: wrapper,\n                data: item.data,\n            };\n        });\n    });\n    const lastItems = [];\n    wrappedItems.onUpdateAndNow((items) => {\n        visibleIndex.set(-1);\n        for (const item of lastItems) {\n            observer?.unobserve(item.element);\n        }\n        scroller.replaceChildren();\n        // An observer is only necessary if there are multiple items to scroll through.\n        if (items.length > 1) {\n            createObserver();\n        }\n        else {\n            destroyObserver();\n        }\n        // Different styling is applied when empty\n        if (items.length === 0) {\n            container.classList.add('-empty');\n        }\n        else {\n            container.classList.remove('-empty');\n        }\n        for (const item of items) {\n            scroller.appendChild(item.element);\n        }\n        visibleIndex.set(0);\n        if (observer) {\n            for (const item of items) {\n                observer.observe(item.element);\n            }\n        }\n    });\n    const visibleItem = ReactiveValue.map(visibleIndex, (index) => {\n        const values = itemsValue.get();\n        if (0 <= index && index < values.length) {\n            return values[index].data;\n        }\n        return null;\n    });\n    // makeSnappedList is generally shown within the toolbar. This allows users to\n    // scroll it with a touchpad.\n    stopPropagationOfScrollingWheelEvents(scroller);\n    container.replaceChildren(makePageMarkers(), scroller);\n    return {\n        container,\n        visibleItem,\n    };\n};\nexport default makeSnappedList;\n","import { toRoundedString } from '@js-draw/math';\nimport  { toolbarCSSPrefix }  from '../../constants.mjs';\nlet idCounter = 0;\nconst makeThicknessSlider = (context, onChange) => {\n    const container = document.createElement('div');\n    const thicknessLabel = document.createElement('label');\n    const thicknessInput = document.createElement('input');\n    container.classList.add(`${toolbarCSSPrefix}thicknessSliderContainer`);\n    // Give inputs IDs so we can label them with a <label for=...>Label text</label>\n    thicknessInput.id = `${toolbarCSSPrefix}thicknessInput${idCounter++}`;\n    thicknessLabel.innerText = context.localization.thicknessLabel;\n    thicknessLabel.setAttribute('for', thicknessInput.id);\n    // Use a logarithmic scale for thicknessInput (finer control over thinner strokewidths.)\n    const inverseThicknessInputFn = (t) => Math.log10(t);\n    const thicknessInputFn = (t) => 10 ** t;\n    thicknessInput.type = 'range';\n    thicknessInput.oninput = () => {\n        onChange(thicknessInputFn(parseFloat(thicknessInput.value)));\n    };\n    container.appendChild(thicknessLabel);\n    container.appendChild(thicknessInput);\n    const setBounds = (min, max) => {\n        const round = (value, roundUp) => {\n            const roundFn = roundUp ? Math.ceil : Math.floor;\n            return roundFn(value * 100) / 100;\n        };\n        const sliderMin = round(inverseThicknessInputFn(min), false);\n        const sliderMax = round(inverseThicknessInputFn(max), true);\n        thicknessInput.min = `${sliderMin}`;\n        thicknessInput.max = `${sliderMax}`;\n        thicknessInput.step = `${toRoundedString((sliderMax - sliderMin) / 20)}`;\n    };\n    setBounds(2, 262);\n    return {\n        container,\n        addTo: (parent) => {\n            parent.appendChild(container);\n        },\n        setBounds,\n        setValue: (thickness) => {\n            thicknessInput.value = inverseThicknessInputFn(thickness).toString();\n        },\n    };\n};\nexport default makeThicknessSlider;\n","import  KeyboardShortcutManager  from '../../shortcuts/KeyboardShortcutManager.mjs';\n// Selection\nexport const resizeImageToSelectionKeyboardShortcut = 'jsdraw.toolbar.SelectionTool.resizeImageToSelection';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(resizeImageToSelectionKeyboardShortcut, ['ctrlOrMeta+r'], 'Resize image to selection');\n// Pen tool\nexport const selectStrokeTypeKeyboardShortcutIds = [1, 2, 3, 4, 5, 6, 7, 8, 9].map((id) => `jsdraw.toolbar.PenTool.select-pen-${id}`);\nfor (let i = 0; i < selectStrokeTypeKeyboardShortcutIds.length; i++) {\n    const id = selectStrokeTypeKeyboardShortcutIds[i];\n    KeyboardShortcutManager.registerDefaultKeyboardShortcut(id, [`CtrlOrMeta+Digit${i + 1}`], 'Select pen style ' + (i + 1));\n}\n// Save\nexport const saveKeyboardShortcut = 'jsdraw.toolbar.SaveActionWidget.save';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(saveKeyboardShortcut, ['ctrlOrMeta+KeyS'], 'Save');\n// Exit\nexport const exitKeyboardShortcut = 'jsdraw.toolbar.ExitActionWidget.exit';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(exitKeyboardShortcut, ['Alt+KeyQ'], 'Exit');\n","import  { EditorEventType }  from '../../../types.mjs';\nimport  EventDispatcher  from '../../../EventDispatcher.mjs';\nimport  { toolbarCSSPrefix }  from '../../constants.mjs';\nimport  { ReactiveValue }  from '../../../util/ReactiveValue.mjs';\nvar DropdownEventType;\n(function (DropdownEventType) {\n    DropdownEventType[DropdownEventType[\"DropdownShown\"] = 0] = \"DropdownShown\";\n    DropdownEventType[DropdownEventType[\"DropdownHidden\"] = 1] = \"DropdownHidden\";\n})(DropdownEventType || (DropdownEventType = {}));\nclass Dropdown {\n    constructor(parent, notifier, onDestroy) {\n        this.parent = parent;\n        this.notifier = notifier;\n        this.onDestroy = onDestroy;\n        this.dropdownToggleListener = null;\n        this.hideDropdownTimeout = null;\n        this.visible = ReactiveValue.fromInitialValue(false);\n        this.dropdownContainer = document.createElement('div');\n        this.dropdownContainer.classList.add(`${toolbarCSSPrefix}dropdown`);\n        this.dropdownContainer.classList.add('hidden');\n        parent.target.insertAdjacentElement('afterend', this.dropdownContainer);\n        // When another dropdown is shown,\n        this.dropdownToggleListener = this.notifier.on(DropdownEventType.DropdownShown, (evt) => {\n            if (evt.dropdown !== this &&\n                // Don't hide if a submenu was shown (it might be a submenu of\n                // the current menu).\n                evt.fromToplevelDropdown) {\n                this.setVisible(false);\n            }\n        });\n    }\n    onActivated() {\n        // Do nothing.\n    }\n    repositionDropdown() {\n        const dropdownBBox = this.dropdownContainer.getBoundingClientRect();\n        const screenWidth = document.scrollingElement?.clientWidth ?? document.body.clientHeight;\n        const screenHeight = document.scrollingElement?.clientHeight ?? document.body.clientHeight;\n        let translateX = undefined;\n        let translateY = undefined;\n        if (dropdownBBox.left > screenWidth / 2) {\n            const targetElem = this.parent.target;\n            translateX = `calc(${targetElem.clientWidth + 'px'} - 100%)`;\n        }\n        // Shift the dropdown if it's off the screen, but only if doing so moves it on to the screen\n        // (prevents dropdowns from going almost completely offscreen on small screens).\n        if (dropdownBBox.bottom > screenHeight && dropdownBBox.top - dropdownBBox.height > 0) {\n            const targetElem = this.parent.target;\n            translateY = `calc(-${targetElem.clientHeight}px - 100%)`;\n        }\n        // Use .translate so as not to conflict with CSS animating the\n        // transform property.\n        if (translateX || translateY) {\n            this.dropdownContainer.style.translate = `${translateX ?? '0'} ${translateY ?? '0'}`;\n        }\n        else {\n            this.dropdownContainer.style.translate = '';\n        }\n    }\n    setVisible(visible) {\n        const currentlyVisible = this.visible.get();\n        if (currentlyVisible === visible) {\n            return;\n        }\n        // If waiting to hide the dropdown, cancel it.\n        if (this.hideDropdownTimeout) {\n            clearTimeout(this.hideDropdownTimeout);\n            this.hideDropdownTimeout = null;\n            this.dropdownContainer.classList.remove('hiding');\n            this.repositionDropdown();\n        }\n        const animationDuration = 150; // ms\n        this.visible.set(visible);\n        if (visible) {\n            this.dropdownContainer.classList.remove('hidden');\n            this.notifier.dispatch(DropdownEventType.DropdownShown, {\n                dropdown: this,\n                fromToplevelDropdown: this.parent.isToplevel(),\n            });\n            this.repositionDropdown();\n        }\n        else {\n            this.notifier.dispatch(DropdownEventType.DropdownHidden, {\n                dropdown: this,\n                fromToplevelDropdown: this.parent.isToplevel(),\n            });\n            this.dropdownContainer.classList.add('hiding');\n            // Hide the dropdown *slightly* before the animation finishes. This\n            // prevents flickering in some browsers.\n            const hideDelay = animationDuration * 0.95;\n            this.hideDropdownTimeout = setTimeout(() => {\n                this.dropdownContainer.classList.add('hidden');\n                this.dropdownContainer.classList.remove('hiding');\n                this.repositionDropdown();\n            }, hideDelay);\n        }\n        // Animate\n        const animationName = `var(--dropdown-${visible ? 'show' : 'hide'}-animation)`;\n        this.dropdownContainer.style.animation = `${animationDuration}ms ease ${animationName}`;\n    }\n    requestShow() {\n        this.setVisible(true);\n    }\n    requestHide() {\n        this.setVisible(false);\n    }\n    appendChild(item) {\n        this.dropdownContainer.appendChild(item);\n    }\n    clearChildren() {\n        this.dropdownContainer.replaceChildren();\n    }\n    destroy() {\n        this.setVisible(false);\n        this.dropdownContainer.remove();\n        this.dropdownToggleListener?.remove();\n        // Allow children to be added to other parents\n        this.clearChildren();\n        this.onDestroy();\n    }\n}\nexport default class DropdownLayoutManager {\n    constructor(announceForAccessibility, localization) {\n        this.localization = localization;\n        this.dropdowns = new Set();\n        this.listeners = [];\n        this.connectedNotifiers = [];\n        this.notifier = new EventDispatcher();\n        this.notifier.on(DropdownEventType.DropdownShown, ({ dropdown, fromToplevelDropdown }) => {\n            if (!dropdown)\n                return;\n            announceForAccessibility(this.localization.dropdownShown(dropdown.parent.getTitle()));\n            // Share the event with other connected notifiers\n            this.connectedNotifiers.forEach((notifier) => {\n                notifier.dispatch(EditorEventType.ToolbarDropdownShown, {\n                    kind: EditorEventType.ToolbarDropdownShown,\n                    fromToplevelDropdown,\n                    layoutManager: this,\n                });\n            });\n        });\n        this.notifier.on(DropdownEventType.DropdownHidden, ({ dropdown }) => {\n            if (!dropdown)\n                return;\n            announceForAccessibility(this.localization.dropdownHidden(dropdown.parent.getTitle()));\n        });\n    }\n    connectToEditorNotifier(notifier) {\n        this.connectedNotifiers.push(notifier);\n        this.refreshListeners();\n    }\n    /** Creates a dropdown within `parent`. */\n    createToolMenu(parent) {\n        const dropdown = new Dropdown(parent, this.notifier, () => {\n            this.dropdowns.delete(dropdown);\n            this.refreshListeners();\n        });\n        this.dropdowns.add(dropdown);\n        this.refreshListeners();\n        return dropdown;\n    }\n    /**\n     * Adds/removes listeners based on whether we have any managed dropdowns.\n     *\n     * We attempt to clean up all resources when `dropdowns.size == 0`, at which\n     * point, an instance of this could be safely garbage collected.\n     */\n    refreshListeners() {\n        const clearListeners = () => {\n            // Remove all listeners & resources that won't be garbage collected.\n            this.listeners.forEach((l) => l.remove());\n            this.listeners = [];\n        };\n        if (this.dropdowns.size === 0) {\n            clearListeners();\n        }\n        else if (this.listeners.length !== this.connectedNotifiers.length) {\n            clearListeners();\n            this.listeners = this.connectedNotifiers.map((notifier) => {\n                return notifier.on(EditorEventType.ToolbarDropdownShown, (evt) => {\n                    if (evt.kind !== EditorEventType.ToolbarDropdownShown ||\n                        // Don't forward to ourselves events that we originally triggered.\n                        evt.layoutManager === this) {\n                        return;\n                    }\n                    this.notifier.dispatch(DropdownEventType.DropdownShown, {\n                        fromToplevelDropdown: evt.fromToplevelDropdown,\n                    });\n                });\n            });\n        }\n    }\n}\n","import  { ReactiveValue }  from '../../../util/ReactiveValue.mjs';\nexport default class EdgeToolbarLayoutManager {\n    // @internal\n    constructor(setSidebarContent, sidebarTitle, sidebarVisibility, announceForAccessibility, localization) {\n        this.setSidebarContent = setSidebarContent;\n        this.sidebarTitle = sidebarTitle;\n        this.sidebarVisibility = sidebarVisibility;\n        this.announceForAccessibility = announceForAccessibility;\n        this.localization = localization;\n        this.visibleWidgetContent = ReactiveValue.fromInitialValue(null);\n    }\n    /** Creates a dropdown within `parent`. */\n    createToolMenu(parent) {\n        const contentElem = document.createElement('div');\n        let result = null;\n        const visible = ReactiveValue.fromCallback(() => {\n            return this.visibleWidgetContent.get() === result && this.sidebarVisibility.get();\n        }, [this.visibleWidgetContent, this.sidebarVisibility]);\n        result = {\n            visible,\n            requestShow: () => {\n                this.setSidebarContent(contentElem);\n                this.sidebarTitle.set(parent.getTitle());\n                // Set visibleWidgetContent first -- this causes the previously visible (if any)\n                // item to not be sent a shown event.\n                this.visibleWidgetContent.set(result);\n                this.sidebarVisibility.set(true);\n                this.announceForAccessibility(this.localization.dropdownShown(parent.getTitle()));\n            },\n            onActivated: () => {\n                // TODO: Only request show when in sidebar mode\n                //result?.requestShow();\n            },\n            requestHide: () => {\n                if (visible.get()) {\n                    this.sidebarVisibility.set(false);\n                }\n            },\n            appendChild: (item) => {\n                contentElem.appendChild(item);\n            },\n            clearChildren: () => {\n                contentElem.replaceChildren();\n            },\n            destroy: () => {\n                result?.requestHide();\n                if (contentElem.parentElement) {\n                    contentElem.remove();\n                }\n                if (this.visibleWidgetContent.get() === result) {\n                    this.visibleWidgetContent.set(null);\n                }\n            },\n        };\n        return result;\n    }\n}\n","export  { default as ActionButtonWidget }  from './ActionButtonWidget.mjs';\nexport  { default as BaseToolWidget }  from './BaseToolWidget.mjs';\nexport  { default as BaseWidget, ToolbarWidgetTag }  from './BaseWidget.mjs';\nexport  { default as PenToolWidget }  from './PenToolWidget.mjs';\nexport  { default as TextToolWidget }  from './TextToolWidget.mjs';\nexport  { default as HandToolWidget }  from './HandToolWidget.mjs';\nexport  { default as SelectionToolWidget }  from './SelectionToolWidget.mjs';\nexport  { default as EraserToolWidget }  from './EraserToolWidget.mjs';\nexport  { default as InsertImageWidget }  from './InsertImageWidget/InsertImageWidget.mjs';\nexport  { default as DocumentPropertiesWidget }  from './DocumentPropertiesWidget.mjs';\n","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _BaseTool_enabled, _BaseTool_group, _BaseTool_inputMapper, _BaseTool_readOnlyEditorChangeListener;\nimport  { EditorEventType }  from '../types.mjs';\nimport  { InputEvtType, }  from '../inputEvents.mjs';\nimport  { ReactiveValue }  from '../util/ReactiveValue.mjs';\nclass BaseTool {\n    constructor(notifier, description) {\n        this.notifier = notifier;\n        this.description = description;\n        _BaseTool_enabled.set(this, void 0);\n        _BaseTool_group.set(this, null);\n        _BaseTool_inputMapper.set(this, null);\n        _BaseTool_readOnlyEditorChangeListener.set(this, null);\n        __classPrivateFieldSet(this, _BaseTool_enabled, ReactiveValue.fromInitialValue(true), \"f\");\n        __classPrivateFieldGet(this, _BaseTool_enabled, \"f\").onUpdate((enabled) => {\n            // Ensure that at most one tool in the group is enabled.\n            if (enabled) {\n                __classPrivateFieldGet(this, _BaseTool_group, \"f\")?.notifyEnabled(this);\n                this.notifier.dispatch(EditorEventType.ToolEnabled, {\n                    kind: EditorEventType.ToolEnabled,\n                    tool: this,\n                });\n            }\n            else {\n                this.notifier.dispatch(EditorEventType.ToolDisabled, {\n                    kind: EditorEventType.ToolDisabled,\n                    tool: this,\n                });\n            }\n        });\n    }\n    /** Override this to allow this tool to be enabled in a read-only editor */\n    canReceiveInputInReadOnlyEditor() {\n        return false;\n    }\n    setInputMapper(mapper) {\n        __classPrivateFieldSet(this, _BaseTool_inputMapper, mapper, \"f\");\n        if (mapper) {\n            mapper.setEmitListener((event) => this.dispatchEventToCallback(event));\n        }\n    }\n    getInputMapper() {\n        return __classPrivateFieldGet(this, _BaseTool_inputMapper, \"f\");\n    }\n    dispatchEventToCallback(event) {\n        let exhaustivenessCheck;\n        switch (event.kind) {\n            case InputEvtType.PointerDownEvt:\n                return this.onPointerDown(event);\n            case InputEvtType.PointerMoveEvt:\n                this.onPointerMove(event);\n                break;\n            case InputEvtType.PointerUpEvt:\n                return this.onPointerUp(event) ?? false;\n            case InputEvtType.GestureCancelEvt:\n                this.onGestureCancel(event);\n                break;\n            case InputEvtType.WheelEvt:\n                return this.onWheel(event);\n            case InputEvtType.KeyPressEvent:\n                return this.onKeyPress(event);\n            case InputEvtType.KeyUpEvent:\n                return this.onKeyUp(event);\n            case InputEvtType.CopyEvent:\n                return this.onCopy(event);\n            case InputEvtType.PasteEvent:\n                return this.onPaste(event);\n            case InputEvtType.ContextMenu:\n                return this.onContextMenu(event);\n            default:\n                exhaustivenessCheck = event;\n                return exhaustivenessCheck;\n        }\n        return true;\n    }\n    // @internal\n    onEvent(event) {\n        if (__classPrivateFieldGet(this, _BaseTool_inputMapper, \"f\")) {\n            return __classPrivateFieldGet(this, _BaseTool_inputMapper, \"f\").onEvent(event);\n        }\n        return this.dispatchEventToCallback(event);\n    }\n    /**\n     * Returns true iff the tool handled the event and thus should receive additional\n     * events.\n     */\n    onPointerDown(_event) {\n        return false;\n    }\n    onPointerMove(_event) { }\n    /**\n     * Returns true iff there are additional pointers down and the tool should\n     * remain active to handle the additional events.\n     *\n     * For most purposes, this should return `false` or nothing.\n     */\n    onPointerUp(_event) { }\n    onGestureCancel(_event) { }\n    onWheel(_event) {\n        return false;\n    }\n    onCopy(_event) {\n        return false;\n    }\n    onPaste(_event) {\n        return false;\n    }\n    onKeyPress(_event) {\n        return false;\n    }\n    onKeyUp(_event) {\n        return false;\n    }\n    onContextMenu(_event) {\n        return false;\n    }\n    /**\n     * Return true if, while this tool is active, `_event` can be delivered to\n     * another tool that is higher priority than this.\n     * @internal May be renamed\n     */\n    eventCanBeDeliveredToNonActiveTool(_event) {\n        return true;\n    }\n    setEnabled(enabled) {\n        __classPrivateFieldGet(this, _BaseTool_enabled, \"f\").set(enabled);\n    }\n    isEnabled() {\n        return __classPrivateFieldGet(this, _BaseTool_enabled, \"f\").get();\n    }\n    /**\n     * Returns a {@link ReactiveValue} that updates based on whether this tool is\n     * enabled.\n     *\n     * @example\n     * ```ts\n     * const tool = new SomeTool();\n     *\n     * // Watch for changes in enabled status\n     * tool.enabledValue().onUpdate(enabled => doSomething(enabled));\n     * ```\n     */\n    enabledValue() {\n        return __classPrivateFieldGet(this, _BaseTool_enabled, \"f\");\n    }\n    // Connect this tool to a set of other tools, ensuring that at most one\n    // of the tools in the group is enabled.\n    setToolGroup(group) {\n        if (this.isEnabled()) {\n            group.notifyEnabled(this);\n        }\n        __classPrivateFieldSet(this, _BaseTool_group, group, \"f\");\n    }\n    getToolGroup() {\n        if (__classPrivateFieldGet(this, _BaseTool_group, \"f\")) {\n            return __classPrivateFieldGet(this, _BaseTool_group, \"f\");\n        }\n        return null;\n    }\n    // Called when the tool is removed/when the editor is destroyed.\n    // Subclasses that override this method **must call super.onDestroy()**.\n    onDestroy() {\n        __classPrivateFieldGet(this, _BaseTool_readOnlyEditorChangeListener, \"f\")?.remove();\n        __classPrivateFieldSet(this, _BaseTool_readOnlyEditorChangeListener, null, \"f\");\n        __classPrivateFieldSet(this, _BaseTool_group, null, \"f\");\n    }\n}\n_BaseTool_enabled = new WeakMap(), _BaseTool_group = new WeakMap(), _BaseTool_inputMapper = new WeakMap(), _BaseTool_readOnlyEditorChangeListener = new WeakMap();\nexport default BaseTool;\n","import  { EditorEventType }  from '../types.mjs';\nimport  BaseTool  from './BaseTool.mjs';\nimport { Vec2, LineSegment2, Color4, Rect2, Path } from '@js-draw/math';\nimport  Erase  from '../commands/Erase.mjs';\nimport  { PointerDevice }  from '../Pointer.mjs';\nimport  { decreaseSizeKeyboardShortcutId, increaseSizeKeyboardShortcutId }  from './keybindings.mjs';\nimport  { ReactiveValue }  from '../util/ReactiveValue.mjs';\nimport  EditorImage  from '../image/EditorImage.mjs';\nimport  uniteCommands  from '../commands/uniteCommands.mjs';\nimport  { pathToRenderable }  from '../rendering/RenderablePathSpec.mjs';\nexport var EraserMode;\n(function (EraserMode) {\n    EraserMode[\"PartialStroke\"] = \"partial-stroke\";\n    EraserMode[\"FullStroke\"] = \"full-stroke\";\n})(EraserMode || (EraserMode = {}));\n/** Handles switching from other primary tools to the eraser and back */\nclass EraserSwitcher extends BaseTool {\n    constructor(editor, eraser) {\n        super(editor.notifier, editor.localization.changeTool);\n        this.editor = editor;\n        this.eraser = eraser;\n    }\n    onPointerDown(event) {\n        if (event.allPointers.length === 1 && event.current.device === PointerDevice.Eraser) {\n            const toolController = this.editor.toolController;\n            const enabledPrimaryTools = toolController\n                .getPrimaryTools()\n                .filter((tool) => tool.isEnabled());\n            if (enabledPrimaryTools.length) {\n                this.previousEnabledTool = enabledPrimaryTools[0];\n            }\n            else {\n                this.previousEnabledTool = null;\n            }\n            this.previousEraserEnabledState = this.eraser.isEnabled();\n            this.eraser.setEnabled(true);\n            if (this.eraser.onPointerDown(event)) {\n                return true;\n            }\n            else {\n                this.restoreOriginalTool();\n            }\n        }\n        return false;\n    }\n    onPointerMove(event) {\n        this.eraser.onPointerMove(event);\n    }\n    restoreOriginalTool() {\n        this.eraser.setEnabled(this.previousEraserEnabledState);\n        if (this.previousEnabledTool) {\n            this.previousEnabledTool.setEnabled(true);\n        }\n    }\n    onPointerUp(event) {\n        this.eraser.onPointerUp(event);\n        this.restoreOriginalTool();\n    }\n    onGestureCancel(event) {\n        this.eraser.onGestureCancel(event);\n        this.restoreOriginalTool();\n    }\n}\n/**\n * A tool that allows a user to erase parts of an image.\n */\nexport default class Eraser extends BaseTool {\n    constructor(editor, description, options) {\n        super(editor.notifier, description);\n        this.editor = editor;\n        this.lastPoint = null;\n        this.isFirstEraseEvt = true;\n        this.toAdd = new Set();\n        // Commands that each remove one element\n        this.eraseCommands = [];\n        this.addCommands = [];\n        this.thickness = options?.thickness ?? 10;\n        this.thicknessValue = ReactiveValue.fromInitialValue(this.thickness);\n        this.thicknessValue.onUpdate((value) => {\n            this.thickness = value;\n            this.editor.notifier.dispatch(EditorEventType.ToolUpdated, {\n                kind: EditorEventType.ToolUpdated,\n                tool: this,\n            });\n        });\n        this.modeValue = ReactiveValue.fromInitialValue(options?.mode ?? EraserMode.FullStroke);\n        this.modeValue.onUpdate((_value) => {\n            this.editor.notifier.dispatch(EditorEventType.ToolUpdated, {\n                kind: EditorEventType.ToolUpdated,\n                tool: this,\n            });\n        });\n    }\n    /**\n     * @returns a tool that briefly enables the eraser when a physical eraser is used.\n     * This tool should be added to the tool list after the primary tools.\n     */\n    makeEraserSwitcherTool() {\n        return new EraserSwitcher(this.editor, this);\n    }\n    clearPreview() {\n        this.editor.clearWetInk();\n    }\n    getSizeOnCanvas() {\n        return this.thickness / this.editor.viewport.getScaleFactor();\n    }\n    drawPreviewAt(point) {\n        this.clearPreview();\n        const size = this.getSizeOnCanvas();\n        const renderer = this.editor.display.getWetInkRenderer();\n        const rect = this.getEraserRect(point);\n        const rect2 = this.getEraserRect(this.lastPoint ?? point);\n        const fill = {\n            fill: Color4.transparent,\n            stroke: { width: size / 10, color: Color4.gray },\n        };\n        renderer.drawPath(pathToRenderable(Path.fromConvexHullOf([...rect.corners, ...rect2.corners]), fill));\n    }\n    /**\n     * @returns the eraser rectangle in canvas coordinates.\n     *\n     * For now, all erasers are rectangles or points.\n     */\n    getEraserRect(centerPoint) {\n        const size = this.getSizeOnCanvas();\n        const halfSize = Vec2.of(size / 2, size / 2);\n        return Rect2.fromCorners(centerPoint.minus(halfSize), centerPoint.plus(halfSize));\n    }\n    /** Erases in a line from the last point to the current. */\n    eraseTo(currentPoint) {\n        if (!this.isFirstEraseEvt && currentPoint.distanceTo(this.lastPoint) === 0) {\n            return;\n        }\n        this.isFirstEraseEvt = false;\n        // Currently only objects within eraserRect or that intersect a straight line\n        // from the center of the current rect to the previous are erased. TODO: Erase\n        // all objects as if there were pointerMove events between the two points.\n        const eraserRect = this.getEraserRect(currentPoint);\n        const line = new LineSegment2(this.lastPoint, currentPoint);\n        const region = Rect2.union(line.bbox, eraserRect);\n        const intersectingElems = this.editor.image\n            .getElementsIntersectingRegion(region)\n            .filter((component) => {\n            return component.intersects(line) || component.intersectsRect(eraserRect);\n        });\n        // Only erase components that could be selected (and thus interacted with)\n        // by the user.\n        const eraseableElems = intersectingElems.filter((elem) => elem.isSelectable());\n        if (this.modeValue.get() === EraserMode.FullStroke) {\n            // Remove any intersecting elements.\n            this.toRemove.push(...eraseableElems);\n            // Create new Erase commands for the now-to-be-erased elements and apply them.\n            const newPartialCommands = eraseableElems.map((elem) => new Erase([elem]));\n            newPartialCommands.forEach((cmd) => cmd.apply(this.editor));\n            this.eraseCommands.push(...newPartialCommands);\n        }\n        else {\n            const toErase = [];\n            const toAdd = [];\n            for (const targetElem of eraseableElems) {\n                toErase.push(targetElem);\n                // Completely delete items that can't be divided.\n                if (!targetElem.withRegionErased) {\n                    continue;\n                }\n                // Completely delete items that are completely or almost completely\n                // contained within the eraser.\n                const grownRect = eraserRect.grownBy(eraserRect.maxDimension / 3);\n                if (grownRect.containsRect(targetElem.getExactBBox())) {\n                    continue;\n                }\n                // Join the current and previous rectangles so that points between events are also\n                // erased.\n                const erasePath = Path.fromConvexHullOf([\n                    ...eraserRect.corners,\n                    ...this.getEraserRect(this.lastPoint ?? currentPoint).corners,\n                ].map((p) => this.editor.viewport.roundPoint(p)));\n                toAdd.push(...targetElem.withRegionErased(erasePath, this.editor.viewport));\n            }\n            const eraseCommand = new Erase(toErase);\n            const newAddCommands = toAdd.map((elem) => EditorImage.addElement(elem));\n            eraseCommand.apply(this.editor);\n            newAddCommands.forEach((command) => command.apply(this.editor));\n            const finalToErase = [];\n            for (const item of toErase) {\n                if (this.toAdd.has(item)) {\n                    this.toAdd.delete(item);\n                }\n                else {\n                    finalToErase.push(item);\n                }\n            }\n            this.toRemove.push(...finalToErase);\n            for (const item of toAdd) {\n                this.toAdd.add(item);\n            }\n            this.eraseCommands.push(new Erase(finalToErase));\n            this.addCommands.push(...newAddCommands);\n        }\n        this.drawPreviewAt(currentPoint);\n        this.lastPoint = currentPoint;\n    }\n    onPointerDown(event) {\n        if (event.allPointers.length === 1 || event.current.device === PointerDevice.Eraser) {\n            this.lastPoint = event.current.canvasPos;\n            this.toRemove = [];\n            this.toAdd.clear();\n            this.isFirstEraseEvt = true;\n            this.drawPreviewAt(event.current.canvasPos);\n            return true;\n        }\n        return false;\n    }\n    onPointerMove(event) {\n        const currentPoint = event.current.canvasPos;\n        this.eraseTo(currentPoint);\n    }\n    onPointerUp(event) {\n        this.eraseTo(event.current.canvasPos);\n        const commands = [];\n        if (this.addCommands.length > 0) {\n            this.addCommands.forEach((cmd) => cmd.unapply(this.editor));\n            // Remove items from toAdd that are also present in toRemove -- adding, then\n            // removing these does nothing, and can break undo/redo.\n            for (const item of this.toAdd) {\n                if (this.toRemove.includes(item)) {\n                    this.toAdd.delete(item);\n                    this.toRemove = this.toRemove.filter((other) => other !== item);\n                }\n            }\n            for (const item of this.toRemove) {\n                if (this.toAdd.has(item)) {\n                    this.toAdd.delete(item);\n                    this.toRemove = this.toRemove.filter((other) => other !== item);\n                }\n            }\n            commands.push(...[...this.toAdd].map((a) => EditorImage.addElement(a)));\n            this.addCommands = [];\n        }\n        if (this.eraseCommands.length > 0) {\n            // Undo commands for each individual component and unite into a single command.\n            this.eraseCommands.forEach((cmd) => cmd.unapply(this.editor));\n            this.eraseCommands = [];\n            const command = new Erase(this.toRemove);\n            commands.push(command);\n        }\n        if (commands.length === 1) {\n            this.editor.dispatch(commands[0]); // dispatch: Makes undo-able.\n        }\n        else {\n            this.editor.dispatch(uniteCommands(commands));\n        }\n        this.clearPreview();\n    }\n    onGestureCancel(_event) {\n        this.addCommands.forEach((cmd) => cmd.unapply(this.editor));\n        this.eraseCommands.forEach((cmd) => cmd.unapply(this.editor));\n        this.eraseCommands = [];\n        this.addCommands = [];\n        this.clearPreview();\n    }\n    onKeyPress(event) {\n        const shortcuts = this.editor.shortcuts;\n        let newThickness;\n        if (shortcuts.matchesShortcut(decreaseSizeKeyboardShortcutId, event)) {\n            newThickness = (this.getThickness() * 2) / 3;\n        }\n        else if (shortcuts.matchesShortcut(increaseSizeKeyboardShortcutId, event)) {\n            newThickness = (this.getThickness() * 3) / 2;\n        }\n        if (newThickness !== undefined) {\n            newThickness = Math.min(Math.max(1, newThickness), 200);\n            this.setThickness(newThickness);\n            return true;\n        }\n        return false;\n    }\n    /** Returns the side-length of the tip of this eraser. */\n    getThickness() {\n        return this.thickness;\n    }\n    /** Sets the side-length of this' tip. */\n    setThickness(thickness) {\n        this.thicknessValue.set(thickness);\n    }\n    /**\n     * Returns a {@link MutableReactiveValue} that can be used to watch\n     * this tool's thickness.\n     */\n    getThicknessValue() {\n        return this.thicknessValue;\n    }\n    /** @returns An object that allows switching between a full stroke and a partial stroke eraser. */\n    getModeValue() {\n        return this.modeValue;\n    }\n}\n","// Displays a find dialog that allows the user to search for and focus text.\n//\n// @packageDocumentation\nimport  TextComponent  from '../components/TextComponent.mjs';\nimport  ImageComponent  from '../components/ImageComponent.mjs';\nimport  BaseTool  from './BaseTool.mjs';\nimport  { toggleFindVisibleShortcutId }  from './keybindings.mjs';\nconst cssPrefix = 'find-tool';\nexport default class FindTool extends BaseTool {\n    constructor(editor) {\n        super(editor.notifier, editor.localization.findLabel);\n        this.editor = editor;\n        this.currentMatchIdx = 0;\n        this.overlay = document.createElement('div');\n        this.fillOverlay();\n        editor.createHTMLOverlay(this.overlay);\n        this.overlay.style.display = 'none';\n        this.overlay.classList.add(`${cssPrefix}-overlay`);\n    }\n    canReceiveInputInReadOnlyEditor() {\n        return true;\n    }\n    getMatches(searchFor) {\n        const lowerSearchFor = searchFor.toLocaleLowerCase();\n        const matchingComponents = this.editor.image.getAllElements().filter((component) => {\n            let text = '';\n            if (component instanceof TextComponent) {\n                text = component.getText();\n            }\n            else if (component instanceof ImageComponent) {\n                text = component.getAltText() ?? '';\n            }\n            else {\n                return false;\n            }\n            const hasLowercaseMatch = text.toLocaleLowerCase().indexOf(lowerSearchFor) !== -1;\n            const hasSameCaseMatch = text.indexOf(searchFor) !== -1;\n            return hasLowercaseMatch || hasSameCaseMatch;\n        });\n        return matchingComponents.map((match) => match.getBBox());\n    }\n    focusCurrentMatch() {\n        const matches = this.getMatches(this.searchInput.value);\n        let matchIdx = this.currentMatchIdx % matches.length;\n        if (matchIdx < 0) {\n            matchIdx = matches.length + matchIdx;\n        }\n        if (matchIdx < matches.length) {\n            const undoable = false;\n            void this.editor.dispatch(this.editor.viewport.zoomTo(matches[matchIdx], true, true), undoable);\n            this.editor.announceForAccessibility(this.editor.localization.focusedFoundText(matchIdx + 1, matches.length));\n        }\n    }\n    toNextMatch() {\n        this.currentMatchIdx++;\n        this.focusCurrentMatch();\n    }\n    toPrevMatch() {\n        this.currentMatchIdx--;\n        this.focusCurrentMatch();\n    }\n    fillOverlay() {\n        const label = document.createElement('label');\n        this.searchInput = document.createElement('input');\n        const nextBtn = document.createElement('button');\n        const closeBtn = document.createElement('button');\n        // Math.random() ensures that the ID is unique (to allow us to refer to it\n        // with an htmlFor).\n        this.searchInput.setAttribute('id', `${cssPrefix}-searchInput-${Math.random()}`);\n        label.htmlFor = this.searchInput.getAttribute('id');\n        label.innerText = this.editor.localization.findLabel;\n        nextBtn.innerText = this.editor.localization.toNextMatch;\n        closeBtn.innerText = this.editor.localization.closeDialog;\n        this.searchInput.onkeydown = (ev) => {\n            if (ev.key === 'Enter') {\n                if (ev.shiftKey) {\n                    this.toPrevMatch();\n                }\n                else {\n                    this.toNextMatch();\n                }\n            }\n            else if (ev.key === 'Escape') {\n                this.setVisible(false);\n            }\n            else if (this.editor.shortcuts.matchesShortcut(toggleFindVisibleShortcutId, ev)) {\n                ev.preventDefault();\n                this.toggleVisible();\n            }\n        };\n        nextBtn.onclick = () => {\n            this.toNextMatch();\n        };\n        closeBtn.onclick = () => {\n            this.setVisible(false);\n        };\n        this.overlay.replaceChildren(label, this.searchInput, nextBtn, closeBtn);\n    }\n    isVisible() {\n        return this.overlay.style.display !== 'none';\n    }\n    setVisible(visible) {\n        if (visible !== this.isVisible()) {\n            this.overlay.style.display = visible ? 'block' : 'none';\n            if (visible) {\n                this.searchInput.focus();\n                this.editor.announceForAccessibility(this.editor.localization.findDialogShown);\n            }\n            else {\n                this.editor.focus();\n                this.editor.announceForAccessibility(this.editor.localization.findDialogHidden);\n            }\n        }\n    }\n    toggleVisible() {\n        this.setVisible(!this.isVisible());\n    }\n    onKeyPress(event) {\n        if (this.editor.shortcuts.matchesShortcut(toggleFindVisibleShortcutId, event)) {\n            this.toggleVisible();\n            return true;\n        }\n        return false;\n    }\n    setEnabled(enabled) {\n        super.setEnabled(enabled);\n        if (this.isEnabled()) {\n            this.setVisible(false);\n        }\n    }\n}\n","import  { InputEvtType, isPointerEvt }  from '../../inputEvents.mjs';\nimport  InputMapper  from './InputMapper.mjs';\nimport  StationaryPenDetector, { defaultStationaryDetectionConfig, }  from '../util/StationaryPenDetector.mjs';\nimport  { PointerDevice }  from '../../Pointer.mjs';\nexport default class ContextMenuRecognizer extends InputMapper {\n    constructor() {\n        super();\n        this.canShowContextMenu = false;\n        this.stationaryDetector = null;\n        this.clickTolerance = 12;\n    }\n    /**\n     * In general, only certain events (i.e. touchscreens) are expected to be able to\n     * create long-press menus. This method checks whether `event` was generated by\n     * one such device.\n     */\n    canMakeLongPressMenuEvent(event) {\n        const allowedDevices = [PointerDevice.Touch];\n        return event.allPointers.length === 1 && allowedDevices.includes(event.current.device);\n    }\n    onEvent(event) {\n        const sendContextMenuEvent = () => {\n            if (!isPointerEvt(event))\n                return false;\n            if (this.canShowContextMenu) {\n                const eventHandled = this.emit({\n                    kind: InputEvtType.ContextMenu,\n                    screenPos: event.current.screenPos,\n                    canvasPos: event.current.canvasPos,\n                });\n                if (eventHandled) {\n                    this.emit({\n                        kind: InputEvtType.GestureCancelEvt,\n                    });\n                    return true;\n                }\n            }\n            return false;\n        };\n        if (event.kind === InputEvtType.PointerDownEvt) {\n            if (event.allPointers.length === 1) {\n                this.canShowContextMenu = true;\n                this.contextMenuTriggerPointer = event.current;\n                this.contextMenuStartPoint = event.current.screenPos;\n                if (this.canMakeLongPressMenuEvent(event)) {\n                    this.stationaryDetector = new StationaryPenDetector(event.current, defaultStationaryDetectionConfig, sendContextMenuEvent);\n                }\n            }\n            else {\n                this.canShowContextMenu = false;\n            }\n        }\n        else if (event.kind === InputEvtType.PointerMoveEvt) {\n            if (this.canShowContextMenu) {\n                this.stationaryDetector?.onPointerMove(event.current);\n                // Only clicks/stationary long presses can create context menu events.\n                const deltaPosition = event.current.screenPos.minus(this.contextMenuStartPoint);\n                const threshold = this.clickTolerance;\n                if (deltaPosition.length() > threshold) {\n                    this.canShowContextMenu = false;\n                }\n            }\n        }\n        else if (event.kind === InputEvtType.PointerUpEvt) {\n            this.stationaryDetector?.destroy();\n            if (this.contextMenuTriggerPointer?.id === event.current.id &&\n                this.contextMenuTriggerPointer.device === PointerDevice.RightButtonMouse &&\n                sendContextMenuEvent()) {\n                return true;\n            }\n        }\n        return this.emit(event);\n    }\n}\n","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _InputMapper_listener;\n/**\n * Accepts input events and emits input events.\n */\nclass InputMapper {\n    constructor() {\n        _InputMapper_listener.set(this, null);\n    }\n    // @internal\n    setEmitListener(listener) {\n        if (listener && typeof listener === 'object') {\n            __classPrivateFieldSet(this, _InputMapper_listener, (event) => {\n                return listener.onEvent(event) ?? false;\n            }, \"f\");\n        }\n        else {\n            __classPrivateFieldSet(this, _InputMapper_listener, listener, \"f\");\n        }\n    }\n    emit(event) {\n        return __classPrivateFieldGet(this, _InputMapper_listener, \"f\")?.call(this, event) ?? false;\n    }\n}\n_InputMapper_listener = new WeakMap();\nexport default InputMapper;\n","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _InputPipeline_head, _InputPipeline_tail;\nimport  InputMapper  from './InputMapper.mjs';\n/**\n * The composition of multiple `InputMapper`s.\n */\nclass InputPipeline extends InputMapper {\n    constructor() {\n        super(...arguments);\n        _InputPipeline_head.set(this, null);\n        _InputPipeline_tail.set(this, null);\n    }\n    onEvent(event) {\n        if (__classPrivateFieldGet(this, _InputPipeline_head, \"f\") === null) {\n            return this.emit(event);\n        }\n        else {\n            return __classPrivateFieldGet(this, _InputPipeline_head, \"f\").onEvent(event);\n        }\n    }\n    /**\n     * Adds a new `InputMapper` to the *tail* of this pipeline.\n     * Note that an instance of an `InputMapper` can only be used in a single\n     * pipeline.\n     */\n    addToTail(mapper) {\n        if (!__classPrivateFieldGet(this, _InputPipeline_tail, \"f\")) {\n            __classPrivateFieldSet(this, _InputPipeline_head, mapper, \"f\");\n            __classPrivateFieldSet(this, _InputPipeline_tail, __classPrivateFieldGet(this, _InputPipeline_head, \"f\"), \"f\");\n        }\n        else {\n            __classPrivateFieldGet(this, _InputPipeline_tail, \"f\").setEmitListener(mapper);\n            __classPrivateFieldSet(this, _InputPipeline_tail, mapper, \"f\");\n        }\n        __classPrivateFieldGet(this, _InputPipeline_tail, \"f\").setEmitListener((event) => this.emit(event));\n    }\n}\n_InputPipeline_head = new WeakMap(), _InputPipeline_tail = new WeakMap();\nexport default InputPipeline;\n","import  { InputEvtType, isPointerEvt, }  from '../../inputEvents.mjs';\nimport  InputMapper  from './InputMapper.mjs';\nimport { Vec2 } from '@js-draw/math';\nimport  untilNextAnimationFrame  from '../../util/untilNextAnimationFrame.mjs';\nvar StabilizerType;\n(function (StabilizerType) {\n    StabilizerType[StabilizerType[\"IntertialStabilizer\"] = 0] = \"IntertialStabilizer\";\n})(StabilizerType || (StabilizerType = {}));\nconst defaultOptions = {\n    kind: StabilizerType.IntertialStabilizer,\n    mass: 0.4, // kg\n    springConstant: 100.0, // N/m\n    frictionCoefficient: 0.28,\n    maxPointDist: 10, // screen units\n    inertiaFraction: 0.75,\n    minSimilarityToFinalize: 0.0,\n    velocityDecayFactor: 0.1,\n};\n// Stabilizes input for a single cursor\nclass StylusInputStabilizer {\n    constructor(\n    // The initial starting point of the pointer.\n    start, \n    // Emits a pointer motion event, returns true if the event was handled.\n    updatePointer, options) {\n        this.updatePointer = updatePointer;\n        this.options = options;\n        this.runLoop = true;\n        this.lastUpdateTime = 0;\n        this.velocity = Vec2.zero;\n        this.strokePoint = start;\n        this.targetPoint = start;\n        this.targetInterval = 10; // ms\n        void this.loop();\n    }\n    async loop() {\n        this.lastUpdateTime = performance.now();\n        while (this.runLoop) {\n            this.update(false);\n            await untilNextAnimationFrame();\n        }\n    }\n    setTarget(point) {\n        this.targetPoint = point;\n    }\n    getNextVelocity(deltaTimeMs) {\n        const toTarget = this.targetPoint.minus(this.strokePoint);\n        const springForce = toTarget.times(this.options.springConstant);\n        const gravityAccel = 10;\n        const normalForceMagnitude = this.options.mass * gravityAccel;\n        const frictionForce = this.velocity\n            .normalizedOrZero()\n            .times(-this.options.frictionCoefficient * normalForceMagnitude);\n        const acceleration = springForce.plus(frictionForce).times(1 / this.options.mass);\n        const decayFactor = this.options.velocityDecayFactor;\n        const springVelocity = this.velocity\n            .times(1 - decayFactor)\n            .plus(acceleration.times(deltaTimeMs / 1000));\n        // An alternate velocity that goes directly towards the target.\n        const toTargetVelocity = toTarget.normalizedOrZero().times(springVelocity.length());\n        return toTargetVelocity.lerp(springVelocity, this.options.inertiaFraction);\n    }\n    update(force) {\n        const nowTime = performance.now();\n        const deltaTime = nowTime - this.lastUpdateTime;\n        const reachedTarget = this.strokePoint.eq(this.targetPoint);\n        if (deltaTime > this.targetInterval || force) {\n            if (!reachedTarget) {\n                let velocity;\n                let deltaX;\n                let parts = 1;\n                do {\n                    velocity = this.getNextVelocity(deltaTime / parts);\n                    deltaX = velocity.times(deltaTime / 1000);\n                    parts++;\n                } while (deltaX.magnitude() > this.options.maxPointDist && parts < 10);\n                for (let i = 0; i < parts; i++) {\n                    this.velocity = this.getNextVelocity(deltaTime / parts);\n                    deltaX = this.velocity.times(deltaTime / 1000);\n                    this.strokePoint = this.strokePoint.plus(deltaX);\n                    // Allows the last updatePointer to be returned.\n                    if (i < parts - 1) {\n                        this.updatePointer(this.strokePoint, nowTime);\n                    }\n                }\n            }\n            // Even if we have reached the target, ensure that lastUpdateTime is updated\n            // (prevent large deltaTime).\n            this.lastUpdateTime = nowTime;\n            if (force || !reachedTarget) {\n                return this.updatePointer(this.strokePoint, nowTime);\n            }\n        }\n        return false;\n    }\n    /** Finalizes the current stroke. */\n    finish() {\n        this.runLoop = false;\n        const toTarget = this.targetPoint.minus(this.strokePoint);\n        if (this.velocity.dot(toTarget) > this.options.minSimilarityToFinalize) {\n            // Connect the stroke to its end point\n            this.updatePointer(this.targetPoint, performance.now());\n        }\n    }\n    cancel() {\n        this.runLoop = false;\n    }\n}\nexport default class InputStabilizer extends InputMapper {\n    constructor(viewport, options = defaultOptions) {\n        super();\n        this.viewport = viewport;\n        this.options = options;\n        this.stabilizer = null;\n        this.lastPointerEvent = null;\n    }\n    mapPointerEvent(event) {\n        // Don't store the last pointer event for use with pressure/button data --\n        // this information can be very different for a pointerup event.\n        if (isPointerEvt(event) && event.kind !== InputEvtType.PointerUpEvt) {\n            this.lastPointerEvent = event;\n        }\n        // Only apply smoothing if there is a single pointer.\n        if (event.kind === InputEvtType.GestureCancelEvt ||\n            event.allPointers.length > 1 ||\n            this.stabilizer === null) {\n            return this.emit(event);\n        }\n        this.stabilizer.setTarget(event.current.screenPos);\n        if (event.kind === InputEvtType.PointerMoveEvt) {\n            return this.stabilizer.update(true);\n        }\n        else if (event.kind === InputEvtType.PointerUpEvt) {\n            this.stabilizer.finish();\n            return this.emit(event);\n        }\n        else {\n            return this.emit(event);\n        }\n    }\n    // Assumes that there is exactly one pointer that is currently down.\n    emitPointerMove(screenPoint, timeStamp) {\n        if (!this.lastPointerEvent) {\n            return false;\n        }\n        const pointer = this.lastPointerEvent.current\n            .withScreenPosition(screenPoint, this.viewport)\n            .withTimestamp(timeStamp);\n        const event = {\n            kind: InputEvtType.PointerMoveEvt,\n            current: pointer,\n            allPointers: [pointer],\n        };\n        const handled = this.emit(event);\n        return handled;\n    }\n    onEvent(event) {\n        if (isPointerEvt(event) || event.kind === InputEvtType.GestureCancelEvt) {\n            if (event.kind === InputEvtType.PointerDownEvt) {\n                if (this.stabilizer === null) {\n                    this.stabilizer = new StylusInputStabilizer(event.current.screenPos, (screenPoint, timeStamp) => this.emitPointerMove(screenPoint, timeStamp), this.options);\n                }\n                else if (event.allPointers.length > 1) {\n                    // Do not attempt to stabilize multiple pointers.\n                    this.stabilizer.cancel();\n                    this.stabilizer = null;\n                }\n            }\n            const handled = this.mapPointerEvent(event);\n            if (event.kind === InputEvtType.PointerUpEvt ||\n                event.kind === InputEvtType.GestureCancelEvt) {\n                this.stabilizer?.cancel();\n                this.stabilizer = null;\n            }\n            return handled;\n        }\n        return this.emit(event);\n    }\n    static fromEditor(editor) {\n        return new InputStabilizer(editor.viewport);\n    }\n}\n","import  { InputEvtType }  from '../../inputEvents.mjs';\nimport  InputMapper  from './InputMapper.mjs';\nimport  { lineLockKeyboardShortcutId, snapToGridKeyboardShortcutId }  from '../keybindings.mjs';\n/**\n * Provides keyboard shortcuts that provide some amount of control over\n * drawing (e.g. snap to grid, plane lock).\n */\nexport default class StrokeKeyboardControl extends InputMapper {\n    constructor(shortcuts, viewport) {\n        super();\n        this.shortcuts = shortcuts;\n        this.viewport = viewport;\n        this.snapToGridEnabled = false;\n        this.angleLockEnabled = false;\n        // The point at which the last pointerDown event happened (or null if\n        // no such event has occurred).\n        this.startPointCanvas = null;\n    }\n    // Snap the given pointer to the nearer of the x/y axes.\n    xyAxesSnap(pointer) {\n        if (!this.startPointCanvas) {\n            return pointer;\n        }\n        // Convert this.startPointCanvas here because the viewport might change\n        // while drawing a stroke.\n        const screenPos = this.viewport.canvasToScreen(this.startPointCanvas);\n        return pointer.lockedToXYAxesScreen(screenPos, this.viewport);\n    }\n    mapPointerEvent(event) {\n        const mapPointer = (pointer) => {\n            // Only map if there's exactly one pointer.\n            if (event.allPointers.length > 1) {\n                return pointer;\n            }\n            if (this.snapToGridEnabled) {\n                return pointer.snappedToGrid(this.viewport);\n            }\n            if (this.angleLockEnabled && this.startPointCanvas) {\n                return this.xyAxesSnap(pointer);\n            }\n            return pointer;\n        };\n        return {\n            kind: event.kind,\n            current: mapPointer(event.current),\n            allPointers: event.allPointers.map(mapPointer),\n        };\n    }\n    onEvent(event) {\n        const shortcuts = this.shortcuts;\n        if (event.kind === InputEvtType.PointerDownEvt ||\n            event.kind === InputEvtType.PointerMoveEvt ||\n            event.kind === InputEvtType.PointerUpEvt) {\n            if (event.kind === InputEvtType.PointerDownEvt) {\n                this.startPointCanvas = event.current.canvasPos;\n            }\n            event = this.mapPointerEvent(event);\n        }\n        let handled = this.emit(event);\n        if (\n        // Always check keyUpEvents (in case we handled the corresponding keyDown event)\n        event.kind === InputEvtType.KeyUpEvent ||\n            // Only handle key press events if another tool isn't handling it. We don't want\n            // snap to grid/angle lock to conflict with selection/another tool's shortcuts.\n            (!handled && event.kind === InputEvtType.KeyPressEvent)) {\n            const isKeyPress = event.kind === InputEvtType.KeyPressEvent;\n            if (shortcuts.matchesShortcut(snapToGridKeyboardShortcutId, event)) {\n                this.snapToGridEnabled = isKeyPress;\n                handled = true;\n            }\n            if (shortcuts.matchesShortcut(lineLockKeyboardShortcutId, event)) {\n                this.angleLockEnabled = isKeyPress;\n                handled = true;\n            }\n        }\n        return handled;\n    }\n    static fromEditor(editor) {\n        return new StrokeKeyboardControl(editor.shortcuts, editor.viewport);\n    }\n}\n","import { Mat33, Vec3, Vec2 } from '@js-draw/math';\nimport  { PointerDevice }  from '../Pointer.mjs';\nimport  { EditorEventType }  from '../types.mjs';\nimport  untilNextAnimationFrame  from '../util/untilNextAnimationFrame.mjs';\nimport  { Viewport }  from '../Viewport.mjs';\nimport  BaseTool  from './BaseTool.mjs';\nimport  { moveDownKeyboardShortcutId, moveLeftKeyboardShortcutId, moveRightKeyboardShortcutId, moveUpKeyboardShortcutId, rotateClockwiseKeyboardShortcutId, rotateCounterClockwiseKeyboardShortcutId, zoomInKeyboardShortcutId, zoomOutKeyboardShortcutId, }  from './keybindings.mjs';\nexport var PanZoomMode;\n(function (PanZoomMode) {\n    /** Touch gestures with a single pointer. Ignores non-touch gestures. */\n    PanZoomMode[PanZoomMode[\"OneFingerTouchGestures\"] = 1] = \"OneFingerTouchGestures\";\n    /** Touch gestures with exactly two pointers. Ignores non-touch gestures. */\n    PanZoomMode[PanZoomMode[\"TwoFingerTouchGestures\"] = 2] = \"TwoFingerTouchGestures\";\n    PanZoomMode[PanZoomMode[\"RightClickDrags\"] = 4] = \"RightClickDrags\";\n    /** Single-pointer gestures of *any* type (including touch). */\n    PanZoomMode[PanZoomMode[\"SinglePointerGestures\"] = 8] = \"SinglePointerGestures\";\n    /** Keyboard navigation (e.g. LeftArrow to move left). */\n    PanZoomMode[PanZoomMode[\"Keyboard\"] = 16] = \"Keyboard\";\n    /** If provided, prevents **this** tool from rotating the viewport (other tools may still do so). */\n    PanZoomMode[PanZoomMode[\"RotationLocked\"] = 32] = \"RotationLocked\";\n})(PanZoomMode || (PanZoomMode = {}));\nclass InertialScroller {\n    constructor(initialVelocity, scrollBy, onComplete) {\n        this.initialVelocity = initialVelocity;\n        this.scrollBy = scrollBy;\n        this.onComplete = onComplete;\n        this.running = false;\n        this.start();\n    }\n    async start() {\n        if (this.running) {\n            return;\n        }\n        this.currentVelocity = this.initialVelocity;\n        let lastTime = performance.now();\n        this.running = true;\n        const maxSpeed = 5000; // units/s\n        const minSpeed = 200; // units/s\n        if (this.currentVelocity.magnitude() > maxSpeed) {\n            this.currentVelocity = this.currentVelocity.normalized().times(maxSpeed);\n        }\n        while (this.running && this.currentVelocity.magnitude() > minSpeed) {\n            const nowTime = performance.now();\n            const dt = (nowTime - lastTime) / 1000;\n            this.currentVelocity = this.currentVelocity.times(Math.pow(1 / 8, dt));\n            this.scrollBy(this.currentVelocity.times(dt));\n            await untilNextAnimationFrame();\n            lastTime = nowTime;\n        }\n        if (this.running) {\n            this.stop();\n        }\n    }\n    getCurrentVelocity() {\n        if (!this.running) {\n            return null;\n        }\n        return this.currentVelocity;\n    }\n    stop() {\n        if (this.running) {\n            this.running = false;\n            this.onComplete();\n        }\n    }\n}\n/**\n * This tool moves the viewport in response to touchpad, touchscreen, mouse, and keyboard events.\n *\n * Which events are handled, and which are skipped, are determined by the tool's `mode`. For example,\n * a `PanZoom` tool with `mode = PanZoomMode.TwoFingerTouchGestures|PanZoomMode.RightClickDrags` would\n * respond to right-click drag events and two-finger touch gestures.\n *\n * @see {@link setModeEnabled}\n */\nexport default class PanZoom extends BaseTool {\n    constructor(editor, mode, description) {\n        super(editor.notifier, description);\n        this.editor = editor;\n        this.mode = mode;\n        this.transform = null;\n        // Constants\n        // initialRotationSnapAngle is larger than afterRotationStartSnapAngle to\n        // make it more difficult to start rotating (and easier to continue rotating).\n        this.initialRotationSnapAngle = 0.22; // radians\n        this.afterRotationStartSnapAngle = 0.07; // radians\n        this.pinchZoomStartThreshold = 1.08; // scale factor\n        // Last timestamp at which a pointerdown event was received\n        this.lastPointerDownTimestamp = 0;\n        this.initialTouchAngle = 0;\n        this.initialViewportRotation = 0;\n        this.initialViewportScale = 0;\n        // Set to `true` only when scaling has started (if two fingers are down and have moved\n        // far enough).\n        this.isScaling = false;\n        this.isRotating = false;\n        this.inertialScroller = null;\n        this.velocity = null;\n    }\n    // The pan/zoom tool can be used in a read-only editor.\n    canReceiveInputInReadOnlyEditor() {\n        return true;\n    }\n    // Returns information about the pointers in a gesture\n    computePinchData(p1, p2) {\n        // Swap the pointers to ensure consistent ordering.\n        if (p1.id < p2.id) {\n            const tmp = p1;\n            p1 = p2;\n            p2 = tmp;\n        }\n        const screenBetween = p2.screenPos.minus(p1.screenPos);\n        const angle = screenBetween.angle();\n        const dist = screenBetween.magnitude();\n        const canvasCenter = p2.canvasPos.plus(p1.canvasPos).times(0.5);\n        const screenCenter = p2.screenPos.plus(p1.screenPos).times(0.5);\n        return { canvasCenter, screenCenter, angle, dist };\n    }\n    allPointersAreOfType(pointers, kind) {\n        return pointers.every((pointer) => pointer.device === kind);\n    }\n    onPointerDown({ allPointers: pointers, current: currentPointer, }) {\n        let handlingGesture = false;\n        const inertialScrollerVelocity = this.inertialScroller?.getCurrentVelocity() ?? Vec2.zero;\n        this.inertialScroller?.stop();\n        this.velocity = inertialScrollerVelocity;\n        this.lastPointerDownTimestamp = currentPointer.timeStamp;\n        const allAreTouch = this.allPointersAreOfType(pointers, PointerDevice.Touch);\n        const isRightClick = this.allPointersAreOfType(pointers, PointerDevice.RightButtonMouse);\n        if (allAreTouch && pointers.length === 2 && this.mode & PanZoomMode.TwoFingerTouchGestures) {\n            const { screenCenter, angle, dist } = this.computePinchData(pointers[0], pointers[1]);\n            this.lastTouchDist = dist;\n            this.startTouchDist = dist;\n            this.lastScreenCenter = screenCenter;\n            this.initialTouchAngle = angle;\n            this.initialViewportRotation = this.editor.viewport.getRotationAngle();\n            this.initialViewportScale = this.editor.viewport.getScaleFactor();\n            this.isScaling = false;\n            // We're initially rotated if `initialViewportRotation` isn't near a multiple of pi/2.\n            // In other words, if sin(2 initialViewportRotation) is near zero.\n            this.isRotating = Math.abs(Math.sin(this.initialViewportRotation * 2)) > 1e-3;\n            handlingGesture = true;\n        }\n        else if (pointers.length === 1 &&\n            ((this.mode & PanZoomMode.OneFingerTouchGestures && allAreTouch) ||\n                (isRightClick && this.mode & PanZoomMode.RightClickDrags) ||\n                this.mode & PanZoomMode.SinglePointerGestures)) {\n            this.lastScreenCenter = pointers[0].screenPos;\n            this.isScaling = false;\n            handlingGesture = true;\n        }\n        if (handlingGesture) {\n            this.lastTimestamp = performance.now();\n            this.transform ??= Viewport.transformBy(Mat33.identity);\n            this.editor.display.setDraftMode(true);\n        }\n        return handlingGesture;\n    }\n    updateVelocity(currentCenter) {\n        const deltaPos = currentCenter.minus(this.lastScreenCenter);\n        let deltaTime = (performance.now() - this.lastTimestamp) / 1000;\n        // Ignore duplicate events, unless there has been enough time between them.\n        if (deltaPos.magnitude() === 0 && deltaTime < 0.1) {\n            return;\n        }\n        // We divide by deltaTime. Don't divide by zero.\n        if (deltaTime === 0) {\n            return;\n        }\n        // Don't divide by almost zero, either\n        deltaTime = Math.max(deltaTime, 0.01);\n        const currentVelocity = deltaPos.times(1 / deltaTime);\n        let smoothedVelocity = currentVelocity;\n        if (this.velocity) {\n            smoothedVelocity = this.velocity.lerp(currentVelocity, 0.5);\n        }\n        this.velocity = smoothedVelocity;\n    }\n    // Returns the change in position of the center of the given group of pointers.\n    // Assumes this.lastScreenCenter has been set appropriately.\n    getCenterDelta(screenCenter) {\n        // Use transformVec3 to avoid translating the delta\n        const delta = this.editor.viewport.screenToCanvasTransform.transformVec3(screenCenter.minus(this.lastScreenCenter));\n        return delta;\n    }\n    //  Snaps `angle` to common desired rotations. For example, if `touchAngle` corresponds\n    // to a viewport rotation of 90.1 degrees, this function returns a rotation delta that,\n    // when applied to the viewport, rotates the viewport to 90.0 degrees.\n    //\n    // Returns a snapped rotation delta that, when applied to the viewport, rotates the viewport,\n    // from its position on the last touchDown event, by `touchAngle - initialTouchAngle`.\n    toSnappedRotationDelta(touchAngle) {\n        const deltaAngle = touchAngle - this.initialTouchAngle;\n        let fullRotation = deltaAngle + this.initialViewportRotation;\n        const snapToMultipleOf = Math.PI / 2;\n        const roundedFullRotation = Math.round(fullRotation / snapToMultipleOf) * snapToMultipleOf;\n        // The maximum angle for which we snap the given angle to a multiple of\n        // `snapToMultipleOf`.\n        // Use a smaller snap angle if already rotated (to avoid pinch zoom gestures from\n        // starting rotation).\n        const maxSnapAngle = this.isRotating\n            ? this.afterRotationStartSnapAngle\n            : this.initialRotationSnapAngle;\n        // Snap the rotation\n        if (Math.abs(fullRotation - roundedFullRotation) < maxSnapAngle) {\n            fullRotation = roundedFullRotation;\n            // Work around a rotation/matrix multiply bug.\n            // (See commit after 4abe27ff8e7913155828f98dee77b09c57c51d30).\n            // TODO: Fix the underlying issue and remove this.\n            if (fullRotation !== 0) {\n                fullRotation += 0.0001;\n            }\n        }\n        return fullRotation - this.editor.viewport.getRotationAngle();\n    }\n    /**\n     * Given a scale update, `scaleFactor`, returns a new scale factor snapped\n     * to a power of two (if within some tolerance of that scale).\n     */\n    toSnappedScaleFactor(touchDist) {\n        // scaleFactor is applied to the current transformation of the viewport.\n        const newScale = (this.initialViewportScale * touchDist) / this.startTouchDist;\n        const currentScale = this.editor.viewport.getScaleFactor();\n        const logNewScale = Math.log(newScale) / Math.log(10);\n        const roundedLogNewScale = Math.round(logNewScale);\n        const logTolerance = 0.04;\n        if (Math.abs(roundedLogNewScale - logNewScale) < logTolerance) {\n            return Math.pow(10, roundedLogNewScale) / currentScale;\n        }\n        return touchDist / this.lastTouchDist;\n    }\n    handleTwoFingerMove(allPointers) {\n        const { screenCenter, canvasCenter, angle, dist } = this.computePinchData(allPointers[0], allPointers[1]);\n        const delta = this.getCenterDelta(screenCenter);\n        let deltaRotation;\n        if (this.isRotationLocked()) {\n            deltaRotation = 0;\n        }\n        else {\n            deltaRotation = this.toSnappedRotationDelta(angle);\n        }\n        // If any rotation, make a note of this (affects rotation snap\n        // angles).\n        if (Math.abs(deltaRotation) > 1e-8) {\n            this.isRotating = true;\n        }\n        this.updateVelocity(screenCenter);\n        if (!this.isScaling) {\n            const initialScaleFactor = dist / this.startTouchDist;\n            // Only start scaling if scaling done so far exceeds some threshold.\n            const upperBound = this.pinchZoomStartThreshold;\n            const lowerBound = 1 / this.pinchZoomStartThreshold;\n            if (initialScaleFactor > upperBound || initialScaleFactor < lowerBound) {\n                this.isScaling = true;\n            }\n        }\n        let scaleFactor = 1;\n        if (this.isScaling) {\n            scaleFactor = this.toSnappedScaleFactor(dist);\n            // Don't set lastDist until we start scaling --\n            this.lastTouchDist = dist;\n        }\n        const transformUpdate = Mat33.translation(delta)\n            .rightMul(Mat33.scaling2D(scaleFactor, canvasCenter))\n            .rightMul(Mat33.zRotation(deltaRotation, canvasCenter));\n        this.lastScreenCenter = screenCenter;\n        this.transform = Viewport.transformBy(this.transform.transform.rightMul(transformUpdate));\n        return transformUpdate;\n    }\n    handleOneFingerMove(pointer) {\n        const delta = this.getCenterDelta(pointer.screenPos);\n        const transformUpdate = Mat33.translation(delta);\n        this.transform = Viewport.transformBy(this.transform.transform.rightMul(transformUpdate));\n        this.updateVelocity(pointer.screenPos);\n        this.lastScreenCenter = pointer.screenPos;\n        return transformUpdate;\n    }\n    onPointerMove({ allPointers }) {\n        this.transform ??= Viewport.transformBy(Mat33.identity);\n        let transformUpdate = Mat33.identity;\n        if (allPointers.length === 2) {\n            transformUpdate = this.handleTwoFingerMove(allPointers);\n        }\n        else if (allPointers.length === 1) {\n            transformUpdate = this.handleOneFingerMove(allPointers[0]);\n        }\n        Viewport.transformBy(transformUpdate).apply(this.editor);\n        this.lastTimestamp = performance.now();\n    }\n    onPointerUp(event) {\n        const onComplete = () => {\n            if (this.transform) {\n                this.transform.unapply(this.editor);\n                this.editor.dispatch(this.transform, false);\n            }\n            this.editor.display.setDraftMode(false);\n            this.transform = null;\n            this.velocity = Vec2.zero;\n        };\n        const minInertialScrollDt = 30;\n        const shouldInertialScroll = event.current.device === PointerDevice.Touch &&\n            event.allPointers.length === 1 &&\n            this.velocity !== null &&\n            event.current.timeStamp - this.lastPointerDownTimestamp > minInertialScrollDt;\n        if (shouldInertialScroll && this.velocity !== null) {\n            const oldVelocity = this.velocity;\n            // If the user drags the screen, then stops, then lifts the pointer,\n            // we want the final velocity to reflect the stop at the end (so the velocity\n            // should be near zero). Handle this:\n            this.updateVelocity(event.current.screenPos);\n            // Work around an input issue. Some devices that disable the touchscreen when a stylus\n            // comes near the screen fire a touch-end event at the position of the stylus when a\n            // touch gesture is canceled. Because the stylus is often far away from the last touch,\n            // this causes a great displacement between the second-to-last (from the touchscreen) and\n            // last (from the pen that is now near the screen) events. Only allow velocity to decrease\n            // to work around this:\n            if (oldVelocity.magnitude() < this.velocity.magnitude()) {\n                this.velocity = oldVelocity;\n            }\n            // Cancel any ongoing inertial scrolling.\n            this.inertialScroller?.stop();\n            this.inertialScroller = new InertialScroller(this.velocity, (scrollDelta) => {\n                if (!this.transform) {\n                    return;\n                }\n                const canvasDelta = this.editor.viewport.screenToCanvasTransform.transformVec3(scrollDelta);\n                // Scroll by scrollDelta\n                this.transform.unapply(this.editor);\n                this.transform = Viewport.transformBy(this.transform.transform.rightMul(Mat33.translation(canvasDelta)));\n                this.transform.apply(this.editor);\n            }, onComplete);\n        }\n        else {\n            onComplete();\n        }\n    }\n    onGestureCancel() {\n        this.inertialScroller?.stop();\n        this.velocity = Vec2.zero;\n        this.transform?.unapply(this.editor);\n        this.editor.display.setDraftMode(false);\n        this.transform = null;\n    }\n    // Applies [transformUpdate] to the editor. This stacks on top of the\n    // current transformation, if it exists.\n    updateTransform(transformUpdate, announce = false) {\n        let newTransform = transformUpdate;\n        if (this.transform) {\n            newTransform = this.transform.transform.rightMul(transformUpdate);\n        }\n        this.transform?.unapply(this.editor);\n        this.transform = Viewport.transformBy(newTransform);\n        this.transform.apply(this.editor);\n        if (announce) {\n            this.editor.announceForAccessibility(this.transform.description(this.editor, this.editor.localization));\n        }\n    }\n    /**\n     * Updates the current transform and clears it. Use this method for events that are not part of\n     * a larger gesture (i.e. have no start and end event). For example, this would be used for `onwheel`\n     * events, but not for `onpointer` events.\n     */\n    applyAndFinalizeTransform(transformUpdate) {\n        this.updateTransform(transformUpdate, true);\n        this.transform = null;\n    }\n    onWheel({ delta, screenPos }) {\n        this.inertialScroller?.stop();\n        // Reset the transformation -- wheel events are individual events, so we don't\n        // need to unapply/reapply.\n        this.transform = Viewport.transformBy(Mat33.identity);\n        const canvasPos = this.editor.viewport.screenToCanvas(screenPos);\n        const toCanvas = this.editor.viewport.screenToCanvasTransform;\n        // Transform without including translation\n        const translation = toCanvas.transformVec3(Vec3.of(-delta.x, -delta.y, 0));\n        let pinchAmount = delta.z;\n        // Clamp the magnitude of pinchAmount\n        pinchAmount = Math.atan(pinchAmount / 2) * 2;\n        const pinchZoomScaleFactor = 1.04;\n        const transformUpdate = Mat33.scaling2D(Math.max(0.4, Math.min(Math.pow(pinchZoomScaleFactor, -pinchAmount), 4)), canvasPos).rightMul(Mat33.translation(translation));\n        this.applyAndFinalizeTransform(transformUpdate);\n        return true;\n    }\n    onKeyPress(event) {\n        this.inertialScroller?.stop();\n        if (!(this.mode & PanZoomMode.Keyboard)) {\n            return false;\n        }\n        // No need to keep the same the transform for keyboard events.\n        this.transform = Viewport.transformBy(Mat33.identity);\n        let translation = Vec2.zero;\n        let scale = 1;\n        let rotation = 0;\n        // Keyboard shortcut handling\n        const shortcucts = this.editor.shortcuts;\n        if (shortcucts.matchesShortcut(moveLeftKeyboardShortcutId, event)) {\n            translation = Vec2.of(-1, 0);\n        }\n        else if (shortcucts.matchesShortcut(moveRightKeyboardShortcutId, event)) {\n            translation = Vec2.of(1, 0);\n        }\n        else if (shortcucts.matchesShortcut(moveUpKeyboardShortcutId, event)) {\n            translation = Vec2.of(0, -1);\n        }\n        else if (shortcucts.matchesShortcut(moveDownKeyboardShortcutId, event)) {\n            translation = Vec2.of(0, 1);\n        }\n        else if (shortcucts.matchesShortcut(zoomInKeyboardShortcutId, event)) {\n            scale = 1 / 2;\n        }\n        else if (shortcucts.matchesShortcut(zoomOutKeyboardShortcutId, event)) {\n            scale = 2;\n        }\n        else if (shortcucts.matchesShortcut(rotateClockwiseKeyboardShortcutId, event)) {\n            rotation = 1;\n        }\n        else if (shortcucts.matchesShortcut(rotateCounterClockwiseKeyboardShortcutId, event)) {\n            rotation = -1;\n        }\n        else {\n            return false;\n        }\n        // For each keypress,\n        translation = translation.times(30); // Move at most 30 units\n        rotation *= Math.PI / 8; // Rotate at least a sixteenth of a rotation\n        // Transform the canvas, not the viewport:\n        translation = translation.times(-1);\n        rotation = rotation * -1;\n        scale = 1 / scale;\n        // Work around an issue that seems to be related to rotation matrices losing precision on inversion.\n        // TODO: Figure out why and implement a better solution.\n        if (rotation !== 0) {\n            rotation += 0.0001;\n        }\n        if (this.isRotationLocked()) {\n            rotation = 0;\n        }\n        const toCanvas = this.editor.viewport.screenToCanvasTransform;\n        // Transform without translating (treat toCanvas as a linear instead of\n        // an affine transformation).\n        translation = toCanvas.transformVec3(translation);\n        // Rotate/scale about the center of the canvas\n        const transformCenter = this.editor.viewport.visibleRect.center;\n        const transformUpdate = Mat33.scaling2D(scale, transformCenter)\n            .rightMul(Mat33.zRotation(rotation, transformCenter))\n            .rightMul(Mat33.translation(translation));\n        this.applyAndFinalizeTransform(transformUpdate);\n        return true;\n    }\n    isRotationLocked() {\n        return !!(this.mode & PanZoomMode.RotationLocked);\n    }\n    /**\n     * Changes the types of gestures used by this pan/zoom tool.\n     *\n     * @see {@link PanZoomMode} {@link setMode}\n     *\n     * @example\n     * ```ts,runnable\n     * import { Editor, PanZoomTool, PanZoomMode } from 'js-draw';\n     *\n     * const editor = new Editor(document.body);\n     *\n     * // By default, there are multiple PanZoom tools that handle different events.\n     * // This gets all PanZoomTools.\n     * const panZoomToolList = editor.toolController.getMatchingTools(PanZoomTool);\n     *\n     * // The first PanZoomTool is the highest priority -- by default,\n     * // this tool is responsible for handling multi-finger touch gestures.\n     * //\n     * // Lower-priority PanZoomTools handle one-finger touch gestures and\n     * // key-presses.\n     * const panZoomTool = panZoomToolList[0];\n     *\n     * // Lock rotation for multi-finger touch gestures.\n     * panZoomTool.setModeEnabled(PanZoomMode.RotationLocked, true);\n     * ```\n     */\n    setModeEnabled(mode, enabled) {\n        let newMode = this.mode;\n        if (enabled) {\n            newMode |= mode;\n        }\n        else {\n            newMode &= ~mode;\n        }\n        this.setMode(newMode);\n    }\n    /**\n     * Sets all modes for this tool using a bitmask.\n     *\n     * @see {@link setModeEnabled}\n     *\n     * @example\n     * ```ts\n     * tool.setMode(PanZoomMode.RotationLocked|PanZoomMode.TwoFingerTouchGestures);\n     * ```\n     */\n    setMode(mode) {\n        if (mode !== this.mode) {\n            this.mode = mode;\n            this.editor.notifier.dispatch(EditorEventType.ToolUpdated, {\n                kind: EditorEventType.ToolUpdated,\n                tool: this,\n            });\n        }\n    }\n    /**\n     * Returns a bitmask indicating the currently-enabled modes.\n     * @see {@link setModeEnabled}\n     */\n    getMode() {\n        return this.mode;\n    }\n}\n","import  TextComponent  from '../components/TextComponent.mjs';\nimport  SVGLoader  from '../SVGLoader/SVGLoader.mjs';\nimport { Mat33, Color4 } from '@js-draw/math';\nimport  BaseTool  from './BaseTool.mjs';\nimport  TextTool  from './TextTool.mjs';\nimport  ImageComponent  from '../components/ImageComponent.mjs';\n/**\n * A tool that handles paste events (e.g. as triggered by ctrl+V).\n *\n * @example\n * While `ToolController` has a `PasteHandler` in its default list of tools,\n * if a non-default set is being used, `PasteHandler` can be added as follows:\n * ```ts\n * const toolController = editor.toolController;\n * toolController.addTool(new PasteHandler(editor));\n * ```\n */\nexport default class PasteHandler extends BaseTool {\n    constructor(editor) {\n        super(editor.notifier, editor.localization.pasteHandler);\n        this.editor = editor;\n    }\n    // @internal\n    onPaste(event, onComplete) {\n        const mime = event.mime.toLowerCase();\n        const svgData = (() => {\n            if (mime === 'image/svg+xml') {\n                return event.data;\n            }\n            // In some environments, it isn't possible to write non-text data to the\n            // clipboard. To support these cases, auto-detect text/plain SVG data.\n            if (mime === 'text/plain') {\n                const trimmedData = event.data.trim();\n                if (trimmedData.startsWith('<svg') && trimmedData.endsWith('</svg>')) {\n                    return trimmedData;\n                }\n            }\n            if (mime !== 'text/html') {\n                return false;\n            }\n            // text/html is sometimes handlable SVG data. Use a hueristic\n            // to determine if this is the case:\n            // We use [^] and not . so that newlines are included.\n            const match = event.data.match(/^[^]{0,200}<svg.*/i); // [^]{0,200} <- Allow for metadata near start\n            if (!match) {\n                return false;\n            }\n            // Extract the SVG element from the pasted data\n            let svgEnd = event.data.toLowerCase().lastIndexOf('</svg>');\n            if (svgEnd === -1)\n                svgEnd = event.data.length;\n            return event.data.substring(event.data.search(/<svg/i), svgEnd);\n        })();\n        if (svgData) {\n            void this.doSVGPaste(svgData).then(onComplete);\n            return true;\n        }\n        else if (mime === 'text/plain') {\n            void this.doTextPaste(event.data).then(onComplete);\n            return true;\n        }\n        else if (mime === 'image/png' || mime === 'image/jpeg') {\n            void this.doImagePaste(event.data).then(onComplete);\n            return true;\n        }\n        return false;\n    }\n    async addComponentsFromPaste(components) {\n        await this.editor.addAndCenterComponents(components, true, this.editor.localization.pasted(components.length));\n    }\n    async doSVGPaste(data) {\n        this.editor.showLoadingWarning(0);\n        try {\n            const loader = SVGLoader.fromString(data, true);\n            const components = [];\n            await loader.start((component) => {\n                components.push(component);\n            }, (_countProcessed, _totalToProcess) => null);\n            await this.addComponentsFromPaste(components);\n        }\n        finally {\n            this.editor.hideLoadingWarning();\n        }\n    }\n    async doTextPaste(text) {\n        const textTools = this.editor.toolController.getMatchingTools(TextTool);\n        textTools.sort((a, b) => {\n            if (!a.isEnabled() && b.isEnabled()) {\n                return -1;\n            }\n            if (!b.isEnabled() && a.isEnabled()) {\n                return 1;\n            }\n            return 0;\n        });\n        const defaultTextStyle = {\n            size: 12,\n            fontFamily: 'sans',\n            renderingStyle: { fill: Color4.red },\n        };\n        const pastedTextStyle = textTools[0]?.getTextStyle() ?? defaultTextStyle;\n        // Don't paste text that would be invisible.\n        if (text.trim() === '') {\n            return;\n        }\n        const lines = text.split('\\n');\n        await this.addComponentsFromPaste([\n            TextComponent.fromLines(lines, Mat33.identity, pastedTextStyle),\n        ]);\n    }\n    async doImagePaste(dataURL) {\n        const image = new Image();\n        image.src = dataURL;\n        const component = await ImageComponent.fromImage(image, Mat33.identity);\n        await this.addComponentsFromPaste([component]);\n    }\n}\n","import { Color4 } from '@js-draw/math';\nimport  EditorImage  from '../image/EditorImage.mjs';\nimport  { PointerDevice }  from '../Pointer.mjs';\nimport  { makeFreehandLineBuilder }  from '../components/builders/FreehandLineBuilder.mjs';\nimport  { EditorEventType }  from '../types.mjs';\nimport  BaseTool  from './BaseTool.mjs';\nimport  { undoKeyboardShortcutId }  from './keybindings.mjs';\nimport  { decreaseSizeKeyboardShortcutId, increaseSizeKeyboardShortcutId }  from './keybindings.mjs';\nimport  InputStabilizer  from './InputFilter/InputStabilizer.mjs';\nimport  { ReactiveValue }  from '../util/ReactiveValue.mjs';\nimport  StationaryPenDetector, { defaultStationaryDetectionConfig, }  from './util/StationaryPenDetector.mjs';\n/**\n * A tool that allows drawing shapes and freehand lines.\n *\n * To change the type of shape drawn by the pen (e.g. to switch to the rectangle\n * pen type), see {@link setStrokeFactory}.\n */\nexport default class Pen extends BaseTool {\n    constructor(editor, description, style) {\n        super(editor.notifier, description);\n        this.editor = editor;\n        this.builder = null;\n        this.lastPoint = null;\n        this.startPoint = null;\n        this.currentDeviceType = null;\n        this.currentPointerId = null;\n        this.shapeAutocompletionEnabled = false;\n        this.autocorrectedShape = null;\n        this.lastAutocorrectedShape = null;\n        this.removedAutocorrectedShapeTime = 0;\n        this.stationaryDetector = null;\n        this.styleValue = ReactiveValue.fromInitialValue({\n            factory: makeFreehandLineBuilder,\n            color: Color4.blue,\n            thickness: 4,\n            ...style,\n        });\n        this.styleValue.onUpdateAndNow((newValue) => {\n            this.style = newValue;\n            this.noteUpdated();\n        });\n    }\n    getPressureMultiplier() {\n        const thickness = this.style.thickness;\n        return (1 / this.editor.viewport.getScaleFactor()) * thickness;\n    }\n    // Converts a `pointer` to a `StrokeDataPoint`.\n    toStrokePoint(pointer) {\n        const minPressure = 0.3;\n        let pressure = Math.max(pointer.pressure ?? 1.0, minPressure);\n        if (!isFinite(pressure)) {\n            console.warn('Non-finite pressure!', pointer);\n            pressure = minPressure;\n        }\n        console.assert(isFinite(pointer.canvasPos.length()), 'Non-finite canvas position!');\n        console.assert(isFinite(pointer.screenPos.length()), 'Non-finite screen position!');\n        console.assert(isFinite(pointer.timeStamp), 'Non-finite timeStamp on pointer!');\n        const pos = pointer.canvasPos;\n        return {\n            pos,\n            width: pressure * this.getPressureMultiplier(),\n            color: this.style.color,\n            time: pointer.timeStamp,\n        };\n    }\n    // Displays the stroke that is currently being built with the display's `wetInkRenderer`.\n    previewStroke() {\n        this.editor.clearWetInk();\n        const wetInkRenderer = this.editor.display.getWetInkRenderer();\n        if (this.autocorrectedShape) {\n            const visibleRect = this.editor.viewport.visibleRect;\n            this.autocorrectedShape.render(wetInkRenderer, visibleRect);\n        }\n        else {\n            this.builder?.preview(wetInkRenderer);\n        }\n    }\n    // Throws if no stroke builder exists.\n    addPointToStroke(point) {\n        if (!this.builder) {\n            throw new Error('No stroke is currently being generated.');\n        }\n        this.builder.addPoint(point);\n        this.lastPoint = point;\n        this.previewStroke();\n    }\n    onPointerDown(event) {\n        // Avoid canceling an existing stroke\n        if (this.builder && !this.eventCanCancelStroke(event)) {\n            return true;\n        }\n        const { current, allPointers } = event;\n        const isEraser = current.device === PointerDevice.Eraser;\n        const isPen = current.device === PointerDevice.Pen;\n        // Always start strokes if the current device is a pen. This is useful in the case\n        // where an accidental touch gesture from a user's hand is ongoing. This gesture\n        // should not prevent the user from drawing.\n        if ((allPointers.length === 1 && !isEraser) || isPen) {\n            this.startPoint = this.toStrokePoint(current);\n            this.builder = this.style.factory(this.startPoint, this.editor.viewport);\n            this.currentDeviceType = current.device;\n            this.currentPointerId = current.id;\n            if (this.shapeAutocompletionEnabled) {\n                this.stationaryDetector = new StationaryPenDetector(current, defaultStationaryDetectionConfig, (pointer) => this.autocorrectShape(pointer));\n            }\n            else {\n                this.stationaryDetector = null;\n            }\n            this.lastAutocorrectedShape = null;\n            this.removedAutocorrectedShapeTime = 0;\n            return true;\n        }\n        return false;\n    }\n    eventCanCancelStroke(event) {\n        // If there has been a delay since the last input event,\n        // it's always okay to cancel\n        const lastInputTime = this.lastPoint?.time ?? 0;\n        if (event.current.timeStamp - lastInputTime > 1000) {\n            return true;\n        }\n        const isPenStroke = this.currentDeviceType === PointerDevice.Pen;\n        const isTouchEvent = event.current.device === PointerDevice.Touch;\n        // Don't allow pen strokes to be cancelled by touch events.\n        if (isPenStroke && isTouchEvent) {\n            return false;\n        }\n        return true;\n    }\n    eventCanBeDeliveredToNonActiveTool(event) {\n        return this.eventCanCancelStroke(event);\n    }\n    onPointerMove({ current }) {\n        if (!this.builder)\n            return;\n        if (current.device !== this.currentDeviceType)\n            return;\n        if (current.id !== this.currentPointerId)\n            return;\n        const isStationary = this.stationaryDetector?.onPointerMove(current);\n        if (!isStationary) {\n            this.addPointToStroke(this.toStrokePoint(current));\n            if (this.autocorrectedShape) {\n                this.removedAutocorrectedShapeTime = performance.now();\n                this.autocorrectedShape = null;\n                this.editor.announceForAccessibility(this.editor.localization.autocorrectionCanceled);\n            }\n        }\n    }\n    onPointerUp({ current }) {\n        if (!this.builder)\n            return false;\n        if (current.id !== this.currentPointerId) {\n            // this.builder still exists, so we're handling events from another\n            // device type.\n            return true;\n        }\n        this.stationaryDetector?.onPointerUp(current);\n        // onPointerUp events can have zero pressure. Use the last pressure instead.\n        const currentPoint = this.toStrokePoint(current);\n        const strokePoint = {\n            ...currentPoint,\n            width: this.lastPoint?.width ?? currentPoint.width,\n        };\n        this.addPointToStroke(strokePoint);\n        this.finalizeStroke();\n        return false;\n    }\n    onGestureCancel() {\n        this.builder = null;\n        this.editor.clearWetInk();\n        this.stationaryDetector?.destroy();\n        this.stationaryDetector = null;\n    }\n    removedAutocorrectedShapeRecently() {\n        return this.removedAutocorrectedShapeTime > performance.now() - 320;\n    }\n    async autocorrectShape(_lastPointer) {\n        if (!this.builder || !this.builder.autocorrectShape)\n            return;\n        if (!this.shapeAutocompletionEnabled)\n            return;\n        // If already corrected, do nothing\n        if (this.autocorrectedShape)\n            return;\n        // Activate stroke fitting\n        const correctedShape = await this.builder.autocorrectShape();\n        if (!this.builder || !correctedShape) {\n            return;\n        }\n        // Don't complete to empty shapes.\n        const bboxArea = correctedShape.getBBox().area;\n        if (bboxArea === 0 || !isFinite(bboxArea)) {\n            return;\n        }\n        const shapeDescription = correctedShape.description(this.editor.localization);\n        this.editor.announceForAccessibility(this.editor.localization.autocorrectedTo(shapeDescription));\n        this.autocorrectedShape = correctedShape;\n        this.lastAutocorrectedShape = correctedShape;\n        this.previewStroke();\n    }\n    finalizeStroke() {\n        if (this.builder) {\n            // If autocorrectedShape was cleared recently enough, it was\n            // probably by mistake. Reset it.\n            if (this.lastAutocorrectedShape && this.removedAutocorrectedShapeRecently()) {\n                this.autocorrectedShape = this.lastAutocorrectedShape;\n            }\n            const stroke = this.autocorrectedShape ?? this.builder.build();\n            this.previewStroke();\n            if (stroke.getBBox().area > 0) {\n                if (stroke === this.autocorrectedShape) {\n                    this.editor.announceForAccessibility(this.editor.localization.autocorrectedTo(stroke.description(this.editor.localization)));\n                }\n                const canFlatten = true;\n                const action = EditorImage.addElement(stroke, canFlatten);\n                this.editor.dispatch(action);\n            }\n            else {\n                console.warn('Pen: Not adding empty stroke', stroke, 'to the canvas.');\n            }\n        }\n        this.builder = null;\n        this.lastPoint = null;\n        this.autocorrectedShape = null;\n        this.lastAutocorrectedShape = null;\n        this.editor.clearWetInk();\n        this.stationaryDetector?.destroy();\n        this.stationaryDetector = null;\n    }\n    noteUpdated() {\n        this.editor.notifier.dispatch(EditorEventType.ToolUpdated, {\n            kind: EditorEventType.ToolUpdated,\n            tool: this,\n        });\n    }\n    setColor(color) {\n        if (color.toHexString() !== this.style.color.toHexString()) {\n            this.styleValue.set({\n                ...this.style,\n                color,\n            });\n        }\n    }\n    setThickness(thickness) {\n        if (thickness !== this.style.thickness) {\n            this.styleValue.set({\n                ...this.style,\n                thickness,\n            });\n        }\n    }\n    /**\n     * Changes the type of stroke created by the pen. The given `factory` can be one of the built-in\n     * stroke factories (e.g. {@link makeFreehandLineBuilder}) or a custom stroke factory.\n     *\n     * Example:\n     * [[include:doc-pages/inline-examples/changing-pen-types.md]]\n     */\n    setStrokeFactory(factory) {\n        if (factory !== this.style.factory) {\n            this.styleValue.set({\n                ...this.style,\n                factory,\n            });\n        }\n    }\n    setHasStabilization(hasStabilization) {\n        const hasInputMapper = !!this.getInputMapper();\n        // TODO: Currently, this assumes that there is no other input mapper.\n        if (hasStabilization === hasInputMapper) {\n            return;\n        }\n        if (hasInputMapper) {\n            this.setInputMapper(null);\n        }\n        else {\n            this.setInputMapper(new InputStabilizer(this.editor.viewport));\n        }\n        this.noteUpdated();\n    }\n    setStrokeAutocorrectEnabled(enabled) {\n        if (enabled !== this.shapeAutocompletionEnabled) {\n            this.shapeAutocompletionEnabled = enabled;\n            this.noteUpdated();\n        }\n    }\n    getStrokeAutocorrectionEnabled() {\n        return this.shapeAutocompletionEnabled;\n    }\n    getThickness() {\n        return this.style.thickness;\n    }\n    getColor() {\n        return this.style.color;\n    }\n    getStrokeFactory() {\n        return this.style.factory;\n    }\n    getStyleValue() {\n        return this.styleValue;\n    }\n    onKeyPress(event) {\n        const shortcuts = this.editor.shortcuts;\n        // Ctrl+Z: End the stroke so that it can be undone/redone.\n        const isCtrlZ = shortcuts.matchesShortcut(undoKeyboardShortcutId, event);\n        if (this.builder && isCtrlZ) {\n            this.finalizeStroke();\n            // Return false: Allow other listeners to handle the event (e.g.\n            // undo/redo).\n            return false;\n        }\n        let newThickness;\n        if (shortcuts.matchesShortcut(decreaseSizeKeyboardShortcutId, event)) {\n            newThickness = (this.getThickness() * 2) / 3;\n        }\n        else if (shortcuts.matchesShortcut(increaseSizeKeyboardShortcutId, event)) {\n            newThickness = (this.getThickness() * 3) / 2;\n        }\n        if (newThickness !== undefined) {\n            newThickness = Math.min(Math.max(1, newThickness), 256);\n            this.setThickness(newThickness);\n            return true;\n        }\n        return false;\n    }\n}\n","// @internal @packageDocumentation\nimport  BaseTool  from './BaseTool.mjs';\n/**\n * A tool used internally to pick colors from the canvas.\n *\n * When color selection is in progress, the `pipette--color-selection-in-progress` class\n * is added to the root element. This can be used by themes.\n *\n * @internal\n */\nexport default class PipetteTool extends BaseTool {\n    constructor(editor, description) {\n        super(editor.notifier, description);\n        this.editor = editor;\n        this.colorPreviewListener = null;\n        this.colorSelectListener = null;\n        this.enabledValue().onUpdateAndNow(() => {\n            this.updateSelectingStatus();\n        });\n    }\n    canReceiveInputInReadOnlyEditor() {\n        return true;\n    }\n    // Ensures that the root editor element correctly reflects whether color selection\n    // is in progress.\n    updateSelectingStatus() {\n        const className = 'pipette--color-selection-in-progress';\n        if (this.isEnabled() && this.colorSelectListener && this.colorPreviewListener) {\n            this.editor.getRootElement().classList.add(className);\n        }\n        else {\n            this.editor.getRootElement().classList.remove(className);\n        }\n    }\n    setColorListener(colorPreviewListener, \n    // Called when the gesture ends -- when the user has selected a color.\n    colorSelectListener) {\n        this.colorPreviewListener = colorPreviewListener;\n        this.colorSelectListener = colorSelectListener;\n        this.updateSelectingStatus();\n    }\n    clearColorListener() {\n        this.colorPreviewListener = null;\n        this.colorSelectListener = null;\n        this.updateSelectingStatus();\n    }\n    onPointerDown({ current, allPointers }) {\n        if (this.colorPreviewListener && allPointers.length === 1) {\n            this.colorPreviewListener(this.editor.display.getColorAt(current.screenPos));\n            return true;\n        }\n        return false;\n    }\n    onPointerMove({ current }) {\n        this.colorPreviewListener?.(this.editor.display.getColorAt(current.screenPos));\n    }\n    onPointerUp({ current }) {\n        this.colorSelectListener?.(this.editor.display.getColorAt(current.screenPos));\n    }\n    onGestureCancel() {\n        this.colorSelectListener?.(null);\n    }\n}\n","import { Rect2 } from '@js-draw/math';\nimport  { EditorEventType }  from '../types.mjs';\nimport  BaseTool  from './BaseTool.mjs';\n/**\n * This tool, when enabled, renders scrollbars reflecting the current position\n * of the view relative to the import/export area of the image.\n *\n * **Note**: These scrollbars are currently not draggable. This may change in\n * a future release.\n */\nexport default class ScrollbarTool extends BaseTool {\n    constructor(editor) {\n        super(editor.notifier, 'scrollbar');\n        this.editor = editor;\n        this.fadeOutTimeout = null;\n        this.scrollbarOverlay = document.createElement('div');\n        this.scrollbarOverlay.classList.add('ScrollbarTool-overlay');\n        this.verticalScrollbar = document.createElement('div');\n        this.verticalScrollbar.classList.add('vertical-scrollbar');\n        this.horizontalScrollbar = document.createElement('div');\n        this.horizontalScrollbar.classList.add('horizontal-scrollbar');\n        this.scrollbarOverlay.replaceChildren(this.verticalScrollbar, this.horizontalScrollbar);\n        let overlay = null;\n        let viewportListener = null;\n        this.enabledValue().onUpdateAndNow((enabled) => {\n            overlay?.remove();\n            viewportListener?.remove();\n            viewportListener = null;\n            overlay = null;\n            if (enabled) {\n                viewportListener = editor.notifier.on(EditorEventType.ViewportChanged, (_event) => {\n                    this.updateScrollbars();\n                });\n                this.updateScrollbars();\n                overlay = editor.createHTMLOverlay(this.scrollbarOverlay);\n            }\n        });\n    }\n    updateScrollbars() {\n        const viewport = this.editor.viewport;\n        const screenSize = viewport.getScreenRectSize();\n        const screenRect = new Rect2(0, 0, screenSize.x, screenSize.y);\n        const imageRect = this.editor\n            .getImportExportRect()\n            // The scrollbars are positioned in screen coordinates, so the exportRect also needs\n            // to be in screen coordinates\n            .transformedBoundingBox(viewport.canvasToScreenTransform)\n            // If the screenRect is outside of the exportRect, expand the image rectangle\n            .union(screenRect);\n        const scrollbarWidth = (screenRect.width / imageRect.width) * screenSize.x;\n        const scrollbarHeight = (screenRect.height / imageRect.height) * screenSize.y;\n        const scrollbarX = ((screenRect.x - imageRect.x) / imageRect.width) * screenSize.x;\n        const scrollbarY = ((screenRect.y - imageRect.y) / imageRect.height) * screenSize.y;\n        this.horizontalScrollbar.style.width = `${scrollbarWidth}px`;\n        this.verticalScrollbar.style.height = `${scrollbarHeight}px`;\n        this.horizontalScrollbar.style.marginLeft = `${scrollbarX}px`;\n        this.verticalScrollbar.style.marginTop = `${scrollbarY}px`;\n        // Style the scrollbars differently when there's no scroll (all content visible)\n        const handleNoScrollStyling = (scrollbar, size, fillSize) => {\n            const fillsWindowClass = 'represents-no-scroll';\n            if (Math.abs(size - fillSize) < 1e-8) {\n                scrollbar.classList.add(fillsWindowClass);\n            }\n            else {\n                scrollbar.classList.remove(fillsWindowClass);\n            }\n        };\n        handleNoScrollStyling(this.horizontalScrollbar, scrollbarWidth, screenSize.x);\n        handleNoScrollStyling(this.verticalScrollbar, scrollbarHeight, screenSize.y);\n        // Fade out after a delay.\n        if (this.fadeOutTimeout !== null) {\n            clearTimeout(this.fadeOutTimeout);\n        }\n        const fadeOutDelay = 3000;\n        this.fadeOutTimeout = setTimeout(() => {\n            this.scrollbarOverlay.classList.remove('just-updated');\n        }, fadeOutDelay);\n        this.scrollbarOverlay.classList.add('just-updated');\n    }\n}\n","import  BaseTool  from '../BaseTool.mjs';\nimport  { selectAllKeyboardShortcut }  from '../keybindings.mjs';\nimport  SelectionTool  from './SelectionTool.mjs';\n// Handles ctrl+a: Select all\nexport default class SelectAllShortcutHandler extends BaseTool {\n    constructor(editor) {\n        super(editor.notifier, editor.localization.selectAllTool);\n        this.editor = editor;\n    }\n    canReceiveInputInReadOnlyEditor() {\n        return true;\n    }\n    // @internal\n    onKeyPress(event) {\n        if (this.editor.shortcuts.matchesShortcut(selectAllKeyboardShortcut, event)) {\n            const selectionTools = this.editor.toolController.getMatchingTools(SelectionTool);\n            if (selectionTools.length > 0) {\n                const selectionTool = selectionTools[0];\n                selectionTool.setEnabled(true);\n                selectionTool.setSelection(this.editor.image.getAllElements());\n                return true;\n            }\n        }\n        return false;\n    }\n}\n","/**\n * @internal\n * @packageDocumentation\n */\nvar _a;\nimport  SerializableCommand  from '../../commands/SerializableCommand.mjs';\nimport { Mat33, Rect2, Vec2 } from '@js-draw/math';\nimport  SelectionHandle, { HandleAction, handleSize }  from './SelectionHandle.mjs';\nimport  { cssPrefix }  from './SelectionTool.mjs';\nimport  Viewport  from '../../Viewport.mjs';\nimport  Erase  from '../../commands/Erase.mjs';\nimport  Duplicate  from '../../commands/Duplicate.mjs';\nimport  { DragTransformer, ResizeTransformer, RotateTransformer }  from './TransformMode.mjs';\nimport  { ResizeMode }  from './types.mjs';\nimport  EditorImage  from '../../image/EditorImage.mjs';\nimport  uniteCommands  from '../../commands/uniteCommands.mjs';\nimport  SelectionMenuShortcut  from './SelectionMenuShortcut.mjs';\nconst updateChunkSize = 100;\nconst maxPreviewElemCount = 500;\n// @internal\nclass Selection {\n    constructor(startPoint, editor, showContextMenu) {\n        this.editor = editor;\n        // The last-computed bounding box of selected content\n        // @see getTightBoundingBox\n        this.selectionTightBoundingBox = null;\n        this.transform = Mat33.identity;\n        // invariant: sorted by increasing z-index\n        this.selectedElems = [];\n        this.hasParent = true;\n        // Maps IDs to whether we removed the component from the image\n        this.removedFromImage = {};\n        this.activeHandle = null;\n        this.backgroundDragging = false;\n        this.selectionDuplicatedAnimationTimeout = null;\n        this.originalRegion = new Rect2(startPoint.x, startPoint.y, 0, 0);\n        this.transformers = {\n            drag: new DragTransformer(editor, this),\n            resize: new ResizeTransformer(editor, this),\n            rotate: new RotateTransformer(editor, this),\n        };\n        // We need two containers for some CSS to apply (the outer container\n        // needs zero height, the inner needs to prevent the selection background\n        // from being visible outside of the editor).\n        this.outerContainer = document.createElement('div');\n        this.outerContainer.classList.add(`${cssPrefix}selection-outer-container`);\n        this.innerContainer = document.createElement('div');\n        this.innerContainer.classList.add(`${cssPrefix}selection-inner-container`);\n        this.backgroundElem = document.createElement('div');\n        this.backgroundElem.classList.add(`${cssPrefix}selection-background`);\n        this.innerContainer.appendChild(this.backgroundElem);\n        this.outerContainer.appendChild(this.innerContainer);\n        const makeResizeHandle = (mode, side) => {\n            const modeToAction = {\n                [ResizeMode.Both]: HandleAction.ResizeXY,\n                [ResizeMode.HorizontalOnly]: HandleAction.ResizeX,\n                [ResizeMode.VerticalOnly]: HandleAction.ResizeY,\n            };\n            return new SelectionHandle({\n                action: modeToAction[mode],\n                side,\n            }, this, this.editor.viewport, (startPoint) => this.transformers.resize.onDragStart(startPoint, mode), (currentPoint) => this.transformers.resize.onDragUpdate(currentPoint), () => this.transformers.resize.onDragEnd());\n        };\n        const resizeHorizontalHandles = [\n            makeResizeHandle(ResizeMode.HorizontalOnly, Vec2.of(0, 0.5)),\n            makeResizeHandle(ResizeMode.HorizontalOnly, Vec2.of(1, 0.5)),\n        ];\n        const resizeVerticalHandle = makeResizeHandle(ResizeMode.VerticalOnly, Vec2.of(0.5, 1));\n        const resizeBothHandle = makeResizeHandle(ResizeMode.Both, Vec2.of(1, 1));\n        const rotationHandle = new SelectionHandle({\n            action: HandleAction.Rotate,\n            side: Vec2.of(0.5, 0),\n            icon: this.editor.icons.makeRotateIcon(),\n        }, this, this.editor.viewport, (startPoint) => this.transformers.rotate.onDragStart(startPoint), (currentPoint) => this.transformers.rotate.onDragUpdate(currentPoint), () => this.transformers.rotate.onDragEnd());\n        const menuToggleButton = new SelectionMenuShortcut(this, this.editor.viewport, this.editor.icons.makeOverflowIcon(), showContextMenu, this.editor.localization);\n        this.childwidgets = [\n            menuToggleButton,\n            resizeBothHandle,\n            ...resizeHorizontalHandles,\n            resizeVerticalHandle,\n            rotationHandle,\n        ];\n        for (const widget of this.childwidgets) {\n            widget.addTo(this.backgroundElem);\n        }\n        this.updateUI();\n    }\n    // @internal Intended for unit tests\n    getBackgroundElem() {\n        return this.backgroundElem;\n    }\n    getTransform() {\n        return this.transform;\n    }\n    get preTransformRegion() {\n        return this.originalRegion;\n    }\n    // The **canvas** region.\n    get region() {\n        // TODO: This currently assumes that the region rotates about its center.\n        // This may not be true.\n        const rotationMatrix = Mat33.zRotation(this.regionRotation, this.originalRegion.center);\n        const scaleAndTranslateMat = this.transform.rightMul(rotationMatrix.inverse());\n        return this.originalRegion.transformedBoundingBox(scaleAndTranslateMat);\n    }\n    /**\n     * Computes and returns the bounding box of the selection without\n     * any additional padding. Computes directly from the elements that are selected.\n     * @internal\n     */\n    computeTightBoundingBox() {\n        const bbox = this.selectedElems.reduce((accumulator, elem) => {\n            return (accumulator ?? elem.getBBox()).union(elem.getBBox());\n        }, null);\n        return bbox ?? Rect2.empty;\n    }\n    get regionRotation() {\n        return this.transform.transformVec3(Vec2.unitX).angle();\n    }\n    get preTransformedScreenRegion() {\n        const toScreen = (vec) => this.editor.viewport.canvasToScreen(vec);\n        return Rect2.fromCorners(toScreen(this.preTransformRegion.topLeft), toScreen(this.preTransformRegion.bottomRight));\n    }\n    get preTransformedScreenRegionRotation() {\n        return this.editor.viewport.getRotationAngle();\n    }\n    getScreenRegion() {\n        const toScreen = this.editor.viewport.canvasToScreenTransform;\n        const scaleFactor = this.editor.viewport.getScaleFactor();\n        const screenCenter = toScreen.transformVec2(this.region.center);\n        return new Rect2(screenCenter.x, screenCenter.y, scaleFactor * this.region.width, scaleFactor * this.region.height).translatedBy(this.region.size.times(-scaleFactor / 2));\n    }\n    get screenRegionRotation() {\n        return this.regionRotation + this.editor.viewport.getRotationAngle();\n    }\n    // Applies, previews, but doesn't finalize the given transformation.\n    setTransform(transform, preview = true) {\n        this.transform = transform;\n        if (preview && this.hasParent) {\n            this.previewTransformCmds();\n        }\n    }\n    getDeltaZIndexToMoveSelectionToTop() {\n        if (this.selectedElems.length === 0) {\n            return 0;\n        }\n        const selectedBottommostZIndex = this.selectedElems[0].getZIndex();\n        const visibleObjects = this.editor.image.getElementsIntersectingRegion(this.region);\n        const topMostVisibleZIndex = visibleObjects[visibleObjects.length - 1]?.getZIndex() ?? selectedBottommostZIndex;\n        const deltaZIndex = topMostVisibleZIndex + 1 - selectedBottommostZIndex;\n        return deltaZIndex;\n    }\n    // Applies the current transformation to the selection\n    finalizeTransform() {\n        const fullTransform = this.transform;\n        const selectedElems = this.selectedElems;\n        // Reset for the next drag\n        this.originalRegion = this.originalRegion.transformedBoundingBox(this.transform);\n        this.transform = Mat33.identity;\n        this.scrollTo();\n        let transformPromise = undefined;\n        // Make the commands undo-able.\n        // Don't check for non-empty transforms because this breaks changing the\n        // z-index of the just-transformed commands.\n        if (this.selectedElems.length > 0) {\n            const deltaZIndex = this.getDeltaZIndexToMoveSelectionToTop();\n            transformPromise = this.editor.dispatch(new _a.ApplyTransformationCommand(this, selectedElems, fullTransform, deltaZIndex));\n        }\n        return transformPromise;\n    }\n    /** Sends all selected elements to the bottom of the visible image. */\n    sendToBack() {\n        const visibleObjects = this.editor.image.getElementsIntersectingRegion(this.editor.viewport.visibleRect);\n        // VisibleObjects and selectedElems should both be sorted by z-index\n        const lowestVisibleZIndex = visibleObjects[0]?.getZIndex() ?? 0;\n        const highestSelectedZIndex = this.selectedElems[this.selectedElems.length - 1]?.getZIndex() ?? 0;\n        const targetHighestZIndex = lowestVisibleZIndex - 1;\n        const deltaZIndex = targetHighestZIndex - highestSelectedZIndex;\n        if (deltaZIndex !== 0) {\n            const commands = this.selectedElems.map((elem) => {\n                return elem.setZIndex(elem.getZIndex() + deltaZIndex);\n            });\n            return uniteCommands(commands, updateChunkSize);\n        }\n        return null;\n    }\n    // Preview the effects of the current transformation on the selection\n    previewTransformCmds() {\n        if (this.selectedElems.length === 0) {\n            return;\n        }\n        // Don't render what we're moving if it's likely to be slow.\n        if (this.selectedElems.length > maxPreviewElemCount) {\n            this.updateUI();\n            return;\n        }\n        const wetInkRenderer = this.editor.display.getWetInkRenderer();\n        wetInkRenderer.clear();\n        wetInkRenderer.pushTransform(this.transform);\n        const viewportVisibleRect = this.editor.viewport.visibleRect.union(this.region);\n        const visibleRect = viewportVisibleRect.transformedBoundingBox(this.transform.inverse());\n        for (const elem of this.selectedElems) {\n            elem.render(wetInkRenderer, visibleRect);\n        }\n        wetInkRenderer.popTransform();\n        this.updateUI();\n    }\n    // Find the objects corresponding to this in the document,\n    // select them.\n    // Returns false iff nothing was selected.\n    resolveToObjects() {\n        let singleItemSelectionMode = false;\n        this.transform = Mat33.identity;\n        // Grow the rectangle, if necessary\n        if (this.region.w === 0 || this.region.h === 0) {\n            const padding = this.editor.viewport.visibleRect.maxDimension / 200;\n            this.originalRegion = Rect2.bboxOf(this.region.corners, padding);\n            // Only select one item if the rectangle was very small.\n            singleItemSelectionMode = true;\n        }\n        this.selectedElems = this.editor.image\n            .getElementsIntersectingRegion(this.region)\n            .filter((elem) => {\n            return elem.intersectsRect(this.region) && elem.isSelectable();\n        });\n        if (singleItemSelectionMode && this.selectedElems.length > 0) {\n            this.selectedElems = [this.selectedElems[this.selectedElems.length - 1]];\n        }\n        // Find the bounding box of all selected elements.\n        if (!this.recomputeRegion()) {\n            return false;\n        }\n        this.updateUI();\n        return true;\n    }\n    // Recompute this' region from the selected elements.\n    // Returns false if the selection is empty.\n    recomputeRegion() {\n        const newRegion = this.computeTightBoundingBox();\n        this.selectionTightBoundingBox = newRegion;\n        if (!newRegion) {\n            this.cancelSelection();\n            return false;\n        }\n        this.originalRegion = newRegion;\n        this.padRegion();\n        return true;\n    }\n    // Applies padding to the current region if it is too small.\n    // @internal\n    padRegion() {\n        const sourceRegion = this.selectionTightBoundingBox ?? this.originalRegion;\n        const minSize = this.getMinCanvasSize();\n        if (sourceRegion.w < minSize || sourceRegion.h < minSize) {\n            // Add padding\n            const padding = minSize / 2;\n            this.originalRegion = Rect2.bboxOf(sourceRegion.corners, padding);\n            this.updateUI();\n        }\n    }\n    getMinCanvasSize() {\n        const canvasHandleSize = handleSize / this.editor.viewport.getScaleFactor();\n        return canvasHandleSize * 2;\n    }\n    getSelectedItemCount() {\n        return this.selectedElems.length;\n    }\n    // @internal\n    updateUI() {\n        // Don't update old selections.\n        if (!this.hasParent) {\n            return;\n        }\n        const screenRegion = this.getScreenRegion();\n        // marginLeft, marginTop: Display relative to the top left of the selection overlay.\n        // left, top don't work for this.\n        this.backgroundElem.style.marginLeft = `${screenRegion.topLeft.x}px`;\n        this.backgroundElem.style.marginTop = `${screenRegion.topLeft.y}px`;\n        this.backgroundElem.style.width = `${screenRegion.width}px`;\n        this.backgroundElem.style.height = `${screenRegion.height}px`;\n        const rotationDeg = (this.screenRegionRotation * 180) / Math.PI;\n        this.backgroundElem.style.transform = `rotate(${rotationDeg}deg)`;\n        this.backgroundElem.style.transformOrigin = 'center';\n        // If closer to perpendicular, apply different CSS\n        const perpendicularClassName = `${cssPrefix}rotated-near-perpendicular`;\n        if (Math.abs(Math.sin(this.screenRegionRotation)) > 0.5) {\n            this.innerContainer.classList.add(perpendicularClassName);\n        }\n        else {\n            this.innerContainer.classList.remove(perpendicularClassName);\n        }\n        // Hide handles when empty\n        if (screenRegion.width === 0 && screenRegion.height === 0) {\n            this.innerContainer.classList.add('-empty');\n        }\n        else {\n            this.innerContainer.classList.remove('-empty');\n        }\n        for (const widget of this.childwidgets) {\n            widget.updatePosition(this.getScreenRegion());\n        }\n    }\n    // Add/remove the contents of this seleciton from the editor.\n    // Used to prevent previewed content from looking like duplicate content\n    // while dragging.\n    //\n    // Does nothing if a large number of elements are selected (and so modifying\n    // the editor image is likely to be slow.)\n    //\n    // If removed from the image, selected elements are drawn as wet ink.\n    //\n    // [inImage] should be `true` if the selected elements should be added to the\n    // main image, `false` if they should be removed.\n    addRemoveSelectionFromImage(inImage) {\n        // Don't hide elements if doing so will be slow.\n        if (!inImage && this.selectedElems.length > maxPreviewElemCount) {\n            return;\n        }\n        for (const elem of this.selectedElems) {\n            const parent = this.editor.image.findParent(elem);\n            if (!inImage && parent) {\n                this.removedFromImage[elem.getId()] = true;\n                parent.remove();\n            }\n            // If we're making things visible and the selected object wasn't previously\n            // visible,\n            else if (!parent && this.removedFromImage[elem.getId()]) {\n                EditorImage.addElement(elem).apply(this.editor);\n                this.removedFromImage[elem.getId()] = false;\n                delete this.removedFromImage[elem.getId()];\n            }\n        }\n        // Don't await queueRerender. If we're running in a test, the re-render might never\n        // happen.\n        this.editor.queueRerender().then(() => {\n            if (!inImage) {\n                this.previewTransformCmds();\n            }\n            else {\n                // Clear renderings of any in-progress transformations\n                const wetInkRenderer = this.editor.display.getWetInkRenderer();\n                wetInkRenderer.clear();\n            }\n        });\n    }\n    removeDeletedElemsFromSelection() {\n        // Remove any deleted elements from the selection.\n        this.selectedElems = this.selectedElems.filter((elem) => {\n            const hasParent = !!this.editor.image.findParent(elem);\n            // If we removed the element and haven't added it back yet, don't remove it\n            // from the selection.\n            const weRemoved = this.removedFromImage[elem.getId()];\n            return hasParent || weRemoved;\n        });\n    }\n    onDragStart(pointer) {\n        // Clear the HTML selection (prevent HTML drag and drop being triggered by this drag)\n        document.getSelection()?.removeAllRanges();\n        this.activeHandle = null;\n        let result = false;\n        this.backgroundDragging = false;\n        if (this.region.containsPoint(pointer.canvasPos)) {\n            this.backgroundDragging = true;\n            result = true;\n        }\n        for (const widget of this.childwidgets) {\n            if (widget.containsPoint(pointer.canvasPos)) {\n                this.activeHandle = widget;\n                this.backgroundDragging = false;\n                result = true;\n            }\n        }\n        if (result) {\n            this.removeDeletedElemsFromSelection();\n            this.addRemoveSelectionFromImage(false);\n        }\n        if (this.activeHandle) {\n            this.activeHandle.handleDragStart(pointer);\n        }\n        if (this.backgroundDragging) {\n            this.transformers.drag.onDragStart(pointer.canvasPos);\n        }\n        return result;\n    }\n    onDragUpdate(pointer) {\n        if (this.backgroundDragging) {\n            this.transformers.drag.onDragUpdate(pointer.canvasPos);\n        }\n        if (this.activeHandle) {\n            this.activeHandle.handleDragUpdate(pointer);\n        }\n    }\n    onDragEnd() {\n        if (this.backgroundDragging) {\n            this.transformers.drag.onDragEnd();\n        }\n        else if (this.activeHandle) {\n            this.activeHandle.handleDragEnd();\n        }\n        this.addRemoveSelectionFromImage(true);\n        this.backgroundDragging = false;\n        this.activeHandle = null;\n        this.updateUI();\n    }\n    onDragCancel() {\n        this.backgroundDragging = false;\n        this.activeHandle = null;\n        this.setTransform(Mat33.identity);\n        this.addRemoveSelectionFromImage(true);\n        this.updateUI();\n    }\n    // Scroll the viewport to this. Does not zoom\n    scrollTo() {\n        if (this.selectedElems.length === 0) {\n            return false;\n        }\n        const screenSize = this.editor.viewport.getScreenRectSize();\n        const screenRect = new Rect2(0, 0, screenSize.x, screenSize.y);\n        const selectionScreenRegion = this.getScreenRegion();\n        if (!screenRect.containsPoint(selectionScreenRegion.center)) {\n            const targetPointScreen = selectionScreenRegion.center;\n            const closestPointScreen = screenRect.getClosestPointOnBoundaryTo(targetPointScreen);\n            const closestPointCanvas = this.editor.viewport.screenToCanvas(closestPointScreen);\n            const targetPointCanvas = this.region.center;\n            const delta = closestPointCanvas.minus(targetPointCanvas);\n            this.editor.dispatchNoAnnounce(Viewport.transformBy(Mat33.translation(delta.times(0.5))), false);\n            this.editor.queueRerender().then(() => {\n                this.previewTransformCmds();\n            });\n            return true;\n        }\n        return false;\n    }\n    deleteSelectedObjects() {\n        if (this.backgroundDragging || this.activeHandle) {\n            this.onDragEnd();\n        }\n        return new Erase(this.selectedElems);\n    }\n    runSelectionDuplicatedAnimation() {\n        if (this.selectionDuplicatedAnimationTimeout) {\n            clearTimeout(this.selectionDuplicatedAnimationTimeout);\n        }\n        const animationDuration = 400; // ms\n        this.backgroundElem.style.animation = `${animationDuration}ms ease selection-duplicated-animation`;\n        this.selectionDuplicatedAnimationTimeout = setTimeout(() => {\n            this.backgroundElem.style.animation = '';\n            this.selectionDuplicatedAnimationTimeout = null;\n        }, animationDuration);\n    }\n    async duplicateSelectedObjects() {\n        const wasTransforming = this.backgroundDragging || this.activeHandle;\n        let tmpApplyCommand = null;\n        if (!wasTransforming) {\n            this.runSelectionDuplicatedAnimation();\n        }\n        let command;\n        if (wasTransforming) {\n            // Don't update the selection's focus when redoing/undoing\n            const selectionToUpdate = null;\n            const deltaZIndex = this.getDeltaZIndexToMoveSelectionToTop();\n            tmpApplyCommand = new _a.ApplyTransformationCommand(selectionToUpdate, this.selectedElems, this.transform, deltaZIndex);\n            // Transform to ensure that the duplicates are in the correct location\n            await tmpApplyCommand.apply(this.editor);\n            // Show items again\n            this.addRemoveSelectionFromImage(true);\n            // With the transformation applied, create the duplicates\n            command = uniteCommands(this.selectedElems.map((elem) => {\n                return EditorImage.addElement(elem.clone());\n            }));\n            // Move the selected objects back to the correct location.\n            await tmpApplyCommand?.unapply(this.editor);\n            this.addRemoveSelectionFromImage(false);\n            this.previewTransformCmds();\n            this.updateUI();\n        }\n        else {\n            command = new Duplicate(this.selectedElems);\n        }\n        return command;\n    }\n    setHandlesVisible(showHandles) {\n        if (!showHandles) {\n            this.innerContainer.classList.add('-hide-handles');\n        }\n        else {\n            this.innerContainer.classList.remove('-hide-handles');\n        }\n    }\n    addTo(elem) {\n        if (this.outerContainer.parentElement) {\n            this.outerContainer.remove();\n        }\n        elem.appendChild(this.outerContainer);\n        this.hasParent = true;\n    }\n    setToPoint(point) {\n        this.originalRegion = this.originalRegion.grownToPoint(point);\n        this.selectionTightBoundingBox = null;\n        this.updateUI();\n    }\n    cancelSelection() {\n        if (this.outerContainer.parentElement) {\n            this.outerContainer.remove();\n        }\n        this.originalRegion = Rect2.empty;\n        this.selectionTightBoundingBox = null;\n        this.hasParent = false;\n    }\n    setSelectedObjects(objects, bbox) {\n        this.addRemoveSelectionFromImage(true);\n        this.originalRegion = bbox;\n        this.selectionTightBoundingBox = bbox;\n        this.selectedElems = objects.filter((object) => object.isSelectable());\n        // Enforce increasing z-index invariant\n        this.selectedElems.sort((a, b) => a.getZIndex() - b.getZIndex());\n        this.padRegion();\n        this.updateUI();\n    }\n    getSelectedObjects() {\n        return [...this.selectedElems];\n    }\n}\n_a = Selection;\n(() => {\n    SerializableCommand.register('selection-tool-transform', (json, _editor) => {\n        // The selection box is lost when serializing/deserializing. No need to store box rotation\n        const fullTransform = new Mat33(...json.transform);\n        const elemIds = json.elems ?? [];\n        const deltaZIndex = parseInt(json.deltaZIndex ?? 0);\n        return new _a.ApplyTransformationCommand(null, elemIds, fullTransform, deltaZIndex);\n    });\n})();\nSelection.ApplyTransformationCommand = class extends SerializableCommand {\n    constructor(selection, \n    // If a `string[]`, selectedElems is a list of element IDs.\n    selectedElems, \n    // Full transformation used to transform elements.\n    fullTransform, deltaZIndex) {\n        super('selection-tool-transform');\n        this.selection = selection;\n        this.fullTransform = fullTransform;\n        this.deltaZIndex = deltaZIndex;\n        const isIDList = (arr) => {\n            return typeof arr[0] === 'string';\n        };\n        // If a list of element IDs,\n        if (isIDList(selectedElems)) {\n            this.selectedElemIds = selectedElems;\n        }\n        else {\n            this.selectedElemIds = selectedElems.map((elem) => elem.getId());\n            this.transformCommands = selectedElems.map((elem) => {\n                return elem.setZIndexAndTransformBy(this.fullTransform, elem.getZIndex() + deltaZIndex);\n            });\n        }\n    }\n    resolveToElems(editor, isUndoing) {\n        if (this.transformCommands) {\n            return;\n        }\n        this.transformCommands = this.selectedElemIds\n            .map((id) => {\n            const elem = editor.image.lookupElement(id);\n            if (!elem) {\n                // There may be valid reasons for an element lookup to fail:\n                // For example, if the element was deleted remotely and the remote deletion\n                // hasn't been undone.\n                console.warn(`Unable to find element with ID, ${id}.`);\n                return null;\n            }\n            let originalZIndex = elem.getZIndex();\n            let targetZIndex = elem.getZIndex() + this.deltaZIndex;\n            // If the command has already been applied, the element should currently\n            // have the target z-index.\n            if (isUndoing) {\n                targetZIndex = elem.getZIndex();\n                originalZIndex = elem.getZIndex() - this.deltaZIndex;\n            }\n            return elem.setZIndexAndTransformBy(this.fullTransform, targetZIndex, originalZIndex);\n        })\n            .filter(\n        // Remove all null commands\n        (command) => command !== null);\n    }\n    async apply(editor) {\n        this.resolveToElems(editor, false);\n        this.selection?.setTransform(this.fullTransform, false);\n        this.selection?.updateUI();\n        await editor.asyncApplyCommands(this.transformCommands, updateChunkSize);\n        this.selection?.setTransform(Mat33.identity, false);\n        this.selection?.recomputeRegion();\n        this.selection?.updateUI();\n    }\n    async unapply(editor) {\n        this.resolveToElems(editor, true);\n        this.selection?.setTransform(this.fullTransform.inverse(), false);\n        this.selection?.updateUI();\n        await editor.asyncUnapplyCommands(this.transformCommands, updateChunkSize, true);\n        this.selection?.setTransform(Mat33.identity, false);\n        this.selection?.recomputeRegion();\n        this.selection?.updateUI();\n    }\n    serializeToJSON() {\n        return {\n            elems: this.selectedElemIds,\n            transform: this.fullTransform.toArray(),\n            deltaZIndex: this.deltaZIndex,\n        };\n    }\n    description(_editor, localizationTable) {\n        return localizationTable.transformedElements(this.selectedElemIds.length);\n    }\n};\nexport default Selection;\n","import  { assertUnreachable }  from '../../util/assertions.mjs';\nimport { Rect2, Vec2 } from '@js-draw/math';\nimport  { cssPrefix }  from './SelectionTool.mjs';\nvar HandleShape;\n(function (HandleShape) {\n    HandleShape[HandleShape[\"Circle\"] = 0] = \"Circle\";\n    HandleShape[HandleShape[\"Square\"] = 1] = \"Square\";\n})(HandleShape || (HandleShape = {}));\nexport var HandleAction;\n(function (HandleAction) {\n    HandleAction[\"ResizeXY\"] = \"resize-xy\";\n    HandleAction[\"Rotate\"] = \"rotate\";\n    HandleAction[\"ResizeX\"] = \"resize-x\";\n    HandleAction[\"ResizeY\"] = \"resize-y\";\n})(HandleAction || (HandleAction = {}));\n// The *interactable* handle size. The visual size will be slightly smaller.\nexport const handleSize = 30;\nexport default class SelectionHandle {\n    constructor(presentation, parent, viewport, onDragStart, onDragUpdate, onDragEnd) {\n        this.presentation = presentation;\n        this.parent = parent;\n        this.viewport = viewport;\n        this.onDragStart = onDragStart;\n        this.onDragUpdate = onDragUpdate;\n        this.onDragEnd = onDragEnd;\n        this.dragLastPos = null;\n        this.element = document.createElement('div');\n        this.element.classList.add(`${cssPrefix}handle`, `${cssPrefix}${presentation.action}`);\n        // Create a slightly smaller content/background element.\n        const visibleContent = document.createElement('div');\n        visibleContent.classList.add(`${cssPrefix}content`);\n        this.element.appendChild(visibleContent);\n        this.parentSide = presentation.side;\n        const icon = presentation.icon;\n        if (icon) {\n            visibleContent.appendChild(icon);\n            icon.classList.add('icon');\n        }\n        if (presentation.action === HandleAction.Rotate) {\n            this.shape = HandleShape.Circle;\n        }\n        else {\n            this.shape = HandleShape.Square;\n        }\n        switch (this.shape) {\n            case HandleShape.Circle:\n                this.element.classList.add(`${cssPrefix}circle`);\n                break;\n            case HandleShape.Square:\n                this.element.classList.add(`${cssPrefix}square`);\n                break;\n            default:\n                assertUnreachable(this.shape);\n        }\n        this.updatePosition();\n    }\n    /**\n     * Adds this to `container`, where `conatiner` should be the background/selection\n     * element visible on the screen.\n     */\n    addTo(container) {\n        container.appendChild(this.element);\n    }\n    /**\n     * Removes this element from its container. Should only be called\n     * after {@link addTo}.\n     */\n    remove() {\n        this.element.remove();\n    }\n    /**\n     * Returns this handle's bounding box relative to the top left of the\n     * selection box.\n     */\n    getBBoxParentCoords() {\n        const parentRect = this.parent.getScreenRegion();\n        const size = Vec2.of(handleSize, handleSize);\n        const topLeft = parentRect.size\n            .scale(this.parentSide)\n            // Center\n            .minus(size.times(1 / 2));\n        return new Rect2(topLeft.x, topLeft.y, size.x, size.y);\n    }\n    /** @returns this handle's bounding box relative to the canvas. */\n    getBBoxCanvasCoords() {\n        const parentRect = this.parent.region;\n        const size = Vec2.of(handleSize, handleSize).times(1 / this.viewport.getScaleFactor());\n        const topLeftFromParent = parentRect.size.scale(this.parentSide).minus(size.times(0.5));\n        return new Rect2(topLeftFromParent.x, topLeftFromParent.y, size.x, size.y).translatedBy(parentRect.topLeft);\n    }\n    /**\n     * Moves the HTML representation of this to the location matching its internal representation.\n     */\n    updatePosition() {\n        const bbox = this.getBBoxParentCoords();\n        // Position within the selection box.\n        this.element.style.marginLeft = `${bbox.topLeft.x}px`;\n        this.element.style.marginTop = `${bbox.topLeft.y}px`;\n        this.element.style.width = `${bbox.w}px`;\n        this.element.style.height = `${bbox.h}px`;\n    }\n    /** @returns true iff `point` (in editor **canvas** coordinates) is in this. */\n    containsPoint(point) {\n        const bbox = this.getBBoxCanvasCoords();\n        const delta = point.minus(bbox.center);\n        // Should have same x and y radius\n        const radius = bbox.size.x / 2;\n        let result;\n        if (this.shape === HandleShape.Circle) {\n            result = delta.magnitude() <= radius;\n        }\n        else {\n            result = Math.abs(delta.x) <= radius && Math.abs(delta.y) <= radius;\n        }\n        return result;\n    }\n    handleDragStart(pointer) {\n        this.onDragStart(pointer.canvasPos);\n        this.dragLastPos = pointer.canvasPos;\n        return true;\n    }\n    handleDragUpdate(pointer) {\n        if (!this.dragLastPos) {\n            return;\n        }\n        this.onDragUpdate(pointer.canvasPos);\n    }\n    handleDragEnd() {\n        if (!this.dragLastPos) {\n            return;\n        }\n        return this.onDragEnd();\n    }\n    setSnapToGrid(snap) {\n        this.snapToGrid = snap;\n    }\n    isSnappingToGrid() {\n        return this.snapToGrid;\n    }\n}\n","import { Rect2, Vec2 } from '@js-draw/math';\nimport  { cssPrefix }  from './SelectionTool.mjs';\nconst verticalOffset = 40;\nexport default class SelectionMenuShortcut {\n    constructor(parent, viewport, icon, showContextMenu, localization) {\n        this.parent = parent;\n        this.viewport = viewport;\n        this.icon = icon;\n        this.localization = localization;\n        this.lastDragPointer = null;\n        this.element = document.createElement('div');\n        this.element.classList.add(`${cssPrefix}handle`, `${cssPrefix}selection-menu`);\n        this.element.style.setProperty('--vertical-offset', `${verticalOffset}px`);\n        this.onClick = () => {\n            this.button?.focus({ preventScroll: true });\n            const anchor = this.getBBoxCanvasCoords().center;\n            showContextMenu(anchor);\n        };\n        this.initUI();\n        this.updatePosition();\n    }\n    initUI() {\n        const button = document.createElement('button');\n        this.icon.classList.add('icon');\n        button.replaceChildren(this.icon);\n        button.ariaLabel = this.localization.selectionMenu__show;\n        button.title = button.ariaLabel;\n        this.button = button;\n        // To prevent editor event handlers from conflicting with those for the button,\n        // don't register a [click] handler. An onclick handler can be fired incorrectly\n        // in this case (in Chrome) after onClick is fired in onDragEnd, leading to a double\n        // on-click action.\n        button.onkeydown = (event) => {\n            if (event.key === 'Enter') {\n                // .preventDefault prevents [Enter] from activating the first item in the\n                // selection menu.\n                event.preventDefault();\n                this.onClick();\n            }\n        };\n        this.element.appendChild(button);\n        // Update the bounding box of this in response to the new button.\n        requestAnimationFrame(() => {\n            this.updatePosition();\n        });\n    }\n    addTo(container) {\n        container.appendChild(this.element);\n    }\n    remove() {\n        this.element.remove();\n    }\n    getElementScreenSize() {\n        return Vec2.of(this.element.clientWidth, this.element.clientHeight);\n    }\n    /** Gets this menu's bounding box relative to the top left of its parent. */\n    getBBoxParentCoords() {\n        const topLeft = Vec2.of(0, -verticalOffset);\n        const screenSize = this.getElementScreenSize();\n        return new Rect2(topLeft.x, topLeft.y, screenSize.x, screenSize.y);\n    }\n    getBBoxCanvasCoords() {\n        const parentCanvasRect = this.parent.region;\n        const toCanvasScale = this.viewport.getSizeOfPixelOnCanvas();\n        // Don't apply rotation -- rotation is handled by the selection container\n        const contentCanvasSize = this.getElementScreenSize().times(toCanvasScale);\n        const handleSizeCanvas = verticalOffset / this.viewport.getScaleFactor();\n        const topLeft = Vec2.of(parentCanvasRect.x, parentCanvasRect.y - handleSizeCanvas);\n        const minSize = Vec2.of(48, 48).times(toCanvasScale);\n        return new Rect2(topLeft.x, topLeft.y, contentCanvasSize.x, contentCanvasSize.y).grownToSize(minSize);\n    }\n    updatePosition() {\n        const bbox = this.getBBoxParentCoords();\n        // Position within the selection box.\n        this.element.style.marginLeft = `${bbox.topLeft.x}px`;\n        this.element.style.marginTop = `${bbox.topLeft.y}px`;\n    }\n    containsPoint(canvasPoint) {\n        return this.getBBoxCanvasCoords().containsPoint(canvasPoint);\n    }\n    handleDragStart(pointer) {\n        this.lastDragPointer = pointer;\n        return true;\n    }\n    handleDragUpdate(pointer) {\n        this.lastDragPointer = pointer;\n    }\n    handleDragEnd() {\n        if (this.lastDragPointer && this.containsPoint(this.lastDragPointer.canvasPos)) {\n            this.onClick();\n        }\n        this.lastDragPointer = null;\n    }\n}\n","import { Mat33, Vec2 } from '@js-draw/math';\nimport  { EditorEventType }  from '../../types.mjs';\nimport  Viewport  from '../../Viewport.mjs';\nimport  BaseTool  from '../BaseTool.mjs';\nimport  CanvasRenderer  from '../../rendering/renderers/CanvasRenderer.mjs';\nimport  SVGRenderer  from '../../rendering/renderers/SVGRenderer.mjs';\nimport  Selection  from './Selection.mjs';\nimport  TextComponent  from '../../components/TextComponent.mjs';\nimport  { duplicateSelectionShortcut, translateLeftSelectionShortcutId, translateRightSelectionShortcutId, selectAllKeyboardShortcut, sendToBackSelectionShortcut, snapToGridKeyboardShortcutId, translateDownSelectionShortcutId, translateUpSelectionShortcutId, rotateClockwiseSelectionShortcutId, rotateCounterClockwiseSelectionShortcutId, stretchXSelectionShortcutId, shrinkXSelectionShortcutId, shrinkYSelectionShortcutId, stretchYSelectionShortcutId, stretchXYSelectionShortcutId, shrinkXYSelectionShortcutId, }  from '../keybindings.mjs';\nimport  ToPointerAutoscroller  from './ToPointerAutoscroller.mjs';\nimport  showSelectionContextMenu  from './util/showSelectionContextMenu.mjs';\nexport const cssPrefix = 'selection-tool-';\n// Allows users to select/transform portions of the `EditorImage`.\n// With respect to `extend`ing, `SelectionTool` is not stable.\nexport default class SelectionTool extends BaseTool {\n    constructor(editor, description) {\n        super(editor.notifier, description);\n        this.editor = editor;\n        // True if clearing and recreating the selectionBox has been deferred. This is used to prevent the selection\n        // from vanishing on pointerdown events that are intended to form other gestures (e.g. long press) that would\n        // ultimately restore the selection.\n        this.rebuildSelectionScheduled = false;\n        this.startPoint = null; // canvas position\n        this.expandingSelectionBox = false;\n        this.shiftKeyPressed = false;\n        this.snapToGrid = false;\n        this.lastPointer = null;\n        this.showContextMenu = async (canvasAnchor, preferSelectionMenu = true) => {\n            await showSelectionContextMenu(this.selectionBox, this.editor, canvasAnchor, preferSelectionMenu, () => this.clearSelection());\n        };\n        this.selectionBoxHandlingEvt = false;\n        this.lastSelectedObjects = [];\n        // Whether the last keypress corresponded to an action that didn't transform the\n        // selection (and thus does not need to be finalized on onKeyUp).\n        this.hasUnfinalizedTransformFromKeyPress = false;\n        this.autoscroller = new ToPointerAutoscroller(editor.viewport, (scrollBy) => {\n            editor.dispatch(Viewport.transformBy(Mat33.translation(scrollBy)), false);\n            // Update the selection box/content to match the new viewport.\n            if (this.lastPointer) {\n                // The viewport has changed -- ensure that the screen and canvas positions\n                // of the pointer are both correct\n                const updatedPointer = this.lastPointer.withScreenPosition(this.lastPointer.screenPos, editor.viewport);\n                this.onMainPointerUpdated(updatedPointer);\n            }\n        });\n        this.handleOverlay = document.createElement('div');\n        editor.createHTMLOverlay(this.handleOverlay);\n        this.handleOverlay.style.display = 'none';\n        this.handleOverlay.classList.add('handleOverlay');\n        editor.notifier.on(EditorEventType.ViewportChanged, (_data) => {\n            // The selection box could be using the wet ink display if its transformation\n            // hasn't been finalized yet. Clear before updating the UI.\n            this.editor.clearWetInk();\n            // If not currently selecting, ensure that the selection box\n            // is large enough.\n            if (!this.expandingSelectionBox) {\n                this.selectionBox?.padRegion();\n            }\n            this.selectionBox?.updateUI();\n        });\n        this.editor.handleKeyEventsFrom(this.handleOverlay);\n        this.editor.handlePointerEventsFrom(this.handleOverlay);\n    }\n    makeSelectionBox(selectionStartPos) {\n        this.prevSelectionBox = this.selectionBox;\n        this.selectionBox = new Selection(selectionStartPos, this.editor, this.showContextMenu);\n        if (!this.expandingSelectionBox) {\n            // Remove any previous selection rects\n            this.prevSelectionBox?.cancelSelection();\n        }\n        this.selectionBox.addTo(this.handleOverlay);\n    }\n    snapSelectionToGrid() {\n        if (!this.selectionBox)\n            throw new Error('No selection to snap!');\n        // Snap the top left corner of what we have selected.\n        const topLeftOfBBox = this.selectionBox.computeTightBoundingBox().topLeft;\n        const snappedTopLeft = this.editor.viewport.snapToGrid(topLeftOfBBox);\n        const snapDelta = snappedTopLeft.minus(topLeftOfBBox);\n        const oldTransform = this.selectionBox.getTransform();\n        this.selectionBox.setTransform(oldTransform.rightMul(Mat33.translation(snapDelta)));\n        this.selectionBox.finalizeTransform();\n    }\n    onContextMenu(event) {\n        const canShowSelectionMenu = this.selectionBox\n            ?.getScreenRegion()\n            ?.containsPoint(event.screenPos);\n        void this.showContextMenu(event.canvasPos, canShowSelectionMenu);\n        return true;\n    }\n    onPointerDown({ allPointers, current }) {\n        const snapToGrid = this.snapToGrid;\n        if (snapToGrid) {\n            current = current.snappedToGrid(this.editor.viewport);\n        }\n        // Don't rely on .isPrimary -- it's buggy in Firefox. See https://github.com/personalizedrefrigerator/js-draw/issues/71\n        if (allPointers.length === 1) {\n            this.startPoint = current.canvasPos;\n            let transforming = false;\n            if (this.selectionBox) {\n                if (snapToGrid) {\n                    this.snapSelectionToGrid();\n                }\n                const dragStartResult = this.selectionBox.onDragStart(current);\n                if (dragStartResult) {\n                    transforming = true;\n                    this.selectionBoxHandlingEvt = true;\n                    this.expandingSelectionBox = false;\n                }\n            }\n            if (!transforming) {\n                // Shift key: Combine the new and old selection boxes at the end of the gesture.\n                this.expandingSelectionBox = this.shiftKeyPressed;\n                this.rebuildSelectionScheduled = true;\n            }\n            else {\n                // Only autoscroll if we're transforming an existing selection\n                this.autoscroller.start();\n            }\n            return true;\n        }\n        return false;\n    }\n    onPointerMove(event) {\n        this.onMainPointerUpdated(event.current);\n    }\n    onMainPointerUpdated(currentPointer) {\n        this.lastPointer = currentPointer;\n        if (this.rebuildSelectionScheduled) {\n            this.rebuildSelectionScheduled = false;\n            this.makeSelectionBox(this.startPoint ?? currentPointer.canvasPos);\n            this.selectionBox?.setHandlesVisible(false);\n        }\n        if (!this.selectionBox)\n            return;\n        this.autoscroller.onPointerMove(currentPointer.screenPos);\n        if (!this.expandingSelectionBox && this.shiftKeyPressed && this.startPoint) {\n            const screenPos = this.editor.viewport.canvasToScreen(this.startPoint);\n            currentPointer = currentPointer.lockedToXYAxesScreen(screenPos, this.editor.viewport);\n        }\n        if (this.snapToGrid) {\n            currentPointer = currentPointer.snappedToGrid(this.editor.viewport);\n        }\n        if (this.selectionBoxHandlingEvt) {\n            this.selectionBox.onDragUpdate(currentPointer);\n        }\n        else {\n            this.selectionBox.setToPoint(currentPointer.canvasPos);\n        }\n    }\n    onPointerUp(event) {\n        this.onMainPointerUpdated(event.current);\n        this.autoscroller.stop();\n        if (!this.selectionBox)\n            return;\n        this.selectionBox.setHandlesVisible(true);\n        // Were we expanding the previous selection?\n        if (this.expandingSelectionBox && this.prevSelectionBox) {\n            // If so, finish expanding.\n            this.expandingSelectionBox = false;\n            this.selectionBox.resolveToObjects();\n            this.setSelection([\n                ...this.selectionBox.getSelectedObjects(),\n                ...this.prevSelectionBox.getSelectedObjects(),\n            ]);\n        }\n        else {\n            if (!this.selectionBoxHandlingEvt) {\n                // Expand/shrink the selection rectangle, if applicable\n                this.selectionBox.resolveToObjects();\n                this.onSelectionUpdated();\n            }\n            else {\n                this.selectionBox.onDragEnd();\n            }\n            this.selectionBoxHandlingEvt = false;\n            this.lastPointer = null;\n        }\n    }\n    onGestureCancel() {\n        this.autoscroller.stop();\n        if (this.selectionBoxHandlingEvt) {\n            this.selectionBox?.onDragCancel();\n        }\n        else if (!this.rebuildSelectionScheduled) {\n            // Revert to the previous selection, if any.\n            this.selectionBox?.cancelSelection();\n            this.selectionBox = this.prevSelectionBox;\n            this.selectionBox?.addTo(this.handleOverlay);\n            this.selectionBox?.recomputeRegion();\n            this.prevSelectionBox = null;\n        }\n        this.rebuildSelectionScheduled = false;\n        this.expandingSelectionBox = false;\n        this.lastPointer = null;\n        this.selectionBoxHandlingEvt = false;\n    }\n    onSelectionUpdated() {\n        const selectedItemCount = this.selectionBox?.getSelectedItemCount() ?? 0;\n        const selectedObjects = this.selectionBox?.getSelectedObjects() ?? [];\n        const hasDifferentSelection = this.lastSelectedObjects.length !== selectedItemCount ||\n            selectedObjects.some((obj, i) => this.lastSelectedObjects[i] !== obj);\n        if (hasDifferentSelection) {\n            this.lastSelectedObjects = selectedObjects;\n            // Note that the selection has changed\n            this.editor.notifier.dispatch(EditorEventType.ToolUpdated, {\n                kind: EditorEventType.ToolUpdated,\n                tool: this,\n            });\n            // Only fire the SelectionUpdated event if the selection really updated.\n            this.editor.notifier.dispatch(EditorEventType.SelectionUpdated, {\n                kind: EditorEventType.SelectionUpdated,\n                selectedComponents: selectedObjects,\n                tool: this,\n            });\n            if (selectedItemCount > 0) {\n                this.editor.announceForAccessibility(this.editor.localization.selectedElements(selectedItemCount));\n                this.zoomToSelection();\n            }\n        }\n        if (selectedItemCount === 0 && this.selectionBox) {\n            this.selectionBox.cancelSelection();\n            this.prevSelectionBox = this.selectionBox;\n            this.selectionBox = null;\n        }\n    }\n    zoomToSelection() {\n        if (this.selectionBox) {\n            const selectionRect = this.selectionBox.region;\n            this.editor.dispatchNoAnnounce(this.editor.viewport.zoomTo(selectionRect, false), false);\n        }\n    }\n    onKeyPress(event) {\n        const shortcucts = this.editor.shortcuts;\n        if (shortcucts.matchesShortcut(snapToGridKeyboardShortcutId, event)) {\n            this.snapToGrid = true;\n            return true;\n        }\n        if (this.selectionBox &&\n            (shortcucts.matchesShortcut(duplicateSelectionShortcut, event) ||\n                shortcucts.matchesShortcut(sendToBackSelectionShortcut, event))) {\n            // Handle duplication on key up — we don't want to accidentally duplicate\n            // many times.\n            return true;\n        }\n        else if (shortcucts.matchesShortcut(selectAllKeyboardShortcut, event)) {\n            this.setSelection(this.editor.image.getAllElements());\n            return true;\n        }\n        else if (event.ctrlKey) {\n            // Don't transform the selection with, for example, ctrl+i.\n            // Pass it to another tool, if apliccable.\n            return false;\n        }\n        else if (event.shiftKey || event.key === 'Shift') {\n            this.shiftKeyPressed = true;\n            if (event.key === 'Shift') {\n                return true;\n            }\n        }\n        let rotationSteps = 0;\n        let xTranslateSteps = 0;\n        let yTranslateSteps = 0;\n        let xScaleSteps = 0;\n        let yScaleSteps = 0;\n        if (shortcucts.matchesShortcut(translateLeftSelectionShortcutId, event)) {\n            xTranslateSteps -= 1;\n        }\n        else if (shortcucts.matchesShortcut(translateRightSelectionShortcutId, event)) {\n            xTranslateSteps += 1;\n        }\n        else if (shortcucts.matchesShortcut(translateUpSelectionShortcutId, event)) {\n            yTranslateSteps -= 1;\n        }\n        else if (shortcucts.matchesShortcut(translateDownSelectionShortcutId, event)) {\n            yTranslateSteps += 1;\n        }\n        else if (shortcucts.matchesShortcut(rotateClockwiseSelectionShortcutId, event)) {\n            rotationSteps += 1;\n        }\n        else if (shortcucts.matchesShortcut(rotateCounterClockwiseSelectionShortcutId, event)) {\n            rotationSteps -= 1;\n        }\n        else if (shortcucts.matchesShortcut(shrinkXSelectionShortcutId, event)) {\n            xScaleSteps -= 1;\n        }\n        else if (shortcucts.matchesShortcut(stretchXSelectionShortcutId, event)) {\n            xScaleSteps += 1;\n        }\n        else if (shortcucts.matchesShortcut(shrinkYSelectionShortcutId, event)) {\n            yScaleSteps -= 1;\n        }\n        else if (shortcucts.matchesShortcut(stretchYSelectionShortcutId, event)) {\n            yScaleSteps += 1;\n        }\n        else if (shortcucts.matchesShortcut(shrinkXYSelectionShortcutId, event)) {\n            xScaleSteps -= 1;\n            yScaleSteps -= 1;\n        }\n        else if (shortcucts.matchesShortcut(stretchXYSelectionShortcutId, event)) {\n            xScaleSteps += 1;\n            yScaleSteps += 1;\n        }\n        let handled = xTranslateSteps !== 0 ||\n            yTranslateSteps !== 0 ||\n            rotationSteps !== 0 ||\n            xScaleSteps !== 0 ||\n            yScaleSteps !== 0;\n        if (!this.selectionBox) {\n            handled = false;\n        }\n        else if (handled) {\n            const translateStepSize = 10 * this.editor.viewport.getSizeOfPixelOnCanvas();\n            const rotateStepSize = Math.PI / 8;\n            const scaleStepSize = 5 / 4;\n            const region = this.selectionBox.region;\n            const scaleFactor = Vec2.of(scaleStepSize ** xScaleSteps, scaleStepSize ** yScaleSteps);\n            const rotationMat = Mat33.zRotation(rotationSteps * rotateStepSize);\n            const roundedRotationMatrix = rotationMat.mapEntries((component) => Viewport.roundScaleRatio(component));\n            const regionCenter = this.editor.viewport.roundPoint(region.center);\n            const transform = Mat33.scaling2D(scaleFactor, this.editor.viewport.roundPoint(region.topLeft))\n                .rightMul(Mat33.translation(regionCenter)\n                .rightMul(roundedRotationMatrix)\n                .rightMul(Mat33.translation(regionCenter.times(-1))))\n                .rightMul(Mat33.translation(this.editor.viewport.roundPoint(Vec2.of(xTranslateSteps, yTranslateSteps).times(translateStepSize))));\n            const oldTransform = this.selectionBox.getTransform();\n            this.selectionBox.setTransform(oldTransform.rightMul(transform));\n            this.selectionBox.scrollTo();\n            // The transformation needs to be finalized at some point (on key up)\n            this.hasUnfinalizedTransformFromKeyPress = true;\n        }\n        if (this.selectionBox && !handled && (event.key === 'Delete' || event.key === 'Backspace')) {\n            this.editor.dispatch(this.selectionBox.deleteSelectedObjects());\n            this.clearSelection();\n            handled = true;\n        }\n        return handled;\n    }\n    onKeyUp(evt) {\n        const shortcucts = this.editor.shortcuts;\n        if (shortcucts.matchesShortcut(snapToGridKeyboardShortcutId, evt)) {\n            this.snapToGrid = false;\n            return true;\n        }\n        if (shortcucts.matchesShortcut(selectAllKeyboardShortcut, evt)) {\n            // Selected all in onKeyDown. Don't finalizeTransform.\n            return true;\n        }\n        if (this.selectionBox && shortcucts.matchesShortcut(duplicateSelectionShortcut, evt)) {\n            // Finalize duplicating the selection\n            this.selectionBox.duplicateSelectedObjects().then((command) => {\n                this.editor.dispatch(command);\n            });\n            return true;\n        }\n        if (this.selectionBox && shortcucts.matchesShortcut(sendToBackSelectionShortcut, evt)) {\n            const sendToBackCommand = this.selectionBox.sendToBack();\n            if (sendToBackCommand) {\n                this.editor.dispatch(sendToBackCommand);\n            }\n            return true;\n        }\n        // Here, we check if shiftKey === false because, as of this writing,\n        // evt.shiftKey is an optional property. Being falsey could just mean\n        // that it wasn't set.\n        if (evt.shiftKey === false) {\n            this.shiftKeyPressed = false;\n            // Don't return immediately -- event may be otherwise handled\n        }\n        // Also check for key === 'Shift' (for the case where shiftKey is undefined)\n        if (evt.key === 'Shift') {\n            this.shiftKeyPressed = false;\n            return true;\n        }\n        // If we don't need to finalize the transform\n        if (!this.hasUnfinalizedTransformFromKeyPress) {\n            return true;\n        }\n        if (this.selectionBox) {\n            this.selectionBox.finalizeTransform();\n            this.hasUnfinalizedTransformFromKeyPress = false;\n            return true;\n        }\n        return false;\n    }\n    onCopy(event) {\n        if (!this.selectionBox) {\n            return false;\n        }\n        const selectedElems = this.selectionBox.getSelectedObjects();\n        const bbox = this.selectionBox.region;\n        if (selectedElems.length === 0) {\n            return false;\n        }\n        const exportViewport = new Viewport(() => { });\n        const selectionScreenSize = this.selectionBox\n            .getScreenRegion()\n            .size.times(this.editor.display.getDevicePixelRatio());\n        // Update the viewport to have screen size roughly equal to the size of the selection box\n        let scaleFactor = selectionScreenSize.maximumEntryMagnitude() / (bbox.size.maximumEntryMagnitude() || 1);\n        // Round to a nearby power of two\n        scaleFactor = Math.pow(2, Math.ceil(Math.log2(scaleFactor)));\n        exportViewport.updateScreenSize(bbox.size.times(scaleFactor));\n        exportViewport.resetTransform(Mat33.scaling2D(scaleFactor)\n            // Move the selection onto the screen\n            .rightMul(Mat33.translation(bbox.topLeft.times(-1))));\n        const { element: svgExportElem, renderer: svgRenderer } = SVGRenderer.fromViewport(exportViewport, { sanitize: true, useViewBoxForPositioning: true });\n        const { element: canvas, renderer: canvasRenderer } = CanvasRenderer.fromViewport(exportViewport, { maxCanvasDimen: 4096 });\n        const text = [];\n        for (const elem of selectedElems) {\n            elem.render(svgRenderer);\n            elem.render(canvasRenderer);\n            if (elem instanceof TextComponent) {\n                text.push(elem.getText());\n            }\n        }\n        event.setData('image/svg+xml', svgExportElem.outerHTML);\n        event.setData('text/html', svgExportElem.outerHTML);\n        event.setData('image/png', new Promise((resolve, reject) => {\n            canvas.toBlob((blob) => {\n                if (blob) {\n                    resolve(blob);\n                }\n                else {\n                    reject(new Error('Failed to convert canvas to blob.'));\n                }\n            }, 'image/png');\n        }));\n        if (text.length > 0) {\n            event.setData('text/plain', text.join('\\n'));\n        }\n        return true;\n    }\n    setEnabled(enabled) {\n        const wasEnabled = this.isEnabled();\n        super.setEnabled(enabled);\n        if (wasEnabled === enabled) {\n            return;\n        }\n        // Clear the selection\n        this.selectionBox?.cancelSelection();\n        this.onSelectionUpdated();\n        this.handleOverlay.replaceChildren();\n        this.selectionBox = null;\n        this.shiftKeyPressed = false;\n        this.snapToGrid = false;\n        this.handleOverlay.style.display = enabled ? 'block' : 'none';\n        if (enabled) {\n            this.handleOverlay.tabIndex = 0;\n            this.handleOverlay.setAttribute('aria-label', this.editor.localization.selectionToolKeyboardShortcuts);\n        }\n        else {\n            this.handleOverlay.tabIndex = -1;\n        }\n    }\n    // Get the object responsible for displaying this' selection.\n    // @internal\n    getSelection() {\n        return this.selectionBox;\n    }\n    getSelectedObjects() {\n        return this.selectionBox?.getSelectedObjects() ?? [];\n    }\n    // Select the given `objects`. Any non-selectable objects in `objects` are ignored.\n    setSelection(objects) {\n        // Only select selectable objects.\n        objects = objects.filter((obj) => obj.isSelectable());\n        // Sort by z-index\n        objects.sort((a, b) => a.getZIndex() - b.getZIndex());\n        // Remove duplicates\n        objects = objects.filter((current, idx) => {\n            if (idx > 0) {\n                return current !== objects[idx - 1];\n            }\n            return true;\n        });\n        let bbox = null;\n        for (const object of objects) {\n            if (bbox) {\n                bbox = bbox.union(object.getBBox());\n            }\n            else {\n                bbox = object.getBBox();\n            }\n        }\n        if (!bbox) {\n            return;\n        }\n        this.clearSelection();\n        if (!this.selectionBox) {\n            this.makeSelectionBox(bbox.topLeft);\n        }\n        this.selectionBox.setSelectedObjects(objects, bbox);\n        this.onSelectionUpdated();\n    }\n    clearSelection() {\n        this.handleOverlay.replaceChildren();\n        this.prevSelectionBox = this.selectionBox;\n        this.selectionBox = null;\n        this.onSelectionUpdated();\n    }\n}\n","import { Rect2, Vec2 } from '@js-draw/math';\nimport  untilNextAnimationFrame  from '../../util/untilNextAnimationFrame.mjs';\n/**\n * Automatically scrolls the viewport such that the user's pointer is visible.\n */\nexport default class ToPointerAutoscroller {\n    constructor(viewport, scrollByCanvasDelta) {\n        this.viewport = viewport;\n        this.scrollByCanvasDelta = scrollByCanvasDelta;\n        this.started = false;\n        this.updateLoopId = 0;\n        this.updateLoopRunning = false;\n        this.targetPoint = null;\n        this.scrollRate = 1000; // px/s\n    }\n    getScrollForPoint(screenPoint) {\n        const screenSize = this.viewport.getScreenRectSize();\n        const screenRect = new Rect2(0, 0, screenSize.x, screenSize.y);\n        // Starts autoscrolling when the cursor is **outside of** this region\n        const marginSize = 44;\n        const autoscrollBoundary = screenRect.grownBy(-marginSize);\n        if (autoscrollBoundary.containsPoint(screenPoint)) {\n            return Vec2.zero;\n        }\n        const closestEdgePoint = autoscrollBoundary.getClosestPointOnBoundaryTo(screenPoint);\n        const distToEdge = closestEdgePoint.distanceTo(screenPoint);\n        const toEdge = closestEdgePoint.minus(screenPoint);\n        // Go faster for points further away from the boundary.\n        const maximumScaleFactor = 1.25;\n        const scaleFactor = Math.min(distToEdge / marginSize, maximumScaleFactor);\n        return toEdge.normalizedOrZero().times(scaleFactor);\n    }\n    start() {\n        this.started = true;\n    }\n    onPointerMove(pointerScreenPosition) {\n        if (!this.started) {\n            return;\n        }\n        if (this.getScrollForPoint(pointerScreenPosition) === Vec2.zero) {\n            this.stopUpdateLoop();\n        }\n        else {\n            this.targetPoint = pointerScreenPosition;\n            this.startUpdateLoop();\n        }\n    }\n    stop() {\n        this.targetPoint = null;\n        this.started = false;\n        this.stopUpdateLoop();\n    }\n    startUpdateLoop() {\n        if (this.updateLoopRunning) {\n            return;\n        }\n        (async () => {\n            this.updateLoopId++;\n            const currentUpdateLoopId = this.updateLoopId;\n            let lastUpdateTime = performance.now();\n            while (this.updateLoopId === currentUpdateLoopId && this.targetPoint) {\n                this.updateLoopRunning = true;\n                const currentTime = performance.now();\n                const deltaTimeMs = currentTime - lastUpdateTime;\n                const scrollDirection = this.getScrollForPoint(this.targetPoint);\n                const screenScrollAmount = scrollDirection.times((this.scrollRate * deltaTimeMs) / 1000);\n                this.scrollByCanvasDelta(this.viewport.screenToCanvasTransform.transformVec3(screenScrollAmount));\n                lastUpdateTime = currentTime;\n                await untilNextAnimationFrame();\n            }\n            this.updateLoopRunning = false;\n        })();\n    }\n    stopUpdateLoop() {\n        this.updateLoopId++;\n    }\n}\n","import { Mat33, Vec2 } from '@js-draw/math';\nimport  Viewport  from '../../Viewport.mjs';\nimport  { ResizeMode }  from './types.mjs';\nexport class DragTransformer {\n    constructor(editor, selection) {\n        this.editor = editor;\n        this.selection = selection;\n    }\n    onDragStart(startPoint) {\n        this.selection.setTransform(Mat33.identity);\n        this.dragStartPoint = startPoint;\n    }\n    onDragUpdate(canvasPos) {\n        const delta = this.editor.viewport.roundPoint(canvasPos.minus(this.dragStartPoint));\n        this.selection.setTransform(Mat33.translation(delta));\n    }\n    onDragEnd() {\n        return this.selection.finalizeTransform();\n    }\n}\nexport class ResizeTransformer {\n    constructor(editor, selection) {\n        this.editor = editor;\n        this.selection = selection;\n        this.mode = ResizeMode.Both;\n    }\n    onDragStart(startPoint, mode) {\n        this.selection.setTransform(Mat33.identity);\n        this.mode = mode;\n        this.dragStartPoint = startPoint;\n        this.computeOriginAndScaleRate();\n    }\n    computeOriginAndScaleRate() {\n        // Store the index of the furthest corner from startPoint. We'll use that\n        // to determine where the transform considers (0, 0) (where we scale from).\n        const selectionRect = this.selection.preTransformRegion;\n        const selectionBoxCorners = selectionRect.corners;\n        let largestDistSquared = 0;\n        for (let i = 0; i < selectionBoxCorners.length; i++) {\n            const currentCorner = selectionBoxCorners[i];\n            const distSquaredToCurrent = this.dragStartPoint.minus(currentCorner).magnitudeSquared();\n            if (distSquaredToCurrent > largestDistSquared) {\n                largestDistSquared = distSquaredToCurrent;\n                this.transformOrigin = currentCorner;\n            }\n        }\n        // Determine whether moving the mouse to the right increases or decreases the width.\n        let widthScaleRate = 1;\n        let heightScaleRate = 1;\n        if (this.transformOrigin.x > selectionRect.center.x) {\n            widthScaleRate = -1;\n        }\n        if (this.transformOrigin.y > selectionRect.center.y) {\n            heightScaleRate = -1;\n        }\n        this.scaleRate = Vec2.of(widthScaleRate, heightScaleRate);\n    }\n    onDragUpdate(canvasPos) {\n        const canvasDelta = canvasPos.minus(this.dragStartPoint);\n        const origWidth = this.selection.preTransformRegion.width;\n        const origHeight = this.selection.preTransformRegion.height;\n        let scale = Vec2.of(1, 1);\n        if (this.mode === ResizeMode.HorizontalOnly) {\n            const newWidth = origWidth + canvasDelta.x * this.scaleRate.x;\n            scale = Vec2.of(newWidth / origWidth, scale.y);\n        }\n        if (this.mode === ResizeMode.VerticalOnly) {\n            const newHeight = origHeight + canvasDelta.y * this.scaleRate.y;\n            scale = Vec2.of(scale.x, newHeight / origHeight);\n        }\n        if (this.mode === ResizeMode.Both) {\n            const delta = Math.abs(canvasDelta.x) > Math.abs(canvasDelta.y) ? canvasDelta.x : canvasDelta.y;\n            const newWidth = origWidth + delta;\n            scale = Vec2.of(newWidth / origWidth, newWidth / origWidth);\n        }\n        // Round: If this isn't done, scaling can create numbers with long decimal representations.\n        //    long decimal representations => large file sizes.\n        scale = scale.map((component) => Viewport.roundScaleRatio(component, 2));\n        if (scale.x !== 0 && scale.y !== 0) {\n            const origin = this.editor.viewport.roundPoint(this.transformOrigin);\n            this.selection.setTransform(Mat33.scaling2D(scale, origin));\n        }\n    }\n    onDragEnd() {\n        return this.selection.finalizeTransform();\n    }\n}\nexport class RotateTransformer {\n    constructor(editor, selection) {\n        this.editor = editor;\n        this.selection = selection;\n        this.startAngle = 0;\n        this.targetRotation = 0;\n        this.maximumDistFromStart = 0;\n    }\n    getAngle(canvasPoint) {\n        const selectionCenter = this.selection.preTransformRegion.center;\n        const offset = canvasPoint.minus(selectionCenter);\n        return offset.angle();\n    }\n    roundAngle(angle) {\n        // Round angles to the nearest 16th of a turn\n        const roundingFactor = 16 / 2 / Math.PI;\n        return Math.round(angle * roundingFactor) / roundingFactor;\n    }\n    onDragStart(startPoint) {\n        this.startPoint = startPoint;\n        this.selection.setTransform(Mat33.identity);\n        this.startAngle = this.getAngle(startPoint);\n        this.targetRotation = 0;\n        // Used to determine whether the user clicked or not.\n        this.maximumDistFromStart = 0;\n        this.startTime = performance.now();\n    }\n    setRotationTo(angle) {\n        // Transform in canvas space\n        const canvasSelCenter = this.editor.viewport.roundPoint(this.selection.preTransformRegion.center);\n        const unrounded = Mat33.zRotation(angle);\n        const roundedRotationTransform = unrounded.mapEntries((entry) => Viewport.roundScaleRatio(entry));\n        const fullRoundedTransform = Mat33.translation(canvasSelCenter)\n            .rightMul(roundedRotationTransform)\n            .rightMul(Mat33.translation(canvasSelCenter.times(-1)));\n        this.selection.setTransform(fullRoundedTransform);\n    }\n    onDragUpdate(canvasPos) {\n        this.targetRotation = this.roundAngle(this.getAngle(canvasPos) - this.startAngle);\n        this.setRotationTo(this.targetRotation);\n        const distFromStart = canvasPos.minus(this.startPoint).magnitude();\n        if (distFromStart > this.maximumDistFromStart) {\n            this.maximumDistFromStart = distFromStart;\n        }\n    }\n    onDragEnd() {\n        // Anything with motion less than this is considered a click\n        const clickThresholdDist = 10;\n        const clickThresholdTime = 0.4; // s\n        const dragTimeSeconds = (performance.now() - this.startTime) / 1000;\n        if (dragTimeSeconds < clickThresholdTime &&\n            this.maximumDistFromStart < clickThresholdDist &&\n            this.targetRotation === 0) {\n            this.setRotationTo(-Math.PI / 2);\n        }\n        return this.selection.finalizeTransform();\n    }\n}\n","import  KeyboardShortcutManager  from '../../shortcuts/KeyboardShortcutManager.mjs';\n// Selection\nexport const selectAllKeyboardShortcut = 'jsdraw.tools.SelectionTool.selectAll';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(selectAllKeyboardShortcut, ['CtrlOrMeta+KeyA'], 'Select all');\nexport const duplicateSelectionShortcut = 'jsdraw.tools.SelectionTool.duplicateSelection';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(duplicateSelectionShortcut, ['CtrlOrMeta+KeyD'], 'Duplicate selection');\nexport const sendToBackSelectionShortcut = 'jsdraw.tools.SelectionTool.sendToBack';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(sendToBackSelectionShortcut, ['End'], 'Send to back');\nexport const translateLeftSelectionShortcutId = 'jsdraw.tools.SelectionTool.translateLeft';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(translateLeftSelectionShortcutId, ['KeyA', 'KeyH', 'ArrowLeft'], 'Move selection left');\nexport const translateRightSelectionShortcutId = 'jsdraw.tools.SelectionTool.translateRight';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(translateRightSelectionShortcutId, ['KeyD', 'KeyL', 'ArrowRight'], 'Move selection right');\nexport const translateUpSelectionShortcutId = 'jsdraw.tools.SelectionTool.translateUp';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(translateUpSelectionShortcutId, ['KeyQ', 'KeyK', 'ArrowUp'], 'Move selection up');\nexport const translateDownSelectionShortcutId = 'jsdraw.tools.SelectionTool.translateDown';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(translateDownSelectionShortcutId, ['KeyE', 'KeyJ', 'ArrowDown'], 'Move selection down');\nexport const rotateCounterClockwiseSelectionShortcutId = 'jsdraw.tools.SelectionTool.rotateCCW';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(rotateCounterClockwiseSelectionShortcutId, ['Shift+KeyR'], 'Rotate selection counter clockwise');\nexport const rotateClockwiseSelectionShortcutId = 'jsdraw.tools.SelectionTool.rotateCW';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(rotateClockwiseSelectionShortcutId, ['KeyR'], 'Rotate selection clockwise');\nexport const shrinkXSelectionShortcutId = 'jsdraw.tools.SelectionTool.shrink.x';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(shrinkXSelectionShortcutId, ['KeyI'], 'Decrease width');\nexport const stretchXSelectionShortcutId = 'jsdraw.tools.SelectionTool.stretch.x';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(stretchXSelectionShortcutId, ['Shift+KeyI'], 'Increase width');\nexport const shrinkYSelectionShortcutId = 'jsdraw.tools.SelectionTool.shrink.y';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(shrinkYSelectionShortcutId, ['KeyO'], 'Decrease height');\nexport const stretchYSelectionShortcutId = 'jsdraw.tools.SelectionTool.stretch.y';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(stretchYSelectionShortcutId, ['Shift+KeyO'], 'Increase height');\nexport const shrinkXYSelectionShortcutId = 'jsdraw.tools.SelectionTool.shrink.xy';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(shrinkXYSelectionShortcutId, ['Comma'], 'Decrease selection size');\nexport const stretchXYSelectionShortcutId = 'jsdraw.tools.SelectionTool.stretch.xy';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(stretchXYSelectionShortcutId, ['Period'], 'Increase selection size');\n","export var ResizeMode;\n(function (ResizeMode) {\n    ResizeMode[ResizeMode[\"Both\"] = 0] = \"Both\";\n    ResizeMode[ResizeMode[\"HorizontalOnly\"] = 1] = \"HorizontalOnly\";\n    ResizeMode[ResizeMode[\"VerticalOnly\"] = 2] = \"VerticalOnly\";\n})(ResizeMode || (ResizeMode = {}));\nexport var TransformMode;\n(function (TransformMode) {\n    TransformMode[TransformMode[\"Snap\"] = 0] = \"Snap\";\n    TransformMode[TransformMode[\"NoSnap\"] = 1] = \"NoSnap\";\n})(TransformMode || (TransformMode = {}));\n","import  makeMessageDialog  from '../../../dialogs/makeMessageDialog.mjs';\nimport  ClipboardHandler  from '../../../util/ClipboardHandler.mjs';\nconst makeClipboardErrorHandlers = (editor) => {\n    const makeErrorDialog = (error) => {\n        const dialog = makeMessageDialog(editor, {\n            title: editor.localization.copyPasteError__heading,\n            classNames: ['clipboard-error-dialog'],\n        });\n        dialog.appendChild(document.createTextNode(editor.localization.copyPasteError__description));\n        const errorDetailsElement = document.createElement('details');\n        const errorDetailsSummary = document.createElement('summary');\n        errorDetailsSummary.textContent = editor.localization.copyPasteError__errorDetails;\n        errorDetailsElement.appendChild(errorDetailsSummary);\n        errorDetailsElement.appendChild(document.createTextNode(`Error: ${error}`));\n        dialog.appendChild(errorDetailsElement);\n        return dialog;\n    };\n    return {\n        onCopyError(error) {\n            const dialog = makeErrorDialog(error);\n            const textboxLabel = document.createElement('label');\n            textboxLabel.textContent = editor.localization.copyPasteError__copyRetry;\n            const copyTextbox = document.createElement('textarea');\n            textboxLabel.appendChild(copyTextbox);\n            const retryHandler = new ClipboardHandler(editor);\n            const handleCopy = (event) => {\n                event.preventDefault();\n                // Use .then to ensure that .copy runs within the event handler.\n                // Copy can fail if certain logic is run async.\n                return retryHandler.copy(event).then(() => {\n                    dialog.close();\n                });\n            };\n            copyTextbox.oncopy = handleCopy;\n            copyTextbox.ondragstart = handleCopy;\n            copyTextbox.value = editor.localization.copyPasteError__copyMe;\n            dialog.appendChild(textboxLabel);\n            copyTextbox.select();\n            document.execCommand('copy');\n        },\n        onPasteError(error) {\n            const dialog = makeErrorDialog(error);\n            const textboxLabel = document.createElement('label');\n            textboxLabel.textContent = editor.localization.copyPasteError__pasteRetry;\n            const pasteTextbox = document.createElement('textarea');\n            textboxLabel.appendChild(pasteTextbox);\n            const retryHandler = new ClipboardHandler(editor);\n            const handlePaste = (event) => {\n                event.preventDefault();\n                // Use .then to ensure that .paste runs within the event handler.\n                // Paste can fail if certain logic is run async.\n                return retryHandler.paste(event).then((pasted) => {\n                    if (pasted) {\n                        dialog.close();\n                    }\n                });\n            };\n            pasteTextbox.onpaste = handlePaste;\n            pasteTextbox.ondrop = handlePaste;\n            dialog.appendChild(textboxLabel);\n            pasteTextbox.focus();\n            document.execCommand('paste');\n        },\n    };\n};\nexport default makeClipboardErrorHandlers;\n","import  createMenuOverlay  from '../../util/createMenuOverlay.mjs';\nimport  ClipboardHandler  from '../../../util/ClipboardHandler.mjs';\nimport  makeClipboardErrorHandlers  from './makeClipboardErrorHandlers.mjs';\nconst showSelectionContextMenu = async (selectionBox, editor, canvasAnchor, preferSelectionMenu, clearSelection) => {\n    const localization = editor.localization;\n    const showSelectionMenu = selectionBox?.getSelectedItemCount() && preferSelectionMenu;\n    const noSelectionMenu = [\n        {\n            text: localization.selectionMenu__paste,\n            icon: () => editor.icons.makePasteIcon(),\n            key: () => {\n                const clipboardHandler = new ClipboardHandler(editor, makeClipboardErrorHandlers(editor));\n                void clipboardHandler.paste();\n            },\n        },\n    ];\n    const onActivated = await createMenuOverlay(editor, canvasAnchor, showSelectionMenu\n        ? [\n            {\n                text: localization.selectionMenu__duplicate,\n                icon: () => editor.icons.makeDuplicateSelectionIcon(),\n                key: async () => {\n                    await editor.dispatch(await selectionBox.duplicateSelectedObjects());\n                },\n            },\n            {\n                text: localization.selectionMenu__delete,\n                icon: () => editor.icons.makeDeleteSelectionIcon(),\n                key: async () => {\n                    await editor.dispatch(selectionBox.deleteSelectedObjects());\n                    clearSelection();\n                },\n            },\n            {\n                text: localization.selectionMenu__copyToClipboard,\n                icon: () => editor.icons.makeCopyIcon(),\n                key: () => {\n                    const clipboardHandler = new ClipboardHandler(editor, makeClipboardErrorHandlers(editor));\n                    void clipboardHandler.copy();\n                },\n            },\n            ...noSelectionMenu,\n        ]\n        : noSelectionMenu);\n    onActivated?.();\n};\nexport default showSelectionContextMenu;\n","import { LineSegment2, Color4 } from '@js-draw/math';\nimport  BaseTool  from './BaseTool.mjs';\nclass SoundFeedback {\n    constructor() {\n        this.closed = false;\n        // No AudioContext? Exit!\n        if (!window.AudioContext) {\n            console.warn('Accessibility sound UI: Unable to open AudioContext.');\n            this.closed = true;\n            return;\n        }\n        this.ctx = new AudioContext();\n        // Color oscillator and gain\n        this.colorOscHue = this.ctx.createOscillator();\n        this.colorOscValue = this.ctx.createOscillator();\n        this.colorOscSaturation = this.ctx.createOscillator();\n        this.colorOscHue.type = 'triangle';\n        this.colorOscSaturation.type = 'sine';\n        this.colorOscValue.type = 'sawtooth';\n        this.valueGain = this.ctx.createGain();\n        this.colorOscValue.connect(this.valueGain);\n        this.valueGain.gain.setValueAtTime(0.18, this.ctx.currentTime);\n        this.colorGain = this.ctx.createGain();\n        this.colorOscHue.connect(this.colorGain);\n        this.valueGain.connect(this.colorGain);\n        this.colorOscSaturation.connect(this.colorGain);\n        this.colorGain.connect(this.ctx.destination);\n        // Boundary oscillator and gain\n        this.boundaryGain = this.ctx.createGain();\n        this.boundaryOsc = this.ctx.createOscillator();\n        this.boundaryOsc.type = 'sawtooth';\n        this.boundaryGain.gain.setValueAtTime(0, this.ctx.currentTime);\n        this.boundaryOsc.connect(this.boundaryGain);\n        this.boundaryGain.connect(this.ctx.destination);\n        // Prepare for the first announcement/feedback.\n        this.colorOscHue.start();\n        this.colorOscSaturation.start();\n        this.colorOscValue.start();\n        this.boundaryOsc.start();\n        this.pause();\n    }\n    pause() {\n        if (this.closed)\n            return;\n        this.colorGain.gain.setValueAtTime(0, this.ctx.currentTime);\n        void this.ctx.suspend();\n    }\n    play() {\n        if (this.closed)\n            return;\n        void this.ctx.resume();\n    }\n    setColor(color) {\n        const hsv = color.asHSV();\n        // Choose frequencies that roughly correspond to hue, saturation, and value.\n        const hueFrequency = -Math.cos(hsv.x / 2) * 220 + 440;\n        const saturationFrequency = hsv.y * 440 + 220;\n        const valueFrequency = (hsv.z + 0.1) * 440;\n        // Sigmoid with maximum 0.25 * alpha.\n        // Louder for greater value.\n        const gain = (0.25 * Math.min(1, color.a)) / (1 + Math.exp(-(hsv.z - 0.5) * 3));\n        this.colorOscHue.frequency.setValueAtTime(hueFrequency, this.ctx.currentTime);\n        this.colorOscSaturation.frequency.setValueAtTime(saturationFrequency, this.ctx.currentTime);\n        this.colorOscValue.frequency.setValueAtTime(valueFrequency, this.ctx.currentTime);\n        this.valueGain.gain.setValueAtTime((1 - hsv.z) * 0.4, this.ctx.currentTime);\n        this.colorGain.gain.setValueAtTime(gain, this.ctx.currentTime);\n    }\n    announceBoundaryCross(boundaryCrossCount) {\n        this.boundaryGain.gain.cancelScheduledValues(this.ctx.currentTime);\n        this.boundaryGain.gain.setValueAtTime(0, this.ctx.currentTime);\n        this.boundaryGain.gain.linearRampToValueAtTime(0.018, this.ctx.currentTime + 0.1);\n        this.boundaryOsc.frequency.setValueAtTime(440 + Math.atan(boundaryCrossCount / 2) * 100, this.ctx.currentTime);\n        this.boundaryGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.25);\n    }\n    close() {\n        void this.ctx.close();\n        this.closed = true;\n    }\n}\n/**\n * This tool, when enabled, plays a sound representing the color of the portion of the display\n * currently under the cursor. This tool adds a button that can be navigated to with the tab key\n * that enables/disables the tool.\n *\n * This allows the user to explore the content of the display without a working screen.\n */\nexport default class SoundUITool extends BaseTool {\n    constructor(editor, description) {\n        super(editor.notifier, description);\n        this.editor = editor;\n        this.soundFeedback = null;\n        // Create a screen-reader-usable method of toggling the tool:\n        this.toggleButtonContainer = document.createElement('div');\n        this.toggleButtonContainer.classList.add('js-draw-sound-ui-toggle');\n        this.toggleButton = document.createElement('button');\n        this.toggleButton.onclick = () => {\n            this.setEnabled(!this.isEnabled());\n        };\n        this.toggleButtonContainer.appendChild(this.toggleButton);\n        this.updateToggleButtonText();\n        editor.createHTMLOverlay(this.toggleButtonContainer);\n    }\n    canReceiveInputInReadOnlyEditor() {\n        return true;\n    }\n    updateToggleButtonText() {\n        const containerEnabledClass = 'sound-ui-tool-enabled';\n        if (this.isEnabled()) {\n            this.toggleButton.innerText = this.editor.localization.disableAccessibilityExploreTool;\n            this.toggleButtonContainer.classList.add(containerEnabledClass);\n        }\n        else {\n            this.toggleButton.innerText = this.editor.localization.enableAccessibilityExploreTool;\n            this.toggleButtonContainer.classList.remove(containerEnabledClass);\n        }\n    }\n    setEnabled(enabled) {\n        super.setEnabled(enabled);\n        if (!this.isEnabled()) {\n            this.soundFeedback?.close();\n            this.soundFeedback = null;\n        }\n        else {\n            this.editor.announceForAccessibility(this.editor.localization.soundExplorerUsageAnnouncement);\n        }\n        this.updateToggleButtonText();\n    }\n    onKeyPress(event) {\n        if (event.code === 'Escape') {\n            this.setEnabled(false);\n            return true;\n        }\n        return false;\n    }\n    onPointerDown({ current, allPointers }) {\n        if (!this.soundFeedback) {\n            this.soundFeedback = new SoundFeedback();\n        }\n        // Allow two-finger gestures to move the screen.\n        if (allPointers.length >= 2) {\n            return false;\n        }\n        // Accept multiple cursors -- some screen readers require multiple (touch) pointers to interact with\n        // an image instead of using the built-in navigation features.\n        this.soundFeedback?.play();\n        this.soundFeedback?.setColor(this.editor.display.getColorAt(current.screenPos) ?? Color4.black);\n        this.lastPointerPos = current.canvasPos;\n        return true;\n    }\n    onPointerMove({ current }) {\n        this.soundFeedback?.setColor(this.editor.display.getColorAt(current.screenPos) ?? Color4.black);\n        const pointerMotionLine = new LineSegment2(this.lastPointerPos, current.canvasPos);\n        const collisions = this.editor.image\n            .getElementsIntersectingRegion(pointerMotionLine.bbox)\n            .filter((component) => component.intersects(pointerMotionLine));\n        this.lastPointerPos = current.canvasPos;\n        if (collisions.length > 0) {\n            this.soundFeedback?.announceBoundaryCross(collisions.length);\n        }\n    }\n    onPointerUp(_event) {\n        this.soundFeedback?.pause();\n    }\n    onGestureCancel() {\n        this.soundFeedback?.pause();\n    }\n}\n","import  TextComponent  from '../components/TextComponent.mjs';\nimport  EditorImage  from '../image/EditorImage.mjs';\nimport { Rect2, Mat33, Vec2, Color4 } from '@js-draw/math';\nimport  { PointerDevice }  from '../Pointer.mjs';\nimport  { EditorEventType }  from '../types.mjs';\nimport  BaseTool  from './BaseTool.mjs';\nimport  Erase  from '../commands/Erase.mjs';\nimport  uniteCommands  from '../commands/uniteCommands.mjs';\nimport  { ReactiveValue }  from '../util/ReactiveValue.mjs';\nconst overlayCSSClass = 'textEditorOverlay';\n/** A tool that allows users to enter and edit text. */\nexport default class TextTool extends BaseTool {\n    constructor(editor, description, localizationTable) {\n        super(editor.notifier, description);\n        this.editor = editor;\n        this.localizationTable = localizationTable;\n        this.textInputElem = null;\n        this.textMeasuringCtx = null;\n        this.removeExistingCommand = null;\n        const editorFonts = editor.getCurrentSettings().text?.fonts ?? [];\n        this.textStyleValue = ReactiveValue.fromInitialValue({\n            size: 32,\n            fontFamily: editorFonts.length > 0 ? editorFonts[0] : 'sans-serif',\n            renderingStyle: {\n                fill: Color4.purple,\n            },\n        });\n        this.textStyleValue.onUpdateAndNow(() => {\n            this.textStyle = this.textStyleValue.get();\n            this.updateTextInput();\n            this.editor.notifier.dispatch(EditorEventType.ToolUpdated, {\n                kind: EditorEventType.ToolUpdated,\n                tool: this,\n            });\n        });\n        this.contentTransform = ReactiveValue.fromInitialValue(Mat33.identity);\n        this.textEditOverlay = document.createElement('div');\n        this.textEditOverlay.classList.add(overlayCSSClass);\n        this.editor.addStyleSheet(`\n\t\t\t.${overlayCSSClass} textarea {\n\t\t\t\tbackground-color: rgba(0, 0, 0, 0);\n\n\t\t\t\twhite-space: pre;\n\t\t\t\toverflow: hidden;\n\n\t\t\t\tpadding: 0;\n\t\t\t\tmargin: 0;\n\t\t\t\tborder: none;\n\t\t\t\tpadding: 0;\n\n\t\t\t\tmin-width: 100px;\n\t\t\t\tmin-height: 1.1em;\n\t\t\t}\n\t\t`);\n        this.anchorControl = this.editor.anchorElementToCanvas(this.textEditOverlay, this.contentTransform);\n    }\n    initTextMeasuringCanvas() {\n        this.textMeasuringCtx ??= document.createElement('canvas').getContext('2d');\n    }\n    getTextAscent(text, style) {\n        this.initTextMeasuringCanvas();\n        if (this.textMeasuringCtx) {\n            this.textMeasuringCtx.textBaseline = 'alphabetic';\n            TextComponent.applyTextStyles(this.textMeasuringCtx, style);\n            const measurement = this.textMeasuringCtx.measureText(text);\n            return measurement.fontBoundingBoxAscent ?? measurement.actualBoundingBoxAscent;\n        }\n        // Estimate\n        return (style.size * 2) / 3;\n    }\n    // Take input from this' textInputElem and add it to the EditorImage.\n    // If [removeInput], the HTML input element is removed. Otherwise, its value\n    // is cleared.\n    flushInput(removeInput = true) {\n        if (!this.textInputElem)\n            return;\n        // Determine the scroll first -- removing the input (and other DOM changes)\n        // also change the scroll.\n        const scrollingRegion = this.textEditOverlay.parentElement;\n        const containerScroll = Vec2.of(scrollingRegion?.scrollLeft ?? 0, scrollingRegion?.scrollTop ?? 0);\n        const content = this.textInputElem.value.trimEnd();\n        this.textInputElem.value = '';\n        if (removeInput) {\n            // In some browsers, .remove() triggers a .blur event (synchronously).\n            // Clear this.textInputElem before removal\n            const input = this.textInputElem;\n            this.textInputElem = null;\n            input.remove();\n        }\n        if (content !== '') {\n            // When the text is long, it can cause its container to scroll so that the\n            // editing caret is in view.\n            // So that the text added to the document is in the same position as the text\n            // shown in the editor, account for this scroll when computing the transform:\n            const scrollCorrectionScreen = containerScroll.times(-1);\n            // Uses .transformVec3 to avoid also translating the scroll correction (treating\n            // it as a point):\n            const scrollCorrectionCanvas = this.editor.viewport.screenToCanvasTransform.transformVec3(scrollCorrectionScreen);\n            const scrollTransform = Mat33.translation(scrollCorrectionCanvas);\n            const textComponent = TextComponent.fromLines(content.split('\\n'), scrollTransform.rightMul(this.contentTransform.get()), this.textStyle);\n            const action = EditorImage.addElement(textComponent);\n            if (this.removeExistingCommand) {\n                // Unapply so that `removeExistingCommand` can be added to the undo stack.\n                this.removeExistingCommand.unapply(this.editor);\n                this.editor.dispatch(uniteCommands([this.removeExistingCommand, action]));\n                this.removeExistingCommand = null;\n            }\n            else {\n                this.editor.dispatch(action);\n            }\n        }\n    }\n    updateTextInput() {\n        if (!this.textInputElem) {\n            return;\n        }\n        this.textInputElem.placeholder = this.localizationTable.enterTextToInsert;\n        this.textInputElem.style.fontFamily = this.textStyle.fontFamily;\n        this.textInputElem.style.fontStyle = this.textStyle.fontStyle ?? '';\n        this.textInputElem.style.fontVariant = this.textStyle.fontVariant ?? '';\n        this.textInputElem.style.fontWeight = this.textStyle.fontWeight ?? '';\n        this.textInputElem.style.fontSize = `${this.textStyle.size}px`;\n        this.textInputElem.style.color = this.textStyle.renderingStyle.fill.toHexString();\n        this.textInputElem.style.margin = '0';\n        this.textInputElem.style.width = `${this.textInputElem.scrollWidth}px`;\n        this.textInputElem.style.height = `${this.textInputElem.scrollHeight}px`;\n        // Get the ascent based on the font, using a string of characters\n        // that is tall in most fonts.\n        const tallText = 'Testing!';\n        const ascent = this.getTextAscent(tallText, this.textStyle);\n        const vertAdjust = ascent;\n        this.textInputElem.style.transform = `translate(0, ${-vertAdjust}px)`;\n        this.textInputElem.style.transformOrigin = 'top left';\n        // Match the line height of default rendered text.\n        const lineHeight = Math.floor(this.textStyle.size);\n        this.textInputElem.style.lineHeight = `${lineHeight}px`;\n    }\n    startTextInput(textCanvasPos, initialText) {\n        this.flushInput();\n        this.textInputElem = document.createElement('textarea');\n        this.textInputElem.value = initialText;\n        this.textInputElem.style.display = 'inline-block';\n        const textTargetPosition = this.editor.viewport.roundPoint(textCanvasPos);\n        const textRotation = -this.editor.viewport.getRotationAngle();\n        const textScale = Vec2.of(1, 1).times(this.editor.viewport.getSizeOfPixelOnCanvas());\n        this.contentTransform.set(\n        // Scale, then rotate, then translate:\n        Mat33.translation(textTargetPosition)\n            .rightMul(Mat33.zRotation(textRotation))\n            .rightMul(Mat33.scaling2D(textScale)));\n        this.updateTextInput();\n        // Update the input size/position/etc. after the placeHolder has had time to appear.\n        setTimeout(() => this.updateTextInput(), 0);\n        this.textInputElem.oninput = () => {\n            if (this.textInputElem) {\n                this.textInputElem.style.width = `${this.textInputElem.scrollWidth}px`;\n                this.textInputElem.style.height = `${this.textInputElem.scrollHeight}px`;\n            }\n        };\n        this.textInputElem.onblur = () => {\n            const input = this.textInputElem;\n            // Delay removing the input -- flushInput may be called within a blur()\n            // event handler\n            const removeInput = false;\n            this.flushInput(removeInput);\n            this.textInputElem = null;\n            if (input) {\n                input.classList.add('-hiding');\n            }\n            setTimeout(() => {\n                input?.remove();\n            }, 0);\n        };\n        this.textInputElem.onkeyup = (evt) => {\n            // In certain input modes, the <enter> key is used to select characters.\n            // When in this mode, prevent <enter> from submitting:\n            if (evt.isComposing)\n                return;\n            if (evt.key === 'Enter' && !evt.shiftKey) {\n                this.flushInput();\n                this.editor.focus();\n            }\n            else if (evt.key === 'Escape') {\n                // Cancel input.\n                this.textInputElem?.remove();\n                this.textInputElem = null;\n                this.editor.focus();\n                this.removeExistingCommand?.unapply(this.editor);\n                this.removeExistingCommand = null;\n            }\n        };\n        this.textEditOverlay.replaceChildren(this.textInputElem);\n        setTimeout(() => this.textInputElem?.focus(), 0);\n    }\n    setEnabled(enabled) {\n        super.setEnabled(enabled);\n        if (!this.isEnabled()) {\n            this.flushInput();\n        }\n        this.textEditOverlay.style.display = enabled ? 'block' : 'none';\n    }\n    onPointerDown({ current, allPointers }) {\n        if (current.device === PointerDevice.Eraser) {\n            return false;\n        }\n        if (allPointers.length === 1) {\n            // Are we clicking on a text node?\n            const canvasPos = current.canvasPos;\n            const halfTestRegionSize = Vec2.of(4, 4).times(this.editor.viewport.getSizeOfPixelOnCanvas());\n            const testRegion = Rect2.fromCorners(canvasPos.minus(halfTestRegionSize), canvasPos.plus(halfTestRegionSize));\n            const targetNodes = this.editor.image.getElementsIntersectingRegion(testRegion);\n            let targetTextNodes = targetNodes.filter((node) => node instanceof TextComponent);\n            // Don't try to edit text nodes that contain the viewport (this allows us\n            // to zoom in on text nodes and add text on top of them.)\n            const visibleRect = this.editor.viewport.visibleRect;\n            targetTextNodes = targetTextNodes.filter((node) => !node.getBBox().containsRect(visibleRect));\n            // End any TextNodes we're currently editing.\n            this.flushInput();\n            if (targetTextNodes.length > 0) {\n                const targetNode = targetTextNodes[targetTextNodes.length - 1];\n                this.setTextStyle(targetNode.getTextStyle());\n                // Create and temporarily apply removeExistingCommand.\n                this.removeExistingCommand = new Erase([targetNode]);\n                this.removeExistingCommand.apply(this.editor);\n                this.startTextInput(targetNode.getBaselinePos(), targetNode.getText());\n                this.contentTransform.set(targetNode.getTransform());\n                this.updateTextInput();\n            }\n            else {\n                this.removeExistingCommand = null;\n                this.startTextInput(current.canvasPos, '');\n            }\n            return true;\n        }\n        return false;\n    }\n    onGestureCancel() {\n        this.flushInput();\n        this.editor.focus();\n    }\n    setFontFamily(fontFamily) {\n        if (fontFamily !== this.textStyle.fontFamily) {\n            this.textStyleValue.set({\n                ...this.textStyle,\n                fontFamily: fontFamily,\n            });\n        }\n    }\n    setColor(color) {\n        if (!color.eq(this.textStyle.renderingStyle.fill)) {\n            this.textStyleValue.set({\n                ...this.textStyle,\n                renderingStyle: {\n                    ...this.textStyle.renderingStyle,\n                    fill: color,\n                },\n            });\n        }\n    }\n    setFontSize(size) {\n        if (size !== this.textStyle.size) {\n            this.textStyleValue.set({\n                ...this.textStyle,\n                size,\n            });\n        }\n    }\n    getTextStyle() {\n        return this.textStyle;\n    }\n    getStyleValue() {\n        return this.textStyleValue;\n    }\n    setTextStyle(style) {\n        this.textStyleValue.set(style);\n    }\n    // @internal\n    onDestroy() {\n        super.onDestroy();\n        this.anchorControl.remove();\n    }\n}\n","import  { EditorEventType }  from '../types.mjs';\nimport { Color4 } from '@js-draw/math';\nimport  PanZoom, { PanZoomMode }  from './PanZoom.mjs';\nimport  Pen  from './Pen.mjs';\nimport  ToolEnabledGroup  from './ToolEnabledGroup.mjs';\nimport  Eraser  from './Eraser.mjs';\nimport  SelectionTool  from './SelectionTool/SelectionTool.mjs';\nimport  UndoRedoShortcut  from './UndoRedoShortcut.mjs';\nimport  TextTool  from './TextTool.mjs';\nimport  PipetteTool  from './PipetteTool.mjs';\nimport  ToolSwitcherShortcut  from './ToolSwitcherShortcut.mjs';\nimport  PasteHandler  from './PasteHandler.mjs';\nimport  ToolbarShortcutHandler  from './ToolbarShortcutHandler.mjs';\nimport  { makePressureSensitiveFreehandLineBuilder }  from '../components/builders/PressureSensitiveFreehandLineBuilder.mjs';\nimport  FindTool  from './FindTool.mjs';\nimport  SelectAllShortcutHandler  from './SelectionTool/SelectAllShortcutHandler.mjs';\nimport  SoundUITool  from './SoundUITool.mjs';\nimport  { InputEvtType }  from '../inputEvents.mjs';\nimport  InputPipeline  from './InputFilter/InputPipeline.mjs';\nimport  InputStabilizer  from './InputFilter/InputStabilizer.mjs';\nimport  ScrollbarTool  from './ScrollbarTool.mjs';\nexport default class ToolController {\n    /** @internal */\n    constructor(editor, localization) {\n        this.activeTool = null;\n        this.isEditorReadOnly = editor.isReadOnlyReactiveValue();\n        this.inputPipeline = new InputPipeline();\n        this.inputPipeline.setEmitListener((event) => this.onEventInternal(event));\n        const primaryToolGroup = new ToolEnabledGroup();\n        this.primaryToolGroup = primaryToolGroup;\n        const panZoomTool = new PanZoom(editor, PanZoomMode.TwoFingerTouchGestures | PanZoomMode.RightClickDrags, localization.touchPanTool);\n        const keyboardPanZoomTool = new PanZoom(editor, PanZoomMode.Keyboard, localization.keyboardPanZoom);\n        const primaryPenTool = new Pen(editor, localization.penTool(1), {\n            color: Color4.purple,\n            thickness: 8,\n        });\n        const secondaryPenTool = new Pen(editor, localization.penTool(2), {\n            color: Color4.clay,\n            thickness: 4,\n        });\n        // Stabilize the secondary pen tool.\n        secondaryPenTool.setInputMapper(new InputStabilizer(editor.viewport));\n        const eraser = new Eraser(editor, localization.eraserTool);\n        const primaryTools = [\n            // Three pens\n            primaryPenTool,\n            secondaryPenTool,\n            // Highlighter-like pen with width=40\n            new Pen(editor, localization.penTool(3), {\n                color: Color4.ofRGBA(1, 1, 0, 0.5),\n                thickness: 40,\n                factory: makePressureSensitiveFreehandLineBuilder,\n            }),\n            eraser,\n            new SelectionTool(editor, localization.selectionTool),\n            new TextTool(editor, localization.textTool, localization),\n            new PanZoom(editor, PanZoomMode.SinglePointerGestures, localization.anyDevicePanning),\n        ];\n        // Accessibility tools\n        const soundExplorer = new SoundUITool(editor, localization.soundExplorer);\n        soundExplorer.setEnabled(false);\n        this.tools = [\n            new ScrollbarTool(editor),\n            new PipetteTool(editor, localization.pipetteTool),\n            soundExplorer,\n            panZoomTool,\n            ...primaryTools,\n            keyboardPanZoomTool,\n            new UndoRedoShortcut(editor),\n            new ToolbarShortcutHandler(editor),\n            new ToolSwitcherShortcut(editor),\n            eraser.makeEraserSwitcherTool(),\n            new FindTool(editor),\n            new PasteHandler(editor),\n            new SelectAllShortcutHandler(editor),\n        ];\n        primaryTools.forEach((tool) => tool.setToolGroup(primaryToolGroup));\n        panZoomTool.setEnabled(true);\n        primaryPenTool.setEnabled(true);\n        editor.notifier.on(EditorEventType.ToolEnabled, (event) => {\n            if (event.kind === EditorEventType.ToolEnabled) {\n                editor.announceForAccessibility(localization.toolEnabledAnnouncement(event.tool.description));\n            }\n        });\n        editor.notifier.on(EditorEventType.ToolDisabled, (event) => {\n            if (event.kind === EditorEventType.ToolDisabled) {\n                editor.announceForAccessibility(localization.toolDisabledAnnouncement(event.tool.description));\n            }\n        });\n        this.activeTool = null;\n    }\n    /**\n     * Replaces the current set of tools with `tools`. This should only be done before\n     * the creation of the app's toolbar (if using `AbstractToolbar`).\n     *\n     * If no `primaryToolGroup` is given, an empty one will be created.\n     */\n    setTools(tools, primaryToolGroup) {\n        this.tools = tools;\n        this.primaryToolGroup = primaryToolGroup ?? new ToolEnabledGroup();\n    }\n    /**\n     * Add a tool that acts like one of the primary tools (only one primary tool can be enabled at a time).\n     *\n     * If the tool is already added to this, the tool is converted to a primary tool.\n     *\n     * This should be called before creating the app's toolbar.\n     */\n    addPrimaryTool(tool) {\n        tool.setToolGroup(this.primaryToolGroup);\n        if (tool.isEnabled()) {\n            this.primaryToolGroup.notifyEnabled(tool);\n        }\n        if (!this.tools.includes(tool)) {\n            this.addTool(tool);\n        }\n    }\n    getPrimaryTools() {\n        return this.tools.filter((tool) => {\n            return tool.getToolGroup() === this.primaryToolGroup;\n        });\n    }\n    /**\n     * Add a tool to the end of this' tool list (the added tool receives events after tools already added to this).\n     * This should be called before creating the app's toolbar.\n     *\n     * If `options.addToFront`, the tool is added to the beginning of this' tool list.\n     *\n     * Does nothing if the tool is already present.\n     */\n    addTool(tool, options) {\n        // Only add if not already present.\n        if (!this.tools.includes(tool)) {\n            if (options?.addToFront) {\n                this.tools.splice(0, 0, tool);\n            }\n            else {\n                this.tools.push(tool);\n            }\n        }\n    }\n    /**\n     * Removes **and destroys** all tools in `tools` from this.\n     */\n    removeAndDestroyTools(tools) {\n        const newTools = [];\n        for (const tool of this.tools) {\n            if (tools.includes(tool)) {\n                if (this.activeTool === tool) {\n                    this.activeTool = null;\n                }\n                tool.onDestroy();\n            }\n            else {\n                newTools.push(tool);\n            }\n        }\n        this.tools = newTools;\n    }\n    insertTools(insertNear, toolsToInsert, mode) {\n        this.tools = this.tools.filter((tool) => !toolsToInsert.includes(tool));\n        const newTools = [];\n        for (const tool of this.tools) {\n            if (mode === 'after') {\n                newTools.push(tool);\n            }\n            if (tool === insertNear) {\n                newTools.push(...toolsToInsert);\n            }\n            if (mode === 'before') {\n                newTools.push(tool);\n            }\n        }\n        this.tools = newTools;\n    }\n    /**\n     * Removes a tool from this' tool list and replaces it with `replaceWith`.\n     *\n     * If any of `toolsToInsert` have already been added to this, the tools are\n     * moved.\n     *\n     * This should be called before creating the editor's toolbar.\n     */\n    insertToolsAfter(insertAfter, toolsToInsert) {\n        this.insertTools(insertAfter, toolsToInsert, 'after');\n    }\n    /** @see {@link insertToolsAfter} */\n    insertToolsBefore(insertBefore, toolsToInsert) {\n        this.insertTools(insertBefore, toolsToInsert, 'before');\n    }\n    // @internal use `dispatchEvent` rather than calling `onEvent` directly.\n    onEventInternal(event) {\n        const isEditorReadOnly = this.isEditorReadOnly.get();\n        const canToolReceiveInput = (tool) => {\n            return tool.isEnabled() && (!isEditorReadOnly || tool.canReceiveInputInReadOnlyEditor());\n        };\n        let handled = false;\n        if (event.kind === InputEvtType.PointerDownEvt) {\n            let canOnlySendToActiveTool = false;\n            if (this.activeTool && !this.activeTool.eventCanBeDeliveredToNonActiveTool(event)) {\n                canOnlySendToActiveTool = true;\n            }\n            for (const tool of this.tools) {\n                if (canOnlySendToActiveTool && tool !== this.activeTool) {\n                    continue;\n                }\n                if (canToolReceiveInput(tool) && tool.onEvent(event)) {\n                    if (this.activeTool !== tool) {\n                        this.activeTool?.onEvent({ kind: InputEvtType.GestureCancelEvt });\n                    }\n                    this.activeTool = tool;\n                    handled = true;\n                    break;\n                }\n            }\n        }\n        else if (event.kind === InputEvtType.PointerUpEvt) {\n            const upResult = this.activeTool?.onEvent(event);\n            const continueHandlingEvents = upResult && event.allPointers.length > 1;\n            // Should the active tool continue handling events (without an additional pointer down?)\n            if (!continueHandlingEvents) {\n                // No -- Remove the current tool\n                this.activeTool = null;\n            }\n            handled = true;\n        }\n        else if (event.kind === InputEvtType.PointerMoveEvt) {\n            if (this.activeTool !== null) {\n                this.activeTool.onEvent(event);\n                handled = true;\n            }\n        }\n        else if (event.kind === InputEvtType.GestureCancelEvt) {\n            if (this.activeTool !== null) {\n                this.activeTool.onEvent(event);\n                this.activeTool = null;\n            }\n        }\n        else {\n            for (const tool of this.tools) {\n                if (!canToolReceiveInput(tool)) {\n                    continue;\n                }\n                handled = tool.onEvent(event);\n                if (handled) {\n                    break;\n                }\n            }\n        }\n        return handled;\n    }\n    /** Alias for {@link dispatchInputEvent}. */\n    onEvent(event) {\n        return this.dispatchInputEvent(event);\n    }\n    // Returns true if the event was handled.\n    dispatchInputEvent(event) {\n        // Feed the event through the input pipeline\n        return this.inputPipeline.onEvent(event);\n    }\n    /**\n     * Adds a new `InputMapper` to this' input pipeline.\n     *\n     * A `mapper` is really a relation that maps each event to no, one,\n     * or many other events.\n     *\n     * @see {@link InputMapper}.\n     */\n    addInputMapper(mapper) {\n        this.inputPipeline.addToTail(mapper);\n    }\n    getMatchingTools(type) {\n        return this.tools.filter((tool) => tool instanceof type);\n    }\n    // @internal\n    onEditorDestroyed() {\n        for (const tool of this.tools) {\n            tool.onDestroy();\n        }\n    }\n}\n","// Connects a group of tools -- at most one tool in the group can be enabled.\nexport default class ToolEnabledGroup {\n    constructor() { }\n    notifyEnabled(tool) {\n        if (tool !== this.activeTool) {\n            this.activeTool?.setEnabled(false);\n            this.activeTool = tool;\n        }\n    }\n}\n","import  BaseTool  from './BaseTool.mjs';\n/**\n * Handles keyboard events used, by default, to select tools. By default,\n * 1 maps to the first primary tool, 2 to the second primary tool, ... .\n *\n * This is in the default set of {@link ToolController} tools.\n *\n */\nexport default class ToolSwitcherShortcut extends BaseTool {\n    constructor(editor) {\n        super(editor.notifier, editor.localization.changeTool);\n        this.editor = editor;\n    }\n    canReceiveInputInReadOnlyEditor() {\n        return true;\n    }\n    // @internal\n    onKeyPress({ key }) {\n        const toolController = this.editor.toolController;\n        const primaryTools = toolController.getPrimaryTools();\n        // Map keys 0-9 to primary tools.\n        const keyMatch = /^[0-9]$/.exec(key);\n        let targetTool;\n        if (keyMatch) {\n            const targetIdx = parseInt(keyMatch[0], 10) - 1;\n            targetTool = primaryTools[targetIdx];\n        }\n        if (targetTool) {\n            targetTool.setEnabled(true);\n            return true;\n        }\n        return false;\n    }\n}\n","// Allows the toolbar to register keyboard events.\n// @packageDocumentation\nimport  BaseTool  from './BaseTool.mjs';\nexport default class ToolbarShortcutHandler extends BaseTool {\n    constructor(editor) {\n        super(editor.notifier, editor.localization.changeTool);\n        this.listeners = new Set([]);\n    }\n    registerListener(listener) {\n        this.listeners.add(listener);\n    }\n    removeListener(listener) {\n        this.listeners.delete(listener);\n    }\n    onKeyPress(event) {\n        // TypeScript seems to automatically convert for of loops into for(init;check;update)\n        // loops (even with target set to es6). Thus, we cannot iterate directly through the\n        // set here.\n        // See https://stackoverflow.com/q/48886500\n        const listeners = Array.from(this.listeners.values());\n        for (const listener of listeners) {\n            if (listener(event)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n","import  BaseTool  from './BaseTool.mjs';\nimport  { redoKeyboardShortcutId, undoKeyboardShortcutId }  from './keybindings.mjs';\n// Handles ctrl+Z, ctrl+Shift+Z keyboard shortcuts.\nexport default class UndoRedoShortcut extends BaseTool {\n    constructor(editor) {\n        super(editor.notifier, editor.localization.undoRedoTool);\n        this.editor = editor;\n    }\n    // @internal\n    onKeyPress(event) {\n        if (this.editor.shortcuts.matchesShortcut(undoKeyboardShortcutId, event)) {\n            void this.editor.history.undo();\n            return true;\n        }\n        else if (this.editor.shortcuts.matchesShortcut(redoKeyboardShortcutId, event)) {\n            void this.editor.history.redo();\n            return true;\n        }\n        return false;\n    }\n}\n","import  KeyboardShortcutManager  from '../shortcuts/KeyboardShortcutManager.mjs';\n// This file contains user-overridable tool-realted keybindings.\n// Undo/redo\nexport const undoKeyboardShortcutId = 'jsdraw.tools.undo';\nexport const redoKeyboardShortcutId = 'jsdaw.tools.redo';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(undoKeyboardShortcutId, ['CtrlOrMeta+KeyZ'], 'Undo');\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(redoKeyboardShortcutId, ['CtrlOrMeta+Shift+KeyZ', 'CtrlOrMeta+KeyY'], 'Redo');\n// Pen/eraser/selection keybindings\nexport const increaseSizeKeyboardShortcutId = 'jsdraw.tools.increaseSize';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(increaseSizeKeyboardShortcutId, ['Equal', 'Shift+Equal'], 'Increase pen/eraser size');\nexport const decreaseSizeKeyboardShortcutId = 'jsdraw.tools.decreaseSize';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(decreaseSizeKeyboardShortcutId, ['Minus', 'Shift+Minus'], 'Decrease pen/eraser size');\nexport const snapToGridKeyboardShortcutId = 'jsdraw.tools.snapToGrid';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(snapToGridKeyboardShortcutId, ['Control', 'Meta'], 'Snap to grid (press and hold)');\nexport const lineLockKeyboardShortcutId = 'jsdraw.tools.lockToLine';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(lineLockKeyboardShortcutId, ['Shift'], 'Snap to XY axes (press and hold)');\n// Find tool\nexport const toggleFindVisibleShortcutId = 'js-draw.tools.FindTool.toggleVisible';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(toggleFindVisibleShortcutId, ['CtrlOrMeta+KeyF'], 'Shows/hides the find tool');\n// Pan/zoom\nexport const moveLeftKeyboardShortcutId = 'jsdraw.tools.PanZoom.moveLeft';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(moveLeftKeyboardShortcutId, ['ArrowLeft', 'KeyH', 'KeyA'], 'Pan left');\nexport const moveRightKeyboardShortcutId = 'jsdraw.tools.PanZoom.moveRight';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(moveRightKeyboardShortcutId, ['ArrowRight', 'KeyL', 'KeyD'], 'Pan right');\nexport const moveUpKeyboardShortcutId = 'jsdraw.tools.PanZoom.moveUp';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(moveUpKeyboardShortcutId, ['ArrowUp', 'KeyK', 'KeyQ'], 'Pan up');\nexport const moveDownKeyboardShortcutId = 'jsdraw.tools.PanZoom.moveDown';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(moveDownKeyboardShortcutId, ['ArrowDown', 'KeyJ', 'KeyE'], 'Pan down');\nexport const rotateClockwiseKeyboardShortcutId = 'jsdraw.tools.PanZoom.rotateViewClockwise';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(rotateClockwiseKeyboardShortcutId, ['Shift+KeyR'], 'Rotate viewport clockwise');\nexport const rotateCounterClockwiseKeyboardShortcutId = 'jsdraw.tools.PanZoom.rotateViewCounterClockwise';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(rotateCounterClockwiseKeyboardShortcutId, ['KeyR'], 'Rotate viewport counter-clockwise');\nexport const zoomInKeyboardShortcutId = 'jsdraw.tools.PanZoom.zoomIn';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(zoomInKeyboardShortcutId, ['KeyW'], 'Zoom in');\nexport const zoomOutKeyboardShortcutId = 'jsdraw.tools.PanZoom.zoomOut';\nKeyboardShortcutManager.registerDefaultKeyboardShortcut(zoomOutKeyboardShortcutId, ['KeyS'], 'Zoom out');\n// Selection tool\nexport  *  from './SelectionTool/keybindings.mjs';\n","export  { default as InputMapper }  from './InputFilter/InputMapper.mjs';\nexport  { default as BaseTool }  from './BaseTool.mjs';\nexport  { default as ToolController }  from './ToolController.mjs';\nexport  { default as ToolEnabledGroup }  from './ToolEnabledGroup.mjs';\nexport  { default as UndoRedoShortcut }  from './UndoRedoShortcut.mjs';\nexport  { default as ToolSwitcherShortcut }  from './ToolSwitcherShortcut.mjs';\nexport  { default as PanZoomTool, PanZoomMode }  from './PanZoom.mjs';\nexport  { default as PenTool }  from './Pen.mjs';\nexport  { default as TextTool }  from './TextTool.mjs';\nexport  { default as SelectionTool }  from './SelectionTool/SelectionTool.mjs';\nexport  { default as SelectAllShortcutHandler }  from './SelectionTool/SelectAllShortcutHandler.mjs';\nexport  { default as EraserTool, EraserMode }  from './Eraser.mjs';\nexport  { default as PasteHandler }  from './PasteHandler.mjs';\nexport  { default as SoundUITool }  from './SoundUITool.mjs';\nexport  { default as ToolbarShortcutHandler }  from './ToolbarShortcutHandler.mjs';\n","export const defaultToolLocalization = {\n    penTool: (penId) => `Pen ${penId}`,\n    selectionTool: 'Selection',\n    selectAllTool: 'Select all shortcut',\n    eraserTool: 'Eraser',\n    touchPanTool: 'Touch panning',\n    twoFingerPanZoomTool: 'Panning and zooming',\n    undoRedoTool: 'Undo/Redo',\n    rightClickDragPanTool: 'Right-click drag',\n    pipetteTool: 'Pick color from screen',\n    keyboardPanZoom: 'Keyboard pan/zoom shortcuts',\n    selectionMenu__show: 'Show selection menu',\n    selectionMenu__copyToClipboard: 'Copy to clipboard',\n    selectionMenu__duplicate: 'Duplicate',\n    selectionMenu__delete: 'Delete',\n    selectionMenu__paste: 'Paste',\n    copyPasteError__heading: 'Copy/paste',\n    copyPasteError__description: 'Something went wrong — this tool may not have clipboard access.',\n    copyPasteError__errorDetails: 'Show error',\n    copyPasteError__pasteRetry: 'To retry, please paste into the input box below:',\n    copyPasteError__copyRetry: 'To retry, please copy the text in the input box below:',\n    copyPasteError__copyMe: 'Copy me!',\n    autocorrectedTo: (strokeDescription) => `Autocorrected to ${strokeDescription}`,\n    autocorrectionCanceled: 'Autocorrect cancelled',\n    textTool: 'Text',\n    enterTextToInsert: 'Text to insert',\n    changeTool: 'Change tool',\n    pasteHandler: 'Copy paste handler',\n    soundExplorer: 'Sound-based image exploration',\n    disableAccessibilityExploreTool: 'Disable sound-based exploration',\n    enableAccessibilityExploreTool: 'Enable sound-based exploration',\n    soundExplorerUsageAnnouncement: 'Sound-based image exploration enabled: Click/drag the screen to play a sound representation of different parts of the image.',\n    findLabel: 'Find',\n    toNextMatch: 'Next',\n    closeDialog: 'Close',\n    findDialogShown: 'Find dialog shown',\n    findDialogHidden: 'Find dialog hidden',\n    focusedFoundText: (matchIdx, totalMatches) => `Viewing match ${matchIdx} of ${totalMatches}`,\n    anyDevicePanning: 'Any device panning',\n    copied: (count) => `Copied ${count} item(s)`,\n    pasted: (count) => `Pasted ${count} item(s)`,\n    toolEnabledAnnouncement: (toolName) => `${toolName} enabled`,\n    toolDisabledAnnouncement: (toolName) => `${toolName} disabled`,\n};\n","import { Vec2 } from '@js-draw/math';\nexport const defaultStationaryDetectionConfig = {\n    maxSpeed: 8.5, // screenPx/s\n    maxRadius: 11, // screenPx\n    minTimeSeconds: 0.5, // s\n};\nexport default class StationaryPenDetector {\n    // Only handles one pen. As such, `startPointer` should be the same device/finger\n    // as `updatedPointer` in `onPointerMove`.\n    //\n    // A new `StationaryPenDetector` should be created for each gesture.\n    constructor(startPointer, config, onStationary) {\n        this.config = config;\n        this.onStationary = onStationary;\n        this.timeout = null;\n        this.stationaryStartPointer = startPointer;\n        this.lastPointer = startPointer;\n        this.averageVelocity = Vec2.zero;\n        this.setStationaryTimeout(this.config.minTimeSeconds * 1000);\n    }\n    // Returns true if stationary\n    onPointerMove(currentPointer) {\n        if (!this.stationaryStartPointer) {\n            // Destoroyed\n            return;\n        }\n        if (currentPointer.id !== this.stationaryStartPointer.id) {\n            return false;\n        }\n        // dx: \"Δx\" Displacement from last.\n        const dxFromLast = currentPointer.screenPos.minus(this.lastPointer.screenPos);\n        const dxFromStationaryStart = currentPointer.screenPos.minus(this.stationaryStartPointer.screenPos);\n        // dt: Delta time:\n        // /1000: Convert to s.\n        let dtFromLast = (currentPointer.timeStamp - this.lastPointer.timeStamp) / 1000; // s\n        // Don't divide by zero\n        if (dtFromLast === 0) {\n            dtFromLast = 1;\n        }\n        const currentVelocity = dxFromLast.times(1 / dtFromLast); // px/s\n        // Slight smoothing of the velocity to prevent input jitter from affecting the\n        // velocity too significantly.\n        this.averageVelocity = this.averageVelocity.lerp(currentVelocity, 0.5); // px/s\n        const dtFromStart = currentPointer.timeStamp - this.stationaryStartPointer.timeStamp; // ms\n        const movedOutOfRadius = dxFromStationaryStart.length() > this.config.maxRadius;\n        this.hasMovedOutOfRadius ||= movedOutOfRadius;\n        // If not stationary\n        if (movedOutOfRadius ||\n            this.averageVelocity.length() > this.config.maxSpeed ||\n            dtFromStart < this.config.minTimeSeconds) {\n            this.stationaryStartPointer = currentPointer;\n            this.lastPointer = currentPointer;\n            this.setStationaryTimeout(this.config.minTimeSeconds * 1000);\n            return false;\n        }\n        const stationaryTimeoutMs = this.config.minTimeSeconds * 1000 - dtFromStart;\n        this.lastPointer = currentPointer;\n        return stationaryTimeoutMs <= 0;\n    }\n    onPointerUp(pointer) {\n        if (pointer.id !== this.stationaryStartPointer?.id) {\n            this.cancelStationaryTimeout();\n        }\n    }\n    destroy() {\n        this.cancelStationaryTimeout();\n        this.stationaryStartPointer = null;\n    }\n    getHasMovedOutOfRadius() {\n        return this.hasMovedOutOfRadius;\n    }\n    cancelStationaryTimeout() {\n        if (this.timeout !== null) {\n            clearTimeout(this.timeout);\n            this.timeout = null;\n        }\n    }\n    setStationaryTimeout(timeoutMs) {\n        if (this.timeout !== null) {\n            return;\n        }\n        if (timeoutMs <= 0) {\n            this.onStationary(this.lastPointer);\n        }\n        else {\n            this.timeout = setTimeout(() => {\n                this.timeout = null;\n                if (!this.stationaryStartPointer) {\n                    // Destroyed\n                    return;\n                }\n                const timeSinceStationaryStart = performance.now() - this.stationaryStartPointer.timeStamp;\n                const timeRemaining = this.config.minTimeSeconds * 1000 - timeSinceStationaryStart;\n                if (timeRemaining <= 0) {\n                    this.onStationary(this.lastPointer);\n                }\n                else {\n                    this.setStationaryTimeout(timeRemaining);\n                }\n            }, timeoutMs);\n        }\n    }\n}\n","import  waitForTimeout  from '../../util/waitForTimeout.mjs';\nimport  { EditorEventType }  from '../../types.mjs';\nlet idCounter = 0;\nconst createMenuOverlay = async (editor, canvasAnchor, options) => {\n    const overlay = document.createElement('div');\n    const { remove: removeOverlay } = editor.createHTMLOverlay(overlay);\n    const menuModal = document.createElement('dialog');\n    menuModal.classList.add('editor-popup-menu');\n    const hideMenuTimeout = 240;\n    menuModal.style.setProperty('--hide-menu-animation-timeout', `${hideMenuTimeout}ms`);\n    const updateMenuLocation = () => {\n        const overlayRect = editor.getOutputBBoxInDOM();\n        const anchor = editor.viewport.canvasToScreen(canvasAnchor).plus(overlayRect.topLeft);\n        menuModal.style.setProperty('--anchor-x', `${anchor.x}px`);\n        menuModal.style.setProperty('--anchor-y', `${anchor.y}px`);\n    };\n    updateMenuLocation();\n    const viewportChangeListener = editor.notifier.on(EditorEventType.ViewportChanged, updateMenuLocation);\n    overlay.appendChild(menuModal);\n    let dismissing = false;\n    const dismissMenu = async () => {\n        if (dismissing)\n            return;\n        dismissing = true;\n        viewportChangeListener.remove();\n        menuModal.classList.add('-hide');\n        await waitForTimeout(hideMenuTimeout);\n        menuModal.close();\n    };\n    return new Promise((resolve) => {\n        let resolved = false;\n        let result = null;\n        const resolveWithSelectedResult = () => {\n            if (!resolved) {\n                resolve(result);\n                resolved = true;\n            }\n        };\n        menuModal.onclose = () => {\n            removeOverlay();\n            resolveWithSelectedResult();\n        };\n        const onOptionSelected = (key) => {\n            result = key;\n            void dismissMenu();\n            // To properly handle clipboard events, this needs to be called synchronously\n            // and not after a delay:\n            resolveWithSelectedResult();\n        };\n        editor.handlePointerEventsExceptClicksFrom(menuModal, (eventName, event) => {\n            if (event.target === menuModal && eventName === 'pointerdown') {\n                void dismissMenu();\n                return true;\n            }\n            else if (dismissing) {\n                // Send pointer events to the editor if the dialog is in the process of being\n                // dismissed (e.g. pointermove events just after a pointerdown outside of the\n                // editor).\n                return true;\n            }\n            return false;\n        }, (_eventName, event) => {\n            return event.target === menuModal;\n        });\n        const contentElement = document.createElement('div');\n        contentElement.classList.add('content');\n        contentElement.role = 'menu';\n        const optionElements = [];\n        // Keyboard focus handling as described in\n        // - https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/menu_role and\n        // - https://www.w3.org/WAI/ARIA/apg/patterns/disclosure/examples/disclosure-navigation/\n        contentElement.addEventListener('keydown', (event) => {\n            const focusedIndex = optionElements.findIndex((item) => item === document.activeElement);\n            if (focusedIndex === -1)\n                return;\n            let newFocusedIndex = focusedIndex;\n            if (event.key === 'ArrowDown') {\n                newFocusedIndex++;\n            }\n            else if (event.key === 'ArrowUp') {\n                newFocusedIndex--;\n            }\n            else if (event.key === 'End') {\n                newFocusedIndex = optionElements.length - 1;\n            }\n            else if (event.key === 'Home') {\n                newFocusedIndex = 0;\n            }\n            if (newFocusedIndex < 0) {\n                newFocusedIndex += optionElements.length;\n            }\n            newFocusedIndex %= optionElements.length;\n            if (newFocusedIndex !== focusedIndex) {\n                event.preventDefault();\n                optionElements[newFocusedIndex].focus();\n            }\n        });\n        for (const option of options) {\n            const optionElement = document.createElement('button');\n            optionElement.id = `menu-overlay-option-${idCounter++}`;\n            optionElement.role = 'menuitem';\n            optionElement.classList.add('option', 'editor-popup-menu-option');\n            optionElement.replaceChildren(option.icon(), document.createTextNode(option.text));\n            optionElement.onclick = (event) => {\n                if (event.defaultPrevented)\n                    return;\n                onOptionSelected(option.key);\n            };\n            contentElement.appendChild(optionElement);\n            if (optionElements.length === 0) {\n                optionElement.autofocus = true;\n            }\n            optionElements.push(optionElement);\n        }\n        menuModal.appendChild(contentElement);\n        menuModal.showModal();\n        // Ensures that the menu is visible even if triggered near the edge of the screen.\n        contentElement.scrollIntoView({ block: 'nearest' });\n    });\n};\nexport default createMenuOverlay;\n","// Types related to the image editor\n/** @see {@link EditorNotifier} */\nexport var EditorEventType;\n(function (EditorEventType) {\n    EditorEventType[EditorEventType[\"ToolEnabled\"] = 0] = \"ToolEnabled\";\n    EditorEventType[EditorEventType[\"ToolDisabled\"] = 1] = \"ToolDisabled\";\n    EditorEventType[EditorEventType[\"ToolUpdated\"] = 2] = \"ToolUpdated\";\n    EditorEventType[EditorEventType[\"UndoRedoStackUpdated\"] = 3] = \"UndoRedoStackUpdated\";\n    EditorEventType[EditorEventType[\"CommandDone\"] = 4] = \"CommandDone\";\n    EditorEventType[EditorEventType[\"CommandUndone\"] = 5] = \"CommandUndone\";\n    EditorEventType[EditorEventType[\"ObjectAdded\"] = 6] = \"ObjectAdded\";\n    EditorEventType[EditorEventType[\"ViewportChanged\"] = 7] = \"ViewportChanged\";\n    EditorEventType[EditorEventType[\"DisplayResized\"] = 8] = \"DisplayResized\";\n    EditorEventType[EditorEventType[\"SelectionUpdated\"] = 9] = \"SelectionUpdated\";\n    EditorEventType[EditorEventType[\"ReadOnlyModeToggled\"] = 10] = \"ReadOnlyModeToggled\";\n    /** @internal */\n    EditorEventType[EditorEventType[\"ColorPickerToggled\"] = 11] = \"ColorPickerToggled\";\n    /** @internal */\n    EditorEventType[EditorEventType[\"ColorPickerColorSelected\"] = 12] = \"ColorPickerColorSelected\";\n    /** @deprecated @internal */\n    EditorEventType[EditorEventType[\"ToolbarDropdownShown\"] = 13] = \"ToolbarDropdownShown\";\n})(EditorEventType || (EditorEventType = {}));\n// Types of `EditorUndoStackUpdated` events.\nexport var UndoEventType;\n(function (UndoEventType) {\n    UndoEventType[UndoEventType[\"CommandDone\"] = 0] = \"CommandDone\";\n    UndoEventType[UndoEventType[\"CommandUndone\"] = 1] = \"CommandUndone\";\n    UndoEventType[UndoEventType[\"CommandRedone\"] = 2] = \"CommandRedone\";\n})(UndoEventType || (UndoEventType = {}));\n","/* eslint-disable @typescript-eslint/no-redundant-type-constituents -- Used for clarity */\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _ClipboardHandler_preferClipboardEvents;\nimport  { InputEvtType }  from '../inputEvents.mjs';\nimport  fileToBase64Url  from './fileToBase64Url.mjs';\nconst isTextMimeType = (mime) => \n// +xml: Handles image/svg+xml\nmime.endsWith('+xml') || mime.startsWith('text/');\n/**\n * Handles conversion between the browser clipboard APIs and internal\n * js-draw clipboard events.\n */\nclass ClipboardHandler {\n    constructor(editor, callbacks) {\n        this.editor = editor;\n        this.callbacks = callbacks;\n        _ClipboardHandler_preferClipboardEvents.set(this, false);\n    }\n    /**\n     * Pastes data from the clipboard into the editor associated with\n     * this handler.\n     *\n     * @param event Optional -- a clipboard/drag event. If not provided,\n     * \t\t\t\t`navigator.clipboard` will be used instead.\n     * @returns true if the paste event was handled by the editor.\n     */\n    paste(event) {\n        const onError = (error) => {\n            if (this.callbacks?.onPasteError) {\n                this.callbacks.onPasteError(error);\n                return Promise.resolve(false);\n            }\n            else {\n                throw error;\n            }\n        };\n        try {\n            // Use .catch rather than `async` to prevent future modifications from\n            // moving clipboard handling logic out of user event handlers.\n            // In the past, `await`s have caused permissions issues in some browsers.\n            return this.pasteInternal(event).catch(onError);\n        }\n        catch (error) {\n            return onError(error);\n        }\n    }\n    async pasteInternal(event) {\n        const editor = this.editor;\n        const clipboardData = event?.dataTransfer ?? event?.clipboardData ?? null;\n        const hasEvent = !!clipboardData;\n        const sendPasteEvent = (mime, data) => {\n            return (data &&\n                editor.toolController.dispatchInputEvent({\n                    kind: InputEvtType.PasteEvent,\n                    mime,\n                    data,\n                }));\n        };\n        // Listed in order of precedence\n        const supportedMIMEs = ['image/svg+xml', 'text/html', 'image/png', 'image/jpeg', 'text/plain'];\n        let files = [];\n        const textData = new Map();\n        const editorSettings = editor.getCurrentSettings();\n        if (hasEvent) {\n            // NOTE: On some browsers, .getData and .files must be used before any async operations.\n            files = [...clipboardData.files];\n            for (const mime of supportedMIMEs) {\n                const data = clipboardData.getData(mime);\n                if (data) {\n                    textData.set(mime, data);\n                }\n            }\n        }\n        else if (editorSettings.clipboardApi) {\n            const clipboardData = await editorSettings.clipboardApi.read();\n            for (const [type, data] of clipboardData.entries()) {\n                if (typeof data === 'string') {\n                    textData.set(type, data);\n                }\n                else {\n                    let blob = data;\n                    if (blob.type !== type) {\n                        blob = new Blob([blob], { type });\n                    }\n                    files.push(blob);\n                }\n            }\n        }\n        else {\n            const clipboardData = await navigator.clipboard.read();\n            for (const item of clipboardData) {\n                for (const mime of item.types) {\n                    if (supportedMIMEs.includes(mime)) {\n                        files.push(await item.getType(mime));\n                    }\n                }\n            }\n        }\n        // Returns true if handled\n        const handleMIME = async (mime) => {\n            const isTextFormat = isTextMimeType(mime);\n            if (isTextFormat) {\n                const data = textData.get(mime);\n                if (sendPasteEvent(mime, data)) {\n                    event?.preventDefault();\n                    return true;\n                }\n            }\n            for (const file of files) {\n                const fileType = file?.type?.toLowerCase();\n                if (fileType !== mime) {\n                    continue;\n                }\n                if (isTextFormat) {\n                    const text = await file.text();\n                    if (sendPasteEvent(mime, text)) {\n                        event?.preventDefault();\n                        return true;\n                    }\n                }\n                else {\n                    editor.showLoadingWarning(0);\n                    const onprogress = (evt) => {\n                        editor.showLoadingWarning(evt.loaded / evt.total);\n                    };\n                    try {\n                        const data = await fileToBase64Url(file, { onprogress });\n                        if (sendPasteEvent(mime, data)) {\n                            event?.preventDefault();\n                            editor.hideLoadingWarning();\n                            return true;\n                        }\n                    }\n                    catch (e) {\n                        console.error('Error reading image:', e);\n                    }\n                    editor.hideLoadingWarning();\n                }\n            }\n            return false;\n        };\n        for (const mime of supportedMIMEs) {\n            if (await handleMIME(mime)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Copies text from the editor associated with this.\n     *\n     * Even if `event` is provided, the `navigator.clipboard` API may be used if image data\n     * is to be copied. This is done because `ClipboardEvent`s seem to not support attaching\n     * images.\n     */\n    copy(event) {\n        const onError = (error) => {\n            if (this.callbacks?.onCopyError) {\n                this.callbacks.onCopyError(error);\n                return Promise.resolve();\n            }\n            else {\n                throw error;\n            }\n        };\n        try {\n            // As above, use `.catch` to be certain that certain copyInternal\n            // is run now, before returning.\n            return this.copyInternal(event).catch(onError);\n        }\n        catch (error) {\n            return onError(error);\n        }\n    }\n    copyInternal(event) {\n        const mimeToData = new Map();\n        if (this.editor.toolController.dispatchInputEvent({\n            kind: InputEvtType.CopyEvent,\n            setData: (mime, data) => {\n                mimeToData.set(mime, data);\n            },\n        })) {\n            event?.preventDefault();\n        }\n        const mimeTypes = [...mimeToData.keys()];\n        const hasNonTextMimeTypes = mimeTypes.some((mime) => !isTextMimeType(mime));\n        const copyToEvent = (reason) => {\n            if (!event) {\n                throw new Error(`Unable to copy -- no event provided${reason ? `. Original error: ${reason}` : ''}`);\n            }\n            for (const [key, value] of mimeToData.entries()) {\n                if (typeof value === 'string') {\n                    if ('clipboardData' in event) {\n                        event.clipboardData?.setData(key, value);\n                    }\n                    else {\n                        event.dataTransfer?.setData(key, value);\n                    }\n                }\n            }\n        };\n        const copyToClipboardApi = () => {\n            const mapInternalDataToBrowserData = (originalMimeToData) => {\n                const mappedMimeToData = Object.create(null);\n                for (const [key, data] of originalMimeToData.entries()) {\n                    if (typeof data === 'string') {\n                        const loadedData = new Blob([new TextEncoder().encode(data)], { type: key });\n                        mappedMimeToData[key] = loadedData;\n                    }\n                    else {\n                        mappedMimeToData[key] = data;\n                    }\n                    // Different platforms have varying support for different clipboard MIME types:\n                    // - As of September 2024, image/svg+xml is unsupported on iOS\n                    // - text/html is unsupported on Chrome/Android (and perhaps Chrome on other platforms).\n                    //    - See https://issues.chromium.org/issues/40851502\n                    if (key === 'image/svg+xml') {\n                        mappedMimeToData['text/html'] ??= mappedMimeToData[key];\n                    }\n                }\n                return mappedMimeToData;\n            };\n            const removeUnsupportedMime = (originalMimeToData) => {\n                const filteredMimeToData = Object.create(null);\n                for (const [key, data] of Object.entries(originalMimeToData)) {\n                    // Browser support for ClipboardItem.supports is limited as of mid 2024. However, some browsers\n                    // that do support `.supports` throw an exception when attempting to copy an unsupported MIME type\n                    // (e.g. Firefox).\n                    const unsupported = 'supports' in ClipboardItem &&\n                        typeof ClipboardItem.supports === 'function' &&\n                        !ClipboardItem.supports(key);\n                    if (!unsupported) {\n                        filteredMimeToData[key] = data;\n                    }\n                }\n                return filteredMimeToData;\n            };\n            const browserMimeToData = removeUnsupportedMime(mapInternalDataToBrowserData(mimeToData));\n            return navigator.clipboard.write([new ClipboardItem(browserMimeToData)]);\n        };\n        const supportsClipboardApi = typeof ClipboardItem !== 'undefined' && typeof navigator?.clipboard?.write !== 'undefined';\n        const prefersClipboardApi = !__classPrivateFieldGet(this, _ClipboardHandler_preferClipboardEvents, \"f\") && supportsClipboardApi && (hasNonTextMimeTypes || !event);\n        const editorSettings = this.editor.getCurrentSettings();\n        if (prefersClipboardApi && editorSettings.clipboardApi) {\n            const writeResult = editorSettings.clipboardApi.write(mimeToData);\n            return writeResult ?? Promise.resolve();\n        }\n        else if (prefersClipboardApi) {\n            let clipboardApiPromise = null;\n            const fallBackToCopyEvent = (reason) => {\n                console.warn('Unable to copy to the clipboard API. Future calls to .copy will use ClipboardEvents if possible.', reason);\n                __classPrivateFieldSet(this, _ClipboardHandler_preferClipboardEvents, true, \"f\");\n                copyToEvent(reason);\n            };\n            try {\n                clipboardApiPromise = copyToClipboardApi();\n            }\n            catch (error) {\n                fallBackToCopyEvent(error);\n            }\n            if (clipboardApiPromise) {\n                return clipboardApiPromise.catch(fallBackToCopyEvent);\n            }\n        }\n        else {\n            copyToEvent();\n        }\n        return Promise.resolve();\n    }\n}\n_ClipboardHandler_preferClipboardEvents = new WeakMap();\nexport default ClipboardHandler;\n","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ReactiveValueImpl_value, _ReactiveValueImpl_onUpdateListeners;\nconst noOpUpdateListenerResult = {\n    remove() { },\n};\n/**\n * An update listener that does nothing. Useful for reactive values\n * that will never change.\n */\nconst noOpSetUpdateListener = () => {\n    return noOpUpdateListenerResult;\n};\n/**\n * A `ReactiveValue` is a value that\n * - updates periodically,\n * - can fire listeners when it updates,\n * - and can be chanined together with other `ReactiveValue`s.\n *\n * A `ReactiveValue` is a read-only view. See {@link MutableReactiveValue} for a\n * read-write view.\n *\n * Static methods in the `ReactiveValue` and `MutableReactiveValue` classes are\n * constructors (e.g. `fromImmutable`).\n *\n * Avoid extending this class from an external library, as that may not be stable.\n */\nexport class ReactiveValue {\n    /** Returns a promise that resolves when this value is next changed. */\n    waitForNextUpdate() {\n        return new Promise((resolve) => {\n            const listener = this.onUpdate((value) => {\n                listener.remove();\n                resolve(value);\n            });\n        });\n    }\n    /** Creates a `ReactiveValue` with an initial value, `initialValue`. */\n    static fromInitialValue(initialValue) {\n        return new ReactiveValueImpl(initialValue);\n    }\n    /** Returns a `ReactiveValue` that is **known** will never change. */\n    static fromImmutable(value) {\n        return {\n            get: () => value,\n            onUpdate: noOpSetUpdateListener,\n            onUpdateAndNow: (callback) => {\n                callback(value);\n                return noOpUpdateListenerResult;\n            },\n            // Never resolves -- immutable.\n            waitForNextUpdate: () => new Promise(() => { }),\n        };\n    }\n    /**\n     * Creates a `ReactiveValue` whose values come from `callback`.\n     *\n     * `callback` is called whenever any of `sourceValues` are updated and initially to\n     * set the initial value of the result.\n     */\n    static fromCallback(callback, sourceValues) {\n        const result = new ReactiveValueImpl(callback());\n        const resultRef = false\n            ? new window.WeakRef(result)\n            : { deref: () => result };\n        for (const value of sourceValues) {\n            const listener = value.onUpdate(() => {\n                // Use resultRef to allow `result` to be garbage collected\n                // despite this listener.\n                const value = resultRef.deref();\n                if (value) {\n                    value.set(callback());\n                }\n                else {\n                    listener.remove();\n                }\n            });\n        }\n        return result;\n    }\n    static map(source, map, inverseMap) {\n        const result = ReactiveValue.fromInitialValue(map(source.get()));\n        let expectedResultValue = result.get();\n        source.onUpdate((newValue) => {\n            expectedResultValue = map(newValue);\n            result.set(expectedResultValue);\n        });\n        if (inverseMap) {\n            result.onUpdate((newValue) => {\n                // Prevent infinite loops if inverseMap is not a true\n                // inverse.\n                if (newValue !== expectedResultValue) {\n                    source.set(inverseMap(newValue));\n                }\n            });\n        }\n        return result;\n    }\n    static union(values) {\n        return ReactiveValue.fromCallback(() => {\n            return values.map((value) => value.get());\n        }, values);\n    }\n}\nexport class MutableReactiveValue extends ReactiveValue {\n    static fromProperty(sourceValue, propertyName) {\n        const child = ReactiveValue.fromInitialValue(sourceValue.get()[propertyName]);\n        const childRef = window.WeakRef\n            ? new window.WeakRef(child)\n            : { deref: () => child };\n        // When the source is updated...\n        const sourceListener = sourceValue.onUpdate((newValue) => {\n            const childValue = childRef.deref();\n            if (childValue) {\n                childValue.set(newValue[propertyName]);\n            }\n            else {\n                // TODO: What if `sourceValue` would be dropped before\n                // the child value?\n                sourceListener.remove();\n            }\n        });\n        // When the child is updated, also apply the update to the\n        // parent.\n        child.onUpdate((newValue) => {\n            sourceValue.set({\n                ...sourceValue.get(),\n                [propertyName]: newValue,\n            });\n        });\n        return child;\n    }\n}\n// @internal\nclass ReactiveValueImpl extends MutableReactiveValue {\n    constructor(initialValue) {\n        super();\n        _ReactiveValueImpl_value.set(this, void 0);\n        _ReactiveValueImpl_onUpdateListeners.set(this, void 0);\n        __classPrivateFieldSet(this, _ReactiveValueImpl_value, initialValue, \"f\");\n        __classPrivateFieldSet(this, _ReactiveValueImpl_onUpdateListeners, [], \"f\");\n    }\n    set(newValue) {\n        if (__classPrivateFieldGet(this, _ReactiveValueImpl_value, \"f\") === newValue) {\n            return;\n        }\n        __classPrivateFieldSet(this, _ReactiveValueImpl_value, newValue, \"f\");\n        for (const listener of __classPrivateFieldGet(this, _ReactiveValueImpl_onUpdateListeners, \"f\")) {\n            listener(newValue);\n        }\n    }\n    get() {\n        return __classPrivateFieldGet(this, _ReactiveValueImpl_value, \"f\");\n    }\n    onUpdate(listener) {\n        // **Note**: If memory is a concern, listeners should avoid referencing this\n        // reactive value directly. Doing so allows the value to be garbage collected when\n        // no longer referenced.\n        __classPrivateFieldGet(this, _ReactiveValueImpl_onUpdateListeners, \"f\").push(listener);\n        return {\n            remove: () => {\n                __classPrivateFieldSet(this, _ReactiveValueImpl_onUpdateListeners, __classPrivateFieldGet(this, _ReactiveValueImpl_onUpdateListeners, \"f\").filter((otherListener) => {\n                    return otherListener !== listener;\n                }), \"f\");\n            },\n        };\n    }\n    onUpdateAndNow(callback) {\n        callback(this.get());\n        return this.onUpdate(callback);\n    }\n}\n_ReactiveValueImpl_value = new WeakMap(), _ReactiveValueImpl_onUpdateListeners = new WeakMap();\nexport default ReactiveValue;\n","import  listenForLongPressOrHover  from './listenForLongPressOrHover.mjs';\n/**\n * When a pointer is inside `element`, after a delay, adds the `has-long-press-or-hover`\n * CSS class to `element`.\n *\n * When no pointers are inside `element`, adds the CSS class `no-long-press-or-hover`.\n */\nconst addLongPressOrHoverCssClasses = (element, options) => {\n    const hasLongPressClass = 'has-long-press-or-hover';\n    const noLongPressClass = 'no-long-press-or-hover';\n    element.classList.add('no-long-press-or-hover');\n    const { removeListeners } = listenForLongPressOrHover(element, {\n        onStart() {\n            element.classList.remove(noLongPressClass);\n            element.classList.add(hasLongPressClass);\n        },\n        onEnd() {\n            element.classList.add(noLongPressClass);\n            element.classList.remove(hasLongPressClass);\n        },\n        longPressTimeout: options?.timeout,\n    });\n    return {\n        removeEventListeners: () => {\n            element.classList.remove(noLongPressClass);\n            removeListeners();\n        },\n    };\n};\nexport default addLongPressOrHoverCssClasses;\n","import { Color4, Vec3 } from '@js-draw/math';\n/**\n * Adjusts the current editor theme such that colors have appropriate contrast.\n *\n * As this method overrides CSS variables using the `.style` property,\n * **assumes** all original theme variables are set using CSS and not the `.style` property.\n *\n * If the editor changes theme in response to the system theme, this method should be\n * called whenever the system theme changes (e.g. by using [the `matchMedia`](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia)\n * method).\n *\n * @example\n * ```ts,runnable\n * import { Editor, adjustEditorThemeForContrast } from 'js-draw';\n *\n * const editor = new Editor(document.body);\n * editor.addToolbar();\n *\n * const css = `\n *   :root .imageEditorContainer {\n *     --background-color-1: #ffff77;\n *     --foreground-color-1: #fff;\n *     --background-color-2: #ffff99;\n *     --foreground-color-2: #ffff88;\n *     --background-color-3: #ddffff;\n *     --foreground-color-3: #eeffff;\n *     --selection-background-color: #9f7;\n *     --selection-foreground-color: #98f;\n *   }\n *\n *   @media screen and (prefers-color-scheme: dark) {\n *     :root .imageEditorContainer {\n *       --background-color-1: black;\n *     }\n *   }\n * `;\n * editor.addStyleSheet(css);\n *\n * adjustEditorThemeForContrast(editor);\n *\n * // Because adjustEditorThemeForContrast overrides the current theme, it should be called again\n * // to allow the editor to switch between light/dark themes.\n * window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {\n *   adjustEditorThemeForContrast(editor);\n * });\n *\n * window.matchMedia('print').addEventListener('change', () => {\n *   adjustEditorThemeForContrast(editor);\n * });\n * ```\n */\nconst adjustEditorThemeForContrast = (editor, options) => {\n    const editorElem = editor.getRootElement();\n    // Each set of entries in colorPairs should resolve to colors with sufficient\n    // contrast.\n    const colorPairs = [\n        ['--background-color-1', '--foreground-color-1', true, true],\n        ['--background-color-2', '--foreground-color-2', true, true],\n        ['--background-color-3', '--foreground-color-3', true, true],\n        ['--background-color-2', '--primary-action-foreground-color', false, true],\n        ['--selection-background-color', '--selection-foreground-color', false, true],\n    ];\n    if (!options?.dontClearOverrides) {\n        // Clear any overrides\n        for (const [backgroundVar, foregroundVar] of colorPairs) {\n            editorElem.style.setProperty(backgroundVar, null);\n            editorElem.style.setProperty(foregroundVar, null);\n        }\n    }\n    const styles = getComputedStyle(editorElem);\n    const updatedColors = Object.create(null);\n    const adjustVariablesForContrast = (var1, var2, minContrast, \n    // true if the variable can be updated\n    updateVar1, updateVar2) => {\n        // Fetch from updatedColors if available -- styles isn't updated dynamically.\n        let color1 = updatedColors[var1]\n            ? updatedColors[var1]\n            : Color4.fromString(styles.getPropertyValue(var1));\n        let color2 = updatedColors[var2]\n            ? updatedColors[var2]\n            : Color4.fromString(styles.getPropertyValue(var2));\n        // Ensure that color1 has the lesser luminance\n        if (color1.relativeLuminance() < color2.relativeLuminance()) {\n            const tmp = color1;\n            color1 = color2;\n            color2 = tmp;\n            const oldVar2 = var2;\n            var2 = var1;\n            var1 = oldVar2;\n            const oldUpdateVar1 = updateVar1;\n            updateVar1 = updateVar2;\n            updateVar2 = oldUpdateVar1;\n        }\n        let colorsUpdated = false;\n        let currentContrast = Color4.contrastRatio(color1, color2);\n        let iterations = 0;\n        // Step the brightness of color1 and color2 in different directions while necessary\n        while (currentContrast < minContrast && iterations < 8) {\n            const step = Vec3.of(0.1, 0.1, 0.1);\n            if (updateVar1) {\n                if (color2.eq(Color4.white) && !updateVar2) {\n                    color2 = Color4.black;\n                }\n                color1 = Color4.fromRGBVector(color1.rgb.plus(step));\n            }\n            if (updateVar2) {\n                if (color2.eq(Color4.black) && !updateVar1) {\n                    color2 = Color4.white;\n                }\n                color2 = Color4.fromRGBVector(color2.rgb.minus(step));\n            }\n            currentContrast = Color4.contrastRatio(color1, color2);\n            colorsUpdated = true;\n            iterations++;\n        }\n        // Update the CSS variables if necessary\n        if (colorsUpdated) {\n            editorElem.style.setProperty(var1, color1.toHexString());\n            editorElem.style.setProperty(var2, color2.toHexString());\n            updatedColors[var1] = color1;\n            updatedColors[var2] = color2;\n        }\n    };\n    // Also adjust the selection background\n    adjustVariablesForContrast('--selection-background-color', '--background-color-2', 1.29, true, false);\n    for (const [backgroundVar, foregroundVar, updateBackground, updateForeground] of colorPairs) {\n        const minContrast = 4.5;\n        adjustVariablesForContrast(backgroundVar, foregroundVar, minContrast, updateBackground, updateForeground);\n    }\n};\nexport default adjustEditorThemeForContrast;\n","// Note: Arrow functions cannot be used for type assertions. See\n// https://github.com/microsoft/TypeScript/issues/34523\n/**\n * Compile-time assertion that a branch of code is unreachable.\n * @internal\n */\nexport function assertUnreachable(key) {\n    // See https://stackoverflow.com/a/39419171/17055750\n    throw new Error(`Should be unreachable. Key: ${key}.`);\n}\n/**\n * Throws an exception if the typeof given value is not a number or `value` is NaN.\n *\n * @example\n * ```ts\n * const foo: unknown = 3;\n * assertIsNumber(foo);\n *\n * assertIsNumber('hello, world'); // throws an Error.\n * ```\n */\nexport function assertIsNumber(value, allowNaN = false) {\n    if (typeof value !== 'number' || (!allowNaN && isNaN(value))) {\n        throw new Error('Given value is not a number');\n    }\n}\nexport function assertIsArray(values) {\n    if (!Array.isArray(values)) {\n        throw new Error('Asserting isArray: Given entity is not an array');\n    }\n}\n/**\n * Throws if any of `values` is not of type number.\n */\nexport function assertIsNumberArray(values, allowNaN = false) {\n    assertIsArray(values);\n    assertIsNumber(values.length);\n    for (const value of values) {\n        assertIsNumber(value, allowNaN);\n    }\n}\n/**\n * Throws an exception if `typeof value` is not a boolean.\n */\nexport function assertIsBoolean(value) {\n    if (typeof value !== 'boolean') {\n        throw new Error('Given value is not a boolean');\n    }\n}\nexport function assertTruthy(value) {\n    if (!value) {\n        throw new Error(`${JSON.stringify(value)} is not truthy`);\n    }\n}\nexport function assertIsObject(value) {\n    if (typeof value !== 'object') {\n        throw new Error(`AssertIsObject: Given entity is not an object (type = ${typeof value})`);\n    }\n}\n","/**\n * Returns a size in bytes, KiB, or MiB with units suffix.\n */\nconst bytesToSizeString = (sizeBytes) => {\n    const sizeInKiB = sizeBytes / 1024;\n    const sizeInMiB = sizeInKiB / 1024;\n    const sizeInGiB = sizeInMiB / 1024;\n    let units = 'B';\n    let size = sizeBytes;\n    if (sizeInGiB >= 1) {\n        size = sizeInGiB;\n        units = 'GiB';\n    }\n    else if (sizeInMiB >= 1) {\n        size = sizeInMiB;\n        units = 'MiB';\n    }\n    else if (sizeInKiB >= 1) {\n        size = sizeInKiB;\n        units = 'KiB';\n    }\n    return { size, units };\n};\nexport default bytesToSizeString;\n","/**\n * Makes a clone of `element` and recursively applies styles from the original to the\n * clone's children.\n */\nconst cloneElementWithStyles = (element) => {\n    const restyle = (originalElement, clonedElement) => {\n        const originalComputedStyle = getComputedStyle(originalElement);\n        // jsdom doesn't support iterators in CSSStyleDeclarations. Iterate with\n        // an index.\n        for (let index = 0; index < originalComputedStyle.length; index++) {\n            const propertyName = originalComputedStyle.item(index);\n            const propertyValue = originalComputedStyle.getPropertyValue(propertyName);\n            clonedElement.style?.setProperty(propertyName, propertyValue);\n        }\n        for (let i = 0; i < originalElement.children.length; i++) {\n            const originalChild = originalElement.children.item(i);\n            const clonedChild = clonedElement.children.item(i);\n            if (originalChild && clonedChild) {\n                restyle(originalChild, clonedChild);\n            }\n            else {\n                console.warn('CloneElement: Missing child');\n            }\n        }\n    };\n    const elementClone = element.cloneNode(true);\n    restyle(element, elementClone);\n    return elementClone;\n};\nexport default cloneElementWithStyles;\n","export var ElementNamespace;\n(function (ElementNamespace) {\n    ElementNamespace[\"Html\"] = \"html\";\n    ElementNamespace[\"Svg\"] = \"svg\";\n})(ElementNamespace || (ElementNamespace = {}));\n/**\n * Shorthand for creating an element with `document.createElement`, then assigning properties.\n *\n * Non-HTML elements (e.g. `svg` elements) should use the `elementType` parameter to select\n * the element namespace.\n */\nconst createElement = (tag, props, elementType = ElementNamespace.Html) => {\n    let elem;\n    if (elementType === ElementNamespace.Html) {\n        elem = document.createElement(tag);\n    }\n    else if (elementType === ElementNamespace.Svg) {\n        elem = document.createElementNS('http://www.w3.org/2000/svg', tag);\n    }\n    else {\n        throw new Error(`Unknown element type ${elementType}`);\n    }\n    for (const [key, value] of Object.entries(props)) {\n        if (key === 'children')\n            continue;\n        if (typeof value !== 'string' && typeof value !== 'number') {\n            throw new Error(`Unsupported value type ${typeof value}`);\n        }\n        elem.setAttribute(key, value.toString());\n    }\n    if (props.children) {\n        for (const item of props.children) {\n            elem.appendChild(item);\n        }\n    }\n    return elem;\n};\nexport const createSvgElement = (tag, props) => {\n    return createElement(tag, props, ElementNamespace.Svg);\n};\nexport const createSvgElements = (tag, elements) => {\n    return elements.map((props) => createSvgElement(tag, props));\n};\nexport const createSvgPaths = (...paths) => {\n    return createSvgElements('path', paths);\n};\nexport default createElement;\n","/**\n * Converts `file` to a base64 data URL.\n */\nconst fileToBase64Url = async (file, options = {}) => {\n    try {\n        const reader = new FileReader();\n        return await new Promise((resolve, reject) => {\n            reader.onload = () => resolve(reader.result);\n            reader.onerror = reject;\n            reader.onabort = reject;\n            reader.onprogress = (evt) => {\n                options.onprogress?.(evt);\n            };\n            reader.readAsDataURL(file);\n        });\n    }\n    catch (error) {\n        // Files can fail to load with a FileReader in some cases. For example,\n        // in iOS Lockdown mode, where FileReader is unavailable.\n        (options.onWarning ?? console.warn)('Unable to convert file to base64 with a FileReader: ', error);\n        const arrayBuffer = await file.arrayBuffer();\n        const array = new Uint8Array(arrayBuffer);\n        // step: must be divisible by 3 (3 bytes = 4 base64 numerals)\n        //       If too large, this will fail (String.fromCharCode accepts a limited\n        //       number of arguments).\n        const step = 30;\n        const result = [];\n        for (let i = 0; i < array.length; i += step) {\n            // btoa accepts only characters with byte value 0-255 (which can be created\n            // with String.fromCharCode)\n            const stringByteArray = String.fromCharCode(...array.slice(i, i + step));\n            result.push(btoa(stringByteArray));\n        }\n        return `data:${file.type ?? 'image/*'};base64,${result.join('')}`;\n    }\n};\nexport default fileToBase64Url;\n","// See https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_code_values for\n// more\nconst keyToKeyCode = {\n    Control: 'ControlLeft',\n    '=': 'Equal',\n    '-': 'Minus',\n    ';': 'Semicolon',\n    ' ': 'Space',\n};\n/**\n * Attempts to guess the .code value corresponding to the given key.\n *\n * Use this to facilitate testing.\n *\n * If no matching keycode is found, returns `key`.\n */\nconst guessKeyCodeFromKey = (key) => {\n    const upperKey = key.toUpperCase();\n    if ('A' <= upperKey && upperKey <= 'Z') {\n        return `Key${upperKey}`;\n    }\n    if ('0' <= key && key <= '9') {\n        return `Digit${key}`;\n    }\n    if (key in keyToKeyCode) {\n        return keyToKeyCode[key];\n    }\n    return key;\n};\nexport default guessKeyCodeFromKey;\n","export  { default as adjustEditorThemeForContrast }  from './adjustEditorThemeForContrast.mjs';\nexport  { ReactiveValue, MutableReactiveValue }  from './ReactiveValue.mjs';\n","/**\n * Returns true iff all elements in the shorter list equal (===) the elements\n * in the longer list.\n */\nconst listPrefixMatch = (a, b) => {\n    const shorter = a.length < b.length ? a : b;\n    const longer = shorter === a ? b : a;\n    for (let i = 0; i < shorter.length; i++) {\n        if (shorter[i] !== longer[i]) {\n            return false;\n        }\n    }\n    return true;\n};\nexport default listPrefixMatch;\n","/**\n * Calls `callbacks` when different keys are known to be pressed.\n *\n * `filter` can be used to ignore events.\n *\n * This includes keys that didn't trigger a keydown or keyup event, but did cause\n * shiftKey/altKey/metaKey/etc. properties to change on other events (e.g. mousemove\n * events). Artifical events are created for these changes and sent to `callbacks`.\n */\nconst listenForKeyboardEventsFrom = (elem, callbacks) => {\n    // Track which keys are down so we can release them when the element\n    // loses focus. This is particularly important for keys like Control\n    // that can trigger shortcuts that cause the editor to lose focus before\n    // the keyup event is triggered.\n    let keysDown = [];\n    // Return whether two objects that are similar to keyboard events represent the\n    // same key.\n    const keyEventsMatch = (a, b) => {\n        return a.key === b.key && a.code === b.code;\n    };\n    const isKeyDown = (keyEvent) => {\n        return keysDown.some((other) => keyEventsMatch(other, keyEvent));\n    };\n    const keyEventToRecord = (event) => {\n        return {\n            code: event.code,\n            key: event.key,\n            ctrlKey: event.ctrlKey,\n            altKey: event.altKey,\n            shiftKey: event.shiftKey,\n            metaKey: event.metaKey,\n        };\n    };\n    const handleKeyEvent = (htmlEvent) => {\n        if (htmlEvent.type === 'keydown') {\n            // Add event to the list of keys that are down (so long as it\n            // isn't a duplicate).\n            if (!isKeyDown(htmlEvent)) {\n                // Destructructring, then pushing seems to cause\n                // data loss. Copy properties individually:\n                keysDown.push(keyEventToRecord(htmlEvent));\n            }\n            if (!callbacks.filter(htmlEvent)) {\n                return;\n            }\n            callbacks.handleKeyDown(htmlEvent);\n        }\n        else {\n            // keyup\n            console.assert(htmlEvent.type === 'keyup');\n            // Remove the key from keysDown -- it's no longer down.\n            keysDown = keysDown.filter((event) => {\n                const matches = keyEventsMatch(event, htmlEvent);\n                return !matches;\n            });\n            if (!callbacks.filter(htmlEvent)) {\n                return;\n            }\n            callbacks.handleKeyUp(htmlEvent);\n        }\n    };\n    elem.addEventListener('keydown', (htmlEvent) => {\n        handleKeyEvent(htmlEvent);\n    });\n    elem.addEventListener('keyup', (htmlEvent) => {\n        handleKeyEvent(htmlEvent);\n    });\n    elem.addEventListener('focusout', (focusEvent) => {\n        let stillHasFocus = false;\n        if (focusEvent.relatedTarget) {\n            const relatedTarget = focusEvent.relatedTarget;\n            stillHasFocus =\n                elem.contains(relatedTarget) || callbacks.getHandlesKeyEventsFrom(relatedTarget);\n        }\n        if (!stillHasFocus) {\n            for (const event of keysDown) {\n                callbacks.handleKeyUp(new KeyboardEvent('keyup', {\n                    ...event,\n                }));\n            }\n            keysDown = [];\n        }\n    });\n    const fireArtificalEventsBasedOn = (htmlEvent) => {\n        let wasShiftDown = false;\n        let wasCtrlDown = false;\n        let wasAltDown = false;\n        let wasMetaDown = false;\n        for (const otherEvent of keysDown) {\n            const code = otherEvent.code;\n            wasShiftDown ||= !!code.match(/^Shift(Left|Right)$/);\n            wasCtrlDown ||= !!code.match(/^Control(Left|Right)$/);\n            wasAltDown ||= !!code.match(/^Alt(Left|Right)$/);\n            wasMetaDown ||= !!code.match(/^Meta(Left|Right)$/);\n        }\n        const eventName = (isDown) => {\n            if (isDown) {\n                return 'keydown';\n            }\n            else {\n                return 'keyup';\n            }\n        };\n        const eventInitDefaults = {\n            shiftKey: htmlEvent.shiftKey,\n            altKey: htmlEvent.altKey,\n            metaKey: htmlEvent.metaKey,\n            ctrlKey: htmlEvent.ctrlKey,\n        };\n        if (htmlEvent.shiftKey !== wasShiftDown) {\n            handleKeyEvent(new KeyboardEvent(eventName(htmlEvent.shiftKey), {\n                ...eventInitDefaults,\n                key: 'Shift',\n                code: 'ShiftLeft',\n            }));\n        }\n        if (htmlEvent.altKey !== wasAltDown) {\n            handleKeyEvent(new KeyboardEvent(eventName(htmlEvent.altKey), {\n                ...eventInitDefaults,\n                key: 'Alt',\n                code: 'AltLeft',\n            }));\n        }\n        if (htmlEvent.ctrlKey !== wasCtrlDown) {\n            handleKeyEvent(new KeyboardEvent(eventName(htmlEvent.ctrlKey), {\n                ...eventInitDefaults,\n                key: 'Control',\n                code: 'ControlLeft',\n            }));\n        }\n        if (htmlEvent.metaKey !== wasMetaDown) {\n            handleKeyEvent(new KeyboardEvent(eventName(htmlEvent.metaKey), {\n                ...eventInitDefaults,\n                key: 'Meta',\n                code: 'MetaLeft',\n            }));\n        }\n    };\n    elem.addEventListener('mousedown', (htmlEvent) => {\n        fireArtificalEventsBasedOn(htmlEvent);\n    });\n    elem.addEventListener('mousemove', (htmlEvent) => {\n        fireArtificalEventsBasedOn(htmlEvent);\n    });\n};\nexport default listenForKeyboardEventsFrom;\n","/**\n * Calls `options.onStart` at the start of a long press or hover.\n * Calls `options.onEnd` when no pointers are within the container.\n */\nconst listenForLongPressOrHover = (target, options) => {\n    const pointersInside = new Map();\n    let timeoutId = null;\n    let isLongPressInProgress = false;\n    const updateTimeout = () => {\n        if (pointersInside.size === 0) {\n            if (isLongPressInProgress) {\n                isLongPressInProgress = false;\n                options.onEnd();\n            }\n            else if (timeoutId !== null) {\n                clearTimeout(timeoutId);\n                timeoutId = null;\n            }\n        }\n        else {\n            const nowTime = Date.now();\n            let timeSinceFirstPointer = 0; // ms\n            for (const record of pointersInside.values()) {\n                const timeSince = nowTime - record.timeEnter;\n                timeSinceFirstPointer = Math.max(timeSince, timeSinceFirstPointer);\n            }\n            const longPressTimeout = options.longPressTimeout ?? 700; // ms\n            if (timeoutId !== null) {\n                clearTimeout(timeoutId);\n                timeoutId = null;\n            }\n            const timeLeft = longPressTimeout - timeSinceFirstPointer;\n            if (timeLeft <= 0) {\n                options.onStart();\n                isLongPressInProgress = true;\n            }\n            else {\n                timeoutId = setTimeout(() => {\n                    timeoutId = null;\n                    updateTimeout();\n                }, timeLeft);\n            }\n        }\n    };\n    // Detects long press\n    const pointerEventListener = (event) => {\n        const eventRecord = {\n            timeEnter: Date.now(),\n        };\n        if (event.type === 'pointerenter') {\n            pointersInside.set(event.pointerId, eventRecord);\n        }\n        else if (event.type === 'pointerleave' || event.type === 'pointercancel') {\n            // In some cases (for example, a click with a stylus on Android/Chrome), moving the pen\n            // over the target, clicking, then moving the pen out of the target produces input\n            // similar to this:\n            // - pointerenter (pointerId: 4)\n            // - pointerleave (pointerId: 4)\n            // - pointerenter (pointerId: 6)\n            // - pointerenter (pointerId: 1)\n            // - pointerleave (pointerId: 6)\n            // Observe that no pointerleave event was fired for the pointer with ID 1.\n            pointersInside.clear();\n        }\n        updateTimeout();\n    };\n    target.addEventListener('pointerenter', pointerEventListener);\n    target.addEventListener('pointerleave', pointerEventListener);\n    target.addEventListener('pointercancel', pointerEventListener);\n    return {\n        removeListeners: () => {\n            target.removeEventListener('pointerenter', pointerEventListener);\n            target.removeEventListener('pointerleave', pointerEventListener);\n            target.removeEventListener('pointercancel', pointerEventListener);\n        },\n    };\n};\nexport default listenForLongPressOrHover;\n","const mitLicenseAttribution = (copyright) => {\n    const removeSingleLineBreaks = (text) => text.replace(/([^\\n])[\\n]([^\\n])/g, '$1 $2');\n    return removeSingleLineBreaks(`\nMIT License\n\nCopyright (c) ${copyright}\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.`);\n};\nexport default mitLicenseAttribution;\n","const stopPropagationOfScrollingWheelEvents = (scrollingContainer) => {\n    const scrollsAxis = (delta, clientSize, scrollOffset, scrollSize) => {\n        const hasScroll = clientSize !== scrollSize && delta !== 0;\n        const eventScrollsPastStart = scrollOffset + delta <= 0;\n        const scrollEnd = scrollOffset + clientSize;\n        const eventScrollsPastEnd = scrollEnd + delta > scrollSize;\n        return hasScroll && !eventScrollsPastStart && !eventScrollsPastEnd;\n    };\n    scrollingContainer.onwheel = (event) => {\n        const scrollsX = scrollsAxis(event.deltaX, scrollingContainer.clientWidth, scrollingContainer.scrollLeft, scrollingContainer.scrollWidth);\n        const scrollsY = scrollsAxis(event.deltaY, scrollingContainer.clientHeight, scrollingContainer.scrollTop, scrollingContainer.scrollHeight);\n        // Stop the editor from receiving the event if it will scroll the pen type selector\n        // instead.\n        if (scrollsX || scrollsY) {\n            event.stopPropagation();\n        }\n    };\n};\nexport default stopPropagationOfScrollingWheelEvents;\n","/** @internal */\nconst untilNextAnimationFrame = () => {\n    return new Promise((resolve) => {\n        requestAnimationFrame(() => resolve());\n    });\n};\nexport default untilNextAnimationFrame;\n","/**\n * Resolves when all given promises have resolved. If no promises are given,\n * does not return a Promise.\n *\n * If all elements of `results` are known to be `Promise`s, use `Promise.all`.\n */\nconst waitForAll = (results) => {\n    // If any are Promises...\n    if (results.some((command) => command && command['then'])) {\n        // Wait for all commands to finish.\n        return (Promise.all(results)\n            // Ensure we return a Promise<void> and not a Promise<void[]>\n            .then(() => { }));\n    }\n    return;\n};\nexport default waitForAll;\n","const waitForImageLoad = async (image) => {\n    if (!image.complete) {\n        await new Promise((resolve, reject) => {\n            image.onload = (event) => resolve(event);\n            // TODO(v2): Return a `new Error(event.message)`\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors -- Forwarding an error-like object.\n            image.onerror = (event) => reject(event);\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors -- Forwarding an error-like object.\n            image.onabort = (event) => reject(event);\n        });\n    }\n};\nexport default waitForImageLoad;\n","/** Returns a promise that resolves after `timeout` milliseconds. */\nconst waitForTimeout = (timeout) => {\n    return new Promise((resolve) => {\n        setTimeout(() => resolve(), timeout);\n    });\n};\nexport default waitForTimeout;\n","/**\n * Contains the current version of the library -- used\n * internaly (e.g. for documentation).\n * @internal\n */\nexport default {\n    number: '1.26.0',\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Editor, EditorEventType, } from \"js-draw\";\nimport \"js-draw/bundledStyles\";\nimport { Color4 } from \"@js-draw/math\";\nimport { getSVG, queueSave } from \"./data/db\";\nimport { update, updateZoom } from \"./update\";\nimport { initToolbar } from \"./toolbar/toolbar\";\nconst initializeEditor = () => {\n    const editor = new Editor(document.body, {\n        wheelEventsEnabled: false,\n        // maxZoom: 1,\n        // minZoom: 1,\n    });\n    const toolbar = initToolbar(editor);\n    editor.dispatch(editor.setBackgroundStyle({\n        color: Color4.transparent,\n        autoresize: true,\n        // type: BackgroundComponentBackgroundType.Grid,\n    }));\n    editor.notifier.on(EditorEventType.CommandDone, (event) => {\n        queueSave(editor);\n    });\n    editor.notifier.on(EditorEventType.CommandUndone, (event) => {\n        queueSave(editor);\n    });\n    getSVG(document.location.href).then((svg) => {\n        if (svg && typeof svg === \"string\") {\n            editor.loadFromSVG(svg);\n        }\n    });\n    return { editor, toolbar };\n};\nlet editor;\nlet toolbar;\ndocument.addEventListener(\"scroll\", () => {\n    if (editor) {\n        update(editor, window);\n    }\n});\nbrowser.runtime.onMessage.addListener((message) => {\n    if (message.command === \"show-toolbar\") {\n        if (!toolbar || !editor) {\n            ({ editor, toolbar } = initializeEditor());\n        }\n        updateZoom(editor, window);\n        document.querySelector(\".js-draw\")?.classList.remove(\"display-none\");\n    }\n});\n"],"names":[],"sourceRoot":""}