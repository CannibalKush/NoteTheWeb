/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/js-draw/dist/bundledStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/js-draw/dist/bundledStyles.js ***!
  \****************************************************/
/***/ (() => {

var jsdrawStyles=(()=>{(()=>{if(typeof document<"u"&&typeof document.createElement=="function"){let o=document.createElement("style");o.textContent='\uFEFF:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content>div>div{padding:5px}:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content>div{min-height:0}:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content img{max-width:100%;max-height:100%;display:block;margin-left:auto;margin-right:auto}:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content .insert-image-image-status-view{display:flex;justify-content:space-between;padding-bottom:0}:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content .action-button-row{margin-top:4px;display:flex;flex-direction:row;justify-content:flex-end;padding-bottom:0;margin-bottom:0}:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content .action-button-row>button{flex-grow:1;text-align:end;max-width:50%;min-width:min(100%,40px)}.toolbar-overflow-widget-overflow-list{display:flex;flex-direction:column;flex-wrap:wrap;justify-content:center}.toolbar-overflow-widget-overflow-list>.toolbar-toolContainer>.toolbar-button{height:var(--toolbar-button-height)}.toolbar-overflow-widget.horizontal .toolbar-overflow-widget-overflow-list{flex-direction:row}.toolbar-overflow-widget.horizontal>.toolbar-dropdown{max-width:100%;left:15px;right:15px;margin-left:0 !important;translate:none !important;padding:4px}:root .toolbar--pen-tool-toggle-buttons.toolbar--pen-tool-toggle-buttons{display:flex;justify-content:stretch;padding-top:0;padding-bottom:5px;direction:ltr}:root .toolbar--pen-tool-toggle-buttons.toolbar--pen-tool-toggle-buttons>*{flex-grow:1;text-align:start;margin-inline-end:5px}:root .toolbar--pen-tool-toggle-buttons.toolbar--pen-tool-toggle-buttons>* .icon{margin:0;margin-inline-start:4px;margin-inline-end:10px}:root .toolbar--pen-tool-toggle-buttons.toolbar--pen-tool-toggle-buttons>:nth-child(1){direction:ltr}:root .toolbar--pen-tool-toggle-buttons.toolbar--pen-tool-toggle-buttons>:last-child{direction:rtl}.toolbar-zoomLevelEditor{display:flex;flex-direction:row;align-items:center}.toolbar-zoomLevelEditor .zoomDisplay{flex-grow:1}.toolbar-zoomLevelEditor button{min-width:48px}.selection-format-menu.disabled{opacity:.5}.toolbar-document-properties-widget button.about-button{width:100%;text-align:end}.toolbar-document-properties-widget>*{--align-items-to-x: 120px}.toolbar-document-properties-widget .js-draw-size-input-row.js-draw-size-input-row{display:flex}.toolbar-document-properties-widget .js-draw-size-input-row.js-draw-size-input-row.size-input-row--automatic-size{display:none}.toolbar-thicknessSliderContainer{display:flex;flex-direction:row}.toolbar-thicknessSliderContainer input{flex-grow:1}.toolbar-element .clr-field *{cursor:pointer}.toolbar-element .clr-field button{width:1.2em;height:1.2em;top:50%;left:0;border-radius:50%;margin-left:0;margin-right:0}.toolbar-element .clr-field input{opacity:0}.color-input-container{display:inline-flex;flex-direction:row}.color-input-container .coloris_input{height:calc(100% - 6px)}.color-input-container.picker-open .clr-field{pointer-events:none}:root .color-input-container>button.pipetteButton{width:30px;height:30px;padding:0;display:inline-flex}.color-input-container>.color-input-wrapper{display:flex;justify-content:stretch}.color-input-container .pipetteButton>svg{width:100%}.color-input-container .pipetteButton .pickColorInstructions{display:none;font-size:1em;position:absolute;margin-left:30px;background-color:var(--background-color-1);border-radius:30px;padding:4px;opacity:0;transition:.2s ease opacity}@media(prefers-reduced-motion: reduce){.color-input-container .pipetteButton .pickColorInstructions{transition:none}}.color-input-container .pipetteButton.active{background-color:var(--selection-background-color);--icon-color: var(--selection-foreground-color)}.color-input-container .pipetteButton.active .pickColorInstructions{display:block;opacity:.8}.tool-dropdown-separator{--border-color: rgba(100, 100, 100, 0.2);--border-color: color-mix(in srgb, var(--foreground-color-1), rgba(0, 0, 0, 0) 80%);border-top:1px solid var(--border-color);padding-left:2px;margin-top:10px;margin-bottom:10px}.toolbar-element .toolbar--file-input-container{display:flex}.toolbar-element .toolbar--file-input-container.-loading{opacity:.8}.toolbar-element .toolbar--file-input-container>input.file-input{opacity:0;width:0;min-width:0 !important;max-width:0;height:0;overflow:hidden;padding:0;margin:0}.toolbar-element .toolbar--file-input-container>label{display:block;flex-grow:1;padding:0 !important;padding-bottom:5px;--active-border-color: rgba(100, 100, 100, 0.5);--active-border-color: color-mix(in srgb, var(--foreground-color-1), transparent)}.toolbar-element .toolbar--file-input-container>label .cancel-button{padding-left:3px;padding-right:3px}.toolbar-element .toolbar--file-input-container>label>.toolbar--file-input-description{background-color:var(--background-color-3);color:var(--foreground-color-3);border:1px dashed var(--active-border-color);padding:10px;margin-top:10px;display:flex;flex-direction:column;align-items:center;text-align:center;--action-color: var(--primary-action-foreground-color);--icon-color: var(--action-color)}.toolbar-element .toolbar--file-input-container>label>.toolbar--file-input-description>span{white-space:pre-wrap}.toolbar-element .toolbar--file-input-container>label>.toolbar--file-input-description>span>b{color:var(--action-color);cursor:pointer}.toolbar-element .toolbar--file-input-container>label>.toolbar--file-input-description>.icon{width:min(50vw,42px);height:min(50vw,42px);margin-bottom:8px;display:block}.toolbar-element .toolbar--file-input-container>label:active,.toolbar-element .toolbar--file-input-container>label:hover,.toolbar-element .toolbar--file-input-container>label.drag-target{--active-border-color: var(--foreground-color-1)}.toolbar-element .toolbar--file-input-container>label.drag-target>.toolbar--file-input-description{border-width:2px}.toolbar-grid-selector{position:relative}.toolbar-grid-selector>div{display:flex;flex-direction:row;max-width:350px;flex-wrap:wrap;--button-size: 48px}.toolbar-grid-selector .choice-button{display:flex;flex-direction:column-reverse;box-sizing:border-box;cursor:pointer;flex-shrink:1;margin:2px}.toolbar-grid-selector .choice-button.focus-visible{outline:2px solid var(--foreground-color-1)}.toolbar-grid-selector .choice-button input{opacity:0;height:0}.toolbar-grid-selector .choice-button label{display:flex;flex-direction:column;box-sizing:border-box;width:var(--button-size);height:var(--button-size);font-size:.7rem;align-items:center;justify-content:center;padding:4px;user-select:none;-webkit-user-select:none}.toolbar-grid-selector .choice-button .icon{flex-grow:1;flex-shrink:1;width:100%}.toolbar-grid-selector .choice-button.checked{background-color:var(--selection-background-color);color:var(--selection-foreground-color);--icon-color: var(--selection-foreground-color)}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list{height:min(200px,50vh);position:relative;display:flex;align-items:center}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.scroller{display:flex;flex-direction:column;overflow-y:auto;scroll-snap-type:y mandatory;height:100%;width:100%;flex-grow:1}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.scroller>.item{height:100%;width:100%;flex-shrink:0;display:flex;justify-content:center;align-items:center;scroll-snap-align:start;scroll-snap-stop:always;box-sizing:border-box}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.-empty{display:none}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.page-markers{overflow:hidden;display:flex;flex-direction:column;align-items:center;max-height:100%;min-height:0}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.page-markers.-one-element{visibility:hidden}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.page-markers>.marker{padding:2px;opacity:.1;cursor:pointer;left:0;transition:left .2s ease}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.page-markers>.marker>.content{background-color:var(--foreground-color-1);border-radius:2px;padding:2px}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.page-markers>.marker.-active{position:relative;left:2px;opacity:.2}.toolbar-root{background-color:var(--background-color-1);--icon-color: var(--foreground-color-1);--toolbar-button-height: min(20vh, 60px);flex-wrap:wrap;box-sizing:border-box;width:100%;display:flex;flex-direction:row;justify-content:center}.toolbar-element{z-index:1;font-family:system-ui,-apple-system,sans-serif}.toolbar-element details>summary{cursor:pointer}.toolbar-element>.toolbar-toolContainer>.toolbar-button,.toolbar-element>.toolbar-toolContainer>*>button,.toolbar-element>.toolbar-buttonGroup>button,.toolbar-element>.toolbar-button{white-space:pre;height:var(--toolbar-button-height)}.toolbar-dropdown .toolbar-button>.toolbar-icon{max-width:50px;width:100%}.toolbar-button.disabled{filter:sepia(0.2);opacity:.45;cursor:unset}.toolbar-button,.toolbar-element button{cursor:pointer;text-align:center;border-radius:6px;border:none;box-shadow:0px 0px 2px var(--shadow-color);user-select:none;-webkit-user-select:none;transition:background-color .15s ease,box-shadow .25s ease,opacity .2s ease}.toolbar-button,.toolbar-buttonGroup>button,.toolbar-toolContainer>*>button,.toolbar-root>button{display:flex;flex-direction:column;align-items:center;justify-content:center;padding-left:3px;padding-right:3px;min-width:40px;max-width:105px;width:min-content;font-size:1em}.toolbar-button>label{cursor:inherit;user-select:none;-webkit-user-select:none}.toolbar-root>.toolbar-toolContainer>.toolbar-button>label.long-label{font-size:.75em}.toolbar-dropdown>.toolbar-toolContainer>button,.toolbar-dropdown>.toolbar-toolContainer>.toolbar-button{width:6em}.toolbar-button:not(.disabled):hover,.toolbar-root button:not(:disabled):hover{box-shadow:0px 2px 4px var(--shadow-color)}.toolbar-root button:disabled{cursor:inherit;opacity:.5}.toolbar-root .toolbar-icon{flex-shrink:1;user-select:none;width:100%;min-width:20px;min-height:20px}.toolbar-toolContainer.selected>.toolbar-button{background-color:var(--selection-background-color);color:var(--selection-foreground-color);--icon-color: var(--selection-foreground-color)}.toolbar-toolContainer:not(.selected):not(.dropdownShowable)>.toolbar-button>.toolbar-showHideDropdownIcon{display:none}.toolbar-toolContainer>.toolbar-button>.toolbar-showHideDropdownIcon{height:15px;transition:transform .25s ease}.toolbar-toolContainer.dropdownVisible>.toolbar-button>.toolbar-showHideDropdownIcon{transform:rotate(180deg)}.toolbar-dropdown.hidden,.toolbar-toolContainer:not(.selected):not(.dropdownShowable)>.toolbar-dropdown:not(.hiding){display:none}.toolbar-dropdown{position:absolute;padding:15px;padding-top:5px;display:flex;flex-wrap:wrap;flex-direction:column;max-height:80vh;max-width:fit-content;z-index:2;background-color:var(--background-color-1);box-shadow:0px 3px 3px var(--shadow-color)}@keyframes dropdown-transition-in{0%{opacity:0;transform:scale(1, 0)}100%{opacity:1;transform:scale(1, 1)}}@keyframes dropdown-transition-out{0%{opacity:1;transform:scale(1, 1)}100%{opacity:0;transform:scale(1, 0)}}.toolbar-dropdown{transform-origin:top left;--dropdown-show-animation: dropdown-transition-in;--dropdown-hide-animation: dropdown-transition-out}@media(prefers-reduced-motion: reduce){.toolbar-dropdown{--dropdown-show-animation: none;--dropdown-hide-animation: none}.toolbar-dropdown.hiding{display:none}.toolbar-toolContainer>.toolbar-button>.toolbar-showHideDropdownIcon{transition:none}:root .toolbar-button,.toolbar-root button{transition:none}}.toolbar-buttonGroup{display:flex;flex-direction:row;justify-content:center}.toolbar-element .toolbar--toggle-button{color:var(--foreground-color-1);font-weight:normal}.toolbar-element .toolbar--toggle-button[aria-checked=true]{background:var(--selection-background-color);color:var(--selection-foreground-color)}.toolbar-element .toolbar--toggle-button>.icon{width:25px;height:25px;margin:0 5px}.toolbar-element .toolbar--toggle-button>*{vertical-align:middle}.toolbar-closeColorPickerOverlay{display:none;position:fixed;top:0;left:0;bottom:0;right:0;touch-action:none;background-color:var(--background-color-1);opacity:.3;z-index:2}.toolbar-spacedList>*{padding-bottom:5px;padding-top:5px}.toolbar-indentedList{padding-left:10px}@media print{.toolbar-element{display:none}}@keyframes rehide-label{0%{opacity:.8}80%{opacity:.8}100%{opacity:.1}}@keyframes show-label-delayed{0%{opacity:0}80%{opacity:0}100%{opacity:.8}}@keyframes show-label-now{0%{opacity:0}5%{opacity:0}100%{opacity:.8}}@keyframes keep-label-hidden{0%{opacity:0}100%{opacity:0}}@keyframes toolbar--edgemenu-transition-in{from{transform:translate(0, 100%)}to{transform:translate(0, 0)}}@keyframes toolbar--edgemenu-transition-in-reduce-motion{from{opacity:0}to{opacity:1}}@keyframes toolbar--edgemenu-transition-out{to{transform:translate(0, 100%)}}@keyframes toolbar--edgemenu-transition-out-reduce-motion{from{opacity:1}to{opacity:0}}@keyframes toolbar--edgemenu-container-transition-in{from{overflow-y:hidden}to{overflow-y:hidden}}@keyframes toolbar--edgemenu-container-transition-out{from{overflow-y:hidden}to{overflow-y:hidden}}.toolbar-edge-toolbar{--toolbar-button-height: min(20vh, 48px);--toolbar-button-size: var(--toolbar-button-height);--label-hover-offset-size: calc(14px + var(--toolbar-button-height));box-sizing:border-box;flex-direction:row;justify-content:space-around;--button-label-hover-offset-y: var(--label-hover-offset-size);--button-label-hover-offset-x: 0}@media screen and (min-width: 540px){.toolbar-edge-toolbar{flex-wrap:nowrap}.toolbar-edge-toolbar>.toolbar-action-row{max-width:50vw;flex-grow:0;flex-shrink:0}}@media screen and (max-width: 700px){.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline{font-size:.9em}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button{width:var(--toolbar-button-size)}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button label{opacity:0;animation:.2s linear hide-initially}@keyframes hide-initially{from{opacity:0}to{opacity:0}}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):hover:not(:focus-visible)>label,.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):active>label{opacity:.8;animation:1s ease show-label-delayed}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button.has-long-press-or-hover>label{opacity:.8}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button:focus-visible>label,.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button.focus-visible>label{animation:1.5s ease rehide-label;opacity:0}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button:has(:focus-visible)>label{animation:1.5s ease rehide-label;opacity:0}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button>label{opacity:0;position:absolute;margin-top:var(--button-label-hover-offset-y);margin-left:var(--button-label-hover-offset-x);z-index:1;pointer-events:none;background-color:var(--background-color-1);color:var(--foreground-color-1);border-radius:25px;padding:10px;transition:.3s ease opacity,.2s ease margin-top}}@media screen and (max-width: 700px)and (prefers-reduced-motion: reduce){.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button>label{transition:none}}@media screen and (max-width: 700px){.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button>.toolbar-icon.toolbar-icon{margin-left:0;margin-right:0}}.toolbar-edge-toolbar>div.toolbar-element{flex-direction:row;display:flex;flex-grow:1;justify-content:center;background-color:var(--background-color-2);color:var(--foreground-color-2);--icon-color: var(--foreground-color-2);--extra-left-right-padding: 0px}.toolbar-edge-toolbar>div.toolbar-element::-webkit-scrollbar{width:3px;height:3px}.toolbar-edge-toolbar>div.toolbar-element::-webkit-scrollbar-thumb{background-color:var(--shadow-color)}.toolbar-edge-toolbar>div.toolbar-element.toolbar-tool-row{overflow-x:auto;overflow-y:hidden;flex-grow:100}.toolbar-edge-toolbar>div.toolbar-element.toolbar-action-row{z-index:2;background-color:var(--background-color-3);color:var(--foreground-color-3);--icon-color: var(--foreground-color-3)}.toolbar-edge-toolbar>div.toolbar-element.has-scroll{justify-content:start;position:relative;--button-label-hover-offset-y: 0;--button-label-hover-offset-x: calc(0px - var(--label-hover-offset-size))}.toolbar-edge-toolbar>div.toolbar-element.has-scroll>:nth-child(1){--button-label-hover-offset-x: var(--label-hover-offset-size)}.toolbar-edge-toolbar .toolbar-toolContainer.selected>.toolbar-button{background-color:var(--selection-background-color);color:var(--selection-foreground-color);--icon-color: var(--selection-foreground-color)}.toolbar-edge-toolbar .toolbar-button{box-sizing:border-box;background-color:rgba(0,0,0,0)}.toolbar-edge-toolbar .toolbar-button .toolbar-showHideDropdownIcon{flex-shrink:.01;height:12px}.toolbar-edge-toolbar .toolbar-toolContainer{order:1}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline{flex-grow:1;display:flex;--button-flex-direction: row}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline.label-left{justify-content:end;--button-flex-direction: row-reverse;order:100}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline.label-left>.toolbar-button>.toolbar-icon{margin-left:7px;margin-right:0}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline.label-right{order:-1}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline>.toolbar-button{width:auto;flex-direction:var(--button-flex-direction)}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline>.toolbar-button>.toolbar-icon{height:100%;margin-right:7px;margin-left:0;width:22px}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button{width:calc(var(--toolbar-button-size) + var(--extra-left-right-padding));height:var(--toolbar-button-size)}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):hover:not(:focus-visible)>label,.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):active>label{opacity:.8;animation:1s ease show-label-delayed}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button.has-long-press-or-hover>label{opacity:.8}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button:focus-visible>label,.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button.focus-visible>label{animation:1.5s ease rehide-label;opacity:0}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button:has(:focus-visible)>label{animation:1.5s ease rehide-label;opacity:0}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button>label{opacity:0;position:absolute;margin-top:var(--button-label-hover-offset-y);margin-left:var(--button-label-hover-offset-x);z-index:1;pointer-events:none;background-color:var(--background-color-1);color:var(--foreground-color-1);border-radius:25px;padding:10px;transition:.3s ease opacity,.2s ease margin-top}@media(prefers-reduced-motion: reduce){.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button>label{transition:none}}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline).dropdownVisible>.toolbar-button>label{opacity:.8;animation:1.5s ease rehide-label .3s,1s ease keep-label-hidden 1.8s infinite}.toolbar-edge-toolbar>div>.toolbar-toolContainer:not(.selected):not(.dropdownShowable)>.toolbar-button>.toolbar-showHideDropdownIcon{display:block;visibility:hidden}.toolbar-edge-toolbar .toolbar-toolContainer>.toolbar-button{margin:0;border-radius:0;padding:8px;box-shadow:none}.toolbar-edge-toolbar .toolbar-toolContainer>.toolbar-button.has-dropdown{padding-left:8px;padding-right:8px;padding-top:8px;padding-bottom:0px}.imageEditorContainer.pipette--color-selection-in-progress .toolbar-edgemenu-container{height:0;background-color:rgba(0,0,0,0);opacity:.9}.imageEditorContainer.pipette--color-selection-in-progress .toolbar-edgemenu-container .toolbar-edgemenu{position:absolute}.toolbar-edgemenu-container{background-color:var(--background-color-transparent);transition:.15s ease-in-out height,.15s ease-in-out background-color,.2s ease-in-out opacity;position:absolute;width:var(--editor-current-width-px);height:var(--editor-current-height-px);box-sizing:border-box;display:flex;flex-direction:column-reverse;align-items:center;z-index:2}@media(prefers-reduced-motion: reduce){.toolbar-edgemenu-container{transition:.15s ease-in-out background-color,.2s ease-in-out opacity}}.toolbar-edgemenu-container.dropdown-below-edge{overflow-y:hidden}.toolbar-edgemenu-container button{font-size:1.2em;box-shadow:none;border:none;padding:10px;transition:.2s ease box-shadow;font-weight:bold;color:var(--primary-action-foreground-color)}.toolbar-edgemenu-container button:not(:disabled):hover{box-shadow:0 1px 2px var(--shadow-color)}.toolbar-edgemenu-container button:disabled{opacity:.5;font-weight:unset;cursor:unset;color:var(--foreground-color-1)}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button{--button-label-hover-offset-y: var(--button-size)}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):hover:not(:focus-visible)>label>.button-label-text,.toolbar-edgemenu-container .toolbar-grid-selector .choice-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):active>label>.button-label-text{opacity:.8;animation:1s ease show-label-delayed}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button.has-long-press-or-hover>label>.button-label-text{opacity:.8}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button:focus-visible>label>.button-label-text,.toolbar-edgemenu-container .toolbar-grid-selector .choice-button.focus-visible>label>.button-label-text{animation:1.5s ease rehide-label;opacity:0}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button:has(:focus-visible)>label>.button-label-text{animation:1.5s ease rehide-label;opacity:0}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button>label>.button-label-text{opacity:0;position:absolute;margin-top:var(--button-label-hover-offset-y);margin-left:var(--button-label-hover-offset-x);z-index:1;pointer-events:none;background-color:var(--background-color-1);color:var(--foreground-color-1);border-radius:25px;padding:10px;transition:.3s ease opacity,.2s ease margin-top}@media(prefers-reduced-motion: reduce){.toolbar-edgemenu-container .toolbar-grid-selector .choice-button>label>.button-label-text{transition:none}}.toolbar-edgemenu-container .toolbar-help-overlay-button{align-items:last baseline}.toolbar-edgemenu-container .toolbar-edgemenu{--toolbar-button-height: 48px;touch-action:none;user-select:none;-webkit-user-select:none;background-color:var(--background-color-2);color:var(--foreground-color-2);--icon-color: var(--foreground-color-2);box-shadow:0px 0px 1px var(--shadow-color);padding-left:10px;padding-right:10px;width:min(400px,100vw);box-sizing:border-box;border-top-left-radius:30px;border-top-right-radius:30px;transition:transform .1s ease,padding-bottom .1s ease}.toolbar-edgemenu-container .toolbar-edgemenu input,.toolbar-edgemenu-container .toolbar-edgemenu textarea{user-select:auto;-webkit-user-select:auto}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer{display:inline-block}.toolbar-edgemenu-container .toolbar-edgemenu button{background-color:rgba(0,0,0,0)}.toolbar-edgemenu-container .toolbar-edgemenu>button.drag-elem{height:40px;display:block;cursor:ns-resize;position:relative;margin-top:-15px;margin-bottom:10px;width:100%;border:none;box-shadow:none;background:rgba(0,0,0,0)}.toolbar-edgemenu-container .toolbar-edgemenu>button.drag-elem::before{content:"";background-color:var(--icon-color);opacity:.2;display:block;position:relative;top:10px;height:5px;border-radius:5px;width:min(80%,40px);margin-left:auto;margin-right:auto}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer{display:block}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer .toolbar-button{flex-direction:row;max-width:unset;width:100%;box-sizing:border-box;justify-content:flex-start;box-shadow:none;padding:2px}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer .toolbar-button>.toolbar-icon{width:25px;height:25px;padding:13px;margin-right:15px}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer .toolbar-button label,.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer .toolbar-button>label.long-label{font-size:1em}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-nonbutton-controls-main-list{padding-left:10px;padding-right:10px}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList{box-sizing:border-box;--align-items-to-x: 105px}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList>div{display:flex;align-items:center;margin-top:5px;min-height:35px}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList>div:first-child{margin-top:0}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList>div>label{padding-right:35px;min-width:var(--align-items-to-x);flex-shrink:1;box-sizing:border-box}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList>div>input[type=checkbox]{width:20px;height:20px;margin-left:0}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList>div>input:not([type=checkbox]){flex-grow:1;min-width:48px;flex-shrink:1}.toolbar-dropdown-toolbar button,.toolbar-dropdown-toolbar .toolbar-button{background-color:var(--background-color-2);color:var(--foreground-color-2);--icon-color: var(--foreground-color-2)}.toolbar-dropdown-toolbar,.toolbar-dropdown-toolbar .toolbar-dropdown{background-color:var(--background-color-3);color:var(--foreground-color-3)}.toolbar-dropdown-toolbar .toolbar-spacedList>div>label{padding-right:10px;min-width:50px}.toolbar-dropdown-toolbar .clr-field button{width:100%;height:100%;top:50%;left:0;border-radius:5px}.toolbar-dropdown-toolbar .toolbar-grid-selector>div{--button-size: 57px}.toolbar-dropdown-toolbar .toolbar-dropdown>div>.toolbar-toolContainer{display:inline-block}.toolbar-help-overlay{width:100%;height:100%;max-width:none;max-height:none;border:none;margin:0;padding:0;z-index:5;touch-action:none;overflow:hidden;color:#fff;--icon-color: white;background-color:rgba(0,0,0,0);display:flex;flex-direction:column;transition:.3s ease transform}.toolbar-help-overlay::backdrop{background-color:rgba(0,0,0,.8);backdrop-filter:blur(1px);-webkit-backdrop-filter:blur(1px)}.toolbar-help-overlay,.toolbar-help-overlay::backdrop{animation:.25s ease transition-in}@keyframes transition-in{0%{opacity:0}100%{opacity:1}}@keyframes transition-out{0%{opacity:1}100%{opacity:0}}.toolbar-help-overlay.-hiding,.toolbar-help-overlay.-hiding::backdrop{animation:.25s ease transition-out;opacity:0}.toolbar-help-overlay.-dragging{transition:none}@media(prefers-reduced-motion: reduce){.toolbar-help-overlay{transition:none}}@media screen and (min-width: 800px){.toolbar-help-overlay>.navigation-buttons{order:1;margin-top:auto}}.toolbar-help-overlay .with-text-shadow,.toolbar-help-overlay .help-page-container>.label,.toolbar-help-overlay button{text-shadow:0 0 3px rgba(20,20,20,.9);filter:drop-shadow(0px 0px 2px rgba(0, 0, 0, 0.5))}.toolbar-help-overlay button:not(:disabled){cursor:pointer}.toolbar-help-overlay button{background:rgba(0,0,0,0);border:none;color:var(--help-overlay-foreground);border-radius:15px}.toolbar-help-overlay .close-button{align-self:flex-start;width:48px;height:48px;z-index:1}.toolbar-help-overlay .close-button>svg{width:100%}.toolbar-help-overlay .navigation-content{flex-grow:1;display:flex}.toolbar-help-overlay .help-page-container{display:flex;align-items:center;flex-grow:1;touch-action:none}.toolbar-help-overlay .help-page-container>.label{flex-grow:1;text-align:center;font-size:18.5pt;margin-left:15px;margin-right:15px;margin-top:0px;z-index:1;transition:.5s ease margin-top}.toolbar-help-overlay .help-page-container>.label.-large-space-below{margin-top:0;margin-bottom:auto}.toolbar-help-overlay .help-page-container>.label.-small-space-above{margin-top:40px;margin-bottom:auto}.toolbar-help-overlay .help-page-container>.label.-large-space-above{margin-top:auto;margin-bottom:10px}@media(prefers-reduced-motion: reduce){.toolbar-help-overlay .help-page-container>.label{transition:none}}.toolbar-help-overlay .help-page-container>.cloned-element-container{position:absolute;z-index:0;user-select:none;-webkit-user-select:none;border-radius:10px;opacity:.01;background-color:rgba(100,100,100,.01);box-shadow:none;transition:.5s ease opacity,.5s ease background-color}.toolbar-help-overlay .help-page-container>.cloned-element-container *{pointer-events:none !important}.toolbar-help-overlay .help-page-container>.cloned-element-container>*{margin:0;opacity:.01 !important;transition:.3s ease opacity !important}.toolbar-help-overlay .help-page-container>.cloned-element-container:not(.-clickable) *{cursor:unset !important}.toolbar-help-overlay .help-page-container>.cloned-element-container.-clickable,.toolbar-help-overlay .help-page-container>.cloned-element-container.-background{z-index:1;touch-action:none}.toolbar-help-overlay .help-page-container>.cloned-element-container.-clickable{cursor:pointer;z-index:2}.toolbar-help-overlay .help-page-container>.cloned-element-container.-clickable.has-long-press-or-hover{opacity:.5 !important}.toolbar-help-overlay .help-page-container>.cloned-element-container.-clickable.has-long-press-or-hover,.toolbar-help-overlay .help-page-container>.cloned-element-container.-active{background-color:var(--background-color-1)}.toolbar-help-overlay .help-page-container>.cloned-element-container.-active{opacity:1;background-color:var(--background-color-1);box-shadow:0 0 3px rgba(100,100,100,.5)}.toolbar-help-overlay .help-page-container>.cloned-element-container.-active>*{opacity:1 !important}.toolbar-help-overlay .navigation-buttons{display:flex;flex-direction:row;justify-content:space-between;direction:ltr}.toolbar-help-overlay .navigation-buttons>button:disabled{opacity:.5}.toolbar-help-overlay .navigation-buttons>.next,.toolbar-help-overlay .navigation-buttons>.previous{font-size:1em;padding:10px;transition:.2s ease font-size;z-index:3}@media(prefers-reduced-motion: reduce){.toolbar-help-overlay .navigation-buttons>.next,.toolbar-help-overlay .navigation-buttons>.previous{transition:none}}.toolbar-help-overlay .navigation-buttons:not(.-has-previous)>.next:not(:disabled){animation:.5s ease highlight-button .5s}@keyframes highlight-button{0%{transform:scale(1)}50%{transform:scale(1.2)}55%{transform:scale(1.2) rotate(2deg)}65%{transform:scale(1.2) rotate(-2deg)}100%{transform:scale(1)}}@media(prefers-reduced-motion: reduce){.toolbar-help-overlay .navigation-buttons:not(.-has-previous)>.next:not(:disabled){animation:none}}.toolbar-help-overlay .navigation-buttons>.next::after{content:"\u276F";margin-left:3px}.toolbar-help-overlay .navigation-buttons>.previous::before{content:"\u276E";margin-right:3px}.toolbar-help-overlay .navigation-buttons.-has-next>.next{font-size:1.4em}.toolbar-help-overlay .navigation-buttons.-has-previous>.previous{font-size:1.4em}.toolbar-help-overlay .navigation-buttons.-highlight-next>.next,.toolbar-help-overlay .navigation-buttons.-highlight-previous>.previous{font-weight:bold;background-color:rgba(200,200,200,.1);font-size:1.4em}.toolbar-help-overlay .navigation-help{margin-top:1em;font-size:.7em}.toolbar-element .toolbar-help-overlay-button{height:0;position:relative;display:flex;justify-content:end}.toolbar-element .toolbar-help-overlay-button>.button{margin:0;padding:5px;padding-top:0;padding-bottom:0;box-shadow:none;text-align:center;opacity:.5}.toolbar-element .toolbar-help-overlay-button>.button>.icon{width:1.18em;height:1.18em;transition:.2s ease filter}.toolbar-element .toolbar-help-overlay-button>.button:focus-visible>.icon,.toolbar-element .toolbar-help-overlay-button>.button:hover>.icon{filter:drop-shadow(0px 0px 1px var(--shadow-color))}.ScrollbarTool-overlay{width:0;height:0;overflow:visible;opacity:.2;pointer-events:none;--fade-out-animation: 1s ease 0s fade-out;--scrollbar-size: 3px}@media(prefers-reduced-motion: reduce){.ScrollbarTool-overlay{--fade-out-animation: none !important}}@keyframes fade-out{from{opacity:.2}to{opacity:0}}.ScrollbarTool-overlay:not(.just-updated){animation:var(--fade-out-animation);opacity:0}.ScrollbarTool-overlay .vertical-scrollbar,.ScrollbarTool-overlay .horizontal-scrollbar{width:var(--scrollbar-size);height:var(--scrollbar-size);min-width:var(--scrollbar-size);min-height:var(--scrollbar-size);background-color:var(--foreground-color-1);border-radius:var(--scrollbar-size);position:absolute}.ScrollbarTool-overlay .vertical-scrollbar.represents-no-scroll,.ScrollbarTool-overlay .horizontal-scrollbar.represents-no-scroll{animation:var(--fade-out-animation);opacity:0}.ScrollbarTool-overlay:not(.scrollbar-left) .vertical-scrollbar{margin-left:calc(var(--editor-current-display-width-px) - var(--scrollbar-size))}.ScrollbarTool-overlay:not(.scrollbar-top) .horizontal-scrollbar{margin-top:calc(var(--editor-current-display-height-px) - var(--scrollbar-size))}.clipboard-error-dialog details>summary{cursor:pointer}.clipboard-error-dialog details[open]{margin-bottom:12px}.clipboard-error-dialog textarea{width:100%;box-sizing:border-box}.selection-tool-selection-background{background-color:var(--selection-background-color);opacity:.5;overflow:visible}.selection-tool-handle{position:absolute;box-sizing:border-box;display:flex;align-items:center;justify-content:center;--max-size: 17px}.selection-tool-handle .selection-tool-content{border:1px solid var(--foreground-color-1);background:var(--background-color-1);box-sizing:border-box;max-width:var(--max-size);max-height:var(--max-size);width:100%;height:100%;display:flex;justify-content:center;align-items:center;padding:3px}.selection-tool-handle .selection-tool-content .icon{width:100%;height:100%}.selection-tool-handle.selection-tool-circle .selection-tool-content{border-radius:100%}.selection-tool-handle.selection-tool-rotate{--max-size: 28px;cursor:grab}.selection-tool-handle.selection-tool-resize-x{cursor:ew-resize}.selection-tool-handle.selection-tool-resize-y{cursor:ns-resize}.selection-tool-handle.selection-tool-resize-xy{cursor:nwse-resize}.selection-tool-rotated-near-perpendicular .selection-tool-handle.selection-tool-resize-x{cursor:ns-resize}.selection-tool-rotated-near-perpendicular .selection-tool-handle.selection-tool-resize-y{cursor:ew-resize}.selection-tool-rotated-near-perpendicular .selection-tool-handle.selection-tool-resize-xy{cursor:nesw-resize}.selection-tool-selection-menu>button{max-height:var(--vertical-offset);background-color:var(--background-color-1);width:24px;height:24px;padding:6px;font-size:14px;user-select:none;-webkit-user-select:none;color:var(--foreground-color-1);border:.5px solid var(--foreground-color-1);border-radius:3px;opacity:.8;transition:.2s ease opacity}.selection-tool-selection-menu>button:hover,.selection-tool-selection-menu>button:focus-visible{background-color:var(--background-color-2);color:var(--foreground-color-2);cursor:pointer;opacity:1}.selection-tool-selection-menu>button>.icon{width:100%;height:100%}.overlay.handleOverlay{touch-action:none;direction:ltr}.overlay.handleOverlay,.overlay.handleOverlay .selection-tool-selection-outer-container{height:0;overflow:visible}.overlay.handleOverlay .selection-tool-selection-inner-container{width:var(--editor-current-display-width-px);height:var(--editor-current-display-height-px);overflow:hidden;pointer-events:none}.overlay.handleOverlay .selection-tool-selection-inner-container>*{pointer-events:all}.overlay.handleOverlay .selection-tool-selection-inner-container.-empty{opacity:0}.overlay.handleOverlay .selection-tool-selection-inner-container.-hide-handles .selection-tool-handle{display:none}@keyframes selection-duplicated-animation{0%{scale:1 1}50%{scale:1.02 1.02}100%{scale:1 1}}@media(prefers-reduced-motion: reduce){@keyframes selection-duplicated-animation{}}.find-tool-overlay{order:-1;position:absolute}.js-draw-sound-ui-toggle{width:0px;height:0px;overflow:hidden;user-select:none;-webkit-user-select:none}.js-draw-sound-ui-toggle button{margin-top:1px}.js-draw-sound-ui-toggle:focus-within,.js-draw-sound-ui-toggle.sound-ui-tool-enabled{overflow:visible;z-index:5}.js-draw-sound-ui-toggle:not(:focus-within):not(:hover).sound-ui-tool-enabled{opacity:.5}@keyframes show-popup-menu-animation{from{opacity:0}to{opacity:1}}.editor-popup-menu{width:100%;height:100%;background-color:rgba(0,0,0,0);border:none;animation:var(--hide-menu-animation-timeout) ease show-popup-menu-animation;opacity:1;transition:var(--hide-menu-animation-timeout) ease opacity;overflow:hidden}.editor-popup-menu.-hide{opacity:0}.editor-popup-menu>.content{position:absolute;left:var(--anchor-x);top:var(--anchor-y);display:flex;flex-direction:column;overflow:clip;border-radius:6px;box-shadow:0px 1px 2px var(--shadow-color);background-color:var(--background-color-1)}.editor-popup-menu::backdrop{background:rgba(0,0,0,0)}.editor-popup-menu-option{display:flex;justify-content:start;cursor:pointer;padding:5px;padding-top:6px;padding-bottom:6px;background-color:rgba(0,0,0,0);color:var(--foreground-color-1);--icon-color: currentColor;border:none;font-size:1em}.editor-popup-menu-option:hover,.editor-popup-menu-option:focus-visible{background-color:var(--background-color-2);color:var(--foreground-color-2)}.editor-popup-menu-option>:first-child{width:1em;height:1em;flex-shrink:0;margin-inline-start:0em;margin-inline-end:.25em}.about-dialog-content>.scroll{white-space:pre-wrap;font-family:monospace}.about-dialog-content>.scroll>details>summary{cursor:pointer}.about-dialog-content>.scroll>h2,.about-dialog-content>.scroll>details>summary{margin-top:15px;font-size:1.2em;font-weight:bold}.about-dialog-content>.scroll>h2 a,.about-dialog-content>.scroll>details>summary a{color:var(--foreground-color-1);text-decoration:underline}@keyframes fade-in{from{opacity:0}to{opacity:1}}.message-dialog-container dialog{display:flex}.message-dialog-container dialog.-closing{opacity:0}.message-dialog-container dialog.-closing::backdrop{opacity:0}.message-dialog-container dialog,.message-dialog-container dialog::backdrop{transition:opacity .2s ease;animation:fade-in .2s ease}.message-dialog-content{display:flex;flex-direction:column;flex-grow:1}.message-dialog-content>.close{display:block;margin-left:auto;margin-right:auto}.message-dialog-content>.scroll{flex-grow:1;flex-shrink:1;overflow-y:auto;margin-left:20px;margin-right:20px;padding-bottom:20px}.dialog-container>dialog{background-color:var(--background-color-1);color:var(--foreground-color-1);border:none;outline:none;box-shadow:0 0 2px var(--shadow-color);border-radius:8px;max-height:90vh;width:min(100%,500px);box-sizing:border-box}.dialog-container>dialog::backdrop{backdrop-filter:blur(5px);-webkit-backdrop-filter:blur(5px);background-color:var(--background-color-transparent)}#clr-picker{--clr-slider-size: 30px}#clr-picker #clr-color-area,#clr-picker .clr_hue{touch-action:none}#clr-picker .clr-alpha{margin-top:15px;margin-bottom:15px}#clr-picker.clr-picker input[type=range]::-moz-range-thumb{width:var(--clr-slider-size);height:var(--clr-slider-size)}#clr-picker.clr-picker input[type=range]::-webkit-slider-thumb{width:var(--clr-slider-size);height:var(--clr-slider-size)}#clr-picker.clr-picker input[type=range]::-webkit-slider-runnable-track{height:var(--clr-slider-size)}#clr-picker.clr-picker input[type=range]::-moz-range-track{height:var(--clr-slider-size)}.imageEditorContainer{--background-color-1: white;--foreground-color-1: black;--background-color-2: #f5f5f5;--foreground-color-2: #2c303a;--background-color-3: #e5e5e5;--foreground-color-3: #1c202a;--selection-background-color: #cbdaf1;--selection-foreground-color: #2c303a;--background-color-transparent: rgba(105, 100, 100, 0.5);--shadow-color: rgba(0, 0, 0, 0.5);--primary-action-foreground-color: #15b}@media(prefers-color-scheme: dark){.imageEditorContainer{--background-color-1: #151515;--foreground-color-1: white;--background-color-2: #222;--foreground-color-2: #efefef;--background-color-3: #272627;--foreground-color-3: #eee;--selection-background-color: #607;--selection-foreground-color: white;--shadow-color: rgba(250, 250, 250, 0.5);--background-color-transparent: rgba(50, 50, 50, 0.5);--primary-action-foreground-color: #7ae}}.imageEditorContainer{--icon-color: var(--foreground-color-1)}.imageEditorContainer{color:var(--foreground-color-1);font-family:system-ui,-apple-system,sans-serif;background-color:var(--background-color-1);width:100%;height:400px;min-height:220px;min-width:100px;writing-mode:horizontal-tb;box-sizing:border-box;display:flex;flex-direction:column-reverse}.imageEditorContainer input{accent-color:var(--primary-action-foreground-color)}.imageEditorContainer .imageEditorRenderArea{display:grid;grid-template-columns:1fr;flex-grow:2;flex-shrink:1;min-height:100px;min-width:0;width:100%;height:100%}.imageEditorContainer .imageEditorRenderArea canvas{grid-row:1/1;grid-column:1/1;touch-action:none;box-sizing:border-box;width:100%;height:100%;min-width:0;max-width:inherit;min-height:0px;max-height:inherit;user-select:none;-webkit-user-select:none;-webkit-user-drag:none}.imageEditorContainer .loadingMessage{position:fixed;text-align:center;font-size:2em;text-shadow:0px 0px 1px var(--background-color-1);bottom:0;left:0;right:0}.imageEditorContainer .accessibilityAnnouncement{opacity:0;width:0;height:0;overflow:hidden;pointer-events:none;user-select:none;-webkit-user-select:none}.imageEditorContainer .textRendererOutputContainer{width:.001px;height:.001px;overflow:hidden;-webkit-user-select:none;user-select:none}.imageEditorContainer .textRendererOutputContainer:focus-within{overflow:visible;z-index:5}.imageEditorContainer .anchored-element-overlay{overflow:visible;height:0}.imageEditorContainer .anchored-element-overlay>.content-wrapper{width:var(--editor-current-display-width-px);height:var(--editor-current-display-height-px);overflow:hidden;position:relative;pointer-events:none}.imageEditorContainer .anchored-element-overlay>.content-wrapper>.content{position:absolute;left:var(--position-x);top:var(--position-y);transform:scale(var(--scale)) rotate(var(--rotation));transform-origin:left top;margin:0;pointer-events:all}@media print{.imageEditorContainer .loadingMessage{display:none}.imageEditorContainer .imageEditorRenderArea canvas{width:100%;height:initial}}',document.head.appendChild(o)}})();(()=>{if(typeof document<"u"&&typeof document.createElement=="function"){let o=document.createElement("style");o.textContent='.clr-picker{display:none;flex-wrap:wrap;position:absolute;width:200px;z-index:1000;border-radius:10px;background-color:#fff;justify-content:flex-end;direction:ltr;box-shadow:0 0 5px rgba(0, 0, 0, 0.05),0 5px 20px rgba(0, 0, 0, 0.1);-moz-user-select:none;-webkit-user-select:none;user-select:none}.clr-picker.clr-open,.clr-picker[data-inline=true]{display:flex}.clr-picker[data-inline=true]{position:relative}.clr-gradient{position:relative;width:100%;height:100px;margin-bottom:15px;border-radius:3px 3px 0 0;background-image:linear-gradient(rgba(0, 0, 0, 0), #000),linear-gradient(90deg, #fff, currentColor);cursor:pointer}.clr-marker{position:absolute;width:12px;height:12px;margin:-6px 0 0 -6px;border:1px solid #fff;border-radius:50%;background-color:currentColor;cursor:pointer}.clr-picker input[type=range]::-webkit-slider-runnable-track{width:100%;height:16px}.clr-picker input[type=range]::-webkit-slider-thumb{width:16px;height:16px;-webkit-appearance:none}.clr-picker input[type=range]::-moz-range-track{width:100%;height:16px;border:0}.clr-picker input[type=range]::-moz-range-thumb{width:16px;height:16px;border:0}.clr-hue{background-image:linear-gradient(to right, #f00 0%, #ff0 16.66%, #0f0 33.33%, #0ff 50%, #00f 66.66%, #f0f 83.33%, #f00 100%)}.clr-hue,.clr-alpha{position:relative;width:calc(100% - 40px);height:8px;margin:5px 20px;border-radius:4px}.clr-alpha span{display:block;height:100%;width:100%;border-radius:inherit;background-image:linear-gradient(90deg, rgba(0, 0, 0, 0), currentColor)}.clr-hue input,.clr-alpha input{position:absolute;width:calc(100% + 32px);height:16px;left:-16px;top:-4px;margin:0;background-color:transparent;opacity:0;cursor:pointer;appearance:none;-webkit-appearance:none}.clr-hue div,.clr-alpha div{position:absolute;width:16px;height:16px;left:0;top:50%;margin-left:-8px;transform:translateY(-50%);border:2px solid #fff;border-radius:50%;background-color:currentColor;box-shadow:0 0 1px #888;pointer-events:none}.clr-alpha div:before{content:"";position:absolute;height:100%;width:100%;left:0;top:0;border-radius:50%;background-color:currentColor}.clr-format{display:none;order:1;width:calc(100% - 40px);margin:0 20px 20px}.clr-segmented{display:flex;position:relative;width:100%;margin:0;padding:0;border:1px solid #ddd;border-radius:15px;box-sizing:border-box;color:#999;font-size:12px}.clr-segmented input,.clr-segmented legend{position:absolute;width:100%;height:100%;margin:0;padding:0;border:0;left:0;top:0;opacity:0;pointer-events:none}.clr-segmented label{flex-grow:1;margin:0;padding:4px 0;font-size:inherit;font-weight:normal;line-height:initial;text-align:center;cursor:pointer}.clr-segmented label:first-of-type{border-radius:10px 0 0 10px}.clr-segmented label:last-of-type{border-radius:0 10px 10px 0}.clr-segmented input:checked+label{color:#fff;background-color:#666}.clr-swatches{order:2;width:calc(100% - 32px);margin:0 16px}.clr-swatches div{display:flex;flex-wrap:wrap;padding-bottom:12px;justify-content:center}.clr-swatches button{position:relative;width:20px;height:20px;margin:0 4px 6px 4px;padding:0;border:0;border-radius:50%;color:inherit;text-indent:-1000px;white-space:nowrap;overflow:hidden;cursor:pointer}.clr-swatches button:after{content:"";display:block;position:absolute;width:100%;height:100%;left:0;top:0;border-radius:inherit;background-color:currentColor;box-shadow:inset 0 0 0 1px rgba(0, 0, 0, 0.1)}input.clr-color{order:1;width:calc(100% - 80px);height:32px;margin:15px 20px 20px auto;padding:0 10px;border:1px solid #ddd;border-radius:16px;color:#444;background-color:#fff;font-family:sans-serif;font-size:14px;text-align:center;box-shadow:none}input.clr-color:focus{outline:none;border:1px solid #1e90ff}.clr-close,.clr-clear{display:none;order:2;height:24px;margin:0 20px 20px;padding:0 20px;border:0;border-radius:12px;color:#fff;background-color:#666;font-family:inherit;font-size:12px;font-weight:400;cursor:pointer}.clr-close{display:block;margin:0 20px 20px auto}.clr-preview{position:relative;width:32px;height:32px;margin:15px 0 20px 20px;border-radius:50%;overflow:hidden}.clr-preview:before,.clr-preview:after{content:"";position:absolute;height:100%;width:100%;left:0;top:0;border:1px solid #fff;border-radius:50%}.clr-preview:after{border:0;background-color:currentColor;box-shadow:inset 0 0 0 1px rgba(0, 0, 0, 0.1)}.clr-preview button{position:absolute;width:100%;height:100%;z-index:1;margin:0;padding:0;border:0;border-radius:50%;outline-offset:-2px;background-color:transparent;text-indent:-9999px;cursor:pointer;overflow:hidden}.clr-marker,.clr-hue div,.clr-alpha div,.clr-color{box-sizing:border-box}.clr-field{display:inline-block;position:relative;color:transparent}.clr-field input{margin:0;direction:ltr}.clr-field.clr-rtl input{text-align:right}.clr-field button{position:absolute;width:30px;height:100%;right:0;top:50%;transform:translateY(-50%);margin:0;padding:0;border:0;color:inherit;text-indent:-1000px;white-space:nowrap;overflow:hidden;pointer-events:none}.clr-field.clr-rtl button{right:auto;left:0}.clr-field button:after{content:"";display:block;position:absolute;width:100%;height:100%;left:0;top:0;border-radius:inherit;background-color:currentColor;box-shadow:inset 0 0 1px rgba(0, 0, 0, 0.5)}.clr-alpha,.clr-alpha div,.clr-swatches button,.clr-preview:before,.clr-field button{background-image:repeating-linear-gradient(45deg, #aaa 25%, transparent 25%, transparent 75%, #aaa 75%, #aaa),repeating-linear-gradient(45deg, #aaa 25%, #fff 25%, #fff 75%, #aaa 75%, #aaa);background-position:0 0,4px 4px;background-size:8px 8px}.clr-marker:focus{outline:none}.clr-keyboard-nav .clr-marker:focus,.clr-keyboard-nav .clr-hue input:focus+div,.clr-keyboard-nav .clr-alpha input:focus+div,.clr-keyboard-nav .clr-segmented input:focus+label{outline:none;box-shadow:0 0 0 2px #1e90ff,0 0 2px 2px #fff}.clr-picker[data-alpha=false] .clr-alpha{display:none}.clr-picker[data-minimal=true]{padding-top:16px}.clr-picker[data-minimal=true] .clr-gradient,.clr-picker[data-minimal=true] .clr-hue,.clr-picker[data-minimal=true] .clr-alpha,.clr-picker[data-minimal=true] .clr-color,.clr-picker[data-minimal=true] .clr-preview{display:none}.clr-dark{background-color:#444}.clr-dark .clr-segmented{border-color:#777}.clr-dark .clr-swatches button:after{box-shadow:inset 0 0 0 1px rgba(255, 255, 255, 0.3)}.clr-dark input.clr-color{color:#fff;border-color:#777;background-color:#555}.clr-dark input.clr-color:focus{border-color:#1e90ff}.clr-dark .clr-preview:after{box-shadow:inset 0 0 0 1px rgba(255, 255, 255, 0.5)}.clr-dark .clr-alpha,.clr-dark .clr-alpha div,.clr-dark .clr-swatches button,.clr-dark .clr-preview:before{background-image:repeating-linear-gradient(45deg, #666 25%, transparent 25%, transparent 75%, #888 75%, #888),repeating-linear-gradient(45deg, #888 25%, #444 25%, #444 75%, #888 75%, #888)}.clr-picker.clr-polaroid{border-radius:6px;box-shadow:0 0 5px rgba(0, 0, 0, 0.1),0 5px 30px rgba(0, 0, 0, 0.2)}.clr-picker.clr-polaroid:before{content:"";display:block;position:absolute;width:16px;height:10px;left:20px;top:-10px;border:solid transparent;border-width:0 8px 10px 8px;border-bottom-color:currentColor;box-sizing:border-box;color:#fff;filter:drop-shadow(0 -4px 3px rgba(0, 0, 0, 0.1));pointer-events:none}.clr-picker.clr-polaroid.clr-dark:before{color:#444}.clr-picker.clr-polaroid.clr-left:before{left:auto;right:20px}.clr-picker.clr-polaroid.clr-top:before{top:auto;bottom:-10px;transform:rotateZ(180deg)}.clr-polaroid .clr-gradient{width:calc(100% - 20px);height:120px;margin:10px;border-radius:3px}.clr-polaroid .clr-hue,.clr-polaroid .clr-alpha{width:calc(100% - 30px);height:10px;margin:6px 15px;border-radius:5px}.clr-polaroid .clr-hue div,.clr-polaroid .clr-alpha div{box-shadow:0 0 5px rgba(0, 0, 0, 0.2)}.clr-polaroid .clr-format{width:calc(100% - 20px);margin:0 10px 15px}.clr-polaroid .clr-swatches{width:calc(100% - 12px);margin:0 6px}.clr-polaroid .clr-swatches div{padding-bottom:10px}.clr-polaroid .clr-swatches button{width:22px;height:22px}.clr-polaroid input.clr-color{width:calc(100% - 60px);margin:10px 10px 15px auto}.clr-polaroid .clr-clear{margin:0 10px 15px 10px}.clr-polaroid .clr-close{margin:0 10px 15px auto}.clr-polaroid .clr-preview{margin:10px 0 15px 10px}.clr-picker.clr-large{width:275px}.clr-large .clr-gradient{height:150px}.clr-large .clr-swatches button{width:22px;height:22px}.clr-picker.clr-pill{width:380px;padding-left:180px;box-sizing:border-box}.clr-pill .clr-gradient{position:absolute;width:180px;height:100%;left:0;top:0;margin-bottom:0;border-radius:3px 0 0 3px}.clr-pill .clr-hue{margin-top:20px}',document.head.appendChild(o)}})();})();


/***/ }),

/***/ "./src/db.ts":
/*!*******************!*\
  !*** ./src/db.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSVG: () => (/* binding */ getSVG),
/* harmony export */   openDatabase: () => (/* binding */ openDatabase),
/* harmony export */   queueSave: () => (/* binding */ queueSave),
/* harmony export */   saveSVG: () => (/* binding */ saveSVG)
/* harmony export */ });
async function openDatabase() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open("SVGStorageDB", 1);
        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains("SVGs")) {
                db.createObjectStore("SVGs", { keyPath: "id" });
            }
        };
        request.onsuccess = (event) => {
            resolve(event.target.result);
        };
        request.onerror = (event) => {
            reject(event.target.error);
        };
    });
}
async function saveSVG(id, svgData) {
    const db = await openDatabase();
    return new Promise((resolve, reject) => {
        const transaction = db.transaction("SVGs", "readwrite");
        const store = transaction.objectStore("SVGs");
        const data = { id, svgData };
        const request = store.put(data);
        request.onsuccess = () => {
            resolve("SVG saved successfully!");
        };
        request.onerror = (event) => {
            reject(event.target.error);
        };
    });
}
async function getSVG(id) {
    const db = await openDatabase();
    return new Promise((resolve, reject) => {
        const transaction = db.transaction("SVGs", "readonly");
        const store = transaction.objectStore("SVGs");
        const request = store.get(id);
        request.onsuccess = (event) => {
            resolve(event.target.result?.svgData || null);
        };
        request.onerror = (event) => {
            reject(event.target.error);
        };
    });
}
let debounce = null;
const queueSave = (editor) => {
    if (debounce && Date.now() - debounce < 2000) {
        return;
    }
    debounce = Date.now();
    const maxDimension = Math.max(editor.viewport.visibleRect.width, editor.viewport.visibleRect.height);
    const svg = editor.toSVG({ minDimension: maxDimension });
    console.log(svg);
    saveSVG(document.location.href, svg.outerHTML)
        .then(console.log)
        .catch(console.error);
};


/***/ }),

/***/ "./src/toolbar/btnClear.ts":
/*!*********************************!*\
  !*** ./src/toolbar/btnClear.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ClearButton: () => (/* binding */ ClearButton)
/* harmony export */ });
/* harmony import */ var js_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! js-draw */ "./node_modules/js-draw/dist/mjs/lib.mjs");

const ClearButton = (editor) => {
    const clearIcon = document.createElement("div");
    clearIcon.textContent = "🧹";
    return [
        { icon: clearIcon, label: "Clear" },
        () => {
            const allComponents = editor.image.getAllElements();
            const deleteCommand = new js_draw__WEBPACK_IMPORTED_MODULE_0__.Erase(allComponents);
            editor.dispatch(deleteCommand);
        },
    ];
};
// Clear icon clears the canvas
// const clearIcon = document.createElement("div");
// clearIcon.textContent = "🧹";
// toolbar.addActionButton({ icon: clearIcon, label: "Clear" }, () => {
// });


/***/ }),

/***/ "./src/toolbar/btnClose.ts":
/*!*********************************!*\
  !*** ./src/toolbar/btnClose.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CloseButton: () => (/* binding */ CloseButton)
/* harmony export */ });
const CloseButton = () => {
    const closeIcon = document.createElement("div");
    closeIcon.textContent = "❌";
    return [
        { icon: closeIcon, label: "Close" },
        () => {
            document.querySelector(".js-draw")?.classList.add("display-none");
        },
    ];
};


/***/ }),

/***/ "./src/toolbar/btnHide.ts":
/*!********************************!*\
  !*** ./src/toolbar/btnHide.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HideButton: () => (/* binding */ HideButton)
/* harmony export */ });
const HideButton = ({ onSelect, }) => {
    const hideIcon = document.createElement("div");
    hideIcon.textContent = "👁️";
    return {
        hide: [
            { icon: hideIcon, label: "Hide" },
            () => {
                onSelect();
                const element = document.querySelector(".imageEditorRenderArea");
                const drawElement = document.querySelector(".js-draw");
                if (!element || !drawElement)
                    return;
                element.classList.add("visibility-hidden");
                drawElement.classList.add("pointer-events-none");
            },
        ],
        resetHide: () => {
            const element = document.querySelector(".imageEditorRenderArea");
            const drawElement = document.querySelector(".js-draw");
            if (!element || !drawElement)
                return;
            element.classList.remove("visibility-hidden");
            drawElement.classList.remove("pointer-events-none");
        },
    };
};


/***/ }),

/***/ "./src/toolbar/btnNormal.ts":
/*!**********************************!*\
  !*** ./src/toolbar/btnNormal.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NormalButton: () => (/* binding */ NormalButton)
/* harmony export */ });
const NormalButton = ({ onSelect, }) => {
    const normalIcon = document.createElement("div");
    normalIcon.textContent = "📝";
    return {
        normal: [
            { icon: normalIcon, label: "Normal" },
            () => {
                onSelect();
            },
        ],
        resetNormal: () => {
            //
        },
    };
};


/***/ }),

/***/ "./src/toolbar/btnTransparent.ts":
/*!***************************************!*\
  !*** ./src/toolbar/btnTransparent.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TransparentButton: () => (/* binding */ TransparentButton)
/* harmony export */ });
const TransparentButton = ({ onSelect, }) => {
    const transparentIcon = document.createElement("div");
    transparentIcon.textContent = "🪟";
    return {
        transparent: [
            { icon: transparentIcon, label: "Transparent" },
            () => {
                onSelect();
                const element = document.querySelector(".js-draw");
                if (!element)
                    return;
                console.log(element);
                element.classList.add("pointer-events-none");
            },
        ],
        resetTransparent: () => {
            const element = document.querySelector(".js-draw");
            if (!element)
                return;
            element.classList.remove("pointer-events-none");
        },
    };
};


/***/ }),

/***/ "./src/toolbar/toolbar.ts":
/*!********************************!*\
  !*** ./src/toolbar/toolbar.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initToolbar: () => (/* binding */ initToolbar)
/* harmony export */ });
/* harmony import */ var js_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! js-draw */ "./node_modules/js-draw/dist/mjs/lib.mjs");
/* harmony import */ var _btnClose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./btnClose */ "./src/toolbar/btnClose.ts");
/* harmony import */ var _btnClear__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./btnClear */ "./src/toolbar/btnClear.ts");
/* harmony import */ var _btnTransparent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./btnTransparent */ "./src/toolbar/btnTransparent.ts");
/* harmony import */ var _btnHide__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./btnHide */ "./src/toolbar/btnHide.ts");
/* harmony import */ var _btnNormal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./btnNormal */ "./src/toolbar/btnNormal.ts");






let mode = "draw";
const initToolbar = (editor) => {
    const toolController = editor.toolController;
    const panTools = toolController.getMatchingTools(js_draw__WEBPACK_IMPORTED_MODULE_0__.PanZoomTool);
    toolController.removeAndDestroyTools(panTools);
    const toolbar = editor.addToolbar();
    toolbar.addActionButton(...(0,_btnClose__WEBPACK_IMPORTED_MODULE_1__.CloseButton)());
    toolbar.addActionButton(...(0,_btnClear__WEBPACK_IMPORTED_MODULE_2__.ClearButton)(editor));
    const { transparent, resetTransparent } = (0,_btnTransparent__WEBPACK_IMPORTED_MODULE_3__.TransparentButton)({
        onSelect: () => {
            resetHide();
            mode = "transparent";
            transparentButton.addCSSClassToContainer("toggle-on");
            hideButton.removeCSSClassFromContainer("toggle-on");
            normalButton.removeCSSClassFromContainer("toggle-on");
        },
    });
    const transparentButton = toolbar.addActionButton(...transparent);
    transparentButton.addCSSClassToContainer("margin-left-48");
    const { hide, resetHide } = (0,_btnHide__WEBPACK_IMPORTED_MODULE_4__.HideButton)({
        onSelect: () => {
            resetTransparent();
            mode = "hide";
            hideButton.addCSSClassToContainer("toggle-on");
            transparentButton.removeCSSClassFromContainer("toggle-on");
            normalButton.removeCSSClassFromContainer("toggle-on");
        },
    });
    const hideButton = toolbar.addActionButton(...hide);
    const { normal, resetNormal } = (0,_btnNormal__WEBPACK_IMPORTED_MODULE_5__.NormalButton)({
        onSelect: () => {
            resetHide();
            resetTransparent();
            mode = "draw";
            normalButton.addCSSClassToContainer("toggle-on");
            hideButton.removeCSSClassFromContainer("toggle-on");
            transparentButton.removeCSSClassFromContainer("toggle-on");
        },
    });
    const normalButton = toolbar.addActionButton(...normal);
    return toolbar;
};


/***/ }),

/***/ "./src/update.ts":
/*!***********************!*\
  !*** ./src/update.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   update: () => (/* binding */ update)
/* harmony export */ });
/* harmony import */ var js_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! js-draw */ "./node_modules/js-draw/dist/mjs/lib.mjs");
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");


let lastPos = { x: 0, y: 0 };
function update(edtr, wndw) {
    const scrollX = wndw.scrollX;
    const scrollY = wndw.scrollY;
    const deltaX = scrollX - lastPos.x;
    const deltaY = lastPos.y - scrollY;
    if (deltaX !== 0 || deltaY !== 0) {
        const delta = _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Mat33.translation(_js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(deltaX, deltaY));
        const deltaCommand = js_draw__WEBPACK_IMPORTED_MODULE_0__.Viewport.transformBy(delta);
        deltaCommand.apply(edtr);
    }
    lastPos = { x: scrollX, y: scrollY };
}


/***/ }),

/***/ "./node_modules/@js-draw/math/dist/mjs/Color4.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/mjs/Color4.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Color4: () => (/* binding */ Color4),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Vec3_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vec3.mjs */ "./node_modules/@js-draw/math/dist/mjs/Vec3.mjs");

/**
 * Represents a color.
 *
 * @example
 * ```ts,runnable,console
 * import { Color4 } from '@js-draw/math';
 *
 * console.log('Red:', Color4.fromString('#f00'));
 * console.log('Also red:', Color4.ofRGB(1, 0, 0), Color4.red);
 * console.log('Mixing red and blue:', Color4.red.mix(Color4.blue, 0.5));
 * console.log('To string:', Color4.orange.toHexString());
 * ```
 */
class Color4 {
    constructor(
    /** Red component. Should be in the range [0, 1]. */
    r, 
    /** Green component. ${\tt g} \in [0, 1]$ */
    g, 
    /** Blue component. ${\tt b} \in [0, 1]$ */
    b, 
    /** Alpha/transparent component. ${\tt a} \in [0, 1]$. 0 = transparent */
    a) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
        this.hexString = null;
    }
    /**
     * Create a color from red, green, blue components. The color is fully opaque (`a = 1.0`).
     *
     * Each component should be in the range [0, 1].
     */
    static ofRGB(red, green, blue) {
        return Color4.ofRGBA(red, green, blue, 1.0);
    }
    /**
     * Creates a color from red, green, blue, and transparency components. Each component should
     * be in the range $[0, 1]$.
     */
    static ofRGBA(red, green, blue, alpha) {
        red = Math.max(0, Math.min(red, 1));
        green = Math.max(0, Math.min(green, 1));
        blue = Math.max(0, Math.min(blue, 1));
        alpha = Math.max(0, Math.min(alpha, 1));
        return new Color4(red, green, blue, alpha);
    }
    /**
     * Creates a color from an RGB (or RGBA) array.
     *
     * This is similar to {@link ofRGB} and {@link ofRGBA}, but, by default, takes values
     * that range from 0 to 255.
     *
     * If the array values instead range from 0-1, pass `maxValue` as `1`.
     */
    static fromRGBArray(array, maxValue = 255) {
        const red = array[0];
        const green = array[1] ?? red;
        const blue = array[2] ?? red;
        let alpha = 255;
        if (3 < array.length) {
            alpha = array[3];
        }
        return Color4.ofRGBA(red / maxValue, green / maxValue, blue / maxValue, alpha / maxValue);
    }
    /**
     * Creates a `Color4` from a three or four-component hexadecimal
     * [color string](https://en.wikipedia.org/wiki/Web_colors#Hex_triplet).
     *
     * Example:
     * ```ts,runnable,console
     * import { Color4 } from '@js-draw/math';
     * console.log(Color4.fromHex('#ff0'));
     * ```
     */
    static fromHex(hexString) {
        // Remove starting '#' (if present)
        hexString = (hexString.match(/^[#]?(.*)$/) ?? [])[1];
        hexString = hexString.toUpperCase();
        if (!hexString.match(/^[0-9A-F]+$/)) {
            throw new Error(`${hexString} is not in a valid format.`);
        }
        // RGBA or RGB
        if (hexString.length === 3 || hexString.length === 4) {
            // Each character is a component
            const components = hexString.split('');
            // Convert to RRGGBBAA or RRGGBB format
            hexString = components.map((component) => `${component}0`).join('');
        }
        if (hexString.length === 6) {
            // Alpha component
            hexString += 'FF';
        }
        const components = [];
        for (let i = 2; i <= hexString.length; i += 2) {
            const chunk = hexString.substring(i - 2, i);
            components.push(parseInt(chunk, 16) / 255);
        }
        if (components.length !== 4) {
            throw new Error(`Unable to parse ${hexString}: Wrong number of components.`);
        }
        return Color4.ofRGBA(components[0], components[1], components[2], components[3]);
    }
    /** Like {@link fromHex}, but can handle additional colors if an `HTMLCanvasElement` is available. */
    static fromString(text) {
        if (text.startsWith('#')) {
            return Color4.fromHex(text);
        }
        if (text === 'none' || text === 'transparent') {
            return Color4.transparent;
        }
        if (text === '') {
            return Color4.black;
        }
        // rgba?: Match both rgb and rgba strings.
        // ([,0-9.]+): Match any string of only numeric, '.' and ',' characters.
        const rgbRegex = /^rgba?\(([,0-9.]+)\)$/i;
        const rgbMatch = text.replace(/\s*/g, '').match(rgbRegex);
        if (rgbMatch) {
            const componentsListStr = rgbMatch[1];
            const componentsList = JSON.parse(`[ ${componentsListStr} ]`);
            if (componentsList.length === 3) {
                return Color4.ofRGB(componentsList[0] / 255, componentsList[1] / 255, componentsList[2] / 255);
            }
            else if (componentsList.length === 4) {
                return Color4.ofRGBA(componentsList[0] / 255, componentsList[1] / 255, componentsList[2] / 255, componentsList[3]);
            }
            else {
                throw new Error(`RGB string, ${text}, has wrong number of components: ${componentsList.length}`);
            }
        }
        // Otherwise, try to use an HTMLCanvasElement to determine the color.
        // Note: We may be unable to create an HTMLCanvasElement if running as a unit test.
        const canvas = document.createElement('canvas');
        canvas.width = 1;
        canvas.height = 1;
        const ctx = canvas.getContext('2d');
        // Default to black if no canvas is available.
        if (!ctx) {
            return Color4.black;
        }
        ctx.fillStyle = text;
        ctx.fillRect(0, 0, 1, 1);
        const data = ctx.getImageData(0, 0, 1, 1);
        const red = data.data[0] / 255;
        const green = data.data[1] / 255;
        const blue = data.data[2] / 255;
        const alpha = data.data[3] / 255;
        return Color4.ofRGBA(red, green, blue, alpha);
    }
    /** @returns true if `this` and `other` are approximately equal. */
    eq(other) {
        if (other == null) {
            return false;
        }
        // If both completely transparent,
        if (this.a === 0 && other.a === 0) {
            return true;
        }
        return this.toHexString() === other.toHexString();
    }
    /**
     * If `fractionTo` is not in the range $[0, 1]$, it will be clamped to the nearest number
     * in that range. For example, `a.mix(b, -1)` is equivalent to `a.mix(b, 0)`.
     *
     * @returns a color `fractionTo` of the way from this color to `other`.
     *
     * @example
     * ```ts
     * Color4.ofRGB(1, 0, 0).mix(Color4.ofRGB(0, 1, 0), 0.1) // -> Color4(0.9, 0.1, 0)
     * ```
     */
    mix(other, fractionTo) {
        fractionTo = Math.min(Math.max(fractionTo, 0), 1);
        const fractionOfThis = 1 - fractionTo;
        return new Color4(this.r * fractionOfThis + other.r * fractionTo, this.g * fractionOfThis + other.g * fractionTo, this.b * fractionOfThis + other.b * fractionTo, this.a * fractionOfThis + other.a * fractionTo);
    }
    /**
     * Ignoring this color's alpha component, returns a vector with components,
     * $$
     * \begin{pmatrix} \colorbox{#F44}{\tt r} \\ \colorbox{#4F4}{\tt g} \\ \colorbox{#44F}{\tt b} \end{pmatrix}
     * $$
     */
    get rgb() {
        return _Vec3_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].of(this.r, this.g, this.b);
    }
    /**
     * Returns the [relative luminance](https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef)
     * of this color in the sRGB color space.
     *
     * Ignores the alpha component.
     */
    relativeLuminance() {
        // References:
        // - https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
        // - https://stackoverflow.com/a/9733420
        // Normalize the components, as per above
        const components = [this.r, this.g, this.b].map((component) => {
            if (component < 0.03928) {
                return component / 12.92;
            }
            else {
                return Math.pow((component + 0.055) / 1.055, 2.4);
            }
        });
        // From w3.org,
        // > For the sRGB colorspace, the relative luminance of a color is
        // > defined as L = 0.2126 * R + 0.7152 * G + 0.0722 * B
        // where R, G, B are defined in components above.
        return 0.2126 * components[0] + 0.7152 * components[1] + 0.0722 * components[2];
    }
    /**
     * Returns the [contrast ratio](https://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef)
     * between `colorA` and `colorB`.
     */
    static contrastRatio(colorA, colorB) {
        const L1 = colorA.relativeLuminance();
        const L2 = colorB.relativeLuminance();
        return (Math.max(L1, L2) + 0.05) / (Math.min(L1, L2) + 0.05);
    }
    /**
     * @returns the component-wise average of `colors`, or `Color4.transparent` if `colors` is empty.
     */
    static average(colors) {
        let averageA = 0;
        let averageR = 0;
        let averageG = 0;
        let averageB = 0;
        for (const color of colors) {
            averageA += color.a;
            averageR += color.r;
            averageG += color.g;
            averageB += color.b;
        }
        if (colors.length > 0) {
            averageA /= colors.length;
            averageR /= colors.length;
            averageG /= colors.length;
            averageB /= colors.length;
        }
        return new Color4(averageR, averageG, averageB, averageA);
    }
    /**
     * Converts to (hue, saturation, value).
     * See also https://en.wikipedia.org/wiki/HSL_and_HSV#General_approach
     *
     * The resultant hue is represented in radians and is thus in $[0, 2\pi]$.
     */
    asHSV() {
        // Ref: https://en.wikipedia.org/wiki/HSL_and_HSV#General_approach
        //
        // HUE:
        // First, consider the unit cube. Rotate it such that one vertex is at the origin
        // of a plane and its three neighboring vertices are equidistant from that plane:
        //
        //         /\
        //       /  | \
        //   2 /    3   \ 1
        //     \    |   /
        //       \  | /
        //   .     \/      .
        //
        //        .
        //
        // Let z be up and (x, y, 0) be in the plane.
        //
        // Label vectors 1,2,3 with R, G, and B, respectively. Let R's projection into the plane
        // lie along the x axis.
        //
        // Because R is a unit vector and R, G, B are equidistant from the plane, they must
        // form 30-60-90 triangles, which have side lengths proportional to (1, √3, 2)
        //
        //       /|
        //    1/  | (√3)/2
        //    /   |
        //      1/2
        //
        const minComponent = Math.min(this.r, this.g, this.b);
        const maxComponent = Math.max(this.r, this.g, this.b);
        const chroma = maxComponent - minComponent;
        let hue;
        // See https://en.wikipedia.org/wiki/HSL_and_HSV#General_approach
        if (chroma === 0) {
            hue = 0;
        }
        else if (this.r >= this.g && this.r >= this.b) {
            hue = ((this.g - this.b) / chroma) % 6;
        }
        else if (this.g >= this.r && this.g >= this.b) {
            hue = (this.b - this.r) / chroma + 2;
        }
        else {
            hue = (this.r - this.g) / chroma + 4;
        }
        // Convert to degree representation, then to radians.
        hue *= 60;
        hue *= Math.PI / 180;
        // Ensure positivity.
        if (hue < 0) {
            hue += Math.PI * 2;
        }
        const value = maxComponent;
        const saturation = value > 0 ? chroma / value : 0;
        return _Vec3_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].of(hue, saturation, value);
    }
    /**
     * Creates a new `Color4` from a representation [in $HSV$](https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB).
     *
     * [Algorithm](https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB).
     *
     * Note that hue must be given **in radians**. While non-standard, this is consistent with
     * {@link asHSV}.
     *
     * `hue` and `value` should range from 0 to 1.
     *
     * @param hue $H \in [0, 2\pi]$
     * @param saturation $S_V \in [0, 1]$
     * @param value $V \in [0, 1]$
     */
    static fromHSV(hue, saturation, value) {
        if (hue < 0) {
            hue += Math.PI * 2;
        }
        hue %= Math.PI * 2;
        // Clamp value and saturation to [0, 1]
        value = Math.max(0, Math.min(1, value));
        saturation = Math.max(0, Math.min(1, saturation));
        // Formula from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB
        // Saturation can be thought of as scaled chroma. Unapply the scaling.
        // See https://en.wikipedia.org/wiki/HSL_and_HSV#Saturation
        const chroma = value * saturation;
        // Determines which edge of the projected color cube
        const huePrime = hue / (Math.PI / 3);
        const secondLargestComponent = chroma * (1 - Math.abs((huePrime % 2) - 1));
        let rgb;
        if (huePrime < 1) {
            rgb = [chroma, secondLargestComponent, 0];
        }
        else if (huePrime < 2) {
            rgb = [secondLargestComponent, chroma, 0];
        }
        else if (huePrime < 3) {
            rgb = [0, chroma, secondLargestComponent];
        }
        else if (huePrime < 4) {
            rgb = [0, secondLargestComponent, chroma];
        }
        else if (huePrime < 5) {
            rgb = [secondLargestComponent, 0, chroma];
        }
        else {
            rgb = [chroma, 0, secondLargestComponent];
        }
        const adjustment = value - chroma;
        return Color4.ofRGB(rgb[0] + adjustment, rgb[1] + adjustment, rgb[2] + adjustment);
    }
    /**
     * Equivalent to `ofRGB(rgb.x, rgb.y, rgb.z)`.
     *
     * All components should be in the range `[0, 1]` (0 to 1 inclusive).
     */
    static fromRGBVector(rgb, alpha) {
        return Color4.ofRGBA(rgb.x, rgb.y, rgb.z, alpha ?? 1);
    }
    /**
     * @returns a hexadecimal color string representation of `this`, in the form `#rrggbbaa`.
     *
     * @example
     * ```
     * Color4.red.toHexString(); // -> #ff0000ff
     * ```
     */
    toHexString() {
        if (this.hexString) {
            return this.hexString;
        }
        const componentToHex = (component) => {
            const res = Math.round(255 * component).toString(16);
            if (res.length === 1) {
                return `0${res}`;
            }
            return res;
        };
        const alpha = componentToHex(this.a);
        const red = componentToHex(this.r);
        const green = componentToHex(this.g);
        const blue = componentToHex(this.b);
        if (alpha === 'ff') {
            return `#${red}${green}${blue}`;
        }
        this.hexString = `#${red}${green}${blue}${alpha}`;
        return this.hexString;
    }
    toString() {
        return this.toHexString();
    }
}
Color4.transparent = Color4.ofRGBA(0, 0, 0, 0);
Color4.red = Color4.ofRGB(1.0, 0.0, 0.0);
Color4.orange = Color4.ofRGB(1.0, 0.65, 0.0);
Color4.green = Color4.ofRGB(0.0, 1.0, 0.0);
Color4.blue = Color4.ofRGB(0.0, 0.0, 1.0);
Color4.purple = Color4.ofRGB(0.5, 0.2, 0.5);
Color4.yellow = Color4.ofRGB(1, 1, 0.1);
Color4.clay = Color4.ofRGB(0.8, 0.4, 0.2);
Color4.black = Color4.ofRGB(0, 0, 0);
Color4.gray = Color4.ofRGB(0.5, 0.5, 0.5);
Color4.white = Color4.ofRGB(1, 1, 1);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Color4);


/***/ }),

/***/ "./node_modules/@js-draw/math/dist/mjs/Mat33.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/mjs/Mat33.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Mat33: () => (/* binding */ Mat33),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Vec2_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vec2.mjs */ "./node_modules/@js-draw/math/dist/mjs/Vec2.mjs");
/* harmony import */ var _Vec3_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vec3.mjs */ "./node_modules/@js-draw/math/dist/mjs/Vec3.mjs");


/**
 * Represents a three dimensional linear transformation or
 * a two-dimensional affine transformation. (An affine transformation scales/rotates/shears
 * **and** translates while a linear transformation just scales/rotates/shears).
 *
 * In addition to other matrices, {@link Mat33}s can be used to transform {@link Vec3}s and {@link Vec2}s.
 *
 * For example, to move the point $(1, 1)$ by 5 units to the left and 6 units up,
 * ```ts,runnable,console
 * import {Mat33, Vec2} from '@js-draw/math';
 *
 * const moveLeftAndUp = Mat33.translation(Vec2.of(5, 6));
 * console.log(moveLeftAndUp);
 * ```
 *
 * This `moveLeftAndUp` matrix could then translate (move) a {@link Vec2} using
 * {@link Mat33.transformVec2}:
 *
 * ```ts,runnable,console
 * ---use-previous---
 * ---visible---
 * console.log(moveLeftAndUp.transformVec2(Vec2.of(1, 1)));
 * console.log(moveLeftAndUp.transformVec2(Vec2.of(-1, 2)));
 * ```
 *
 * It's also possible to create transformation matrices that scale and rotate.
 * A single transform matrix can be created from multiple using matrix multiplication
 * (see {@link Mat33.rightMul}):
 *
 * ```ts,runnable,console
 * ---use-previous---
 * ---visible---
 * // Create a matrix by right multiplying.
 * const scaleThenRotate =
 *   // The resultant matrix first scales by a factor of two
 *   Mat33.scaling2D(2).rightMul(
 *     // ...then rotates by pi/2 radians = 90 degrees.
 *     Mat33.zRotation(Math.PI / 2)
 *   );
 * console.log(scaleThenRotate);
 *
 * // Use scaleThenRotate to scale then rotate a vector.
 * console.log(scaleThenRotate.transformVec2(Vec2.unitX));
 * ```
 */
class Mat33 {
    /**
     * Creates a matrix from inputs in the form,
     * $$
     * \begin{bmatrix}
     *   a1 & a2 & a3 \\
     *   b1 & b2 & b3 \\
     *   c1 & c2 & c3
     * \end{bmatrix}
     * $$
     *
     * Static constructor methods are also available.
     * See {@link Mat33.scaling2D}, {@link Mat33.zRotation}, {@link Mat33.translation}, and {@link Mat33.fromCSSMatrix}.
     */
    constructor(a1, a2, a3, b1, b2, b3, c1, c2, c3) {
        this.a1 = a1;
        this.a2 = a2;
        this.a3 = a3;
        this.b1 = b1;
        this.b2 = b2;
        this.b3 = b3;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
        this.cachedInverse = undefined;
        this.rows = [_Vec3_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].of(a1, a2, a3), _Vec3_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].of(b1, b2, b3), _Vec3_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].of(c1, c2, c3)];
    }
    /**
     * Creates a matrix from the given rows:
     * $$
     * \begin{bmatrix}
     *  \texttt{r1.x} & \texttt{r1.y} & \texttt{r1.z}\\
     *  \texttt{r2.x} & \texttt{r2.y} & \texttt{r2.z}\\
     *  \texttt{r3.x} & \texttt{r3.y} & \texttt{r3.z}\\
     * \end{bmatrix}
     * $$
     */
    static ofRows(r1, r2, r3) {
        return new Mat33(r1.x, r1.y, r1.z, r2.x, r2.y, r2.z, r3.x, r3.y, r3.z);
    }
    /**
     * Either returns the inverse of this, or, if this matrix is singular/uninvertable,
     * returns Mat33.identity.
     *
     * This may cache the computed inverse and return the cached version instead of recomputing
     * it.
     */
    inverse() {
        return this.computeInverse() ?? Mat33.identity;
    }
    invertable() {
        return this.computeInverse() !== null;
    }
    computeInverse() {
        if (this.cachedInverse !== undefined) {
            return this.cachedInverse;
        }
        const toIdentity = [this.rows[0], this.rows[1], this.rows[2]];
        const toResult = [_Vec3_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].unitX, _Vec3_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].unitY, _Vec3_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].unitZ];
        // Convert toIdentity to the identity matrix and
        // toResult to the inverse through elementary row operations
        for (let cursor = 0; cursor < 3; cursor++) {
            // Select the [cursor]th diagonal entry
            let pivot = toIdentity[cursor].at(cursor);
            // Don't divide by zero (treat very small numbers as zero).
            const minDivideBy = 1e-10;
            if (Math.abs(pivot) < minDivideBy) {
                let swapIndex = -1;
                // For all other rows,
                for (let i = 1; i <= 2; i++) {
                    const otherRowIdx = (cursor + i) % 3;
                    if (Math.abs(toIdentity[otherRowIdx].at(cursor)) >= minDivideBy) {
                        swapIndex = otherRowIdx;
                        break;
                    }
                }
                // Can't swap with another row?
                if (swapIndex === -1) {
                    this.cachedInverse = null;
                    return null;
                }
                const tmpIdentityRow = toIdentity[cursor];
                const tmpResultRow = toResult[cursor];
                // Swap!
                toIdentity[cursor] = toIdentity[swapIndex];
                toResult[cursor] = toResult[swapIndex];
                toIdentity[swapIndex] = tmpIdentityRow;
                toResult[swapIndex] = tmpResultRow;
                pivot = toIdentity[cursor].at(cursor);
            }
            // Make toIdentity[k = cursor] = 1
            let scale = 1.0 / pivot;
            toIdentity[cursor] = toIdentity[cursor].times(scale);
            toResult[cursor] = toResult[cursor].times(scale);
            const cursorToIdentityRow = toIdentity[cursor];
            const cursorToResultRow = toResult[cursor];
            // Make toIdentity[k ≠ cursor] = 0
            for (let i = 1; i <= 2; i++) {
                const otherRowIdx = (cursor + i) % 3;
                scale = -toIdentity[otherRowIdx].at(cursor);
                toIdentity[otherRowIdx] = toIdentity[otherRowIdx].plus(cursorToIdentityRow.times(scale));
                toResult[otherRowIdx] = toResult[otherRowIdx].plus(cursorToResultRow.times(scale));
            }
        }
        const inverse = Mat33.ofRows(toResult[0], toResult[1], toResult[2]);
        this.cachedInverse = inverse;
        return inverse;
    }
    transposed() {
        return new Mat33(this.a1, this.b1, this.c1, this.a2, this.b2, this.c2, this.a3, this.b3, this.c3);
    }
    /**
     * [Right-multiplies](https://en.wikipedia.org/wiki/Matrix_multiplication) this by `other`.
     *
     * See also {@link transformVec3} and {@link transformVec2}.
     *
     * Example:
     * ```ts,runnable,console
     * import {Mat33, Vec2} from '@js-draw/math';
     * console.log(Mat33.identity.rightMul(Mat33.identity));
     *
     * // Create a matrix by right multiplying.
     * const scaleThenRotate =
     *   // The resultant matrix first scales by a factor of two
     *   Mat33.scaling2D(2).rightMul(
     *     // ...then rotates by pi/4 radians = 45 degrees.
     *     Mat33.zRotation(Math.PI / 4)
     *   );
     * console.log(scaleThenRotate);
     *
     * // Use scaleThenRotate to scale then rotate a vector.
     * console.log(scaleThenRotate.transformVec2(Vec2.unitX));
     * ```
     */
    rightMul(other) {
        other = other.transposed();
        const at = (row, col) => {
            return this.rows[row].dot(other.rows[col]);
        };
        return new Mat33(at(0, 0), at(0, 1), at(0, 2), at(1, 0), at(1, 1), at(1, 2), at(2, 0), at(2, 1), at(2, 2));
    }
    /**
     * Applies this as an **affine** transformation to the given vector.
     * Returns a transformed version of `other`.
     *
     * Unlike {@link transformVec3}, this **does** translate the given vector.
     */
    transformVec2(other) {
        // When transforming a Vec2, we want to use the z transformation
        // components of this for translation:
        //  ⎡ . . tX ⎤
        //  ⎢ . . tY ⎥
        //  ⎣ 0 0 1  ⎦
        // For this, we need other's z component to be 1 (so that tX and tY
        // are scaled by 1):
        let intermediate = _Vec3_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].of(other.x, other.y, 1);
        intermediate = this.transformVec3(intermediate);
        // Drop the z=1 to allow magnitude to work as expected
        return _Vec2_mjs__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(intermediate.x, intermediate.y);
    }
    /**
     * Applies this as a linear transformation to the given vector (doesn't translate).
     * This is the standard way of transforming vectors in ℝ³.
     */
    transformVec3(other) {
        return _Vec3_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].of(this.rows[0].dot(other), this.rows[1].dot(other), this.rows[2].dot(other));
    }
    /** @returns true iff this is the identity matrix. */
    isIdentity() {
        if (this === Mat33.identity) {
            return true;
        }
        return this.eq(Mat33.identity);
    }
    /** Returns true iff this = other ± fuzz */
    eq(other, fuzz = 0) {
        for (let i = 0; i < 3; i++) {
            if (!this.rows[i].eq(other.rows[i], fuzz)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Creates a human-readable representation of the matrix.
     *
     * Example:
     * ```ts,runnable,console
     * import { Mat33 } from '@js-draw/math';
     * console.log(Mat33.identity.toString());
     * ```
     */
    toString() {
        let result = '';
        const maxColumnLens = [0, 0, 0];
        // Determine the longest item in each column so we can pad the others to that
        // length.
        for (const row of this.rows) {
            for (let i = 0; i < 3; i++) {
                maxColumnLens[i] = Math.max(maxColumnLens[0], `${row.at(i)}`.length);
            }
        }
        for (let i = 0; i < 3; i++) {
            if (i === 0) {
                result += '⎡ ';
            }
            else if (i === 1) {
                result += '⎢ ';
            }
            else {
                result += '⎣ ';
            }
            // Add each component of the ith row (after padding it)
            for (let j = 0; j < 3; j++) {
                const val = this.rows[i].at(j).toString();
                let padding = '';
                for (let i = val.length; i < maxColumnLens[j]; i++) {
                    padding += ' ';
                }
                result += val + ', ' + padding;
            }
            if (i === 0) {
                result += ' ⎤';
            }
            else if (i === 1) {
                result += ' ⎥';
            }
            else {
                result += ' ⎦';
            }
            result += '\n';
        }
        return result.trimEnd();
    }
    /**
     * ```
     * result[0] = top left element
     * result[1] = element at row zero, column 1
     * ...
     * ```
     *
     * Example:
     * ```ts,runnable,console
     * import { Mat33 } from '@js-draw/math';
     * console.log(
     *   new Mat33(
     *     1, 2, 3,
     *     4, 5, 6,
     *     7, 8, 9,
     *   )
     * );
     * ```
     */
    toArray() {
        return [this.a1, this.a2, this.a3, this.b1, this.b2, this.b3, this.c1, this.c2, this.c3];
    }
    /**
     * Returns a new `Mat33` where each entry is the output of the function
     * `mapping`.
     *
     * @example
     * ```
     * new Mat33(
     *  1, 2, 3,
     *  4, 5, 6,
     *  7, 8, 9,
     * ).mapEntries(component => component - 1);
     * // → ⎡ 0, 1, 2 ⎤
     * //   ⎢ 3, 4, 5 ⎥
     * //   ⎣ 6, 7, 8 ⎦
     * ```
     */
    mapEntries(mapping) {
        return new Mat33(mapping(this.a1, [0, 0]), mapping(this.a2, [0, 1]), mapping(this.a3, [0, 2]), mapping(this.b1, [1, 0]), mapping(this.b2, [1, 1]), mapping(this.b3, [1, 2]), mapping(this.c1, [2, 0]), mapping(this.c2, [2, 1]), mapping(this.c3, [2, 2]));
    }
    /** Estimate the scale factor of this matrix (based on the first row). */
    getScaleFactor() {
        return Math.hypot(this.a1, this.a2);
    }
    /** Returns the `idx`-th column (`idx` is 0-indexed). */
    getColumn(idx) {
        return _Vec3_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].of(this.rows[0].at(idx), this.rows[1].at(idx), this.rows[2].at(idx));
    }
    /** Returns the magnitude of the entry with the largest entry */
    maximumEntryMagnitude() {
        let greatestSoFar = Math.abs(this.a1);
        for (const entry of this.toArray()) {
            greatestSoFar = Math.max(greatestSoFar, Math.abs(entry));
        }
        return greatestSoFar;
    }
    /**
     * Constructs a 3x3 translation matrix (for translating `Vec2`s) using
     * **transformVec2**.
     *
     * Creates a matrix in the form
     * $$
     * 	\begin{pmatrix}
     * 		1 & 0 & {\tt amount.x}\\
     * 		0 & 1 & {\tt amount.y}\\
     * 		0 & 0 & 1
     * 	\end{pmatrix}
     * $$
     */
    static translation(amount) {
        // When transforming Vec2s by a 3x3 matrix, we give the input
        // Vec2s z = 1. As such,
        //   outVec2.x = inVec2.x * 1 + inVec2.y * 0 + 1 * amount.x
        //   ...
        return new Mat33(1, 0, amount.x, 0, 1, amount.y, 0, 0, 1);
    }
    /**
     * Creates a matrix for rotating `Vec2`s about `center` by some number of `radians`.
     *
     * For this function, {@link Vec2}s are considered to be points in 2D space.
     *
     * For example,
     * ```ts,runnable,console
     * import { Mat33, Vec2 } from '@js-draw/math';
     *
     * const halfCircle = Math.PI; // PI radians = 180 degrees = 1/2 circle
     * const center = Vec2.of(1, 1); // The point (1,1)
     * const rotationMatrix = Mat33.zRotation(halfCircle, center);
     *
     * console.log(
     *   'Rotating (0,0) 180deg about', center, 'results in',
     *   // Rotates (0,0)
     *   rotationMatrix.transformVec2(Vec2.zero),
     * );
     * ```
     */
    static zRotation(radians, center = _Vec2_mjs__WEBPACK_IMPORTED_MODULE_0__.Vec2.zero) {
        if (radians === 0) {
            return Mat33.identity;
        }
        const cos = Math.cos(radians);
        const sin = Math.sin(radians);
        // Translate everything so that rotation is about the origin
        let result = Mat33.translation(center);
        result = result.rightMul(new Mat33(cos, -sin, 0, sin, cos, 0, 0, 0, 1));
        return result.rightMul(Mat33.translation(center.times(-1)));
    }
    static scaling2D(amount, center = _Vec2_mjs__WEBPACK_IMPORTED_MODULE_0__.Vec2.zero) {
        let result = Mat33.translation(center);
        let xAmount, yAmount;
        if (typeof amount === 'number') {
            xAmount = amount;
            yAmount = amount;
        }
        else {
            xAmount = amount.x;
            yAmount = amount.y;
        }
        result = result.rightMul(new Mat33(xAmount, 0, 0, 0, yAmount, 0, 0, 0, 1));
        // Translate such that [center] goes to (0, 0)
        return result.rightMul(Mat33.translation(center.times(-1)));
    }
    /**
     * **Note**: Assumes `this.c1 = this.c2 = 0` and `this.c3 = 1`.
     *
     * @see {@link fromCSSMatrix}
     */
    toCSSMatrix() {
        return `matrix(${this.a1},${this.b1},${this.a2},${this.b2},${this.a3},${this.b3})`;
    }
    /**
     * Converts a CSS-form `matrix(a, b, c, d, e, f)` to a Mat33.
     *
     * Note that such a matrix has the form,
     * ```
     * ⎡ a c e ⎤
     * ⎢ b d f ⎥
     * ⎣ 0 0 1 ⎦
     * ```
     */
    static fromCSSMatrix(cssString) {
        if (cssString === '' || cssString === 'none') {
            return Mat33.identity;
        }
        // Normalize spacing
        cssString = cssString.trim().replace(/\s+/g, ' ');
        const parseArguments = (argumentString) => {
            const parsed = argumentString.split(/[, \t\n]+/g).map((argString) => {
                // Handle trailing spaces/commands
                if (argString.trim() === '') {
                    return null;
                }
                let isPercentage = false;
                if (argString.endsWith('%')) {
                    isPercentage = true;
                    argString = argString.substring(0, argString.length - 1);
                }
                // Remove trailing px units.
                argString = argString.replace(/px$/gi, '');
                const numberExp = /^[-]?\d*(?:\.\d*)?(?:[eE][-+]?\d+)?$/i;
                if (!numberExp.exec(argString)) {
                    throw new Error(`All arguments to transform functions must be numeric (state: ${JSON.stringify({
                        currentArgument: argString,
                        allArguments: argumentString,
                    })})`);
                }
                let argNumber = parseFloat(argString);
                if (isPercentage) {
                    argNumber /= 100;
                }
                return argNumber;
            });
            return parsed.filter((n) => n !== null);
        };
        const keywordToAction = {
            matrix: (matrixData) => {
                if (matrixData.length !== 6) {
                    throw new Error(`Invalid matrix argument: ${matrixData}. Must have length 6`);
                }
                const a = matrixData[0];
                const b = matrixData[1];
                const c = matrixData[2];
                const d = matrixData[3];
                const e = matrixData[4];
                const f = matrixData[5];
                const transform = new Mat33(a, c, e, b, d, f, 0, 0, 1);
                return transform;
            },
            scale: (scaleArgs) => {
                let scaleX, scaleY;
                if (scaleArgs.length === 1) {
                    scaleX = scaleArgs[0];
                    scaleY = scaleArgs[0];
                }
                else if (scaleArgs.length === 2) {
                    scaleX = scaleArgs[0];
                    scaleY = scaleArgs[1];
                }
                else {
                    throw new Error(`The scale() function only supports two arguments. Given: ${scaleArgs}`);
                }
                return Mat33.scaling2D(_Vec2_mjs__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(scaleX, scaleY));
            },
            translate: (translateArgs) => {
                let translateX = 0;
                let translateY = 0;
                if (translateArgs.length === 1) {
                    // If no y translation is given, assume 0.
                    translateX = translateArgs[0];
                }
                else if (translateArgs.length === 2) {
                    translateX = translateArgs[0];
                    translateY = translateArgs[1];
                }
                else {
                    throw new Error(`The translate() function requires either 1 or 2 arguments. Given ${translateArgs}`);
                }
                return Mat33.translation(_Vec2_mjs__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(translateX, translateY));
            },
        };
        // A command (\w+)
        // followed by a set of arguments ([^)]*)
        const partRegex = /(?:^|\W)(\w+)\s?\(([^)]*)\)/gi;
        let match;
        let matrix = null;
        while ((match = partRegex.exec(cssString)) !== null) {
            const action = match[1].toLowerCase();
            if (!(action in keywordToAction)) {
                throw new Error(`Unsupported CSS transform action: ${action}`);
            }
            const args = parseArguments(match[2]);
            const currentMatrix = keywordToAction[action](args);
            if (!matrix) {
                matrix = currentMatrix;
            }
            else {
                matrix = matrix.rightMul(currentMatrix);
            }
        }
        return matrix ?? Mat33.identity;
    }
}
/** The 3x3 [identity matrix](https://en.wikipedia.org/wiki/Identity_matrix). */
Mat33.identity = new Mat33(1, 0, 0, 0, 1, 0, 0, 0, 1);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Mat33);


/***/ }),

/***/ "./node_modules/@js-draw/math/dist/mjs/Vec2.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/mjs/Vec2.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Vec2: () => (/* reexport safe */ _Vec3_mjs__WEBPACK_IMPORTED_MODULE_0__.Vec2),
/* harmony export */   Vec3: () => (/* reexport safe */ _Vec3_mjs__WEBPACK_IMPORTED_MODULE_0__.Vec3),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Vec3_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vec3.mjs */ "./node_modules/@js-draw/math/dist/mjs/Vec3.mjs");
// Internally, we define Vec2 as a namespace within Vec3 --
// this allows referencing Vec2s from Vec3 constructors without
// cyclic references.


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_Vec3_mjs__WEBPACK_IMPORTED_MODULE_0__.Vec2);


/***/ }),

/***/ "./node_modules/@js-draw/math/dist/mjs/Vec3.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/mjs/Vec3.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Vec2: () => (/* binding */ Vec2),
/* harmony export */   Vec3: () => (/* binding */ Vec3),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const defaultEqlTolerance = 1e-10;
class Vec3Impl {
    constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
    get xy() {
        // Useful for APIs that behave differently if .z is present.
        return {
            x: this.x,
            y: this.y,
        };
    }
    /** Returns this' `idx`th component. For example, `Vec3.of(1, 2, 3).at(1) → 2`. */
    at(idx) {
        if (idx === 0)
            return this.x;
        if (idx === 1)
            return this.y;
        if (idx === 2)
            return this.z;
        throw new Error(`${idx} out of bounds!`);
    }
    length() {
        return this.magnitude();
    }
    magnitude() {
        return Math.sqrt(this.magnitudeSquared());
    }
    magnitudeSquared() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    squareDistanceTo(p) {
        const dx = this.x - p.x;
        const dy = this.y - p.y;
        const dz = this.z - p.z;
        return dx * dx + dy * dy + dz * dz;
    }
    distanceTo(p) {
        return Math.sqrt(this.squareDistanceTo(p));
    }
    maximumEntryMagnitude() {
        return Math.max(Math.abs(this.x), Math.max(Math.abs(this.y), Math.abs(this.z)));
    }
    angle() {
        return Math.atan2(this.y, this.x);
    }
    normalized() {
        const norm = this.magnitude();
        return Vec3.of(this.x / norm, this.y / norm, this.z / norm);
    }
    normalizedOrZero() {
        if (this.eq(Vec3.zero)) {
            return Vec3.zero;
        }
        return this.normalized();
    }
    times(c) {
        return Vec3.of(this.x * c, this.y * c, this.z * c);
    }
    plus(v) {
        return Vec3.of(this.x + v.x, this.y + v.y, this.z + v.z);
    }
    minus(v) {
        return Vec3.of(this.x - v.x, this.y - v.y, this.z - v.z);
    }
    dot(other) {
        return this.x * other.x + this.y * other.y + this.z * other.z;
    }
    cross(other) {
        // | i  j  k |
        // | x1 y1 z1| = (i)(y1z2 - y2z1) - (j)(x1z2 - x2z1) + (k)(x1y2 - x2y1)
        // | x2 y2 z2|
        return Vec3.of(this.y * other.z - other.y * this.z, other.x * this.z - this.x * other.z, this.x * other.y - other.x * this.y);
    }
    scale(other) {
        if (typeof other === 'number') {
            return this.times(other);
        }
        return Vec3.of(this.x * other.x, this.y * other.y, this.z * other.z);
    }
    orthog() {
        // If parallel to the z-axis
        if (this.dot(Vec3.unitX) === 0 && this.dot(Vec3.unitY) === 0) {
            return this.dot(Vec3.unitX) === 0 ? Vec3.unitX : this.cross(Vec3.unitX).normalized();
        }
        return this.cross(Vec3.unitZ.times(-1)).normalized();
    }
    extend(distance, direction) {
        return this.plus(direction.normalized().times(distance));
    }
    lerp(target, fractionTo) {
        return this.times(1 - fractionTo).plus(target.times(fractionTo));
    }
    zip(other, zip) {
        return Vec3.of(zip(other.x, this.x), zip(other.y, this.y), zip(other.z, this.z));
    }
    map(fn) {
        return Vec3.of(fn(this.x, 0), fn(this.y, 1), fn(this.z, 2));
    }
    asArray() {
        return [this.x, this.y, this.z];
    }
    eq(other, fuzz = defaultEqlTolerance) {
        return (Math.abs(other.x - this.x) <= fuzz &&
            Math.abs(other.y - this.y) <= fuzz &&
            Math.abs(other.z - this.z) <= fuzz);
    }
    toString() {
        return `Vec(${this.x}, ${this.y}, ${this.z})`;
    }
}
class Vec2Impl {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    get z() {
        return 0;
    }
    get xy() {
        // Useful for APIs that behave differently if .z is present.
        return {
            x: this.x,
            y: this.y,
        };
    }
    at(idx) {
        if (idx === 0)
            return this.x;
        if (idx === 1)
            return this.y;
        if (idx === 2)
            return 0;
        throw new Error(`${idx} out of bounds!`);
    }
    length() {
        return this.magnitude();
    }
    magnitude() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    magnitudeSquared() {
        return this.x * this.x + this.y * this.y;
    }
    squareDistanceTo(p) {
        const dx = this.x - p.x;
        const dy = this.y - p.y;
        return dx * dx + dy * dy + p.z * p.z;
    }
    distanceTo(p) {
        return Math.sqrt(this.squareDistanceTo(p));
    }
    maximumEntryMagnitude() {
        return Math.max(Math.abs(this.x), Math.abs(this.y));
    }
    angle() {
        return Math.atan2(this.y, this.x);
    }
    normalized() {
        const norm = this.magnitude();
        return Vec2.of(this.x / norm, this.y / norm);
    }
    normalizedOrZero() {
        if (this.eq(Vec3.zero)) {
            return Vec3.zero;
        }
        return this.normalized();
    }
    times(c) {
        return Vec2.of(this.x * c, this.y * c);
    }
    plus(v) {
        return Vec3.of(this.x + v.x, this.y + v.y, v.z);
    }
    minus(v) {
        return Vec3.of(this.x - v.x, this.y - v.y, -v.z);
    }
    dot(other) {
        return this.x * other.x + this.y * other.y;
    }
    cross(other) {
        // | i  j  k |
        // | x1 y1 z1| = (i)(y1z2 - y2z1) - (j)(x1z2 - x2z1) + (k)(x1y2 - x2y1)
        // | x2 y2 z2|
        return Vec3.of(this.y * other.z, -this.x * other.z, this.x * other.y - other.x * this.y);
    }
    scale(other) {
        if (typeof other === 'number') {
            return this.times(other);
        }
        return Vec2.of(this.x * other.x, this.y * other.y);
    }
    orthog() {
        // If parallel to the z-axis
        if (this.dot(Vec3.unitX) === 0 && this.dot(Vec3.unitY) === 0) {
            return this.dot(Vec3.unitX) === 0 ? Vec3.unitX : this.cross(Vec3.unitX).normalized();
        }
        return this.cross(Vec3.unitZ.times(-1)).normalized();
    }
    extend(distance, direction) {
        return this.plus(direction.normalized().times(distance));
    }
    lerp(target, fractionTo) {
        return this.times(1 - fractionTo).plus(target.times(fractionTo));
    }
    zip(other, zip) {
        return Vec3.of(zip(other.x, this.x), zip(other.y, this.y), zip(other.z, 0));
    }
    map(fn) {
        return Vec3.of(fn(this.x, 0), fn(this.y, 1), fn(0, 2));
    }
    asArray() {
        return [this.x, this.y, 0];
    }
    eq(other, fuzz = defaultEqlTolerance) {
        return (Math.abs(other.x - this.x) <= fuzz &&
            Math.abs(other.y - this.y) <= fuzz &&
            Math.abs(other.z) <= fuzz);
    }
    toString() {
        return `Vec(${this.x}, ${this.y})`;
    }
}
/**
 * A `Vec2` is a {@link Vec3} optimized for working in a plane. `Vec2`s have an
 * always-zero `z` component.
 *
 * ```ts,runnable,console
 * import { Vec2 } from '@js-draw/math';
 *
 * const v = Vec2.of(1, 2);
 * console.log('a Vec2:', v);
 * console.log('x component:', v.x);
 * console.log('z component:', v.z);
 * ```
 */
var Vec2;
(function (Vec2) {
    /**
     * Creates a `Vec2` from an x and y coordinate.
     *
     * @example
     * ```ts,runnable,console
     * import { Vec2 } from '@js-draw/math';
     * const v = Vec2.of(3, 4); // x=3, y=4.
     * ```
     */
    Vec2.of = (x, y) => {
        return new Vec2Impl(x, y);
    };
    /**
     * Creates a `Vec2` from an object containing `x` and `y` coordinates.
     *
     * @example
     * ```ts,runnable,console
     * import { Vec2 } from '@js-draw/math';
     * const v1 = Vec2.ofXY({ x: 3, y: 4.5 });
     * const v2 = Vec2.ofXY({ x: -123.4, y: 1 });
     * ```
     */
    Vec2.ofXY = ({ x, y }) => {
        return Vec2.of(x, y);
    };
    /** A vector of length 1 in the X direction (→). */
    Vec2.unitX = Vec2.of(1, 0);
    /** A vector of length 1 in the Y direction (↑). */
    Vec2.unitY = Vec2.of(0, 1);
    /** The zero vector: A vector with x=0, y=0. */
    Vec2.zero = Vec2.of(0, 0);
})(Vec2 || (Vec2 = {}));
/** Contains static methods for constructing a {@link Vec3}. */
var Vec3;
(function (Vec3) {
    /**
     * Construct a vector from three components.
     *
     * @example
     * ```ts,runnable,console
     * import { Vec3 } from '@js-draw/math';
     * const v1 = Vec3.of(1, 2, 3);
     * console.log(v1.plus(Vec3.of(0, 100, 0)));
     * ```
     */
    Vec3.of = (x, y, z) => {
        if (z === 0) {
            return Vec2.of(x, y);
        }
        else {
            return new Vec3Impl(x, y, z);
        }
    };
    /** A unit vector in the x direction (`[1, 0, 0]`). */
    Vec3.unitX = Vec2.unitX;
    /** A unit vector in the y direction (`[0, 1, 0]`). */
    Vec3.unitY = Vec2.unitY;
    /** The zero vector (`[0, 0, 0]`). */
    Vec3.zero = Vec2.zero;
    /** A vector of length 1 in the z direction. */
    Vec3.unitZ = Vec3.of(0, 0, 1);
})(Vec3 || (Vec3 = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Vec3);


/***/ }),

/***/ "./node_modules/@js-draw/math/dist/mjs/lib.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/mjs/lib.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Abstract2DShape: () => (/* reexport safe */ _shapes_Abstract2DShape_mjs__WEBPACK_IMPORTED_MODULE_5__.Abstract2DShape),
/* harmony export */   Color4: () => (/* reexport safe */ _Color4_mjs__WEBPACK_IMPORTED_MODULE_9__.Color4),
/* harmony export */   LineSegment2: () => (/* reexport safe */ _shapes_LineSegment2_mjs__WEBPACK_IMPORTED_MODULE_0__.LineSegment2),
/* harmony export */   Mat33: () => (/* reexport safe */ _Mat33_mjs__WEBPACK_IMPORTED_MODULE_6__.Mat33),
/* harmony export */   Parameterized2DShape: () => (/* reexport safe */ _shapes_Parameterized2DShape_mjs__WEBPACK_IMPORTED_MODULE_3__.Parameterized2DShape),
/* harmony export */   Path: () => (/* reexport safe */ _shapes_Path_mjs__WEBPACK_IMPORTED_MODULE_1__.Path),
/* harmony export */   PathCommandType: () => (/* reexport safe */ _shapes_Path_mjs__WEBPACK_IMPORTED_MODULE_1__.PathCommandType),
/* harmony export */   QuadraticBezier: () => (/* reexport safe */ _shapes_QuadraticBezier_mjs__WEBPACK_IMPORTED_MODULE_4__.QuadraticBezier),
/* harmony export */   Rect2: () => (/* reexport safe */ _shapes_Rect2_mjs__WEBPACK_IMPORTED_MODULE_2__.Rect2),
/* harmony export */   Vec2: () => (/* reexport safe */ _Vec2_mjs__WEBPACK_IMPORTED_MODULE_7__.Vec2),
/* harmony export */   Vec3: () => (/* reexport safe */ _Vec3_mjs__WEBPACK_IMPORTED_MODULE_8__.Vec3),
/* harmony export */   comparePathIndices: () => (/* reexport safe */ _shapes_Path_mjs__WEBPACK_IMPORTED_MODULE_1__.compareCurveIndices),
/* harmony export */   stepPathIndexBy: () => (/* reexport safe */ _shapes_Path_mjs__WEBPACK_IMPORTED_MODULE_1__.stepCurveIndexBy),
/* harmony export */   toRoundedString: () => (/* reexport safe */ _rounding_lib_mjs__WEBPACK_IMPORTED_MODULE_10__.toRoundedString)
/* harmony export */ });
/* harmony import */ var _shapes_LineSegment2_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shapes/LineSegment2.mjs */ "./node_modules/@js-draw/math/dist/mjs/shapes/LineSegment2.mjs");
/* harmony import */ var _shapes_Path_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shapes/Path.mjs */ "./node_modules/@js-draw/math/dist/mjs/shapes/Path.mjs");
/* harmony import */ var _shapes_Rect2_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shapes/Rect2.mjs */ "./node_modules/@js-draw/math/dist/mjs/shapes/Rect2.mjs");
/* harmony import */ var _shapes_Parameterized2DShape_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shapes/Parameterized2DShape.mjs */ "./node_modules/@js-draw/math/dist/mjs/shapes/Parameterized2DShape.mjs");
/* harmony import */ var _shapes_QuadraticBezier_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shapes/QuadraticBezier.mjs */ "./node_modules/@js-draw/math/dist/mjs/shapes/QuadraticBezier.mjs");
/* harmony import */ var _shapes_Abstract2DShape_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shapes/Abstract2DShape.mjs */ "./node_modules/@js-draw/math/dist/mjs/shapes/Abstract2DShape.mjs");
/* harmony import */ var _Mat33_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Mat33.mjs */ "./node_modules/@js-draw/math/dist/mjs/Mat33.mjs");
/* harmony import */ var _Vec2_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Vec2.mjs */ "./node_modules/@js-draw/math/dist/mjs/Vec2.mjs");
/* harmony import */ var _Vec3_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Vec3.mjs */ "./node_modules/@js-draw/math/dist/mjs/Vec3.mjs");
/* harmony import */ var _Color4_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Color4.mjs */ "./node_modules/@js-draw/math/dist/mjs/Color4.mjs");
/* harmony import */ var _rounding_lib_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./rounding/lib.mjs */ "./node_modules/@js-draw/math/dist/mjs/rounding/lib.mjs");
/**
 * This package contains general math utilities used by `js-draw`.
 * These include 2D and 3D vectors, 2D paths, and 3x3 matrices.
 *
 * ```ts,runnable,console
 * import { Vec2, Mat33, Rect2 } from '@js-draw/math';
 *
 * // Example: Rotate a vector 90 degrees about the z-axis
 * const rotate90Degrees = Mat33.zRotation(Math.PI/2); // π/2 radians = 90 deg
 * const moveUp = Mat33.translation(Vec2.of(1, 0));
 * const moveUpThenRotate = rotate90Degrees.rightMul(moveUp);
 * console.log(moveUpThenRotate.transformVec2(Vec2.of(1, 2)));
 *
 * // Example: Bounding box of some points
 * console.log(Rect2.bboxOf([
 *   Vec2.of(1, 2), Vec2.of(3, 4), Vec2.of(-100, 1000),
 * ]));
 * ```
 *
 * @packageDocumentation
 */











// Note: All above exports cannot use `export { default as ... } from "..."` because this
// breaks TypeDoc -- TypeDoc otherwise labels any imports of these classes as `default`.


/***/ }),

/***/ "./node_modules/@js-draw/math/dist/mjs/polynomial/solveQuadratic.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/mjs/polynomial/solveQuadratic.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Solves an equation of the form ax² + bx + c = 0.
 * The larger solution is returned first.
 *
 * If there are no solutions, returns `[NaN, NaN]`. If there is one solution,
 * repeats the solution twice in the result.
 */
const solveQuadratic = (a, b, c) => {
    // See also https://en.wikipedia.org/wiki/Quadratic_formula
    if (a === 0) {
        let solution;
        if (b === 0) {
            solution = c === 0 ? 0 : NaN;
        }
        else {
            // Then we have bx + c = 0
            // which implies bx = -c.
            // Thus, x = -c/b
            solution = -c / b;
        }
        return [solution, solution];
    }
    const discriminant = b * b - 4 * a * c;
    if (discriminant < 0) {
        return [NaN, NaN];
    }
    const rootDiscriminant = Math.sqrt(discriminant);
    const solution1 = (-b + rootDiscriminant) / (2 * a);
    const solution2 = (-b - rootDiscriminant) / (2 * a);
    if (solution1 > solution2) {
        return [solution1, solution2];
    }
    else {
        return [solution2, solution1];
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (solveQuadratic);


/***/ }),

/***/ "./node_modules/@js-draw/math/dist/mjs/rounding/cleanUpNumber.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/mjs/rounding/cleanUpNumber.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cleanUpNumber: () => (/* binding */ cleanUpNumber),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Cleans up stringified numbers */
const cleanUpNumber = (text) => {
    // Regular expression substitions can be somewhat expensive. Only do them
    // if necessary.
    if (text.indexOf('e') > 0) {
        // Round to zero.
        if (text.match(/[eE][-]\d{2,}$/)) {
            return '0';
        }
    }
    const lastChar = text.charAt(text.length - 1);
    if (lastChar === '0' || lastChar === '.') {
        // Remove trailing zeroes
        text = text.replace(/([.]\d*[^0])0+$/, '$1');
        text = text.replace(/[.]0+$/, '.');
        // Remove trailing period
        text = text.replace(/[.]$/, '');
    }
    const firstChar = text.charAt(0);
    if (firstChar === '0' || firstChar === '-') {
        // Remove unnecessary leading zeroes.
        text = text.replace(/^(0+)[.]/, '.');
        text = text.replace(/^-(0+)[.]/, '-.');
        text = text.replace(/^(-?)0+$/, '$10');
    }
    if (text === '-0') {
        return '0';
    }
    return text;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cleanUpNumber);


/***/ }),

/***/ "./node_modules/@js-draw/math/dist/mjs/rounding/constants.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/mjs/rounding/constants.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   numberRegex: () => (/* binding */ numberRegex)
/* harmony export */ });
const numberRegex = /^([-]?)(\d*)[.](\d+)$/;


/***/ }),

/***/ "./node_modules/@js-draw/math/dist/mjs/rounding/getLenAfterDecimal.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/mjs/rounding/getLenAfterDecimal.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getLenAfterDecimal: () => (/* binding */ getLenAfterDecimal)
/* harmony export */ });
/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.mjs */ "./node_modules/@js-draw/math/dist/mjs/rounding/constants.mjs");

/**
 * Returns the length of `numberAsString` after a decimal point.
 *
 * For example,
 * ```ts
 * getLenAfterDecimal('1.001') // -> 3
 * ```
 */
const getLenAfterDecimal = (numberAsString) => {
    const numberMatch = _constants_mjs__WEBPACK_IMPORTED_MODULE_0__.numberRegex.exec(numberAsString);
    if (!numberMatch) {
        // If not a match, either the number is exponential notation (or is something
        // like NaN or Infinity)
        if (numberAsString.search(/[eE]/) !== -1 || /^[a-zA-Z]+$/.exec(numberAsString)) {
            return -1;
            // Or it has no decimal point
        }
        else {
            return 0;
        }
    }
    const afterDecimalLen = numberMatch[3].length;
    return afterDecimalLen;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getLenAfterDecimal);


/***/ }),

/***/ "./node_modules/@js-draw/math/dist/mjs/rounding/lib.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/mjs/rounding/lib.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   toRoundedString: () => (/* reexport safe */ _toRoundedString_mjs__WEBPACK_IMPORTED_MODULE_0__.toRoundedString)
/* harmony export */ });
/* harmony import */ var _toRoundedString_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toRoundedString.mjs */ "./node_modules/@js-draw/math/dist/mjs/rounding/toRoundedString.mjs");



/***/ }),

/***/ "./node_modules/@js-draw/math/dist/mjs/rounding/toRoundedString.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/mjs/rounding/toRoundedString.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   toRoundedString: () => (/* binding */ toRoundedString)
/* harmony export */ });
/* harmony import */ var _cleanUpNumber_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cleanUpNumber.mjs */ "./node_modules/@js-draw/math/dist/mjs/rounding/cleanUpNumber.mjs");

/**
 * Converts `num` to a string, removing trailing digits that were likely caused by
 * precision errors.
 *
 * @example
 * ```ts,runnable,console
 * import { toRoundedString } from '@js-draw/math';
 *
 * console.log('Rounded: ', toRoundedString(1.000000011));
 * ```
 */
const toRoundedString = (num) => {
    // Try to remove rounding errors. If the number ends in at least three/four zeroes
    // (or nines) just one or two digits, it's probably a rounding error.
    const fixRoundingUpExp = /^([-]?\d*\.\d{3,})0{4,}\d{1,4}$/;
    const hasRoundingDownExp = /^([-]?)(\d*)\.(\d{3,}9{4,})\d{1,4}$/;
    let text = num.toString(10);
    if (text.indexOf('.') === -1) {
        return text;
    }
    const roundingDownMatch = hasRoundingDownExp.exec(text);
    if (roundingDownMatch) {
        const negativeSign = roundingDownMatch[1];
        const postDecimalString = roundingDownMatch[3];
        const lastDigit = parseInt(postDecimalString.charAt(postDecimalString.length - 1), 10);
        const postDecimal = parseInt(postDecimalString, 10);
        const preDecimal = parseInt(roundingDownMatch[2], 10);
        const origPostDecimalString = roundingDownMatch[3];
        let newPostDecimal = (postDecimal + 10 - lastDigit).toString();
        let carry = 0;
        if (newPostDecimal.length > postDecimal.toString().length) {
            // Left-shift
            newPostDecimal = newPostDecimal.substring(1);
            carry = 1;
        }
        // parseInt(...).toString() removes leading zeroes. Add them back.
        while (newPostDecimal.length < origPostDecimalString.length) {
            newPostDecimal = carry.toString(10) + newPostDecimal;
            carry = 0;
        }
        text = `${negativeSign + (preDecimal + carry).toString()}.${newPostDecimal}`;
    }
    text = text.replace(fixRoundingUpExp, '$1');
    return (0,_cleanUpNumber_mjs__WEBPACK_IMPORTED_MODULE_0__["default"])(text);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toRoundedString);


/***/ }),

/***/ "./node_modules/@js-draw/math/dist/mjs/rounding/toStringOfSamePrecision.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/mjs/rounding/toStringOfSamePrecision.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   toStringOfSamePrecision: () => (/* binding */ toStringOfSamePrecision)
/* harmony export */ });
/* harmony import */ var _cleanUpNumber_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cleanUpNumber.mjs */ "./node_modules/@js-draw/math/dist/mjs/rounding/cleanUpNumber.mjs");
/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.mjs */ "./node_modules/@js-draw/math/dist/mjs/rounding/constants.mjs");
/* harmony import */ var _getLenAfterDecimal_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getLenAfterDecimal.mjs */ "./node_modules/@js-draw/math/dist/mjs/rounding/getLenAfterDecimal.mjs");
/* harmony import */ var _toRoundedString_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./toRoundedString.mjs */ "./node_modules/@js-draw/math/dist/mjs/rounding/toRoundedString.mjs");




// [reference] should be a string representation of a base-10 number (no exponential (e.g. 10e10))
const toStringOfSamePrecision = (num, ...references) => {
    const text = num.toString(10);
    const textMatch = _constants_mjs__WEBPACK_IMPORTED_MODULE_1__.numberRegex.exec(text);
    if (!textMatch) {
        return text;
    }
    let decimalPlaces = -1;
    for (const reference of references) {
        decimalPlaces = Math.max((0,_getLenAfterDecimal_mjs__WEBPACK_IMPORTED_MODULE_2__["default"])(reference), decimalPlaces);
    }
    if (decimalPlaces === -1) {
        return (0,_toRoundedString_mjs__WEBPACK_IMPORTED_MODULE_3__["default"])(num);
    }
    // Make text's after decimal length match [afterDecimalLen].
    let postDecimal = textMatch[3].substring(0, decimalPlaces);
    let preDecimal = textMatch[2];
    const nextDigit = textMatch[3].charAt(decimalPlaces);
    if (nextDigit !== '') {
        const asNumber = parseInt(nextDigit, 10);
        if (asNumber >= 5) {
            // Don't attempt to parseInt() an empty string.
            if (postDecimal.length > 0) {
                const leadingZeroMatch = /^(0+)(\d*)$/.exec(postDecimal);
                let leadingZeroes = '';
                let postLeading = postDecimal;
                if (leadingZeroMatch) {
                    leadingZeroes = leadingZeroMatch[1];
                    postLeading = leadingZeroMatch[2];
                }
                postDecimal = (parseInt(postDecimal) + 1).toString();
                // If postDecimal got longer, remove leading zeroes if possible
                if (postDecimal.length > postLeading.length && leadingZeroes.length > 0) {
                    leadingZeroes = leadingZeroes.substring(1);
                }
                postDecimal = leadingZeroes + postDecimal;
            }
            if (postDecimal.length === 0 || postDecimal.length > decimalPlaces) {
                preDecimal = (parseInt(preDecimal) + 1).toString();
                postDecimal = postDecimal.substring(1);
            }
        }
    }
    const negativeSign = textMatch[1];
    return (0,_cleanUpNumber_mjs__WEBPACK_IMPORTED_MODULE_0__["default"])(`${negativeSign}${preDecimal}.${postDecimal}`);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toStringOfSamePrecision);


/***/ }),

/***/ "./node_modules/@js-draw/math/dist/mjs/shapes/Abstract2DShape.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/mjs/shapes/Abstract2DShape.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Abstract2DShape: () => (/* binding */ Abstract2DShape),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * An abstract base class for 2D shapes.
 */
class Abstract2DShape {
    /**
     * @returns the distance from `point` to this shape. If `point` is within this shape,
     * this returns the distance from `point` to the edge of this shape.
     *
     * @see {@link signedDistance}
     */
    distance(point) {
        return Math.abs(this.signedDistance(point));
    }
    /**
     * Returns `true` if and only if the given `point` is contained within this shape.
     *
     * `epsilon` is a small number used to counteract floating point error. Thus, if
     * `point` is within `epsilon` of the inside of this shape, `containsPoint` may also
     * return `true`.
     *
     * The default implementation relies on `signedDistance`.
     * Subclasses may override this method to provide a more efficient implementation.
     */
    containsPoint(point, epsilon = Abstract2DShape.smallValue) {
        return this.signedDistance(point) < epsilon;
    }
    /**
     * Returns a bounding box that **loosely** fits the content of this shape.
     *
     * The result of this call can be larger than the result of {@link getTightBoundingBox},
     * **but should not be smaller**. Thus, a call to `getLooseBoundingBox` can be significantly
     * faster than a call to {@link getTightBoundingBox} for some shapes.
     */
    getLooseBoundingBox() {
        return this.getTightBoundingBox();
    }
}
// @internal
Abstract2DShape.smallValue = 1e-12;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Abstract2DShape);


/***/ }),

/***/ "./node_modules/@js-draw/math/dist/mjs/shapes/BezierJSWrapper.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/mjs/shapes/BezierJSWrapper.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BezierJSWrapper: () => (/* binding */ BezierJSWrapper),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var bezier_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bezier-js */ "./node_modules/bezier-js/src/bezier.js");
/* harmony import */ var _Vec2_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Vec2.mjs */ "./node_modules/@js-draw/math/dist/mjs/Vec2.mjs");
/* harmony import */ var _LineSegment2_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LineSegment2.mjs */ "./node_modules/@js-draw/math/dist/mjs/shapes/LineSegment2.mjs");
/* harmony import */ var _Rect2_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Rect2.mjs */ "./node_modules/@js-draw/math/dist/mjs/shapes/Rect2.mjs");
/* harmony import */ var _Parameterized2DShape_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Parameterized2DShape.mjs */ "./node_modules/@js-draw/math/dist/mjs/shapes/Parameterized2DShape.mjs");
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BezierJSWrapper_bezierJs;





/**
 * A lazy-initializing wrapper around Bezier-js.
 *
 * Subclasses may override `at`, `derivativeAt`, and `normal` with functions
 * that do not initialize a `bezier-js` `Bezier`.
 *
 * **Do not use this class directly.** It may be removed/replaced in a future release.
 * @internal
 */
class BezierJSWrapper extends _Parameterized2DShape_mjs__WEBPACK_IMPORTED_MODULE_4__["default"] {
    constructor(bezierJsBezier) {
        super();
        _BezierJSWrapper_bezierJs.set(this, null);
        if (bezierJsBezier) {
            __classPrivateFieldSet(this, _BezierJSWrapper_bezierJs, bezierJsBezier, "f");
        }
    }
    getBezier() {
        if (!__classPrivateFieldGet(this, _BezierJSWrapper_bezierJs, "f")) {
            __classPrivateFieldSet(this, _BezierJSWrapper_bezierJs, new bezier_js__WEBPACK_IMPORTED_MODULE_0__.Bezier(this.getPoints().map((p) => p.xy)), "f");
        }
        return __classPrivateFieldGet(this, _BezierJSWrapper_bezierJs, "f");
    }
    signedDistance(point) {
        // .d: Distance
        return this.nearestPointTo(point).point.distanceTo(point);
    }
    /**
     * @returns the (more) exact distance from `point` to this.
     *
     * @see {@link approximateDistance}
     */
    distance(point) {
        // A Bézier curve has no interior, thus, signed distance is the same as distance.
        return this.signedDistance(point);
    }
    /**
     * @returns the curve evaluated at `t`.
     */
    at(t) {
        return _Vec2_mjs__WEBPACK_IMPORTED_MODULE_1__.Vec2.ofXY(this.getBezier().get(t));
    }
    /** @returns the curve's directional derivative at `t`. */
    derivativeAt(t) {
        return _Vec2_mjs__WEBPACK_IMPORTED_MODULE_1__.Vec2.ofXY(this.getBezier().derivative(t));
    }
    secondDerivativeAt(t) {
        return _Vec2_mjs__WEBPACK_IMPORTED_MODULE_1__.Vec2.ofXY(this.getBezier().dderivative(t));
    }
    /** @returns the [normal vector](https://en.wikipedia.org/wiki/Normal_(geometry)) to this curve at `t`. */
    normal(t) {
        return _Vec2_mjs__WEBPACK_IMPORTED_MODULE_1__.Vec2.ofXY(this.getBezier().normal(t));
    }
    normalAt(t) {
        return this.normal(t);
    }
    tangentAt(t) {
        return this.derivativeAt(t).normalized();
    }
    getTightBoundingBox() {
        const bbox = this.getBezier().bbox();
        const width = bbox.x.max - bbox.x.min;
        const height = bbox.y.max - bbox.y.min;
        return new _Rect2_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](bbox.x.min, bbox.y.min, width, height);
    }
    argIntersectsLineSegment(line) {
        // Bezier-js has a bug when all control points of a Bezier curve lie on
        // a line. Our solution involves converting the Bezier into a line, then
        // finding the parameter value that produced the intersection.
        //
        // TODO: This is unnecessarily slow. A better solution would be to fix
        // the bug upstream.
        const asLine = _LineSegment2_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].ofSmallestContainingPoints(this.getPoints());
        if (asLine) {
            const intersection = asLine.intersectsLineSegment(line);
            return intersection.map((p) => this.nearestPointTo(p).parameterValue);
        }
        const bezier = this.getBezier();
        return bezier
            .intersects(line)
            .map((t) => {
            // We're using the .intersects(line) function, which is documented
            // to always return numbers. However, to satisfy the type checker (and
            // possibly improperly-defined types),
            if (typeof t === 'string') {
                t = parseFloat(t);
            }
            const point = _Vec2_mjs__WEBPACK_IMPORTED_MODULE_1__.Vec2.ofXY(this.at(t));
            // Ensure that the intersection is on the line segment
            if (point.distanceTo(line.p1) > line.length || point.distanceTo(line.p2) > line.length) {
                return null;
            }
            return t;
        })
            .filter((entry) => entry !== null);
    }
    splitAt(t) {
        if (t <= 0 || t >= 1) {
            return [this];
        }
        const bezier = this.getBezier();
        const split = bezier.split(t);
        return [
            new BezierJSWrapperImpl(split.left.points.map((point) => _Vec2_mjs__WEBPACK_IMPORTED_MODULE_1__.Vec2.ofXY(point)), split.left),
            new BezierJSWrapperImpl(split.right.points.map((point) => _Vec2_mjs__WEBPACK_IMPORTED_MODULE_1__.Vec2.ofXY(point)), split.right),
        ];
    }
    nearestPointTo(point) {
        // One implementation could be similar to this:
        //   const projection = this.getBezier().project(point);
        //   return {
        //    point: Vec2.ofXY(projection),
        //    parameterValue: projection.t!,
        //   };
        // However, Bezier-js is rather impercise (and relies on a lookup table).
        // Thus, we instead use Newton's Method:
        // We want to find t such that f(t) = |B(t) - p|² is minimized.
        // Expanding,
        //   f(t)  = (Bₓ(t) - pₓ)² + (Bᵧ(t) - pᵧ)²
        // ⇒ f'(t) = Dₜ(Bₓ(t) - pₓ)² + Dₜ(Bᵧ(t) - pᵧ)²
        // ⇒ f'(t) = 2(Bₓ(t) - pₓ)(Bₓ'(t)) + 2(Bᵧ(t) - pᵧ)(Bᵧ'(t))
        //         = 2Bₓ(t)Bₓ'(t) - 2pₓBₓ'(t) + 2Bᵧ(t)Bᵧ'(t) - 2pᵧBᵧ'(t)
        // ⇒ f''(t)= 2Bₓ'(t)Bₓ'(t) + 2Bₓ(t)Bₓ''(t) - 2pₓBₓ''(t) + 2Bᵧ'(t)Bᵧ'(t)
        //         + 2Bᵧ(t)Bᵧ''(t) - 2pᵧBᵧ''(t)
        // Because f'(t) = 0 at relative extrema, we can use Newton's Method
        // to improve on an initial guess.
        const sqrDistAt = (t) => point.squareDistanceTo(this.at(t));
        const yIntercept = sqrDistAt(0);
        let t = 0;
        let minSqrDist = yIntercept;
        // Start by testing a few points:
        const pointsToTest = 4;
        for (let i = 0; i < pointsToTest; i++) {
            const testT = i / (pointsToTest - 1);
            const testMinSqrDist = sqrDistAt(testT);
            if (testMinSqrDist < minSqrDist) {
                t = testT;
                minSqrDist = testMinSqrDist;
            }
        }
        // To use Newton's Method, we need to evaluate the second derivative of the distance
        // function:
        const secondDerivativeAt = (t) => {
            // f''(t) = 2Bₓ'(t)Bₓ'(t) + 2Bₓ(t)Bₓ''(t) - 2pₓBₓ''(t)
            //        + 2Bᵧ'(t)Bᵧ'(t) + 2Bᵧ(t)Bᵧ''(t) - 2pᵧBᵧ''(t)
            const b = this.at(t);
            const bPrime = this.derivativeAt(t);
            const bPrimePrime = this.secondDerivativeAt(t);
            return (2 * bPrime.x * bPrime.x +
                2 * b.x * bPrimePrime.x -
                2 * point.x * bPrimePrime.x +
                2 * bPrime.y * bPrime.y +
                2 * b.y * bPrimePrime.y -
                2 * point.y * bPrimePrime.y);
        };
        // Because we're zeroing f'(t), we also need to be able to compute it:
        const derivativeAt = (t) => {
            // f'(t) = 2Bₓ(t)Bₓ'(t) - 2pₓBₓ'(t) + 2Bᵧ(t)Bᵧ'(t) - 2pᵧBᵧ'(t)
            const b = this.at(t);
            const bPrime = this.derivativeAt(t);
            return (2 * b.x * bPrime.x - 2 * point.x * bPrime.x + 2 * b.y * bPrime.y - 2 * point.y * bPrime.y);
        };
        const iterate = () => {
            const slope = secondDerivativeAt(t);
            if (slope === 0)
                return;
            // We intersect a line through the point on f'(t) at t with the x-axis:
            //    y = m(x - x₀) + y₀
            // ⇒  x - x₀ = (y - y₀) / m
            // ⇒  x = (y - y₀) / m + x₀
            //
            // Thus, when zeroed,
            //   tN = (0 - f'(t)) / m + t
            const newT = (0 - derivativeAt(t)) / slope + t;
            //const distDiff = sqrDistAt(newT) - sqrDistAt(t);
            //console.assert(distDiff <= 0, `${-distDiff} >= 0`);
            t = newT;
            if (t > 1) {
                t = 1;
            }
            else if (t < 0) {
                t = 0;
            }
        };
        for (let i = 0; i < 12; i++) {
            iterate();
        }
        return { parameterValue: t, point: this.at(t) };
    }
    intersectsBezier(other) {
        const intersections = this.getBezier().intersects(other.getBezier());
        if (!intersections || intersections.length === 0) {
            return [];
        }
        const result = [];
        for (const intersection of intersections) {
            // From http://pomax.github.io/bezierjs/#intersect-curve,
            // .intersects returns an array of 't1/t2' pairs, where curve1.at(t1) gives the point.
            const match = /^([-0-9.eE]+)\/([-0-9.eE]+)$/.exec(intersection);
            if (!match) {
                throw new Error(`Incorrect format returned by .intersects: ${intersections} should be array of "number/number"!`);
            }
            const t = parseFloat(match[1]);
            result.push({
                parameterValue: t,
                point: this.at(t),
            });
        }
        return result;
    }
    toString() {
        return `Bézier(${this.getPoints()
            .map((point) => point.toString())
            .join(', ')})`;
    }
}
_BezierJSWrapper_bezierJs = new WeakMap();
/**
 * Private concrete implementation of `BezierJSWrapper`, used by methods above that need to return a wrapper
 * around a `Bezier`.
 */
class BezierJSWrapperImpl extends BezierJSWrapper {
    constructor(controlPoints, curve) {
        super(curve);
        this.controlPoints = controlPoints;
    }
    getPoints() {
        return this.controlPoints;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BezierJSWrapper);


/***/ }),

/***/ "./node_modules/@js-draw/math/dist/mjs/shapes/CubicBezier.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/mjs/shapes/CubicBezier.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _BezierJSWrapper_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BezierJSWrapper.mjs */ "./node_modules/@js-draw/math/dist/mjs/shapes/BezierJSWrapper.mjs");
/* harmony import */ var _Rect2_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Rect2.mjs */ "./node_modules/@js-draw/math/dist/mjs/shapes/Rect2.mjs");


/**
 * A wrapper around [`bezier-js`](https://github.com/Pomax/bezierjs)'s cubic Bezier.
 */
class CubicBezier extends _BezierJSWrapper_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(
    // Start point
    p0, 
    // Control point 1
    p1, 
    // Control point 2
    p2, 
    // End point
    p3) {
        super();
        this.p0 = p0;
        this.p1 = p1;
        this.p2 = p2;
        this.p3 = p3;
    }
    getPoints() {
        return [this.p0, this.p1, this.p2, this.p3];
    }
    /** Returns an overestimate of this shape's bounding box. */
    getLooseBoundingBox() {
        return _Rect2_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].bboxOf([this.p0, this.p1, this.p2, this.p3]);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CubicBezier);


/***/ }),

/***/ "./node_modules/@js-draw/math/dist/mjs/shapes/LineSegment2.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/mjs/shapes/LineSegment2.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LineSegment2: () => (/* binding */ LineSegment2),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Rect2_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Rect2.mjs */ "./node_modules/@js-draw/math/dist/mjs/shapes/Rect2.mjs");
/* harmony import */ var _Vec2_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Vec2.mjs */ "./node_modules/@js-draw/math/dist/mjs/Vec2.mjs");
/* harmony import */ var _Parameterized2DShape_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Parameterized2DShape.mjs */ "./node_modules/@js-draw/math/dist/mjs/shapes/Parameterized2DShape.mjs");



/**
 * Represents a line segment. A `LineSegment2` is immutable.
 *
 * @example
 * ```ts,runnable,console
 * import {LineSegment2, Vec2} from '@js-draw/math';
 * const l = new LineSegment2(Vec2.of(1, 1), Vec2.of(2, 2));
 * console.log('length: ', l.length);
 * console.log('direction: ', l.direction);
 * console.log('bounding box: ', l.bbox);
 * ```
 */
class LineSegment2 extends _Parameterized2DShape_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /** Creates a new `LineSegment2` from its endpoints. */
    constructor(point1, point2) {
        super();
        this.point1 = point1;
        this.point2 = point2;
        this.bbox = _Rect2_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].bboxOf([point1, point2]);
        this.direction = point2.minus(point1);
        this.length = this.direction.magnitude();
        // Normalize
        if (this.length > 0) {
            this.direction = this.direction.times(1 / this.length);
        }
    }
    /**
     * Returns the smallest line segment that contains all points in `points`, or `null`
     * if no such line segment exists.
     *
     * @example
     * ```ts,runnable,console
     * import {LineSegment2, Vec2} from '@js-draw/math';
     * console.log(LineSegment2.ofSmallestContainingPoints([Vec2.of(1, 0), Vec2.of(0, 1)]));
     * ```
     */
    static ofSmallestContainingPoints(points) {
        if (points.length <= 1)
            return null;
        const sorted = [...points].sort((a, b) => (a.x !== b.x ? a.x - b.x : a.y - b.y));
        const line = new LineSegment2(sorted[0], sorted[sorted.length - 1]);
        for (const point of sorted) {
            if (!line.containsPoint(point)) {
                return null;
            }
        }
        return line;
    }
    // Accessors to make LineSegment2 compatible with bezier-js's
    // interface
    /** Alias for `point1`. */
    get p1() {
        return this.point1;
    }
    /** Alias for `point2`. */
    get p2() {
        return this.point2;
    }
    get center() {
        return this.point1.lerp(this.point2, 0.5);
    }
    /**
     * Gets a point a **distance** `t` along this line.
     *
     * @deprecated
     */
    get(t) {
        return this.point1.plus(this.direction.times(t));
    }
    /**
     * Returns a point a fraction, `t`, along this line segment.
     * Thus, `segment.at(0)` returns `segment.p1` and `segment.at(1)` returns
     * `segment.p2`.
     *
     * `t` should be in `[0, 1]`.
     */
    at(t) {
        return this.get(t * this.length);
    }
    normalAt(_t) {
        return this.direction.orthog();
    }
    tangentAt(_t) {
        return this.direction;
    }
    splitAt(t) {
        if (t <= 0 || t >= 1) {
            return [this];
        }
        return [new LineSegment2(this.point1, this.at(t)), new LineSegment2(this.at(t), this.point2)];
    }
    /**
     * Returns the intersection of this with another line segment.
     *
     * **WARNING**: The parameter value returned by this method does not range from 0 to 1 and
     *              is currently a length.
     *              This will change in a future release.
     * @deprecated
     */
    intersection(other) {
        // TODO(v2.0.0): Make this return a `t` value from `0` to `1`.
        // We want x₁(t) = x₂(t) and y₁(t) = y₂(t)
        // Observe that
        // x = this.point1.x + this.direction.x · t₁
        //   = other.point1.x + other.direction.x · t₂
        // Thus,
        //  t₁ = (x - this.point1.x) / this.direction.x
        //     = (y - this.point1.y) / this.direction.y
        // and
        //  t₂ = (x - other.point1.x) / other.direction.x
        // (and similarly for y)
        //
        // Letting o₁ₓ = this.point1.x, o₂ₓ = other.point1.x,
        //         d₁ᵧ = this.direction.y, ...
        //
        // We can substitute these into the equations for y:
        // y = o₁ᵧ + d₁ᵧ · (x - o₁ₓ) / d₁ₓ
        //   = o₂ᵧ + d₂ᵧ · (x - o₂ₓ) / d₂ₓ
        // ⇒ o₁ᵧ - o₂ᵧ = d₂ᵧ · (x - o₂ₓ) / d₂ₓ - d₁ᵧ · (x - o₁ₓ) / d₁ₓ
        //            = (d₂ᵧ/d₂ₓ)(x) - (d₂ᵧ/d₂ₓ)(o₂ₓ) - (d₁ᵧ/d₁ₓ)(x) + (d₁ᵧ/d₁ₓ)(o₁ₓ)
        //            = (x)(d₂ᵧ/d₂ₓ - d₁ᵧ/d₁ₓ) - (d₂ᵧ/d₂ₓ)(o₂ₓ) + (d₁ᵧ/d₁ₓ)(o₁ₓ)
        // ⇒ (x)(d₂ᵧ/d₂ₓ - d₁ᵧ/d₁ₓ) = o₁ᵧ - o₂ᵧ + (d₂ᵧ/d₂ₓ)(o₂ₓ) - (d₁ᵧ/d₁ₓ)(o₁ₓ)
        // ⇒ x = (o₁ᵧ - o₂ᵧ + (d₂ᵧ/d₂ₓ)(o₂ₓ) - (d₁ᵧ/d₁ₓ)(o₁ₓ))/(d₂ᵧ/d₂ₓ - d₁ᵧ/d₁ₓ)
        //     = (d₁ₓd₂ₓ)(o₁ᵧ - o₂ᵧ + (d₂ᵧ/d₂ₓ)(o₂ₓ) - (d₁ᵧ/d₁ₓ)(o₁ₓ))/(d₂ᵧd₁ₓ - d₁ᵧd₂ₓ)
        //     = ((o₁ᵧ - o₂ᵧ)((d₁ₓd₂ₓ)) + (d₂ᵧd₁ₓ)(o₂ₓ) - (d₁ᵧd₂ₓ)(o₁ₓ))/(d₂ᵧd₁ₓ - d₁ᵧd₂ₓ)
        // ⇒ y = o₁ᵧ + d₁ᵧ · (x - o₁ₓ) / d₁ₓ = ...
        let resultPoint, resultT;
        // Consider very-near-vertical lines to be vertical --- not doing so can lead to
        // precision error when dividing by this.direction.x.
        const small = 4e-13;
        if (Math.abs(this.direction.x) < small) {
            // Vertical line: Where does the other have x = this.point1.x?
            // x = o₁ₓ = o₂ₓ + d₂ₓ · (y - o₂ᵧ) / d₂ᵧ
            // ⇒ (o₁ₓ - o₂ₓ)(d₂ᵧ/d₂ₓ) + o₂ᵧ = y
            // Avoid division by zero
            if (other.direction.x === 0 || this.direction.y === 0) {
                return null;
            }
            const xIntersect = this.point1.x;
            const yIntersect = ((this.point1.x - other.point1.x) * other.direction.y) / other.direction.x + other.point1.y;
            resultPoint = _Vec2_mjs__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(xIntersect, yIntersect);
            resultT = (yIntersect - this.point1.y) / this.direction.y;
        }
        else {
            // From above,
            // x = ((o₁ᵧ - o₂ᵧ)(d₁ₓd₂ₓ) + (d₂ᵧd₁ₓ)(o₂ₓ) - (d₁ᵧd₂ₓ)(o₁ₓ))/(d₂ᵧd₁ₓ - d₁ᵧd₂ₓ)
            const numerator = (this.point1.y - other.point1.y) * this.direction.x * other.direction.x +
                this.direction.x * other.direction.y * other.point1.x -
                this.direction.y * other.direction.x * this.point1.x;
            const denominator = other.direction.y * this.direction.x - this.direction.y * other.direction.x;
            // Avoid dividing by zero. It means there is no intersection
            if (denominator === 0) {
                return null;
            }
            const xIntersect = numerator / denominator;
            const t1 = (xIntersect - this.point1.x) / this.direction.x;
            const yIntersect = this.point1.y + this.direction.y * t1;
            resultPoint = _Vec2_mjs__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(xIntersect, yIntersect);
            resultT = (xIntersect - this.point1.x) / this.direction.x;
        }
        // Ensure the result is in this/the other segment.
        const resultToP1 = resultPoint.distanceTo(this.point1);
        const resultToP2 = resultPoint.distanceTo(this.point2);
        const resultToP3 = resultPoint.distanceTo(other.point1);
        const resultToP4 = resultPoint.distanceTo(other.point2);
        if (resultToP1 > this.length ||
            resultToP2 > this.length ||
            resultToP3 > other.length ||
            resultToP4 > other.length) {
            return null;
        }
        return {
            point: resultPoint,
            t: resultT,
        };
    }
    intersects(other) {
        return this.intersection(other) !== null;
    }
    argIntersectsLineSegment(lineSegment) {
        const intersection = this.intersection(lineSegment);
        if (intersection) {
            return [intersection.t / this.length];
        }
        return [];
    }
    /**
     * Returns the points at which this line segment intersects the
     * given line segment.
     *
     * Note that {@link intersects} returns *whether* this line segment intersects another
     * line segment. This method, by contrast, returns **the point** at which the intersection
     * occurs, if such a point exists.
     */
    intersectsLineSegment(lineSegment) {
        const intersection = this.intersection(lineSegment);
        if (intersection) {
            return [intersection.point];
        }
        return [];
    }
    // Returns the closest point on this to [target]
    closestPointTo(target) {
        return this.nearestPointTo(target).point;
    }
    nearestPointTo(target) {
        // Distance from P1 along this' direction.
        const projectedDistFromP1 = target.minus(this.p1).dot(this.direction);
        const projectedDistFromP2 = this.length - projectedDistFromP1;
        const projection = this.p1.plus(this.direction.times(projectedDistFromP1));
        if (projectedDistFromP1 > 0 && projectedDistFromP1 < this.length) {
            return { point: projection, parameterValue: projectedDistFromP1 / this.length };
        }
        if (Math.abs(projectedDistFromP2) < Math.abs(projectedDistFromP1)) {
            return { point: this.p2, parameterValue: 1 };
        }
        else {
            return { point: this.p1, parameterValue: 0 };
        }
    }
    /**
     * Returns the distance from this line segment to `target`.
     *
     * Because a line segment has no interior, this signed distance is equivalent to
     * the full distance between `target` and this line segment.
     */
    signedDistance(target) {
        return this.closestPointTo(target).minus(target).magnitude();
    }
    /** Returns a copy of this line segment transformed by the given `affineTransfm`. */
    transformedBy(affineTransfm) {
        return new LineSegment2(affineTransfm.transformVec2(this.p1), affineTransfm.transformVec2(this.p2));
    }
    /** @inheritdoc */
    getTightBoundingBox() {
        return this.bbox;
    }
    toString() {
        return `LineSegment(${this.p1.toString()}, ${this.p2.toString()})`;
    }
    /**
     * Returns `true` iff this is equivalent to `other`.
     *
     * **Options**:
     * - `tolerance`: The maximum difference between endpoints. (Default: 0)
     * - `ignoreDirection`: Allow matching a version of `this` with opposite direction. (Default: `true`)
     */
    eq(other, options) {
        if (!(other instanceof LineSegment2)) {
            return false;
        }
        const tolerance = options?.tolerance;
        const ignoreDirection = options?.ignoreDirection ?? true;
        return ((other.p1.eq(this.p1, tolerance) && other.p2.eq(this.p2, tolerance)) ||
            (ignoreDirection && other.p1.eq(this.p2, tolerance) && other.p2.eq(this.p1, tolerance)));
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LineSegment2);


/***/ }),

/***/ "./node_modules/@js-draw/math/dist/mjs/shapes/Parameterized2DShape.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/mjs/shapes/Parameterized2DShape.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Parameterized2DShape: () => (/* binding */ Parameterized2DShape),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Abstract2DShape_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Abstract2DShape.mjs */ "./node_modules/@js-draw/math/dist/mjs/shapes/Abstract2DShape.mjs");

/**
 * A 2-dimensional path with parameter interval $t \in [0, 1]$.
 *
 * **Note:** Avoid extending this class outside of `js-draw` --- new abstract methods
 * may be added between minor versions.
 */
class Parameterized2DShape extends _Abstract2DShape_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    intersectsLineSegment(line) {
        return this.argIntersectsLineSegment(line).map((t) => this.at(t));
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Parameterized2DShape);


/***/ }),

/***/ "./node_modules/@js-draw/math/dist/mjs/shapes/Path.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/mjs/shapes/Path.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Path: () => (/* binding */ Path),
/* harmony export */   PathCommandType: () => (/* binding */ PathCommandType),
/* harmony export */   compareCurveIndices: () => (/* binding */ compareCurveIndices),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   stepCurveIndexBy: () => (/* binding */ stepCurveIndexBy)
/* harmony export */ });
/* harmony import */ var _LineSegment2_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LineSegment2.mjs */ "./node_modules/@js-draw/math/dist/mjs/shapes/LineSegment2.mjs");
/* harmony import */ var _Rect2_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Rect2.mjs */ "./node_modules/@js-draw/math/dist/mjs/shapes/Rect2.mjs");
/* harmony import */ var _Vec2_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Vec2.mjs */ "./node_modules/@js-draw/math/dist/mjs/Vec2.mjs");
/* harmony import */ var _CubicBezier_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CubicBezier.mjs */ "./node_modules/@js-draw/math/dist/mjs/shapes/CubicBezier.mjs");
/* harmony import */ var _QuadraticBezier_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./QuadraticBezier.mjs */ "./node_modules/@js-draw/math/dist/mjs/shapes/QuadraticBezier.mjs");
/* harmony import */ var _PointShape2D_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./PointShape2D.mjs */ "./node_modules/@js-draw/math/dist/mjs/shapes/PointShape2D.mjs");
/* harmony import */ var _rounding_toRoundedString_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../rounding/toRoundedString.mjs */ "./node_modules/@js-draw/math/dist/mjs/rounding/toRoundedString.mjs");
/* harmony import */ var _rounding_toStringOfSamePrecision_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../rounding/toStringOfSamePrecision.mjs */ "./node_modules/@js-draw/math/dist/mjs/rounding/toStringOfSamePrecision.mjs");
/* harmony import */ var _utils_convexHull2Of_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/convexHull2Of.mjs */ "./node_modules/@js-draw/math/dist/mjs/utils/convexHull2Of.mjs");









/** Identifiers for different path commands. These commands can make up a {@link Path}. */
var PathCommandType;
(function (PathCommandType) {
    PathCommandType[PathCommandType["LineTo"] = 0] = "LineTo";
    PathCommandType[PathCommandType["MoveTo"] = 1] = "MoveTo";
    PathCommandType[PathCommandType["CubicBezierTo"] = 2] = "CubicBezierTo";
    PathCommandType[PathCommandType["QuadraticBezierTo"] = 3] = "QuadraticBezierTo";
})(PathCommandType || (PathCommandType = {}));
/** Returns a positive number if `a` comes after `b`, 0 if equal, and negative otherwise. */
const compareCurveIndices = (a, b) => {
    const indexCompare = a.curveIndex - b.curveIndex;
    if (indexCompare === 0) {
        return a.parameterValue - b.parameterValue;
    }
    else {
        return indexCompare;
    }
};
/**
 * Returns a version of `index` with its parameter value incremented by `stepBy`
 * (which can be either positive or negative).
 */
const stepCurveIndexBy = (index, stepBy) => {
    if (index.parameterValue + stepBy > 1) {
        return { curveIndex: index.curveIndex + 1, parameterValue: index.parameterValue + stepBy - 1 };
    }
    if (index.parameterValue + stepBy < 0) {
        if (index.curveIndex === 0) {
            return { curveIndex: 0, parameterValue: 0 };
        }
        return { curveIndex: index.curveIndex - 1, parameterValue: index.parameterValue + stepBy + 1 };
    }
    return { curveIndex: index.curveIndex, parameterValue: index.parameterValue + stepBy };
};
/**
 * Represents a union of lines and curves.
 *
 * To create a path from a string, see {@link fromString}.
 *
 * @example
 * ```ts,runnable,console
 * import {Path, Mat33, Vec2, LineSegment2} from '@js-draw/math';
 *
 * // Creates a path from an SVG path string.
 * // In this case,
 * // 1. Move to (0,0)
 * // 2. Line to (100,0)
 * const path = Path.fromString('M0,0 L100,0');
 *
 * // Logs the distance from (10,0) to the curve 1 unit
 * // away from path. This curve forms a stroke with the path at
 * // its center.
 * const strokeRadius = 1;
 * console.log(path.signedDistance(Vec2.of(10,0), strokeRadius));
 *
 * // Log a version of the path that's scaled by a factor of 4.
 * console.log(path.transformedBy(Mat33.scaling2D(4)).toString());
 *
 * // Log all intersections of a stroked version of the path with
 * // a vertical line segment.
 * // (Try removing the `strokeRadius` parameter).
 * const segment = new LineSegment2(Vec2.of(5, -100), Vec2.of(5, 100));
 * console.log(path.intersection(segment, strokeRadius).map(i => i.point));
 * ```
 */
class Path {
    /**
     * Creates a new `Path` that starts at `startPoint` and is made up of the path commands,
     * `parts`.
     *
     * See also {@link fromString}
     */
    constructor(startPoint, parts) {
        this.startPoint = startPoint;
        this.cachedGeometry = null;
        this.cachedPolylineApproximation = null;
        this.cachedStringVersion = null;
        this.parts = parts;
        // Initial bounding box contains one point: the start point.
        this.bbox = _Rect2_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].bboxOf([startPoint]);
        // Convert into a representation of the geometry (cache for faster intersection
        // calculation)
        for (const part of this.parts) {
            this.bbox = this.bbox.union(Path.computeBBoxForSegment(startPoint, part));
        }
    }
    /**
     * Computes and returns the full bounding box for this path.
     *
     * If a slight over-estimate of a path's bounding box is sufficient, use
     * {@link bbox} instead.
     */
    getExactBBox() {
        const bboxes = [];
        for (const part of this.geometry) {
            bboxes.push(part.getTightBoundingBox());
        }
        return _Rect2_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].union(...bboxes);
    }
    // Lazy-loads and returns this path's geometry
    get geometry() {
        if (this.cachedGeometry) {
            return this.cachedGeometry;
        }
        let startPoint = this.startPoint;
        const geometry = [];
        for (const part of this.parts) {
            let exhaustivenessCheck;
            switch (part.kind) {
                case PathCommandType.CubicBezierTo:
                    geometry.push(new _CubicBezier_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](startPoint, part.controlPoint1, part.controlPoint2, part.endPoint));
                    startPoint = part.endPoint;
                    break;
                case PathCommandType.QuadraticBezierTo:
                    geometry.push(new _QuadraticBezier_mjs__WEBPACK_IMPORTED_MODULE_4__["default"](startPoint, part.controlPoint, part.endPoint));
                    startPoint = part.endPoint;
                    break;
                case PathCommandType.LineTo:
                    geometry.push(new _LineSegment2_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](startPoint, part.point));
                    startPoint = part.point;
                    break;
                case PathCommandType.MoveTo:
                    geometry.push(new _PointShape2D_mjs__WEBPACK_IMPORTED_MODULE_5__["default"](part.point));
                    startPoint = part.point;
                    break;
                default:
                    exhaustivenessCheck = part;
                    return exhaustivenessCheck;
            }
        }
        this.cachedGeometry = geometry;
        return this.cachedGeometry;
    }
    /**
     * Iterates through the start/end points of each component in this path.
     *
     * If a start point is equivalent to the end point of the previous segment,
     * the point is **not** emitted twice.
     */
    *startEndPoints() {
        yield this.startPoint;
        for (const part of this.parts) {
            let exhaustivenessCheck;
            switch (part.kind) {
                case PathCommandType.CubicBezierTo:
                    yield part.endPoint;
                    break;
                case PathCommandType.QuadraticBezierTo:
                    yield part.endPoint;
                    break;
                case PathCommandType.LineTo:
                    yield part.point;
                    break;
                case PathCommandType.MoveTo:
                    yield part.point;
                    break;
                default:
                    exhaustivenessCheck = part;
                    return exhaustivenessCheck;
            }
        }
    }
    // Approximates this path with a group of line segments.
    polylineApproximation() {
        if (this.cachedPolylineApproximation) {
            return this.cachedPolylineApproximation;
        }
        const points = [];
        for (const part of this.parts) {
            switch (part.kind) {
                case PathCommandType.CubicBezierTo:
                    points.push(part.controlPoint1, part.controlPoint2, part.endPoint);
                    break;
                case PathCommandType.QuadraticBezierTo:
                    points.push(part.controlPoint, part.endPoint);
                    break;
                case PathCommandType.MoveTo:
                case PathCommandType.LineTo:
                    points.push(part.point);
                    break;
            }
        }
        const result = [];
        let prevPoint = this.startPoint;
        for (const point of points) {
            result.push(new _LineSegment2_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](prevPoint, point));
            prevPoint = point;
        }
        return result;
    }
    static computeBBoxForSegment(startPoint, part) {
        const points = [startPoint];
        let exhaustivenessCheck;
        switch (part.kind) {
            case PathCommandType.MoveTo:
            case PathCommandType.LineTo:
                points.push(part.point);
                break;
            case PathCommandType.CubicBezierTo:
                points.push(part.controlPoint1, part.controlPoint2, part.endPoint);
                break;
            case PathCommandType.QuadraticBezierTo:
                points.push(part.controlPoint, part.endPoint);
                break;
            default:
                exhaustivenessCheck = part;
                return exhaustivenessCheck;
        }
        return _Rect2_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].bboxOf(points);
    }
    /**
     * Returns the signed distance between `point` and a curve `strokeRadius` units
     * away from this path.
     *
     * This returns the **signed distance**, which means that points inside this shape
     * have their distance negated. For example,
     * ```ts,runnable,console
     * import {Path, Vec2} from '@js-draw/math';
     * console.log(Path.fromString('m0,0 L100,0').signedDistance(Vec2.zero, 1));
     * ```
     * would print `-1` because (0,0) is on `m0,0 L100,0` and thus one unit away from its boundary.
     *
     * **Note**: `strokeRadius = strokeWidth / 2`
     */
    signedDistance(point, strokeRadius) {
        let minDist = Infinity;
        for (const part of this.geometry) {
            const currentDist = part.signedDistance(point) - strokeRadius;
            if (currentDist < minDist) {
                minDist = currentDist;
            }
        }
        return minDist;
    }
    /**
     * Let `S` be a closed path a distance `strokeRadius` from this path.
     *
     * @returns Approximate intersections of `line` with `S` using ray marching, starting from
     * 	        both end points of `line` and each point in `additionalRaymarchStartPoints`.
     */
    raymarchIntersectionWith(line, strokeRadius, additionalRaymarchStartPoints = []) {
        // No intersection between bounding boxes: No possible intersection
        // of the interior.
        if (!line.bbox.intersects(this.bbox.grownBy(strokeRadius))) {
            return [];
        }
        const lineLength = line.length;
        const partDistFunctionRecords = [];
        // Determine distance functions for all parts that the given line could possibly intersect with
        for (const part of this.geometry) {
            const bbox = part.getTightBoundingBox().grownBy(strokeRadius);
            if (!bbox.intersects(line.bbox)) {
                continue;
            }
            // Signed distance function
            const partDist = (point) => part.signedDistance(point);
            // Part signed distance function (negative result implies `point` is
            // inside the shape).
            const partSdf = (point) => partDist(point) - strokeRadius;
            // If the line can't possibly intersect the part,
            if (partSdf(line.p1) > lineLength && partSdf(line.p2) > lineLength) {
                continue;
            }
            partDistFunctionRecords.push({
                part,
                distFn: partDist,
                bbox,
            });
        }
        // If no distance functions, there are no intersections.
        if (partDistFunctionRecords.length === 0) {
            return [];
        }
        // Returns the minimum distance to a part in this stroke, where only parts that the given
        // line could intersect are considered.
        const sdf = (point) => {
            let minDist = Infinity;
            let minDistPart = null;
            const uncheckedDistFunctions = [];
            // First pass: only curves for which the current point is inside
            // the bounding box.
            for (const distFnRecord of partDistFunctionRecords) {
                const { part, distFn, bbox } = distFnRecord;
                // Check later if the current point isn't in the bounding box.
                if (!bbox.containsPoint(point)) {
                    uncheckedDistFunctions.push(distFnRecord);
                    continue;
                }
                const currentDist = distFn(point);
                if (currentDist <= minDist) {
                    minDist = currentDist;
                    minDistPart = part;
                }
            }
            // Second pass: Everything else
            for (const { part, distFn, bbox } of uncheckedDistFunctions) {
                // Skip if impossible for the distance to the target to be lesser than
                // the current minimum.
                if (isFinite(minDist) && !bbox.grownBy(minDist).containsPoint(point)) {
                    continue;
                }
                const currentDist = distFn(point);
                if (currentDist <= minDist) {
                    minDist = currentDist;
                    minDistPart = part;
                }
            }
            return [minDistPart, minDist - strokeRadius];
        };
        // Raymarch:
        const maxRaymarchSteps = 8;
        // Start raymarching from each of these points. This allows detection of multiple
        // intersections.
        const startPoints = [line.p1, ...additionalRaymarchStartPoints, line.p2];
        // Converts a point ON THE LINE to a parameter
        const pointToParameter = (point) => {
            // Because line.direction is a unit vector, this computes the length
            // of the projection of the vector(line.p1->point) onto line.direction.
            //
            // Note that this can be negative if the given point is outside of the given
            // line segment.
            return point.minus(line.p1).dot(line.direction);
        };
        // Sort start points by parameter on the line.
        // This allows us to determine whether the current value of a parameter
        // drops down to a value already tested.
        startPoints.sort((a, b) => {
            const t_a = pointToParameter(a);
            const t_b = pointToParameter(b);
            // Sort in increasing order
            return t_a - t_b;
        });
        const result = [];
        const stoppingThreshold = strokeRadius / 1000;
        // Returns the maximum parameter value explored
        const raymarchFrom = (startPoint, 
        // Direction to march in (multiplies line.direction)
        directionMultiplier, 
        // Terminate if the current point corresponds to a parameter
        // below this.
        minimumLineParameter) => {
            let currentPoint = startPoint;
            let [lastPart, lastDist] = sdf(currentPoint);
            let lastParameter = pointToParameter(currentPoint);
            if (lastDist > lineLength) {
                return lastParameter;
            }
            const direction = line.direction.times(directionMultiplier);
            for (let i = 0; i < maxRaymarchSteps; i++) {
                // Step in the direction of the edge of the shape.
                const step = lastDist;
                currentPoint = currentPoint.plus(direction.times(step));
                lastParameter = pointToParameter(currentPoint);
                // If we're below the minimum parameter, stop. We've already tried
                // this.
                if (lastParameter <= minimumLineParameter) {
                    return lastParameter;
                }
                const [currentPart, signedDist] = sdf(currentPoint);
                // Ensure we're stepping in the correct direction.
                // Note that because we could start with a negative distance and work towards a
                // positive distance, we need absolute values here.
                if (Math.abs(signedDist) > Math.abs(lastDist)) {
                    // If not, stop.
                    return null;
                }
                lastDist = signedDist;
                lastPart = currentPart;
                // Is the distance close enough that we can stop early?
                if (Math.abs(lastDist) < stoppingThreshold) {
                    break;
                }
            }
            // Ensure that the point we ended with is on the line.
            const isOnLineSegment = lastParameter >= 0 && lastParameter <= lineLength;
            if (lastPart && isOnLineSegment && Math.abs(lastDist) < stoppingThreshold) {
                result.push({
                    point: currentPoint,
                    parameterValue: lastPart.nearestPointTo(currentPoint).parameterValue,
                    curve: lastPart,
                    curveIndex: this.geometry.indexOf(lastPart),
                });
                // Slightly increase the parameter value to prevent the same point from being
                // added to the results twice.
                const parameterIncrease = strokeRadius / 20 / line.length;
                lastParameter += isFinite(parameterIncrease) ? parameterIncrease : 0;
            }
            return lastParameter;
        };
        // The maximum value of the line's parameter explored so far (0 corresponds to
        // line.p1)
        let maxLineT = 0;
        // Raymarch for each start point.
        //
        // Use a for (i from 0 to length) loop because startPoints may be added
        // during iteration.
        for (let i = 0; i < startPoints.length; i++) {
            const startPoint = startPoints[i];
            // Try raymarching in both directions.
            maxLineT = Math.max(maxLineT, raymarchFrom(startPoint, 1, maxLineT) ?? maxLineT);
            maxLineT = Math.max(maxLineT, raymarchFrom(startPoint, -1, maxLineT) ?? maxLineT);
        }
        return result;
    }
    /**
     * Returns a list of intersections with this path. If `strokeRadius` is given,
     * intersections are approximated with the surface `strokeRadius` away from this.
     *
     * If `strokeRadius > 0`, the resultant `parameterValue` has no defined value.
     *
     * **Note**: `strokeRadius` is half of a stroke's width.
     */
    intersection(line, strokeRadius) {
        let result = [];
        // Is any intersection between shapes within the bounding boxes impossible?
        if (!line.bbox.intersects(this.bbox.grownBy(strokeRadius ?? 0))) {
            return [];
        }
        if (this.parts.length === 0) {
            return new Path(this.startPoint, [
                { kind: PathCommandType.MoveTo, point: this.startPoint },
            ]).intersection(line, strokeRadius);
        }
        let index = 0;
        for (const part of this.geometry) {
            const intersections = part.argIntersectsLineSegment(line);
            for (const intersection of intersections) {
                result.push({
                    curve: part,
                    curveIndex: index,
                    point: part.at(intersection),
                    parameterValue: intersection,
                });
            }
            index++;
        }
        // If given a non-zero strokeWidth, attempt to raymarch.
        // Even if raymarching, we need to collect starting points.
        // We use the above-calculated intersections for this.
        const doRaymarching = strokeRadius && strokeRadius > 1e-8;
        if (doRaymarching) {
            // Starting points for raymarching (in addition to the end points of the line).
            const startPoints = result.map((intersection) => intersection.point);
            result = this.raymarchIntersectionWith(line, strokeRadius, startPoints);
        }
        return result;
    }
    /**
     * @returns the nearest point on this path to the given `point`.
     */
    nearestPointTo(point) {
        // Find the closest point on this
        let closestSquareDist = Infinity;
        let closestPartIndex = 0;
        let closestParameterValue = 0;
        let closestPoint = this.startPoint;
        for (let i = 0; i < this.geometry.length; i++) {
            const current = this.geometry[i];
            const nearestPoint = current.nearestPointTo(point);
            const sqareDist = nearestPoint.point.squareDistanceTo(point);
            if (i === 0 || sqareDist < closestSquareDist) {
                closestPartIndex = i;
                closestSquareDist = sqareDist;
                closestParameterValue = nearestPoint.parameterValue;
                closestPoint = nearestPoint.point;
            }
        }
        return {
            curve: this.geometry[closestPartIndex],
            curveIndex: closestPartIndex,
            parameterValue: closestParameterValue,
            point: closestPoint,
        };
    }
    at(index) {
        if (index.curveIndex === 0 && index.parameterValue === 0) {
            return this.startPoint;
        }
        return this.geometry[index.curveIndex].at(index.parameterValue);
    }
    tangentAt(index) {
        return this.geometry[index.curveIndex].tangentAt(index.parameterValue);
    }
    /** Splits this path in two near the given `point`. */
    splitNear(point, options) {
        const nearest = this.nearestPointTo(point);
        return this.splitAt(nearest, options);
    }
    /**
     * Returns a copy of this path with `deleteFrom` until `deleteUntil` replaced with `insert`.
     *
     * This method is analogous to {@link Array.toSpliced}.
     */
    spliced(deleteFrom, deleteTo, insert, options) {
        const isBeforeOrEqual = (a, b) => {
            return (a.curveIndex < b.curveIndex ||
                (a.curveIndex === b.curveIndex && a.parameterValue <= b.parameterValue));
        };
        if (isBeforeOrEqual(deleteFrom, deleteTo)) {
            //          deleteFrom        deleteTo
            //      <---------|             |-------------->
            //      x                                      x
            //  startPoint                             endPoint
            const firstSplit = this.splitAt(deleteFrom, options);
            const secondSplit = this.splitAt(deleteTo, options);
            const before = firstSplit[0];
            const after = secondSplit[secondSplit.length - 1];
            return insert ? before.union(insert).union(after) : before.union(after);
        }
        else {
            // In this case, we need to handle wrapping at the start/end.
            //          deleteTo        deleteFrom
            //      <---------|    keep     |-------------->
            //      x                                      x
            //  startPoint                             endPoint
            const splitAtFrom = this.splitAt([deleteFrom], options);
            const beforeFrom = splitAtFrom[0];
            // We need splitNear, rather than splitAt, because beforeFrom does not have
            // the same indexing as this.
            const splitAtTo = beforeFrom.splitNear(this.at(deleteTo), options);
            const betweenBoth = splitAtTo[splitAtTo.length - 1];
            return insert ? betweenBoth.union(insert) : betweenBoth;
        }
    }
    // @internal
    splitAt(splitAt, options) {
        if (!Array.isArray(splitAt)) {
            splitAt = [splitAt];
        }
        splitAt = [...splitAt];
        splitAt.sort(compareCurveIndices);
        //
        // Bounds checking & reversal.
        //
        while (splitAt.length > 0 &&
            splitAt[splitAt.length - 1].curveIndex >= this.parts.length - 1 &&
            splitAt[splitAt.length - 1].parameterValue >= 1) {
            splitAt.pop();
        }
        splitAt.reverse(); // .reverse() <-- We're `.pop`ing from the end
        while (splitAt.length > 0 &&
            splitAt[splitAt.length - 1].curveIndex <= 0 &&
            splitAt[splitAt.length - 1].parameterValue <= 0) {
            splitAt.pop();
        }
        if (splitAt.length === 0 || this.parts.length === 0) {
            return [this];
        }
        const expectedSplitCount = splitAt.length + 1;
        const mapNewPoint = options?.mapNewPoint ?? ((p) => p);
        const result = [];
        let currentStartPoint = this.startPoint;
        let currentPath = [];
        //
        // Splitting
        //
        let { curveIndex, parameterValue } = splitAt.pop();
        for (let i = 0; i < this.parts.length; i++) {
            if (i !== curveIndex) {
                currentPath.push(this.parts[i]);
            }
            else {
                let part = this.parts[i];
                let geom = this.geometry[i];
                while (i === curveIndex) {
                    let newPathStart;
                    const newPath = [];
                    switch (part.kind) {
                        case PathCommandType.MoveTo:
                            currentPath.push({
                                kind: part.kind,
                                point: part.point,
                            });
                            newPathStart = part.point;
                            break;
                        case PathCommandType.LineTo:
                            {
                                const split = geom.splitAt(parameterValue);
                                currentPath.push({
                                    kind: part.kind,
                                    point: mapNewPoint(split[0].p2),
                                });
                                newPathStart = split[0].p2;
                                if (split.length > 1) {
                                    console.assert(split.length === 2);
                                    newPath.push({
                                        kind: part.kind,
                                        // Don't map: For lines, the end point of the split is
                                        // the same as the end point of the original:
                                        point: split[1].p2,
                                    });
                                    geom = split[1];
                                }
                            }
                            break;
                        case PathCommandType.QuadraticBezierTo:
                        case PathCommandType.CubicBezierTo:
                            {
                                const split = geom.splitAt(parameterValue);
                                let isFirstPart = split.length === 2;
                                for (const segment of split) {
                                    geom = segment;
                                    const targetArray = isFirstPart ? currentPath : newPath;
                                    const controlPoints = segment.getPoints();
                                    if (part.kind === PathCommandType.CubicBezierTo) {
                                        targetArray.push({
                                            kind: part.kind,
                                            controlPoint1: mapNewPoint(controlPoints[1]),
                                            controlPoint2: mapNewPoint(controlPoints[2]),
                                            endPoint: mapNewPoint(controlPoints[3]),
                                        });
                                    }
                                    else {
                                        targetArray.push({
                                            kind: part.kind,
                                            controlPoint: mapNewPoint(controlPoints[1]),
                                            endPoint: mapNewPoint(controlPoints[2]),
                                        });
                                    }
                                    // We want the start of the new path to match the start of the
                                    // FIRST Bézier in the NEW path.
                                    if (!isFirstPart) {
                                        newPathStart = controlPoints[0];
                                    }
                                    isFirstPart = false;
                                }
                            }
                            break;
                        default: {
                            const exhaustivenessCheck = part;
                            return exhaustivenessCheck;
                        }
                    }
                    result.push(new Path(currentStartPoint, [...currentPath]));
                    currentStartPoint = mapNewPoint(newPathStart);
                    console.assert(!!currentStartPoint, 'should have a start point');
                    currentPath = newPath;
                    part = newPath[newPath.length - 1] ?? part;
                    const nextSplit = splitAt.pop();
                    if (!nextSplit) {
                        break;
                    }
                    else {
                        curveIndex = nextSplit.curveIndex;
                        if (i === curveIndex) {
                            const originalPoint = this.at(nextSplit);
                            parameterValue = geom.nearestPointTo(originalPoint).parameterValue;
                            currentPath = [];
                        }
                        else {
                            parameterValue = nextSplit.parameterValue;
                        }
                    }
                }
            }
        }
        result.push(new Path(currentStartPoint, currentPath));
        console.assert(result.length === expectedSplitCount, `should split into splitAt.length + 1 splits (was ${result.length}, expected ${expectedSplitCount})`);
        return result;
    }
    /**
     * Replaces all `MoveTo` commands with `LineTo` commands and connects the end point of this
     * path to the start point.
     */
    asClosed() {
        const newParts = [];
        let hasChanges = false;
        for (const part of this.parts) {
            if (part.kind === PathCommandType.MoveTo) {
                newParts.push({
                    kind: PathCommandType.LineTo,
                    point: part.point,
                });
                hasChanges = true;
            }
            else {
                newParts.push(part);
            }
        }
        if (!this.getEndPoint().eq(this.startPoint)) {
            newParts.push({
                kind: PathCommandType.LineTo,
                point: this.startPoint,
            });
            hasChanges = true;
        }
        if (!hasChanges) {
            return this;
        }
        const result = new Path(this.startPoint, newParts);
        console.assert(result.getEndPoint().eq(result.startPoint));
        return result;
    }
    static mapPathCommand(part, mapping) {
        switch (part.kind) {
            case PathCommandType.MoveTo:
            case PathCommandType.LineTo:
                return {
                    kind: part.kind,
                    point: mapping(part.point),
                };
                break;
            case PathCommandType.CubicBezierTo:
                return {
                    kind: part.kind,
                    controlPoint1: mapping(part.controlPoint1),
                    controlPoint2: mapping(part.controlPoint2),
                    endPoint: mapping(part.endPoint),
                };
                break;
            case PathCommandType.QuadraticBezierTo:
                return {
                    kind: part.kind,
                    controlPoint: mapping(part.controlPoint),
                    endPoint: mapping(part.endPoint),
                };
                break;
        }
        const exhaustivenessCheck = part;
        return exhaustivenessCheck;
    }
    mapPoints(mapping) {
        const startPoint = mapping(this.startPoint);
        const newParts = [];
        for (const part of this.parts) {
            newParts.push(Path.mapPathCommand(part, mapping));
        }
        return new Path(startPoint, newParts);
    }
    transformedBy(affineTransfm) {
        if (affineTransfm.isIdentity()) {
            return this;
        }
        return this.mapPoints((point) => affineTransfm.transformVec2(point));
    }
    /**
     * @internal
     */
    closedContainsPoint(point) {
        const bbox = this.getExactBBox();
        if (!bbox.containsPoint(point)) {
            return false;
        }
        const pointOutside = point.plus(_Vec2_mjs__WEBPACK_IMPORTED_MODULE_2__.Vec2.of(bbox.width, 0));
        const asClosed = this.asClosed();
        const lineToOutside = new _LineSegment2_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](point, pointOutside);
        return asClosed.intersection(lineToOutside).length % 2 === 1;
    }
    // Creates a new path by joining [other] to the end of this path
    union(other, 
    // allowReverse: true iff reversing other or this is permitted if it means
    //               no moveTo command is necessary when unioning the paths.
    options = { allowReverse: true }) {
        if (!other) {
            return this;
        }
        if (Array.isArray(other)) {
            return new Path(this.startPoint, [...this.parts, ...other]);
        }
        const thisEnd = this.getEndPoint();
        let newParts = [];
        if (thisEnd.eq(other.startPoint)) {
            newParts = this.parts.concat(other.parts);
        }
        else if (options.allowReverse && this.startPoint.eq(other.getEndPoint())) {
            return other.union(this, { allowReverse: false });
        }
        else if (options.allowReverse && this.startPoint.eq(other.startPoint)) {
            return this.union(other.reversed(), { allowReverse: false });
        }
        else {
            newParts = [
                ...this.parts,
                {
                    kind: PathCommandType.MoveTo,
                    point: other.startPoint,
                },
                ...other.parts,
            ];
        }
        return new Path(this.startPoint, newParts);
    }
    /**
     * @returns a version of this path with the direction reversed.
     *
     * Example:
     * ```ts,runnable,console
     * import {Path} from '@js-draw/math';
     * console.log(Path.fromString('m0,0l1,1').reversed()); // -> M1,1 L0,0
     * ```
     */
    reversed() {
        const newStart = this.getEndPoint();
        const newParts = [];
        let lastPoint = this.startPoint;
        for (const part of this.parts) {
            switch (part.kind) {
                case PathCommandType.LineTo:
                case PathCommandType.MoveTo:
                    newParts.push({
                        kind: part.kind,
                        point: lastPoint,
                    });
                    lastPoint = part.point;
                    break;
                case PathCommandType.CubicBezierTo:
                    newParts.push({
                        kind: part.kind,
                        controlPoint1: part.controlPoint2,
                        controlPoint2: part.controlPoint1,
                        endPoint: lastPoint,
                    });
                    lastPoint = part.endPoint;
                    break;
                case PathCommandType.QuadraticBezierTo:
                    newParts.push({
                        kind: part.kind,
                        controlPoint: part.controlPoint,
                        endPoint: lastPoint,
                    });
                    lastPoint = part.endPoint;
                    break;
                default: {
                    const exhaustivenessCheck = part;
                    return exhaustivenessCheck;
                }
            }
        }
        newParts.reverse();
        return new Path(newStart, newParts);
    }
    /** Computes and returns the end point of this path */
    getEndPoint() {
        if (this.parts.length === 0) {
            return this.startPoint;
        }
        const lastPart = this.parts[this.parts.length - 1];
        if (lastPart.kind === PathCommandType.QuadraticBezierTo ||
            lastPart.kind === PathCommandType.CubicBezierTo) {
            return lastPart.endPoint;
        }
        else {
            return lastPart.point;
        }
    }
    /**
     * Like {@link closedRoughlyIntersects} except takes stroke width into account.
     *
     * This is intended to be a very fast and rough approximation. Use {@link intersection}
     * and {@link signedDistance} for more accurate (but much slower) intersection calculations.
     *
     * **Note**: Unlike other methods, this accepts `strokeWidth` (and not `strokeRadius`).
     *
     * `strokeRadius` is half of `strokeWidth`.
     */
    roughlyIntersects(rect, strokeWidth = 0) {
        if (this.parts.length === 0) {
            return rect.containsPoint(this.startPoint);
        }
        const isClosed = this.startPoint.eq(this.getEndPoint());
        if (isClosed && strokeWidth === 0) {
            return this.closedRoughlyIntersects(rect);
        }
        if (rect.containsRect(this.bbox)) {
            return true;
        }
        // Does the rectangle intersect the bounding boxes of any of this' parts?
        let startPoint = this.startPoint;
        for (const part of this.parts) {
            const bbox = Path.computeBBoxForSegment(startPoint, part).grownBy(strokeWidth);
            if (part.kind === PathCommandType.LineTo || part.kind === PathCommandType.MoveTo) {
                startPoint = part.point;
            }
            else {
                startPoint = part.endPoint;
            }
            if (rect.intersects(bbox)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Treats this as a closed path and returns true if part of `rect` is *roughly* within
     * this path's interior.
     *
     * **Note**: Assumes that this is a closed, non-self-intersecting path.
     */
    closedRoughlyIntersects(rect) {
        if (rect.containsRect(this.bbox)) {
            return true;
        }
        // Choose a point outside of the path.
        const startPt = this.bbox.topLeft.minus(_Vec2_mjs__WEBPACK_IMPORTED_MODULE_2__.Vec2.of(1, 1));
        const testPts = rect.corners;
        const polygon = this.polylineApproximation();
        for (const point of testPts) {
            const testLine = new _LineSegment2_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](point, startPt);
            let intersectionCount = 0;
            for (const line of polygon) {
                if (line.intersects(testLine)) {
                    intersectionCount++;
                }
            }
            // Odd? The point is within the polygon!
            if (intersectionCount % 2 === 1) {
                return true;
            }
        }
        // Grow the rectangle for possible additional precision.
        const grownRect = rect.grownBy(Math.min(rect.size.x, rect.size.y));
        const edges = [];
        for (const subrect of grownRect.divideIntoGrid(4, 4)) {
            edges.push(...subrect.getEdges());
        }
        for (const edge of edges) {
            for (const line of polygon) {
                if (edge.intersects(line)) {
                    return true;
                }
            }
        }
        // Even? Probably no intersection.
        return false;
    }
    /** @returns true if all points on this are equivalent to the points on `other` */
    eq(other, tolerance) {
        if (other.parts.length !== this.parts.length) {
            return false;
        }
        for (let i = 0; i < this.parts.length; i++) {
            const part1 = this.parts[i];
            const part2 = other.parts[i];
            switch (part1.kind) {
                case PathCommandType.LineTo:
                case PathCommandType.MoveTo:
                    if (part1.kind !== part2.kind) {
                        return false;
                    }
                    else if (!part1.point.eq(part2.point, tolerance)) {
                        return false;
                    }
                    break;
                case PathCommandType.CubicBezierTo:
                    if (part1.kind !== part2.kind) {
                        return false;
                    }
                    else if (!part1.controlPoint1.eq(part2.controlPoint1, tolerance) ||
                        !part1.controlPoint2.eq(part2.controlPoint2, tolerance) ||
                        !part1.endPoint.eq(part2.endPoint, tolerance)) {
                        return false;
                    }
                    break;
                case PathCommandType.QuadraticBezierTo:
                    if (part1.kind !== part2.kind) {
                        return false;
                    }
                    else if (!part1.controlPoint.eq(part2.controlPoint, tolerance) ||
                        !part1.endPoint.eq(part2.endPoint, tolerance)) {
                        return false;
                    }
                    break;
                default: {
                    const exhaustivenessCheck = part1;
                    return exhaustivenessCheck;
                }
            }
        }
        return true;
    }
    /**
     * Returns a path that outlines `rect`.
     *
     * If `lineWidth` is given, the resultant path traces a `lineWidth` thick
     * border around `rect`. Otherwise, the resultant path is just the border
     * of `rect`.
     */
    static fromRect(rect, lineWidth = null) {
        const commands = [];
        let corners;
        let startPoint;
        if (lineWidth !== null) {
            // Vector from the top left corner or bottom right corner to the edge of the
            // stroked region.
            const cornerToEdge = _Vec2_mjs__WEBPACK_IMPORTED_MODULE_2__.Vec2.of(lineWidth, lineWidth).times(0.5);
            const innerRect = _Rect2_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].fromCorners(rect.topLeft.plus(cornerToEdge), rect.bottomRight.minus(cornerToEdge));
            const outerRect = _Rect2_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].fromCorners(rect.topLeft.minus(cornerToEdge), rect.bottomRight.plus(cornerToEdge));
            corners = [innerRect.corners[3], ...innerRect.corners, ...outerRect.corners.reverse()];
            startPoint = outerRect.corners[3];
        }
        else {
            corners = rect.corners.slice(1);
            startPoint = rect.corners[0];
        }
        for (const corner of corners) {
            commands.push({
                kind: PathCommandType.LineTo,
                point: corner,
            });
        }
        // Close the shape
        commands.push({
            kind: PathCommandType.LineTo,
            point: startPoint,
        });
        return new Path(startPoint, commands);
    }
    /**
     * Convert to an [SVG path representation](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths).
     *
     * If `useNonAbsCommands` is given, relative path commands (e.g. `l10,0`) are to be used instead of
     * absolute commands (e.g. `L10,0`).
     *
     * See also {@link fromString}.
     */
    toString(useNonAbsCommands, ignoreCache = false) {
        if (this.cachedStringVersion && !ignoreCache) {
            return this.cachedStringVersion;
        }
        if (useNonAbsCommands === undefined) {
            // Hueristic: Try to determine whether converting absolute to relative commands is worth it.
            useNonAbsCommands = Math.abs(this.bbox.topLeft.x) > 10 && Math.abs(this.bbox.topLeft.y) > 10;
        }
        const result = Path.toString(this.startPoint, this.parts, !useNonAbsCommands);
        this.cachedStringVersion = result;
        return result;
    }
    serialize() {
        return this.toString();
    }
    // @param onlyAbsCommands - True if we should avoid converting absolute coordinates to relative offsets -- such
    //   conversions can lead to smaller output strings, but also take time.
    static toString(startPoint, parts, onlyAbsCommands) {
        const result = [];
        let prevPoint;
        const addCommand = (command, ...points) => {
            const absoluteCommandParts = [];
            const relativeCommandParts = [];
            const makeAbsCommand = !prevPoint || onlyAbsCommands;
            const roundedPrevX = prevPoint ? (0,_rounding_toRoundedString_mjs__WEBPACK_IMPORTED_MODULE_6__["default"])(prevPoint.x) : '';
            const roundedPrevY = prevPoint ? (0,_rounding_toRoundedString_mjs__WEBPACK_IMPORTED_MODULE_6__["default"])(prevPoint.y) : '';
            for (const point of points) {
                const xComponent = (0,_rounding_toRoundedString_mjs__WEBPACK_IMPORTED_MODULE_6__["default"])(point.x);
                const yComponent = (0,_rounding_toRoundedString_mjs__WEBPACK_IMPORTED_MODULE_6__["default"])(point.y);
                // Relative commands are often shorter as strings than absolute commands.
                if (!makeAbsCommand) {
                    const xComponentRelative = (0,_rounding_toStringOfSamePrecision_mjs__WEBPACK_IMPORTED_MODULE_7__["default"])(point.x - prevPoint.x, xComponent, roundedPrevX, roundedPrevY);
                    const yComponentRelative = (0,_rounding_toStringOfSamePrecision_mjs__WEBPACK_IMPORTED_MODULE_7__["default"])(point.y - prevPoint.y, yComponent, roundedPrevX, roundedPrevY);
                    // No need for an additional separator if it starts with a '-'
                    if (yComponentRelative.charAt(0) === '-') {
                        relativeCommandParts.push(`${xComponentRelative}${yComponentRelative}`);
                    }
                    else {
                        relativeCommandParts.push(`${xComponentRelative},${yComponentRelative}`);
                    }
                }
                else {
                    absoluteCommandParts.push(`${xComponent},${yComponent}`);
                }
            }
            let commandString;
            if (makeAbsCommand) {
                commandString = `${command}${absoluteCommandParts.join(' ')}`;
            }
            else {
                commandString = `${command.toLowerCase()}${relativeCommandParts.join(' ')}`;
            }
            // Don't add no-ops.
            if (commandString === 'l0,0' || commandString === 'm0,0') {
                return;
            }
            result.push(commandString);
            if (points.length > 0) {
                prevPoint = points[points.length - 1];
            }
        };
        // Don't add two moveTos in a row (this can happen if
        // the start point corresponds to a moveTo _and_ the first command is
        // also a moveTo)
        if (parts[0]?.kind !== PathCommandType.MoveTo) {
            addCommand('M', startPoint);
        }
        let exhaustivenessCheck;
        for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            switch (part.kind) {
                case PathCommandType.MoveTo:
                    addCommand('M', part.point);
                    break;
                case PathCommandType.LineTo:
                    addCommand('L', part.point);
                    break;
                case PathCommandType.CubicBezierTo:
                    addCommand('C', part.controlPoint1, part.controlPoint2, part.endPoint);
                    break;
                case PathCommandType.QuadraticBezierTo:
                    addCommand('Q', part.controlPoint, part.endPoint);
                    break;
                default:
                    exhaustivenessCheck = part;
                    return exhaustivenessCheck;
            }
        }
        return result.join('');
    }
    /**
     * Create a `Path` from a subset of the SVG path specification.
     *
     * Currently, this does not support elliptical arcs or `s` and `t` command
     * shorthands. See https://github.com/personalizedrefrigerator/js-draw/pull/19.
     *
     * @example
     * ```ts,runnable,console
     * import { Path } from '@js-draw/math';
     *
     * const path = Path.fromString('m0,0l100,100');
     * console.log(path.toString(true)); // true: Prefer relative to absolute path commands
     * ```
     */
    static fromString(pathString) {
        // TODO: Support elliptical arcs, and the `s`, `t` command shorthands.
        //
        // See the MDN reference:
        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d
        // and
        // https://www.w3.org/TR/SVG2/paths.html
        // Remove linebreaks
        pathString = pathString.split('\n').join(' ');
        let lastPos = _Vec2_mjs__WEBPACK_IMPORTED_MODULE_2__.Vec2.zero;
        let firstPos = null;
        let startPos = null;
        let isFirstCommand = true;
        const commands = [];
        const moveTo = (point) => {
            // The first moveTo/lineTo is already handled by the [startPoint] parameter of the Path constructor.
            if (isFirstCommand) {
                isFirstCommand = false;
                return;
            }
            commands.push({
                kind: PathCommandType.MoveTo,
                point,
            });
        };
        const lineTo = (point) => {
            if (isFirstCommand) {
                isFirstCommand = false;
                return;
            }
            commands.push({
                kind: PathCommandType.LineTo,
                point,
            });
        };
        const cubicBezierTo = (cp1, cp2, end) => {
            commands.push({
                kind: PathCommandType.CubicBezierTo,
                controlPoint1: cp1,
                controlPoint2: cp2,
                endPoint: end,
            });
        };
        const quadraticBeierTo = (controlPoint, endPoint) => {
            commands.push({
                kind: PathCommandType.QuadraticBezierTo,
                controlPoint,
                endPoint,
            });
        };
        const commandArgCounts = {
            m: 1,
            l: 1,
            c: 3,
            q: 2,
            z: 0,
            h: 1,
            v: 1,
        };
        // Each command: Command character followed by anything that isn't a command character
        const commandExp = /([MZLHVCSQTA])\s*([^MZLHVCSQTA]*)/gi;
        let current;
        while ((current = commandExp.exec(pathString)) !== null) {
            const argParts = current[2]
                .trim()
                .split(/[^0-9Ee.-]/)
                .filter((part) => part.length > 0)
                .reduce((accumualtor, current) => {
                // As of 09/2022, iOS Safari doesn't support support lookbehind in regular
                // expressions. As such, we need an alternative.
                // Because '-' can be used as a path separator, unless preceeded by an 'e' (as in 1e-5),
                // we need special cases:
                current = current.replace(/([^eE])[-]/g, '$1 -');
                const parts = current.split(' -');
                if (parts[0] !== '') {
                    accumualtor.push(parts[0]);
                }
                accumualtor.push(...parts.slice(1).map((part) => `-${part}`));
                return accumualtor;
            }, []);
            let numericArgs = argParts.map((arg) => parseFloat(arg));
            let commandChar = current[1].toLowerCase();
            let uppercaseCommand = current[1] !== commandChar;
            // Convert commands that don't take points into commands that do.
            if (commandChar === 'v' || commandChar === 'h') {
                numericArgs = numericArgs.reduce((accumulator, current) => {
                    if (commandChar === 'v') {
                        return accumulator.concat(uppercaseCommand ? lastPos.x : 0, current);
                    }
                    else {
                        return accumulator.concat(current, uppercaseCommand ? lastPos.y : 0);
                    }
                }, []);
                commandChar = 'l';
            }
            else if (commandChar === 'z') {
                if (firstPos) {
                    numericArgs = [firstPos.x, firstPos.y];
                    firstPos = lastPos;
                }
                else {
                    continue;
                }
                // 'z' always acts like an uppercase lineTo(startPos)
                uppercaseCommand = true;
                commandChar = 'l';
            }
            const commandArgCount = commandArgCounts[commandChar] ?? 0;
            const allArgs = numericArgs
                .reduce((accumulator, current, index, parts) => {
                if (index % 2 !== 0) {
                    const currentAsFloat = current;
                    const prevAsFloat = parts[index - 1];
                    return accumulator.concat(_Vec2_mjs__WEBPACK_IMPORTED_MODULE_2__.Vec2.of(prevAsFloat, currentAsFloat));
                }
                else {
                    return accumulator;
                }
            }, [])
                .map((coordinate, index) => {
                // Lowercase commands are relative, uppercase commands use absolute
                // positioning
                let newPos;
                if (uppercaseCommand) {
                    newPos = coordinate;
                }
                else {
                    newPos = lastPos.plus(coordinate);
                }
                if ((index + 1) % commandArgCount === 0) {
                    lastPos = newPos;
                }
                return newPos;
            });
            if (allArgs.length % commandArgCount !== 0) {
                throw new Error([
                    `Incorrect number of arguments: got ${JSON.stringify(allArgs)} with a length of ${allArgs.length} ≠ ${commandArgCount}k, k ∈ ℤ.`,
                    `The number of arguments to ${commandChar} must be a multiple of ${commandArgCount}!`,
                    `Command: ${current[0]}`,
                ].join('\n'));
            }
            for (let argPos = 0; argPos < allArgs.length; argPos += commandArgCount) {
                const args = allArgs.slice(argPos, argPos + commandArgCount);
                switch (commandChar.toLowerCase()) {
                    case 'm':
                        if (argPos === 0) {
                            moveTo(args[0]);
                        }
                        else {
                            lineTo(args[0]);
                        }
                        break;
                    case 'l':
                        lineTo(args[0]);
                        break;
                    case 'c':
                        cubicBezierTo(args[0], args[1], args[2]);
                        break;
                    case 'q':
                        quadraticBeierTo(args[0], args[1]);
                        break;
                    default:
                        throw new Error(`Unknown path command ${commandChar}`);
                }
                isFirstCommand = false;
            }
            if (allArgs.length > 0) {
                firstPos ??= allArgs[0];
                startPos ??= firstPos;
                lastPos = allArgs[allArgs.length - 1];
            }
        }
        const result = new Path(startPos ?? _Vec2_mjs__WEBPACK_IMPORTED_MODULE_2__.Vec2.zero, commands);
        result.cachedStringVersion = pathString;
        return result;
    }
    static fromConvexHullOf(points) {
        if (points.length === 0) {
            return Path.empty;
        }
        const hull = (0,_utils_convexHull2Of_mjs__WEBPACK_IMPORTED_MODULE_8__["default"])(points);
        const commands = hull.slice(1).map((p) => ({
            kind: PathCommandType.LineTo,
            point: p,
        }));
        // Close -- connect back to the start
        commands.push({
            kind: PathCommandType.LineTo,
            point: hull[0],
        });
        return new Path(hull[0], commands);
    }
}
// @internal TODO: At present, this isn't really an empty path.
Path.empty = new Path(_Vec2_mjs__WEBPACK_IMPORTED_MODULE_2__.Vec2.zero, []);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Path);


/***/ }),

/***/ "./node_modules/@js-draw/math/dist/mjs/shapes/PointShape2D.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/mjs/shapes/PointShape2D.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Vec2_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Vec2.mjs */ "./node_modules/@js-draw/math/dist/mjs/Vec2.mjs");
/* harmony import */ var _Parameterized2DShape_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Parameterized2DShape.mjs */ "./node_modules/@js-draw/math/dist/mjs/shapes/Parameterized2DShape.mjs");
/* harmony import */ var _Rect2_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Rect2.mjs */ "./node_modules/@js-draw/math/dist/mjs/shapes/Rect2.mjs");



/**
 * Like a {@link Point2}, but with additional functionality (e.g. SDF).
 *
 * Access the internal `Point2` using the `p` property.
 */
class PointShape2D extends _Parameterized2DShape_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(p) {
        super();
        this.p = p;
    }
    signedDistance(point) {
        return this.p.distanceTo(point);
    }
    argIntersectsLineSegment(lineSegment, epsilon) {
        if (lineSegment.containsPoint(this.p, epsilon)) {
            return [0];
        }
        return [];
    }
    getTightBoundingBox() {
        return new _Rect2_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](this.p.x, this.p.y, 0, 0);
    }
    at(_t) {
        return this.p;
    }
    /**
     * Returns an arbitrary unit-length vector.
     */
    normalAt(_t) {
        // Return a vector that makes sense.
        return _Vec2_mjs__WEBPACK_IMPORTED_MODULE_0__.Vec2.unitY;
    }
    tangentAt(_t) {
        return _Vec2_mjs__WEBPACK_IMPORTED_MODULE_0__.Vec2.unitX;
    }
    splitAt(_t) {
        return [this];
    }
    nearestPointTo(_point) {
        return {
            point: this.p,
            parameterValue: 0,
        };
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PointShape2D);


/***/ }),

/***/ "./node_modules/@js-draw/math/dist/mjs/shapes/QuadraticBezier.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/mjs/shapes/QuadraticBezier.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   QuadraticBezier: () => (/* binding */ QuadraticBezier),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Vec2_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Vec2.mjs */ "./node_modules/@js-draw/math/dist/mjs/Vec2.mjs");
/* harmony import */ var _polynomial_solveQuadratic_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../polynomial/solveQuadratic.mjs */ "./node_modules/@js-draw/math/dist/mjs/polynomial/solveQuadratic.mjs");
/* harmony import */ var _BezierJSWrapper_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BezierJSWrapper.mjs */ "./node_modules/@js-draw/math/dist/mjs/shapes/BezierJSWrapper.mjs");
/* harmony import */ var _Rect2_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Rect2.mjs */ "./node_modules/@js-draw/math/dist/mjs/shapes/Rect2.mjs");




/**
 * Represents a 2D [Bézier curve](https://en.wikipedia.org/wiki/B%C3%A9zier_curve).
 *
 * Example:
 * ```ts,runnable,console
 * import { QuadraticBezier, Vec2 } from '@js-draw/math';
 *
 * const startPoint = Vec2.of(4, 3);
 * const controlPoint = Vec2.of(1, 1);
 * const endPoint = Vec2.of(1, 3);
 *
 * const curve = new QuadraticBezier(
 *   startPoint,
 *   controlPoint,
 *   endPoint,
 * );
 *
 * console.log('Curve:', curve);
 * ```
 *
 * **Note**: Some Bézier operations internally use the `bezier-js` library.
 */
class QuadraticBezier extends _BezierJSWrapper_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(
    // Start point
    p0, 
    // Control point
    p1, 
    // End point
    p2) {
        super();
        this.p0 = p0;
        this.p1 = p1;
        this.p2 = p2;
    }
    /**
     * Returns a component of a quadratic Bézier curve at t, where p0,p1,p2 are either all x or
     * all y components of the target curve.
     */
    static componentAt(t, p0, p1, p2) {
        return p0 + t * (-2 * p0 + 2 * p1) + t * t * (p0 - 2 * p1 + p2);
    }
    static derivativeComponentAt(t, p0, p1, p2) {
        return -2 * p0 + 2 * p1 + 2 * t * (p0 - 2 * p1 + p2);
    }
    static secondDerivativeComponentAt(t, p0, p1, p2) {
        return 2 * (p0 - 2 * p1 + p2);
    }
    /**
     * @returns the curve evaluated at `t`.
     *
     * `t` should be a number in `[0, 1]`.
     */
    at(t) {
        if (t === 0)
            return this.p0;
        if (t === 1)
            return this.p2;
        const p0 = this.p0;
        const p1 = this.p1;
        const p2 = this.p2;
        return _Vec2_mjs__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(QuadraticBezier.componentAt(t, p0.x, p1.x, p2.x), QuadraticBezier.componentAt(t, p0.y, p1.y, p2.y));
    }
    derivativeAt(t) {
        const p0 = this.p0;
        const p1 = this.p1;
        const p2 = this.p2;
        return _Vec2_mjs__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(QuadraticBezier.derivativeComponentAt(t, p0.x, p1.x, p2.x), QuadraticBezier.derivativeComponentAt(t, p0.y, p1.y, p2.y));
    }
    secondDerivativeAt(t) {
        const p0 = this.p0;
        const p1 = this.p1;
        const p2 = this.p2;
        return _Vec2_mjs__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(QuadraticBezier.secondDerivativeComponentAt(t, p0.x, p1.x, p2.x), QuadraticBezier.secondDerivativeComponentAt(t, p0.y, p1.y, p2.y));
    }
    normal(t) {
        const tangent = this.derivativeAt(t);
        return tangent.orthog().normalized();
    }
    /** @returns an overestimate of this shape's bounding box. */
    getLooseBoundingBox() {
        return _Rect2_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].bboxOf([this.p0, this.p1, this.p2]);
    }
    /**
     * @returns the *approximate* distance from `point` to this curve.
     */
    approximateDistance(point) {
        // We want to minimize f(t) = |B(t) - p|².
        // Expanding,
        //   f(t)  = (Bₓ(t) - pₓ)² + (Bᵧ(t) - pᵧ)²
        // ⇒ f'(t) = Dₜ(Bₓ(t) - pₓ)² + Dₜ(Bᵧ(t) - pᵧ)²
        //
        // Considering just one component,
        //  Dₜ(Bₓ(t) - pₓ)² = 2(Bₓ(t) - pₓ)(DₜBₓ(t))
        //                  = 2(Bₓ(t)DₜBₓ(t) - pₓBₓ(t))
        //   = 2(p0ₓ + (t)(-2p0ₓ + 2p1ₓ) + (t²)(p0ₓ - 2p1ₓ + p2ₓ) - pₓ)((-2p0ₓ + 2p1ₓ) + 2(t)(p0ₓ - 2p1ₓ + p2ₓ))
        //     - (pₓ)((-2p0ₓ + 2p1ₓ) + (t)(p0ₓ - 2p1ₓ + p2ₓ))
        const A = this.p0.x - point.x;
        const B = -2 * this.p0.x + 2 * this.p1.x;
        const C = this.p0.x - 2 * this.p1.x + this.p2.x;
        // Let A = p0ₓ - pₓ, B = -2p0ₓ + 2p1ₓ, C = p0ₓ - 2p1ₓ + p2ₓ. We then have,
        //  Dₜ(Bₓ(t) - pₓ)²
        //    = 2(A + tB + t²C)(B + 2tC) - (pₓ)(B + 2tC)
        //    = 2(AB + tB² + t²BC + 2tCA + 2tCtB + 2tCt²C) - pₓB - pₓ2tC
        //    = 2(AB + tB² + 2tCA + t²BC + 2t²CB + 2C²t³) - pₓB - pₓ2tC
        //    = 2AB + 2t(B² + 2CA) + 2t²(BC + 2CB) + 4C²t³ - pₓB - pₓ2tC
        //    = 2AB + 2t(B² + 2CA - pₓC) + 2t²(BC + 2CB) + 4C²t³ - pₓB
        //
        const D = this.p0.y - point.y;
        const E = -2 * this.p0.y + 2 * this.p1.y;
        const F = this.p0.y - 2 * this.p1.y + this.p2.y;
        // Using D = p0ᵧ - pᵧ, E = -2p0ᵧ + 2p1ᵧ, F = p0ᵧ - 2p1ᵧ + p2ᵧ, we thus have,
        //  f'(t) = 2AB + 2t(B² + 2CA - pₓC) + 2t²(BC + 2CB) + 4C²t³ - pₓB
        //        + 2DE + 2t(E² + 2FD - pᵧF) + 2t²(EF + 2FE) + 4F²t³ - pᵧE
        const a = 2 * A * B + 2 * D * E - point.x * B - point.y * E;
        const b = 2 * B * B + 2 * E * E + 2 * C * A + 2 * F * D - point.x * C - point.y * F;
        const c = 2 * E * F + 2 * B * C + 2 * C * B + 2 * F * E;
        //const d = 4 * C * C + 4 * F * F;
        // Thus,
        // f'(t) = a + bt + ct² + dt³
        const fDerivAtZero = a;
        const f2ndDerivAtZero = b;
        const f3rdDerivAtZero = 2 * c;
        // Using the first few terms of a Maclaurin series to approximate f'(t),
        // f'(t) ≈ f'(0) + t f''(0) + t² f'''(0) / 2
        let [min1, min2] = (0,_polynomial_solveQuadratic_mjs__WEBPACK_IMPORTED_MODULE_1__["default"])(f3rdDerivAtZero / 2, f2ndDerivAtZero, fDerivAtZero);
        // If the quadratic has no solutions, approximate.
        if (isNaN(min1)) {
            min1 = 0.25;
        }
        if (isNaN(min2)) {
            min2 = 0.75;
        }
        const at1 = this.at(min1);
        const at2 = this.at(min2);
        const sqrDist1 = at1.squareDistanceTo(point);
        const sqrDist2 = at2.squareDistanceTo(point);
        const sqrDist3 = this.at(0).squareDistanceTo(point);
        const sqrDist4 = this.at(1).squareDistanceTo(point);
        return Math.sqrt(Math.min(sqrDist1, sqrDist2, sqrDist3, sqrDist4));
    }
    getPoints() {
        return [this.p0, this.p1, this.p2];
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (QuadraticBezier);


/***/ }),

/***/ "./node_modules/@js-draw/math/dist/mjs/shapes/Rect2.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/mjs/shapes/Rect2.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Rect2: () => (/* binding */ Rect2),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _LineSegment2_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LineSegment2.mjs */ "./node_modules/@js-draw/math/dist/mjs/shapes/LineSegment2.mjs");
/* harmony import */ var _Mat33_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Mat33.mjs */ "./node_modules/@js-draw/math/dist/mjs/Mat33.mjs");
/* harmony import */ var _Vec2_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Vec2.mjs */ "./node_modules/@js-draw/math/dist/mjs/Vec2.mjs");
/* harmony import */ var _Abstract2DShape_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Abstract2DShape.mjs */ "./node_modules/@js-draw/math/dist/mjs/shapes/Abstract2DShape.mjs");




/**
 * Represents a rectangle in 2D space, parallel to the XY axes.
 *
 * **Example**:
 * ```ts,runnable,console
 * import { Rect2, Vec2 } from '@js-draw/math';
 *
 * const rect = Rect2.fromCorners(
 *   Vec2.of(0, 0),
 *   Vec2.of(10, 10),
 * );
 * console.log('area', rect.area);
 * console.log('topLeft', rect.topLeft);
 * ```
 *
 * `invariant: w ≥ 0, h ≥ 0, immutable`
 */
class Rect2 extends _Abstract2DShape_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(
    // Top left x coordinate
    x, 
    // Top left y coordinate
    y, 
    // Width
    w, 
    // Height
    h) {
        super();
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        if (w < 0) {
            this.x += w;
            this.w = Math.abs(w);
        }
        if (h < 0) {
            this.y += h;
            this.h = Math.abs(h);
        }
        // Precompute/store vector forms.
        this.topLeft = _Vec2_mjs__WEBPACK_IMPORTED_MODULE_2__.Vec2.of(this.x, this.y);
        this.size = _Vec2_mjs__WEBPACK_IMPORTED_MODULE_2__.Vec2.of(this.w, this.h);
        this.area = this.w * this.h;
    }
    translatedBy(vec) {
        return new Rect2(vec.x + this.x, vec.y + this.y, this.w, this.h);
    }
    // Returns a copy of this with the given size (but same top-left).
    resizedTo(size) {
        return new Rect2(this.x, this.y, size.x, size.y);
    }
    containsPoint(other) {
        return (this.x <= other.x &&
            this.y <= other.y &&
            this.x + this.w >= other.x &&
            this.y + this.h >= other.y);
    }
    /** @returns true iff `other` is completely within this `Rect2`. */
    containsRect(other) {
        return (this.x <= other.x &&
            this.y <= other.y &&
            this.x + this.w >= other.x + other.w &&
            this.y + this.h >= other.y + other.h);
    }
    /**
     * @returns true iff this and `other` overlap
     */
    intersects(other) {
        // Project along x/y axes.
        const thisMinX = this.x;
        const thisMaxX = thisMinX + this.w;
        const otherMinX = other.x;
        const otherMaxX = other.x + other.w;
        if (thisMaxX < otherMinX || thisMinX > otherMaxX) {
            return false;
        }
        const thisMinY = this.y;
        const thisMaxY = thisMinY + this.h;
        const otherMinY = other.y;
        const otherMaxY = other.y + other.h;
        if (thisMaxY < otherMinY || thisMinY > otherMaxY) {
            return false;
        }
        return true;
    }
    // Returns the overlap of this and [other], or null, if no such
    //          overlap exists
    intersection(other) {
        if (!this.intersects(other)) {
            return null;
        }
        const topLeft = this.topLeft.zip(other.topLeft, Math.max);
        const bottomRight = this.bottomRight.zip(other.bottomRight, Math.min);
        return Rect2.fromCorners(topLeft, bottomRight);
    }
    // Returns a new rectangle containing both [this] and [other].
    union(other) {
        return Rect2.union(this, other);
    }
    // Returns a the subdivision of this into [columns] columns
    // and [rows] rows. For example,
    //	 Rect2.unitSquare.divideIntoGrid(2, 2)
    //		-> [ Rect2(0, 0, 0.5, 0.5), Rect2(0.5, 0, 0.5, 0.5), Rect2(0, 0.5, 0.5, 0.5), Rect2(0.5, 0.5, 0.5, 0.5) ]
    // The rectangles are ordered in row-major order.
    divideIntoGrid(columns, rows) {
        const result = [];
        if (columns <= 0 || rows <= 0) {
            return result;
        }
        const eachRectWidth = this.w / columns;
        const eachRectHeight = this.h / rows;
        if (eachRectWidth === 0) {
            columns = 1;
        }
        if (eachRectHeight === 0) {
            rows = 1;
        }
        for (let j = 0; j < rows; j++) {
            for (let i = 0; i < columns; i++) {
                const x = eachRectWidth * i + this.x;
                const y = eachRectHeight * j + this.y;
                result.push(new Rect2(x, y, eachRectWidth, eachRectHeight));
            }
        }
        return result;
    }
    // Returns a rectangle containing this and [point].
    // [margin] is the minimum distance between the new point and the edge
    // of the resultant rectangle.
    grownToPoint(point, margin = 0) {
        const otherRect = new Rect2(point.x - margin, point.y - margin, margin * 2, margin * 2);
        return this.union(otherRect);
    }
    // Returns this grown by [margin] in both the x and y directions.
    grownBy(margin) {
        if (margin === 0) {
            return this;
        }
        // Prevent width/height from being negative
        if (margin < 0) {
            const xMargin = -Math.min(-margin, this.w / 2);
            const yMargin = -Math.min(-margin, this.h / 2);
            return new Rect2(this.x - xMargin, this.y - yMargin, this.w + xMargin * 2, this.h + yMargin * 2);
        }
        return new Rect2(this.x - margin, this.y - margin, this.w + margin * 2, this.h + margin * 2);
    }
    /**
     * If this rectangle is smaller than `minSize`, returns a copy of this
     * with a larger width/height.
     *
     * If smaller than `minSize`, padding is applied on both sides.
     */
    grownToSize(minSize) {
        if (this.width >= minSize.x && this.height >= minSize.y) {
            return this;
        }
        const deltaWidth = Math.max(0, minSize.x - this.width);
        const deltaHeight = Math.max(0, minSize.y - this.height);
        return new Rect2(this.x - deltaWidth / 2, this.y - deltaHeight / 2, this.width + deltaWidth, this.height + deltaHeight);
    }
    getClosestPointOnBoundaryTo(target) {
        const closestEdgePoints = this.getEdges().map((edge) => {
            return edge.closestPointTo(target);
        });
        let closest = null;
        let closestDist = null;
        for (const point of closestEdgePoints) {
            const dist = point.distanceTo(target);
            if (closestDist === null || dist < closestDist) {
                closest = point;
                closestDist = dist;
            }
        }
        return closest;
    }
    /**
     * Returns `true` iff all points in this rectangle are within `distance` from `point`:
     *
     * If $R$ is the set of points in this rectangle, returns `true` iff
     * $$
     * 	\forall {\bf a} \in R, \|\texttt{point} - {\bf a}\| < \texttt{radius}
     * $$
     */
    isWithinRadiusOf(radius, point) {
        if (this.maxDimension > radius) {
            return false;
        }
        const squareRadius = radius * radius;
        return this.corners.every((corner) => corner.minus(point).magnitudeSquared() < squareRadius);
    }
    get corners() {
        return [this.bottomRight, this.topRight, this.topLeft, this.bottomLeft];
    }
    get maxDimension() {
        return Math.max(this.w, this.h);
    }
    get minDimension() {
        return Math.min(this.w, this.h);
    }
    get bottomRight() {
        return this.topLeft.plus(this.size);
    }
    get topRight() {
        return this.bottomRight.plus(_Vec2_mjs__WEBPACK_IMPORTED_MODULE_2__.Vec2.of(0, -this.h));
    }
    get bottomLeft() {
        return this.topLeft.plus(_Vec2_mjs__WEBPACK_IMPORTED_MODULE_2__.Vec2.of(0, this.h));
    }
    get width() {
        return this.w;
    }
    get height() {
        return this.h;
    }
    get center() {
        return _Vec2_mjs__WEBPACK_IMPORTED_MODULE_2__.Vec2.of(this.x + this.w / 2, this.y + this.h / 2);
    }
    // Returns edges in the order
    // [ rightEdge, topEdge, leftEdge, bottomEdge ]
    getEdges() {
        const corners = this.corners;
        return [
            new _LineSegment2_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](corners[0], corners[1]),
            new _LineSegment2_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](corners[1], corners[2]),
            new _LineSegment2_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](corners[2], corners[3]),
            new _LineSegment2_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](corners[3], corners[0]),
        ];
    }
    intersectsLineSegment(lineSegment) {
        const result = [];
        for (const edge of this.getEdges()) {
            const intersection = edge.intersectsLineSegment(lineSegment);
            intersection.forEach((point) => result.push(point));
        }
        return result;
    }
    signedDistance(point) {
        const closestBoundaryPoint = this.getClosestPointOnBoundaryTo(point);
        const dist = point.minus(closestBoundaryPoint).magnitude();
        if (this.containsPoint(point)) {
            return -dist;
        }
        return dist;
    }
    getTightBoundingBox() {
        return this;
    }
    // [affineTransform] is a transformation matrix that both scales and **translates**.
    // the bounding box of this' four corners after transformed by the given affine transformation.
    transformedBoundingBox(affineTransform) {
        // Optimize transforming by the identity matrix (a common case).
        if (affineTransform === _Mat33_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].identity) {
            return this;
        }
        return Rect2.bboxOf(this.corners.map((corner) => affineTransform.transformVec2(corner)));
    }
    /** @return true iff this is equal to `other ± tolerance` */
    eq(other, tolerance = 0) {
        return this.topLeft.eq(other.topLeft, tolerance) && this.size.eq(other.size, tolerance);
    }
    toString() {
        return `Rect(point(${this.x}, ${this.y}), size(${this.w}, ${this.h}))`;
    }
    static fromCorners(corner1, corner2) {
        return new Rect2(Math.min(corner1.x, corner2.x), Math.min(corner1.y, corner2.y), Math.abs(corner1.x - corner2.x), Math.abs(corner1.y - corner2.y));
    }
    // Returns a box that contains all points in [points] with at least [margin]
    // between each point and the edge of the box.
    static bboxOf(points, margin = 0) {
        let minX = 0;
        let minY = 0;
        let maxX = 0;
        let maxY = 0;
        let isFirst = true;
        for (const point of points) {
            if (isFirst) {
                minX = point.x;
                minY = point.y;
                maxX = point.x;
                maxY = point.y;
                isFirst = false;
            }
            minX = Math.min(minX, point.x);
            minY = Math.min(minY, point.y);
            maxX = Math.max(maxX, point.x);
            maxY = Math.max(maxY, point.y);
        }
        return Rect2.fromCorners(_Vec2_mjs__WEBPACK_IMPORTED_MODULE_2__.Vec2.of(minX - margin, minY - margin), _Vec2_mjs__WEBPACK_IMPORTED_MODULE_2__.Vec2.of(maxX + margin, maxY + margin));
    }
    // @returns a rectangle that contains all of the given rectangles, the bounding box
    //     of the given rectangles.
    static union(...rects) {
        if (rects.length === 0) {
            return Rect2.empty;
        }
        const firstRect = rects[0];
        let minX = firstRect.x;
        let minY = firstRect.y;
        let maxX = firstRect.x + firstRect.w;
        let maxY = firstRect.y + firstRect.h;
        for (let i = 1; i < rects.length; i++) {
            const rect = rects[i];
            minX = Math.min(minX, rect.x);
            minY = Math.min(minY, rect.y);
            maxX = Math.max(maxX, rect.x + rect.w);
            maxY = Math.max(maxY, rect.y + rect.h);
        }
        return new Rect2(minX, minY, maxX - minX, maxY - minY);
    }
    static of(template) {
        const width = template.width ?? template.w ?? 0;
        const height = template.height ?? template.h ?? 0;
        return new Rect2(template.x, template.y, width, height);
    }
}
Rect2.empty = new Rect2(0, 0, 0, 0);
Rect2.unitSquare = new Rect2(0, 0, 1, 1);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Rect2);


/***/ }),

/***/ "./node_modules/@js-draw/math/dist/mjs/utils/convexHull2Of.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/mjs/utils/convexHull2Of.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Vec2_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Vec2.mjs */ "./node_modules/@js-draw/math/dist/mjs/Vec2.mjs");

/**
 * Implements Gift Wrapping, in $O(nh)$. This algorithm is not the most efficient in the worst case.
 *
 * See https://en.wikipedia.org/wiki/Gift_wrapping_algorithm
 * and https://www.cs.jhu.edu/~misha/Spring16/06.pdf
 */
const convexHull2Of = (points) => {
    if (points.length === 0) {
        return [];
    }
    // 1. Start with a vertex on the hull
    const lowestPoint = points.reduce((lowest, current) => (current.y < lowest.y ? current : lowest), points[0]);
    const vertices = [lowestPoint];
    let toProcess = [...points.filter((p) => !p.eq(lowestPoint))];
    let lastBaseDirection = _Vec2_mjs__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(-1, 0);
    // 2. Find the point with greatest angle from the vertex:
    //
    //  . .     .
    //   . .   /  <- Notice that **all** other points are to the
    //       /       **left** of the vector from the current
    //    ./         vertex to the new point.
    while (toProcess.length > 0) {
        const lastVertex = vertices[vertices.length - 1];
        let smallestDotProductSoFar = lastBaseDirection.dot(lowestPoint.minus(lastVertex).normalizedOrZero());
        let furthestPointSoFar = lowestPoint;
        for (const point of toProcess) {
            // Maximizing the angle is the same as minimizing the dot product:
            //              point.minus(lastVertex)
            //             ^
            //            /
            //           /
            //        ϑ /
            //   <-----. lastBaseDirection
            const currentDotProduct = lastBaseDirection.dot(point.minus(lastVertex).normalizedOrZero());
            if (currentDotProduct <= smallestDotProductSoFar) {
                furthestPointSoFar = point;
                smallestDotProductSoFar = currentDotProduct;
            }
        }
        toProcess = toProcess.filter((p) => !p.eq(furthestPointSoFar));
        const newBaseDirection = furthestPointSoFar.minus(lastVertex).normalized();
        // If the last vertex is on the same edge as the current, there's no need to include
        // the previous one.
        if (Math.abs(newBaseDirection.dot(lastBaseDirection)) === 1 && vertices.length > 1) {
            vertices.pop();
        }
        // Stoping condition: We've gone in a full circle.
        if (furthestPointSoFar.eq(lowestPoint)) {
            break;
        }
        else {
            vertices.push(furthestPointSoFar);
            lastBaseDirection = lastVertex.minus(furthestPointSoFar).normalized();
        }
    }
    return vertices;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (convexHull2Of);


/***/ }),

/***/ "./node_modules/@melloware/coloris/dist/esm/coloris.js":
/*!*************************************************************!*\
  !*** ./node_modules/@melloware/coloris/dist/esm/coloris.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   close: () => (/* binding */ _close),
/* harmony export */   coloris: () => (/* binding */ _coloris),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   init: () => (/* binding */ _init),
/* harmony export */   removeInstance: () => (/* binding */ _removeInstance),
/* harmony export */   set: () => (/* binding */ _set),
/* harmony export */   setInstance: () => (/* binding */ _setInstance),
/* harmony export */   updatePosition: () => (/* binding */ _updatePosition),
/* harmony export */   wrap: () => (/* binding */ _wrap)
/* harmony export */ });
const Coloris = (() => {
  /*!
  * Copyright (c) 2021-2023 Momo Bassit.
  * Licensed under the MIT License (MIT)
  * https://github.com/mdbassit/Coloris
  * Version: 0.21.1
  * NPM: https://github.com/melloware/coloris-npm
  */

  return ((window, document, Math, undefined) => {
    const ctx = document.createElement('canvas').getContext('2d');
    const currentColor = { r: 0, g: 0, b: 0, h: 0, s: 0, v: 0, a: 1 };
    let container,picker,colorArea,colorMarker,colorPreview,colorValue,clearButton,closeButton,
      hueSlider,hueMarker,alphaSlider,alphaMarker,currentEl,currentFormat,oldColor,keyboardNav,
      colorAreaDims = {};

    // Default settings
    const settings = {
      el: '[data-coloris]',
      parent: 'body',
      theme: 'default',
      themeMode: 'light',
      rtl: false,
      wrap: true,
      margin: 2,
      format: 'hex',
      formatToggle: false,
      swatches: [],
      swatchesOnly: false,
      alpha: true,
      forceAlpha: false,
      focusInput: true,
      selectInput: false,
      inline: false,
      defaultColor: '#000000',
      clearButton: false,
      clearLabel: 'Clear',
      closeButton: false,
      closeLabel: 'Close',
      onChange: () => undefined,
      a11y: {
        open: 'Open color picker',
        close: 'Close color picker',
        clear: 'Clear the selected color',
        marker: 'Saturation: {s}. Brightness: {v}.',
        hueSlider: 'Hue slider',
        alphaSlider: 'Opacity slider',
        input: 'Color value field',
        format: 'Color format',
        swatch: 'Color swatch',
        instruction: 'Saturation and brightness selector. Use up, down, left and right arrow keys to select.'
      }
    };

    // Virtual instances cache
    const instances = {};
    let currentInstanceId = '';
    let defaultInstance = {};
    let hasInstance = false;

    /**
     * Configure the color picker.
     * @param {object} options Configuration options.
     */
    function configure(options) {
      if (typeof options !== 'object') {
        return;
      }

      for (const key in options) {
        switch (key) {
          case 'el':
            bindFields(options.el);
            if (options.wrap !== false) {
              wrapFields(options.el);
            }
            break;
          case 'parent':
            container = document.querySelector(options.parent);
            if (container) {
              container.appendChild(picker);
              settings.parent = options.parent;

              // document.body is special
              if (container === document.body) {
                container = undefined;
              }
            }
            break;
          case 'themeMode':
            settings.themeMode = options.themeMode;
            if (options.themeMode === 'auto' && window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
              settings.themeMode = 'dark';
            }
          // The lack of a break statement is intentional
          case 'theme':
            if (options.theme) {
              settings.theme = options.theme;
            }

            // Set the theme and color scheme
            picker.className = `clr-picker clr-${settings.theme} clr-${settings.themeMode}`;

            // Update the color picker's position if inline mode is in use
            if (settings.inline) {
              updatePickerPosition();
            }
            break;
          case 'rtl':
            settings.rtl = !!options.rtl;
            document.querySelectorAll('.clr-field').forEach((field) => field.classList.toggle('clr-rtl', settings.rtl));
            break;
          case 'margin':
            options.margin *= 1;
            settings.margin = !isNaN(options.margin) ? options.margin : settings.margin;
            break;
          case 'wrap':
            if (options.el && options.wrap) {
              wrapFields(options.el);
            }
            break;
          case 'formatToggle':
            settings.formatToggle = !!options.formatToggle;
            getEl('clr-format').style.display = settings.formatToggle ? 'block' : 'none';
            if (settings.formatToggle) {
              settings.format = 'auto';
            }
            break;
          case 'swatches':
            if (Array.isArray(options.swatches)) {
              const swatches = [];

              options.swatches.forEach((swatch, i) => {
                swatches.push(`<button type="button" id="clr-swatch-${i}" aria-labelledby="clr-swatch-label clr-swatch-${i}" style="color: ${swatch};">${swatch}</button>`);
              });

              getEl('clr-swatches').innerHTML = swatches.length ? `<div>${swatches.join('')}</div>` : '';
              settings.swatches = options.swatches.slice();
            }
            break;
          case 'swatchesOnly':
            settings.swatchesOnly = !!options.swatchesOnly;
            picker.setAttribute('data-minimal', settings.swatchesOnly);
            break;
          case 'alpha':
            settings.alpha = !!options.alpha;
            picker.setAttribute('data-alpha', settings.alpha);
            break;
          case 'inline':
            settings.inline = !!options.inline;
            picker.setAttribute('data-inline', settings.inline);

            if (settings.inline) {
              const defaultColor = options.defaultColor || settings.defaultColor;

              currentFormat = getColorFormatFromStr(defaultColor);
              updatePickerPosition();
              setColorFromStr(defaultColor);
            }
            break;
          case 'clearButton':
            // Backward compatibility
            if (typeof options.clearButton === 'object') {
              if (options.clearButton.label) {
                settings.clearLabel = options.clearButton.label;
                clearButton.innerHTML = settings.clearLabel;
              }

              options.clearButton = options.clearButton.show;
            }

            settings.clearButton = !!options.clearButton;
            clearButton.style.display = settings.clearButton ? 'block' : 'none';
            break;
          case 'clearLabel':
            settings.clearLabel = options.clearLabel;
            clearButton.innerHTML = settings.clearLabel;
            break;
          case 'closeButton':
            settings.closeButton = !!options.closeButton;

            if (settings.closeButton) {
              picker.insertBefore(closeButton, colorPreview);
            } else {
              colorPreview.appendChild(closeButton);
            }

            break;
          case 'closeLabel':
            settings.closeLabel = options.closeLabel;
            closeButton.innerHTML = settings.closeLabel;
            break;
          case 'a11y':
            const labels = options.a11y;
            let update = false;

            if (typeof labels === 'object') {
              for (const label in labels) {
                if (labels[label] && settings.a11y[label]) {
                  settings.a11y[label] = labels[label];
                  update = true;
                }
              }
            }

            if (update) {
              const openLabel = getEl('clr-open-label');
              const swatchLabel = getEl('clr-swatch-label');

              openLabel.innerHTML = settings.a11y.open;
              swatchLabel.innerHTML = settings.a11y.swatch;
              closeButton.setAttribute('aria-label', settings.a11y.close);
              clearButton.setAttribute('aria-label', settings.a11y.clear);
              hueSlider.setAttribute('aria-label', settings.a11y.hueSlider);
              alphaSlider.setAttribute('aria-label', settings.a11y.alphaSlider);
              colorValue.setAttribute('aria-label', settings.a11y.input);
              colorArea.setAttribute('aria-label', settings.a11y.instruction);
            }
            break;
          default:
            settings[key] = options[key];
        }
      }
    }

    /**
     * Add or update a virtual instance.
     * @param {String} selector The CSS selector of the elements to which the instance is attached.
     * @param {Object} options Per-instance options to apply.
     */
    function setVirtualInstance(selector, options) {
      if (typeof selector === 'string' && typeof options === 'object') {
        instances[selector] = options;
        hasInstance = true;
      }
    }

    /**
     * Remove a virtual instance.
     * @param {String} selector The CSS selector of the elements to which the instance is attached.
     */
    function removeVirtualInstance(selector) {
      delete instances[selector];

      if (Object.keys(instances).length === 0) {
        hasInstance = false;

        if (selector === currentInstanceId) {
          resetVirtualInstance();
        }
      }
    }

    /**
     * Attach a virtual instance to an element if it matches a selector.
     * @param {Object} element Target element that will receive a virtual instance if applicable.
     */
    function attachVirtualInstance(element) {
      if (hasInstance) {
        // These options can only be set globally, not per instance
        const unsupportedOptions = ['el', 'wrap', 'rtl', 'inline', 'defaultColor', 'a11y'];

        for (let selector in instances) {
          const options = instances[selector];

          // If the element matches an instance's CSS selector
          if (element.matches(selector)) {
            currentInstanceId = selector;
            defaultInstance = {};

            // Delete unsupported options
            unsupportedOptions.forEach((option) => delete options[option]);

            // Back up the default options so we can restore them later
            for (let option in options) {
              defaultInstance[option] = Array.isArray(settings[option]) ? settings[option].slice() : settings[option];
            }

            // Set the instance's options
            configure(options);
            break;
          }
        }
      }
    }

    /**
     * Revert any per-instance options that were previously applied.
     */
    function resetVirtualInstance() {
      if (Object.keys(defaultInstance).length > 0) {
        configure(defaultInstance);
        currentInstanceId = '';
        defaultInstance = {};
      }
    }

    /**
     * Bind the color picker to input fields that match the selector.
     * @param {string} selector One or more selectors pointing to input fields.
     */
    function bindFields(selector) {
      // Show the color picker on click on the input fields that match the selector
      addListener(document, 'click', selector, (event) => {
        // Skip if inline mode is in use
        if (settings.inline) {
          return;
        }

        // Apply any per-instance options first
        attachVirtualInstance(event.target);

        currentEl = event.target;
        oldColor = currentEl.value;
        currentFormat = getColorFormatFromStr(oldColor);
        picker.classList.add('clr-open');

        updatePickerPosition();
        setColorFromStr(oldColor);

        if (settings.focusInput || settings.selectInput) {
          colorValue.focus({ preventScroll: true });
          colorValue.setSelectionRange(currentEl.selectionStart, currentEl.selectionEnd);
        }

        if (settings.selectInput) {
          colorValue.select();
        }

        // Always focus the first element when using keyboard navigation
        if (keyboardNav || settings.swatchesOnly) {
          getFocusableElements().shift().focus();
        }

        // Trigger an "open" event
        currentEl.dispatchEvent(new Event('open', { bubbles: true }));
      });

      // Update the color preview of the input fields that match the selector
      addListener(document, 'input', selector, (event) => {
        const parent = event.target.parentNode;

        // Only update the preview if the field has been previously wrapped
        if (parent.classList.contains('clr-field')) {
          parent.style.color = event.target.value;
        }
      });
    }

    /**
     * Update the color picker's position and the color gradient's offset
     */
    function updatePickerPosition() {
      if (!picker || !currentEl && !settings.inline) return; //** DO NOT REMOVE: in case called before initialized
      const parent = container;
      const scrollY = window.scrollY;
      const pickerWidth = picker.offsetWidth;
      const pickerHeight = picker.offsetHeight;
      const reposition = { left: false, top: false };
      let parentStyle, parentMarginTop, parentBorderTop;
      let offset = { x: 0, y: 0 };

      if (parent) {
        parentStyle = window.getComputedStyle(parent);
        parentMarginTop = parseFloat(parentStyle.marginTop);
        parentBorderTop = parseFloat(parentStyle.borderTopWidth);

        offset = parent.getBoundingClientRect();
        offset.y += parentBorderTop + scrollY;
      }

      if (!settings.inline) {
        const coords = currentEl.getBoundingClientRect();
        let left = coords.x;
        let top = scrollY + coords.y + coords.height + settings.margin;

        // If the color picker is inside a custom container
        // set the position relative to it
        if (parent) {
          left -= offset.x;
          top -= offset.y;

          if (left + pickerWidth > parent.clientWidth) {
            left += coords.width - pickerWidth;
            reposition.left = true;
          }

          if (top + pickerHeight > parent.clientHeight - parentMarginTop) {
            if (pickerHeight + settings.margin <= coords.top - (offset.y - scrollY)) {
              top -= coords.height + pickerHeight + settings.margin * 2;
              reposition.top = true;
            }
          }

          top += parent.scrollTop;

          // Otherwise set the position relative to the whole document
        } else {
          if (left + pickerWidth > document.documentElement.clientWidth) {
            left += coords.width - pickerWidth;
            reposition.left = true;
          }

          if (top + pickerHeight - scrollY > document.documentElement.clientHeight) {
            if (pickerHeight + settings.margin <= coords.top) {
              top = scrollY + coords.y - pickerHeight - settings.margin;
              reposition.top = true;
            }
          }
        }

        picker.classList.toggle('clr-left', reposition.left);
        picker.classList.toggle('clr-top', reposition.top);
        picker.style.left = `${left}px`;
        picker.style.top = `${top}px`;
        offset.x += picker.offsetLeft;
        offset.y += picker.offsetTop;
      }

      colorAreaDims = {
        width: colorArea.offsetWidth,
        height: colorArea.offsetHeight,
        x: colorArea.offsetLeft + offset.x,
        y: colorArea.offsetTop + offset.y
      };
    }

    /**
     * Wrap the linked input fields in a div that adds a color preview.
     * @param {string} selector One or more selectors pointing to input fields.
     */
    function wrapFields(selector) {
      document.querySelectorAll(selector).forEach((field) => {
        const parentNode = field.parentNode;

        if (!parentNode.classList.contains('clr-field')) {
          const wrapper = document.createElement('div');
          let classes = 'clr-field';

          if (settings.rtl || field.classList.contains('clr-rtl')) {
            classes += ' clr-rtl';
          }

          wrapper.innerHTML = `<button type="button" aria-labelledby="clr-open-label"></button>`;
          parentNode.insertBefore(wrapper, field);
          wrapper.setAttribute('class', classes);
          wrapper.style.color = field.value;
          wrapper.appendChild(field);
        }
      });
    }

    /**
     * Close the color picker.
     * @param {boolean} [revert] If true, revert the color to the original value.
     */
    function closePicker(revert) {
      if (currentEl && !settings.inline) {
        const prevEl = currentEl;

        // Revert the color to the original value if needed
        if (revert) {
          // This will prevent the "change" event on the colorValue input to execute its handler
          currentEl = undefined;

          if (oldColor !== prevEl.value) {
            prevEl.value = oldColor;

            // Trigger an "input" event to force update the thumbnail next to the input field
            prevEl.dispatchEvent(new Event('input', { bubbles: true }));
          }
        }

        // Trigger a "change" event if needed
        setTimeout(() => {// Add this to the end of the event loop
          if (oldColor !== prevEl.value) {
            prevEl.dispatchEvent(new Event('change', { bubbles: true }));
          }
        });

        // Hide the picker dialog
        picker.classList.remove('clr-open');

        // Reset any previously set per-instance options
        if (hasInstance) {
          resetVirtualInstance();
        }

        // Trigger a "close" event
        prevEl.dispatchEvent(new Event('close', { bubbles: true }));

        if (settings.focusInput) {
          prevEl.focus({ preventScroll: true });
        }

        // This essentially marks the picker as closed
        currentEl = undefined;
      }
    }

    /**
     * Set the active color from a string.
     * @param {string} str String representing a color.
     */
    function setColorFromStr(str) {
      const rgba = strToRGBA(str);
      const hsva = RGBAtoHSVA(rgba);

      updateMarkerA11yLabel(hsva.s, hsva.v);
      updateColor(rgba, hsva);

      // Update the UI
      hueSlider.value = hsva.h;
      picker.style.color = `hsl(${hsva.h}, 100%, 50%)`;
      hueMarker.style.left = `${hsva.h / 360 * 100}%`;

      colorMarker.style.left = `${colorAreaDims.width * hsva.s / 100}px`;
      colorMarker.style.top = `${colorAreaDims.height - colorAreaDims.height * hsva.v / 100}px`;

      alphaSlider.value = hsva.a * 100;
      alphaMarker.style.left = `${hsva.a * 100}%`;
    }

    /**
     * Guess the color format from a string.
     * @param {string} str String representing a color.
     * @return {string} The color format.
     */
    function getColorFormatFromStr(str) {
      const format = str.substring(0, 3).toLowerCase();

      if (format === 'rgb' || format === 'hsl') {
        return format;
      }

      return 'hex';
    }

    /**
     * Copy the active color to the linked input field.
     * @param {number} [color] Color value to override the active color.
     */
    function pickColor(color) {
      color = color !== undefined ? color : colorValue.value;

      if (currentEl) {
        currentEl.value = color;
        currentEl.dispatchEvent(new Event('input', { bubbles: true }));
      }

      if (settings.onChange) {
        settings.onChange.call(window, color, currentEl);
      }

      document.dispatchEvent(new CustomEvent('coloris:pick', { detail: { color, currentEl } }));
    }

    /**
     * Set the active color based on a specific point in the color gradient.
     * @param {number} x Left position.
     * @param {number} y Top position.
     */
    function setColorAtPosition(x, y) {
      const hsva = {
        h: hueSlider.value * 1,
        s: x / colorAreaDims.width * 100,
        v: 100 - y / colorAreaDims.height * 100,
        a: alphaSlider.value / 100
      };
      const rgba = HSVAtoRGBA(hsva);

      updateMarkerA11yLabel(hsva.s, hsva.v);
      updateColor(rgba, hsva);
      pickColor();
    }

    /**
     * Update the color marker's accessibility label.
     * @param {number} saturation
     * @param {number} value
     */
    function updateMarkerA11yLabel(saturation, value) {
      let label = settings.a11y.marker;

      saturation = saturation.toFixed(1) * 1;
      value = value.toFixed(1) * 1;
      label = label.replace('{s}', saturation);
      label = label.replace('{v}', value);
      colorMarker.setAttribute('aria-label', label);
    }

    //
    /**
     * Get the pageX and pageY positions of the pointer.
     * @param {object} event The MouseEvent or TouchEvent object.
     * @return {object} The pageX and pageY positions.
     */
    function getPointerPosition(event) {
      return {
        pageX: event.changedTouches ? event.changedTouches[0].pageX : event.pageX,
        pageY: event.changedTouches ? event.changedTouches[0].pageY : event.pageY
      };
    }

    /**
     * Move the color marker when dragged.
     * @param {object} event The MouseEvent object.
     */
    function moveMarker(event) {
      const pointer = getPointerPosition(event);
      let x = pointer.pageX - colorAreaDims.x;
      let y = pointer.pageY - colorAreaDims.y;

      if (container) {
        y += container.scrollTop;
      }

      setMarkerPosition(x, y);

      // Prevent scrolling while dragging the marker
      event.preventDefault();
      event.stopPropagation();
    }

    /**
     * Move the color marker when the arrow keys are pressed.
     * @param {number} offsetX The horizontal amount to move.
     * @param {number} offsetY The vertical amount to move.
     */
    function moveMarkerOnKeydown(offsetX, offsetY) {
      let x = colorMarker.style.left.replace('px', '') * 1 + offsetX;
      let y = colorMarker.style.top.replace('px', '') * 1 + offsetY;

      setMarkerPosition(x, y);
    }

    /**
     * Set the color marker's position.
     * @param {number} x Left position.
     * @param {number} y Top position.
     */
    function setMarkerPosition(x, y) {
      // Make sure the marker doesn't go out of bounds
      x = x < 0 ? 0 : x > colorAreaDims.width ? colorAreaDims.width : x;
      y = y < 0 ? 0 : y > colorAreaDims.height ? colorAreaDims.height : y;

      // Set the position
      colorMarker.style.left = `${x}px`;
      colorMarker.style.top = `${y}px`;

      // Update the color
      setColorAtPosition(x, y);

      // Make sure the marker is focused
      colorMarker.focus();
    }

    /**
     * Update the color picker's input field and preview thumb.
     * @param {Object} rgba Red, green, blue and alpha values.
     * @param {Object} [hsva] Hue, saturation, value and alpha values.
     */
    function updateColor(rgba, hsva) {if (rgba === void 0) {rgba = {};}if (hsva === void 0) {hsva = {};}
      let format = settings.format;

      for (const key in rgba) {
        currentColor[key] = rgba[key];
      }

      for (const key in hsva) {
        currentColor[key] = hsva[key];
      }

      const hex = RGBAToHex(currentColor);
      const opaqueHex = hex.substring(0, 7);

      colorMarker.style.color = opaqueHex;
      alphaMarker.parentNode.style.color = opaqueHex;
      alphaMarker.style.color = hex;
      colorPreview.style.color = hex;

      // Force repaint the color and alpha gradients as a workaround for a Google Chrome bug
      colorArea.style.display = 'none';
      colorArea.offsetHeight;
      colorArea.style.display = '';
      alphaMarker.nextElementSibling.style.display = 'none';
      alphaMarker.nextElementSibling.offsetHeight;
      alphaMarker.nextElementSibling.style.display = '';

      if (format === 'mixed') {
        format = currentColor.a === 1 ? 'hex' : 'rgb';
      } else if (format === 'auto') {
        format = currentFormat;
      }

      switch (format) {
        case 'hex':
          colorValue.value = hex;
          break;
        case 'rgb':
          colorValue.value = RGBAToStr(currentColor);
          break;
        case 'hsl':
          colorValue.value = HSLAToStr(HSVAtoHSLA(currentColor));
          break;
      }

      // Select the current format in the format switcher
      document.querySelector(`.clr-format [value="${format}"]`).checked = true;
    }

    /**
     * Set the hue when its slider is moved.
     */
    function setHue() {
      const hue = hueSlider.value * 1;
      const x = colorMarker.style.left.replace('px', '') * 1;
      const y = colorMarker.style.top.replace('px', '') * 1;

      picker.style.color = `hsl(${hue}, 100%, 50%)`;
      hueMarker.style.left = `${hue / 360 * 100}%`;

      setColorAtPosition(x, y);
    }

    /**
     * Set the alpha when its slider is moved.
     */
    function setAlpha() {
      const alpha = alphaSlider.value / 100;

      alphaMarker.style.left = `${alpha * 100}%`;
      updateColor({ a: alpha });
      pickColor();
    }

    /**
     * Convert HSVA to RGBA.
     * @param {object} hsva Hue, saturation, value and alpha values.
     * @return {object} Red, green, blue and alpha values.
     */
    function HSVAtoRGBA(hsva) {
      const saturation = hsva.s / 100;
      const value = hsva.v / 100;
      let chroma = saturation * value;
      let hueBy60 = hsva.h / 60;
      let x = chroma * (1 - Math.abs(hueBy60 % 2 - 1));
      let m = value - chroma;

      chroma = chroma + m;
      x = x + m;

      const index = Math.floor(hueBy60) % 6;
      const red = [chroma, x, m, m, x, chroma][index];
      const green = [x, chroma, chroma, x, m, m][index];
      const blue = [m, m, x, chroma, chroma, x][index];

      return {
        r: Math.round(red * 255),
        g: Math.round(green * 255),
        b: Math.round(blue * 255),
        a: hsva.a
      };
    }

    /**
     * Convert HSVA to HSLA.
     * @param {object} hsva Hue, saturation, value and alpha values.
     * @return {object} Hue, saturation, lightness and alpha values.
     */
    function HSVAtoHSLA(hsva) {
      const value = hsva.v / 100;
      const lightness = value * (1 - hsva.s / 100 / 2);
      let saturation;

      if (lightness > 0 && lightness < 1) {
        saturation = Math.round((value - lightness) / Math.min(lightness, 1 - lightness) * 100);
      }

      return {
        h: hsva.h,
        s: saturation || 0,
        l: Math.round(lightness * 100),
        a: hsva.a
      };
    }

    /**
     * Convert RGBA to HSVA.
     * @param {object} rgba Red, green, blue and alpha values.
     * @return {object} Hue, saturation, value and alpha values.
     */
    function RGBAtoHSVA(rgba) {
      const red = rgba.r / 255;
      const green = rgba.g / 255;
      const blue = rgba.b / 255;
      const xmax = Math.max(red, green, blue);
      const xmin = Math.min(red, green, blue);
      const chroma = xmax - xmin;
      const value = xmax;
      let hue = 0;
      let saturation = 0;

      if (chroma) {
        if (xmax === red) {hue = (green - blue) / chroma;}
        if (xmax === green) {hue = 2 + (blue - red) / chroma;}
        if (xmax === blue) {hue = 4 + (red - green) / chroma;}
        if (xmax) {saturation = chroma / xmax;}
      }

      hue = Math.floor(hue * 60);

      return {
        h: hue < 0 ? hue + 360 : hue,
        s: Math.round(saturation * 100),
        v: Math.round(value * 100),
        a: rgba.a
      };
    }

    /**
     * Parse a string to RGBA.
     * @param {string} str String representing a color.
     * @return {object} Red, green, blue and alpha values.
     */
    function strToRGBA(str) {
      const regex = /^((rgba)|rgb)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]*?([\d.]+|$)/i;
      let match, rgba;

      // Default to black for invalid color strings
      ctx.fillStyle = '#000';

      // Use canvas to convert the string to a valid color string
      ctx.fillStyle = str;
      match = regex.exec(ctx.fillStyle);

      if (match) {
        rgba = {
          r: match[3] * 1,
          g: match[4] * 1,
          b: match[5] * 1,
          a: match[6] * 1
        };

        // Workaround to mitigate a Chromium bug where the alpha value is rounded incorrectly
        rgba.a = +rgba.a.toFixed(2);

      } else {
        match = ctx.fillStyle.replace('#', '').match(/.{2}/g).map((h) => parseInt(h, 16));
        rgba = {
          r: match[0],
          g: match[1],
          b: match[2],
          a: 1
        };
      }

      return rgba;
    }

    /**
     * Convert RGBA to Hex.
     * @param {object} rgba Red, green, blue and alpha values.
     * @return {string} Hex color string.
     */
    function RGBAToHex(rgba) {
      let R = rgba.r.toString(16);
      let G = rgba.g.toString(16);
      let B = rgba.b.toString(16);
      let A = '';

      if (rgba.r < 16) {
        R = '0' + R;
      }

      if (rgba.g < 16) {
        G = '0' + G;
      }

      if (rgba.b < 16) {
        B = '0' + B;
      }

      if (settings.alpha && (rgba.a < 1 || settings.forceAlpha)) {
        const alpha = rgba.a * 255 | 0;
        A = alpha.toString(16);

        if (alpha < 16) {
          A = '0' + A;
        }
      }

      return '#' + R + G + B + A;
    }

    /**
     * Convert RGBA values to a CSS rgb/rgba string.
     * @param {object} rgba Red, green, blue and alpha values.
     * @return {string} CSS color string.
     */
    function RGBAToStr(rgba) {
      if (!settings.alpha || rgba.a === 1 && !settings.forceAlpha) {
        return `rgb(${rgba.r}, ${rgba.g}, ${rgba.b})`;
      } else {
        return `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`;
      }
    }

    /**
     * Convert HSLA values to a CSS hsl/hsla string.
     * @param {object} hsla Hue, saturation, lightness and alpha values.
     * @return {string} CSS color string.
     */
    function HSLAToStr(hsla) {
      if (!settings.alpha || hsla.a === 1 && !settings.forceAlpha) {
        return `hsl(${hsla.h}, ${hsla.s}%, ${hsla.l}%)`;
      } else {
        return `hsla(${hsla.h}, ${hsla.s}%, ${hsla.l}%, ${hsla.a})`;
      }
    }

    /**
     * Init the color picker.
     */
    function init() {
      if (document.getElementById('clr-picker')) return; //** DO NOT REMOVE: Prevent binding events multiple times
      // Render the UI
      container = undefined;
      picker = document.createElement('div');
      picker.setAttribute('id', 'clr-picker');
      picker.className = 'clr-picker';
      picker.innerHTML =
      `<input id="clr-color-value" name="clr-color-value" class="clr-color" type="text" value="" spellcheck="false" aria-label="${settings.a11y.input}">` +
      `<div id="clr-color-area" class="clr-gradient" role="application" aria-label="${settings.a11y.instruction}">` +
      '<div id="clr-color-marker" class="clr-marker" tabindex="0"></div>' +
      '</div>' +
      '<div class="clr-hue">' +
      `<input id="clr-hue-slider" name="clr-hue-slider" type="range" min="0" max="360" step="1" aria-label="${settings.a11y.hueSlider}">` +
      '<div id="clr-hue-marker"></div>' +
      '</div>' +
      '<div class="clr-alpha">' +
      `<input id="clr-alpha-slider" name="clr-alpha-slider" type="range" min="0" max="100" step="1" aria-label="${settings.a11y.alphaSlider}">` +
      '<div id="clr-alpha-marker"></div>' +
      '<span></span>' +
      '</div>' +
      '<div id="clr-format" class="clr-format">' +
      '<fieldset class="clr-segmented">' +
      `<legend>${settings.a11y.format}</legend>` +
      '<input id="clr-f1" type="radio" name="clr-format" value="hex">' +
      '<label for="clr-f1">Hex</label>' +
      '<input id="clr-f2" type="radio" name="clr-format" value="rgb">' +
      '<label for="clr-f2">RGB</label>' +
      '<input id="clr-f3" type="radio" name="clr-format" value="hsl">' +
      '<label for="clr-f3">HSL</label>' +
      '<span></span>' +
      '</fieldset>' +
      '</div>' +
      '<div id="clr-swatches" class="clr-swatches"></div>' +
      `<button type="button" id="clr-clear" class="clr-clear" aria-label="${settings.a11y.clear}">${settings.clearLabel}</button>` +
      '<div id="clr-color-preview" class="clr-preview">' +
      `<button type="button" id="clr-close" class="clr-close" aria-label="${settings.a11y.close}">${settings.closeLabel}</button>` +
      '</div>' +
      `<span id="clr-open-label" hidden>${settings.a11y.open}</span>` +
      `<span id="clr-swatch-label" hidden>${settings.a11y.swatch}</span>`;

      // Append the color picker to the DOM
      document.body.appendChild(picker);

      // Reference the UI elements
      colorArea = getEl('clr-color-area');
      colorMarker = getEl('clr-color-marker');
      clearButton = getEl('clr-clear');
      closeButton = getEl('clr-close');
      colorPreview = getEl('clr-color-preview');
      colorValue = getEl('clr-color-value');
      hueSlider = getEl('clr-hue-slider');
      hueMarker = getEl('clr-hue-marker');
      alphaSlider = getEl('clr-alpha-slider');
      alphaMarker = getEl('clr-alpha-marker');

      // Bind the picker to the default selector
      bindFields(settings.el);
      wrapFields(settings.el);

      addListener(picker, 'mousedown', (event) => {
        picker.classList.remove('clr-keyboard-nav');
        event.stopPropagation();
      });

      addListener(colorArea, 'mousedown', (event) => {
        addListener(document, 'mousemove', moveMarker);
      });

      addListener(colorArea, 'touchstart', (event) => {
        document.addEventListener('touchmove', moveMarker, { passive: false });
      });

      addListener(colorMarker, 'mousedown', (event) => {
        addListener(document, 'mousemove', moveMarker);
      });

      addListener(colorMarker, 'touchstart', (event) => {
        document.addEventListener('touchmove', moveMarker, { passive: false });
      });

      addListener(colorValue, 'change', (event) => {
        const value = colorValue.value;

        if (currentEl || settings.inline) {
          const color = value === '' ? value : setColorFromStr(value);
          pickColor(color);
        }
      });

      addListener(clearButton, 'click', (event) => {
        pickColor('');
        closePicker();
      });

      addListener(closeButton, 'click', (event) => {
        pickColor();
        closePicker();
      });

      addListener(getEl('clr-format'), 'click', '.clr-format input', (event) => {
        currentFormat = event.target.value;
        updateColor();
        pickColor();
      });

      addListener(picker, 'click', '.clr-swatches button', (event) => {
        setColorFromStr(event.target.textContent);
        pickColor();

        if (settings.swatchesOnly) {
          closePicker();
        }
      });

      addListener(document, 'mouseup', (event) => {
        document.removeEventListener('mousemove', moveMarker);
      });

      addListener(document, 'touchend', (event) => {
        document.removeEventListener('touchmove', moveMarker);
      });

      addListener(document, 'mousedown', (event) => {
        keyboardNav = false;
        picker.classList.remove('clr-keyboard-nav');
        closePicker();
      });

      addListener(document, 'keydown', (event) => {
        const key = event.key;
        const target = event.target;
        const shiftKey = event.shiftKey;
        const navKeys = ['Tab', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];

        if (key === 'Escape') {
          closePicker(true);

          // Display focus rings when using the keyboard
        } else if (navKeys.includes(key)) {
          keyboardNav = true;
          picker.classList.add('clr-keyboard-nav');
        }

        // Trap the focus within the color picker while it's open
        if (key === 'Tab' && target.matches('.clr-picker *')) {
          const focusables = getFocusableElements();
          const firstFocusable = focusables.shift();
          const lastFocusable = focusables.pop();

          if (shiftKey && target === firstFocusable) {
            lastFocusable.focus();
            event.preventDefault();
          } else if (!shiftKey && target === lastFocusable) {
            firstFocusable.focus();
            event.preventDefault();
          }
        }
      });

      addListener(document, 'click', '.clr-field button', (event) => {
        // Reset any previously set per-instance options
        if (hasInstance) {
          resetVirtualInstance();
        }

        // Open the color picker
        event.target.nextElementSibling.dispatchEvent(new Event('click', { bubbles: true }));
      });

      addListener(colorMarker, 'keydown', (event) => {
        const movements = {
          ArrowUp: [0, -1],
          ArrowDown: [0, 1],
          ArrowLeft: [-1, 0],
          ArrowRight: [1, 0]
        };

        if (Object.keys(movements).includes(event.key)) {
          moveMarkerOnKeydown(...movements[event.key]);
          event.preventDefault();
        }
      });

      addListener(colorArea, 'click', moveMarker);
      addListener(hueSlider, 'input', setHue);
      addListener(alphaSlider, 'input', setAlpha);
    }

    /**
     * Return a list of focusable elements within the color picker.
     * @return {array} The list of focusable DOM elemnts.
     */
    function getFocusableElements() {
      const controls = Array.from(picker.querySelectorAll('input, button'));
      const focusables = controls.filter((node) => !!node.offsetWidth);

      return focusables;
    }

    /**
     * Shortcut for getElementById to optimize the minified JS.
     * @param {string} id The element id.
     * @return {object} The DOM element with the provided id.
     */
    function getEl(id) {
      return document.getElementById(id);
    }

    /**
     * Shortcut for addEventListener to optimize the minified JS.
     * @param {object} context The context to which the listener is attached.
     * @param {string} type Event type.
     * @param {(string|function)} selector Event target if delegation is used, event handler if not.
     * @param {function} [fn] Event handler if delegation is used.
     */
    function addListener(context, type, selector, fn) {
      const matches = Element.prototype.matches || Element.prototype.msMatchesSelector;

      // Delegate event to the target of the selector
      if (typeof selector === 'string') {
        context.addEventListener(type, (event) => {
          if (matches.call(event.target, selector)) {
            fn.call(event.target, event);
          }
        });

        // If the selector is not a string then it's a function
        // in which case we need a regular event listener
      } else {
        fn = selector;
        context.addEventListener(type, fn);
      }
    }

    /**
     * Call a function only when the DOM is ready.
     * @param {function} fn The function to call.
     * @param {array} [args] Arguments to pass to the function.
     */
    function DOMReady(fn, args) {
      args = args !== undefined ? args : [];

      if (document.readyState !== 'loading') {
        fn(...args);
      } else {
        document.addEventListener('DOMContentLoaded', () => {
          fn(...args);
        });
      }
    }

    // Polyfill for Nodelist.forEach
    if (NodeList !== undefined && NodeList.prototype && !NodeList.prototype.forEach) {
      NodeList.prototype.forEach = Array.prototype.forEach;
    }

    //*****************************************************
    //******* NPM: Custom code starts here ****************
    //*****************************************************

    /**
     * Copy the active color to the linked input field and set the color.
     * @param {string} [color] Color value to override the active color.
     * @param {HTMLelement} [target] the element setting the color on
     */
    function setColor(color, target) {
      currentEl = target;
      oldColor = currentEl.value;
      attachVirtualInstance(target);
      currentFormat = getColorFormatFromStr(color);
      updatePickerPosition();
      setColorFromStr(color);
      pickColor();
      if (oldColor !== color) {
        currentEl.dispatchEvent(new Event('change', { bubbles: true }));
      }
    }

    // Expose the color picker to the global scope
    const Coloris = (() => {
      const methods = {
        init: init,
        set: configure,
        wrap: wrapFields,
        close: closePicker,
        setInstance: setVirtualInstance,
        setColor: setColor,
        removeInstance: removeVirtualInstance,
        updatePosition: updatePickerPosition,
        ready: DOMReady
      };

      function Coloris(options) {
        DOMReady(() => {
          if (options) {
            if (typeof options === 'string') {
              bindFields(options);
            } else {
              configure(options);
            }
          }
        });
      }

      for (const key in methods) {
        Coloris[key] = function () {for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}
          DOMReady(methods[key], args);
        };
      }

      // handle window resize events re-aligning the panel
      DOMReady(() => {
        window.addEventListener('resize', (event) => {Coloris.updatePosition();});
        window.addEventListener('scroll', (event) => {Coloris.updatePosition();});
      });

      return Coloris;
    })();

    // Ensure init function is available not only as as a default import
    Coloris.coloris = Coloris;

    // Init the color picker when the DOM is ready
    return Coloris;

  })(window, document, Math);
})();

const _coloris = Coloris.coloris;
const _init = Coloris.init;
const _set = Coloris.set;
const _wrap = Coloris.wrap;
const _close = Coloris.close;
const _setInstance = Coloris.setInstance;
const _removeInstance = Coloris.removeInstance;
const _updatePosition = Coloris.updatePosition;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Coloris);


/***/ }),

/***/ "./node_modules/bezier-js/src/bezier.js":
/*!**********************************************!*\
  !*** ./node_modules/bezier-js/src/bezier.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Bezier: () => (/* binding */ Bezier)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/bezier-js/src/utils.js");
/* harmony import */ var _poly_bezier_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./poly-bezier.js */ "./node_modules/bezier-js/src/poly-bezier.js");
/**
  A javascript Bezier curve library by Pomax.

  Based on http://pomax.github.io/bezierinfo

  This code is MIT licensed.
**/




// math-inlining.
const { abs, min, max, cos, sin, acos, sqrt } = Math;
const pi = Math.PI;
// a zero coordinate, which is surprisingly useful
const ZERO = { x: 0, y: 0, z: 0 };

/**
 * Bezier curve constructor.
 *
 * ...docs pending...
 */
class Bezier {
  constructor(coords) {
    let args =
      coords && coords.forEach ? coords : Array.from(arguments).slice();
    let coordlen = false;

    if (typeof args[0] === "object") {
      coordlen = args.length;
      const newargs = [];
      args.forEach(function (point) {
        ["x", "y", "z"].forEach(function (d) {
          if (typeof point[d] !== "undefined") {
            newargs.push(point[d]);
          }
        });
      });
      args = newargs;
    }

    let higher = false;
    const len = args.length;

    if (coordlen) {
      if (coordlen > 4) {
        if (arguments.length !== 1) {
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        }
        higher = true;
      }
    } else {
      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {
        if (arguments.length !== 1) {
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        }
      }
    }

    const _3d = (this._3d =
      (!higher && (len === 9 || len === 12)) ||
      (coords && coords[0] && typeof coords[0].z !== "undefined"));

    const points = (this.points = []);
    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {
      var point = {
        x: args[idx],
        y: args[idx + 1],
      };
      if (_3d) {
        point.z = args[idx + 2];
      }
      points.push(point);
    }
    const order = (this.order = points.length - 1);

    const dims = (this.dims = ["x", "y"]);
    if (_3d) dims.push("z");
    this.dimlen = dims.length;

    // is this curve, practically speaking, a straight line?
    const aligned = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.align(points, { p1: points[0], p2: points[order] });
    const baselength = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.dist(points[0], points[order]);
    this._linear = aligned.reduce((t, p) => t + abs(p.y), 0) < baselength / 50;

    this._lut = [];
    this._t1 = 0;
    this._t2 = 1;
    this.update();
  }

  static quadraticFromPoints(p1, p2, p3, t) {
    if (typeof t === "undefined") {
      t = 0.5;
    }
    // shortcuts, although they're really dumb
    if (t === 0) {
      return new Bezier(p2, p2, p3);
    }
    if (t === 1) {
      return new Bezier(p1, p2, p2);
    }
    // real fitting.
    const abc = Bezier.getABC(2, p1, p2, p3, t);
    return new Bezier(p1, abc.A, p3);
  }

  static cubicFromPoints(S, B, E, t, d1) {
    if (typeof t === "undefined") {
      t = 0.5;
    }
    const abc = Bezier.getABC(3, S, B, E, t);
    if (typeof d1 === "undefined") {
      d1 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.dist(B, abc.C);
    }
    const d2 = (d1 * (1 - t)) / t;

    const selen = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.dist(S, E),
      lx = (E.x - S.x) / selen,
      ly = (E.y - S.y) / selen,
      bx1 = d1 * lx,
      by1 = d1 * ly,
      bx2 = d2 * lx,
      by2 = d2 * ly;
    // derivation of new hull coordinates
    const e1 = { x: B.x - bx1, y: B.y - by1 },
      e2 = { x: B.x + bx2, y: B.y + by2 },
      A = abc.A,
      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },
      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },
      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },
      nc2 = {
        x: E.x + (v2.x - E.x) / (1 - t),
        y: E.y + (v2.y - E.y) / (1 - t),
      };
    // ...done
    return new Bezier(S, nc1, nc2, E);
  }

  static getUtils() {
    return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils;
  }

  getUtils() {
    return Bezier.getUtils();
  }

  static get PolyBezier() {
    return _poly_bezier_js__WEBPACK_IMPORTED_MODULE_1__.PolyBezier;
  }

  valueOf() {
    return this.toString();
  }

  toString() {
    return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.pointsToString(this.points);
  }

  toSVG() {
    if (this._3d) return false;
    const p = this.points,
      x = p[0].x,
      y = p[0].y,
      s = ["M", x, y, this.order === 2 ? "Q" : "C"];
    for (let i = 1, last = p.length; i < last; i++) {
      s.push(p[i].x);
      s.push(p[i].y);
    }
    return s.join(" ");
  }

  setRatios(ratios) {
    if (ratios.length !== this.points.length) {
      throw new Error("incorrect number of ratio values");
    }
    this.ratios = ratios;
    this._lut = []; //  invalidate any precomputed LUT
  }

  verify() {
    const print = this.coordDigest();
    if (print !== this._print) {
      this._print = print;
      this.update();
    }
  }

  coordDigest() {
    return this.points
      .map(function (c, pos) {
        return "" + pos + c.x + c.y + (c.z ? c.z : 0);
      })
      .join("");
  }

  update() {
    // invalidate any precomputed LUT
    this._lut = [];
    this.dpoints = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.derive(this.points, this._3d);
    this.computedirection();
  }

  computedirection() {
    const points = this.points;
    const angle = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.angle(points[0], points[this.order], points[1]);
    this.clockwise = angle > 0;
  }

  length() {
    return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.length(this.derivative.bind(this));
  }

  static getABC(order = 2, S, B, E, t = 0.5) {
    const u = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.projectionratio(t, order),
      um = 1 - u,
      C = {
        x: u * S.x + um * E.x,
        y: u * S.y + um * E.y,
      },
      s = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.abcratio(t, order),
      A = {
        x: B.x + (B.x - C.x) / s,
        y: B.y + (B.y - C.y) / s,
      };
    return { A, B, C, S, E };
  }

  getABC(t, B) {
    B = B || this.get(t);
    let S = this.points[0];
    let E = this.points[this.order];
    return Bezier.getABC(this.order, S, B, E, t);
  }

  getLUT(steps) {
    this.verify();
    steps = steps || 100;
    if (this._lut.length === steps + 1) {
      return this._lut;
    }
    this._lut = [];
    // n steps means n+1 points
    steps++;
    this._lut = [];
    for (let i = 0, p, t; i < steps; i++) {
      t = i / (steps - 1);
      p = this.compute(t);
      p.t = t;
      this._lut.push(p);
    }
    return this._lut;
  }

  on(point, error) {
    error = error || 5;
    const lut = this.getLUT(),
      hits = [];
    for (let i = 0, c, t = 0; i < lut.length; i++) {
      c = lut[i];
      if (_utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.dist(c, point) < error) {
        hits.push(c);
        t += i / lut.length;
      }
    }
    if (!hits.length) return false;
    return (t /= hits.length);
  }

  project(point) {
    // step 1: coarse check
    const LUT = this.getLUT(),
      l = LUT.length - 1,
      closest = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.closest(LUT, point),
      mpos = closest.mpos,
      t1 = (mpos - 1) / l,
      t2 = (mpos + 1) / l,
      step = 0.1 / l;

    // step 2: fine check
    let mdist = closest.mdist,
      t = t1,
      ft = t,
      p;
    mdist += 1;
    for (let d; t < t2 + step; t += step) {
      p = this.compute(t);
      d = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.dist(point, p);
      if (d < mdist) {
        mdist = d;
        ft = t;
      }
    }
    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;
    p = this.compute(ft);
    p.t = ft;
    p.d = mdist;
    return p;
  }

  get(t) {
    return this.compute(t);
  }

  point(idx) {
    return this.points[idx];
  }

  compute(t) {
    if (this.ratios) {
      return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.computeWithRatios(t, this.points, this.ratios, this._3d);
    }
    return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.compute(t, this.points, this._3d, this.ratios);
  }

  raise() {
    const p = this.points,
      np = [p[0]],
      k = p.length;
    for (let i = 1, pi, pim; i < k; i++) {
      pi = p[i];
      pim = p[i - 1];
      np[i] = {
        x: ((k - i) / k) * pi.x + (i / k) * pim.x,
        y: ((k - i) / k) * pi.y + (i / k) * pim.y,
      };
    }
    np[k] = p[k - 1];
    return new Bezier(np);
  }

  derivative(t) {
    return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.compute(t, this.dpoints[0], this._3d);
  }

  dderivative(t) {
    return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.compute(t, this.dpoints[1], this._3d);
  }

  align() {
    let p = this.points;
    return new Bezier(_utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.align(p, { p1: p[0], p2: p[p.length - 1] }));
  }

  curvature(t) {
    return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);
  }

  inflections() {
    return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.inflections(this.points);
  }

  normal(t) {
    return this._3d ? this.__normal3(t) : this.__normal2(t);
  }

  __normal2(t) {
    const d = this.derivative(t);
    const q = sqrt(d.x * d.x + d.y * d.y);
    return { t, x: -d.y / q, y: d.x / q };
  }

  __normal3(t) {
    // see http://stackoverflow.com/questions/25453159
    const r1 = this.derivative(t),
      r2 = this.derivative(t + 0.01),
      q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),
      q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);
    r1.x /= q1;
    r1.y /= q1;
    r1.z /= q1;
    r2.x /= q2;
    r2.y /= q2;
    r2.z /= q2;
    // cross product
    const c = {
      x: r2.y * r1.z - r2.z * r1.y,
      y: r2.z * r1.x - r2.x * r1.z,
      z: r2.x * r1.y - r2.y * r1.x,
    };
    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);
    c.x /= m;
    c.y /= m;
    c.z /= m;
    // rotation matrix
    const R = [
      c.x * c.x,
      c.x * c.y - c.z,
      c.x * c.z + c.y,
      c.x * c.y + c.z,
      c.y * c.y,
      c.y * c.z - c.x,
      c.x * c.z - c.y,
      c.y * c.z + c.x,
      c.z * c.z,
    ];
    // normal vector:
    const n = {
      t,
      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,
      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,
      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,
    };
    return n;
  }

  hull(t) {
    let p = this.points,
      _p = [],
      q = [],
      idx = 0;
    q[idx++] = p[0];
    q[idx++] = p[1];
    q[idx++] = p[2];
    if (this.order === 3) {
      q[idx++] = p[3];
    }
    // we lerp between all points at each iteration, until we have 1 point left.
    while (p.length > 1) {
      _p = [];
      for (let i = 0, pt, l = p.length - 1; i < l; i++) {
        pt = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.lerp(t, p[i], p[i + 1]);
        q[idx++] = pt;
        _p.push(pt);
      }
      p = _p;
    }
    return q;
  }

  split(t1, t2) {
    // shortcuts
    if (t1 === 0 && !!t2) {
      return this.split(t2).left;
    }
    if (t2 === 1) {
      return this.split(t1).right;
    }

    // no shortcut: use "de Casteljau" iteration.
    const q = this.hull(t1);
    const result = {
      left:
        this.order === 2
          ? new Bezier([q[0], q[3], q[5]])
          : new Bezier([q[0], q[4], q[7], q[9]]),
      right:
        this.order === 2
          ? new Bezier([q[5], q[4], q[2]])
          : new Bezier([q[9], q[8], q[6], q[3]]),
      span: q,
    };

    // make sure we bind _t1/_t2 information!
    result.left._t1 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.map(0, 0, 1, this._t1, this._t2);
    result.left._t2 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.map(t1, 0, 1, this._t1, this._t2);
    result.right._t1 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.map(t1, 0, 1, this._t1, this._t2);
    result.right._t2 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.map(1, 0, 1, this._t1, this._t2);

    // if we have no t2, we're done
    if (!t2) {
      return result;
    }

    // if we have a t2, split again:
    t2 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.map(t2, t1, 1, 0, 1);
    return result.right.split(t2).left;
  }

  extrema() {
    const result = {};
    let roots = [];

    this.dims.forEach(
      function (dim) {
        let mfn = function (v) {
          return v[dim];
        };
        let p = this.dpoints[0].map(mfn);
        result[dim] = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.droots(p);
        if (this.order === 3) {
          p = this.dpoints[1].map(mfn);
          result[dim] = result[dim].concat(_utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.droots(p));
        }
        result[dim] = result[dim].filter(function (t) {
          return t >= 0 && t <= 1;
        });
        roots = roots.concat(result[dim].sort(_utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.numberSort));
      }.bind(this)
    );

    result.values = roots.sort(_utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.numberSort).filter(function (v, idx) {
      return roots.indexOf(v) === idx;
    });

    return result;
  }

  bbox() {
    const extrema = this.extrema(),
      result = {};
    this.dims.forEach(
      function (d) {
        result[d] = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.getminmax(this, d, extrema[d]);
      }.bind(this)
    );
    return result;
  }

  overlaps(curve) {
    const lbbox = this.bbox(),
      tbbox = curve.bbox();
    return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.bboxoverlap(lbbox, tbbox);
  }

  offset(t, d) {
    if (typeof d !== "undefined") {
      const c = this.get(t),
        n = this.normal(t);
      const ret = {
        c: c,
        n: n,
        x: c.x + n.x * d,
        y: c.y + n.y * d,
      };
      if (this._3d) {
        ret.z = c.z + n.z * d;
      }
      return ret;
    }
    if (this._linear) {
      const nv = this.normal(0),
        coords = this.points.map(function (p) {
          const ret = {
            x: p.x + t * nv.x,
            y: p.y + t * nv.y,
          };
          if (p.z && nv.z) {
            ret.z = p.z + t * nv.z;
          }
          return ret;
        });
      return [new Bezier(coords)];
    }
    return this.reduce().map(function (s) {
      if (s._linear) {
        return s.offset(t)[0];
      }
      return s.scale(t);
    });
  }

  simple() {
    if (this.order === 3) {
      const a1 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.angle(this.points[0], this.points[3], this.points[1]);
      const a2 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.angle(this.points[0], this.points[3], this.points[2]);
      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;
    }
    const n1 = this.normal(0);
    const n2 = this.normal(1);
    let s = n1.x * n2.x + n1.y * n2.y;
    if (this._3d) {
      s += n1.z * n2.z;
    }
    return abs(acos(s)) < pi / 3;
  }

  reduce() {
    // TODO: examine these var types in more detail...
    let i,
      t1 = 0,
      t2 = 0,
      step = 0.01,
      segment,
      pass1 = [],
      pass2 = [];
    // first pass: split on extrema
    let extrema = this.extrema().values;
    if (extrema.indexOf(0) === -1) {
      extrema = [0].concat(extrema);
    }
    if (extrema.indexOf(1) === -1) {
      extrema.push(1);
    }

    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {
      t2 = extrema[i];
      segment = this.split(t1, t2);
      segment._t1 = t1;
      segment._t2 = t2;
      pass1.push(segment);
      t1 = t2;
    }

    // second pass: further reduce these segments to simple segments
    pass1.forEach(function (p1) {
      t1 = 0;
      t2 = 0;
      while (t2 <= 1) {
        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {
          segment = p1.split(t1, t2);
          if (!segment.simple()) {
            t2 -= step;
            if (abs(t1 - t2) < step) {
              // we can never form a reduction
              return [];
            }
            segment = p1.split(t1, t2);
            segment._t1 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.map(t1, 0, 1, p1._t1, p1._t2);
            segment._t2 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.map(t2, 0, 1, p1._t1, p1._t2);
            pass2.push(segment);
            t1 = t2;
            break;
          }
        }
      }
      if (t1 < 1) {
        segment = p1.split(t1, 1);
        segment._t1 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.map(t1, 0, 1, p1._t1, p1._t2);
        segment._t2 = p1._t2;
        pass2.push(segment);
      }
    });
    return pass2;
  }

  translate(v, d1, d2) {
    d2 = typeof d2 === "number" ? d2 : d1;

    // TODO: make this take curves with control points outside
    //       of the start-end interval into account

    const o = this.order;
    let d = this.points.map((_, i) => (1 - i / o) * d1 + (i / o) * d2);
    return new Bezier(
      this.points.map((p, i) => ({
        x: p.x + v.x * d[i],
        y: p.y + v.y * d[i],
      }))
    );
  }

  scale(d) {
    const order = this.order;
    let distanceFn = false;
    if (typeof d === "function") {
      distanceFn = d;
    }
    if (distanceFn && order === 2) {
      return this.raise().scale(distanceFn);
    }

    // TODO: add special handling for non-linear degenerate curves.

    const clockwise = this.clockwise;
    const points = this.points;

    if (this._linear) {
      return this.translate(
        this.normal(0),
        distanceFn ? distanceFn(0) : d,
        distanceFn ? distanceFn(1) : d
      );
    }

    const r1 = distanceFn ? distanceFn(0) : d;
    const r2 = distanceFn ? distanceFn(1) : d;
    const v = [this.offset(0, 10), this.offset(1, 10)];
    const np = [];
    const o = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.lli4(v[0], v[0].c, v[1], v[1].c);

    if (!o) {
      throw new Error("cannot scale this curve. Try reducing it first.");
    }

    // move all points by distance 'd' wrt the origin 'o',
    // and move end points by fixed distance along normal.
    [0, 1].forEach(function (t) {
      const p = (np[t * order] = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.copy(points[t * order]));
      p.x += (t ? r2 : r1) * v[t].n.x;
      p.y += (t ? r2 : r1) * v[t].n.y;
    });

    if (!distanceFn) {
      // move control points to lie on the intersection of the offset
      // derivative vector, and the origin-through-control vector
      [0, 1].forEach((t) => {
        if (order === 2 && !!t) return;
        const p = np[t * order];
        const d = this.derivative(t);
        const p2 = { x: p.x + d.x, y: p.y + d.y };
        np[t + 1] = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.lli4(p, p2, o, points[t + 1]);
      });
      return new Bezier(np);
    }

    // move control points by "however much necessary to
    // ensure the correct tangent to endpoint".
    [0, 1].forEach(function (t) {
      if (order === 2 && !!t) return;
      var p = points[t + 1];
      var ov = {
        x: p.x - o.x,
        y: p.y - o.y,
      };
      var rc = distanceFn ? distanceFn((t + 1) / order) : d;
      if (distanceFn && !clockwise) rc = -rc;
      var m = sqrt(ov.x * ov.x + ov.y * ov.y);
      ov.x /= m;
      ov.y /= m;
      np[t + 1] = {
        x: p.x + rc * ov.x,
        y: p.y + rc * ov.y,
      };
    });
    return new Bezier(np);
  }

  outline(d1, d2, d3, d4) {
    d2 = d2 === undefined ? d1 : d2;

    if (this._linear) {
      // TODO: find the actual extrema, because they might
      //       be before the start, or past the end.

      const n = this.normal(0);
      const start = this.points[0];
      const end = this.points[this.points.length - 1];
      let s, mid, e;

      if (d3 === undefined) {
        d3 = d1;
        d4 = d2;
      }

      s = { x: start.x + n.x * d1, y: start.y + n.y * d1 };
      e = { x: end.x + n.x * d3, y: end.y + n.y * d3 };
      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };
      const fline = [s, mid, e];

      s = { x: start.x - n.x * d2, y: start.y - n.y * d2 };
      e = { x: end.x - n.x * d4, y: end.y - n.y * d4 };
      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };
      const bline = [e, mid, s];

      const ls = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.makeline(bline[2], fline[0]);
      const le = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.makeline(fline[2], bline[0]);
      const segments = [ls, new Bezier(fline), le, new Bezier(bline)];
      return new _poly_bezier_js__WEBPACK_IMPORTED_MODULE_1__.PolyBezier(segments);
    }

    const reduced = this.reduce(),
      len = reduced.length,
      fcurves = [];

    let bcurves = [],
      p,
      alen = 0,
      tlen = this.length();

    const graduated = typeof d3 !== "undefined" && typeof d4 !== "undefined";

    function linearDistanceFunction(s, e, tlen, alen, slen) {
      return function (v) {
        const f1 = alen / tlen,
          f2 = (alen + slen) / tlen,
          d = e - s;
        return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.map(v, 0, 1, s + f1 * d, s + f2 * d);
      };
    }

    // form curve oulines
    reduced.forEach(function (segment) {
      const slen = segment.length();
      if (graduated) {
        fcurves.push(
          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))
        );
        bcurves.push(
          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))
        );
      } else {
        fcurves.push(segment.scale(d1));
        bcurves.push(segment.scale(-d2));
      }
      alen += slen;
    });

    // reverse the "return" outline
    bcurves = bcurves
      .map(function (s) {
        p = s.points;
        if (p[3]) {
          s.points = [p[3], p[2], p[1], p[0]];
        } else {
          s.points = [p[2], p[1], p[0]];
        }
        return s;
      })
      .reverse();

    // form the endcaps as lines
    const fs = fcurves[0].points[0],
      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],
      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],
      be = bcurves[0].points[0],
      ls = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.makeline(bs, fs),
      le = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.makeline(fe, be),
      segments = [ls].concat(fcurves).concat([le]).concat(bcurves);

    return new _poly_bezier_js__WEBPACK_IMPORTED_MODULE_1__.PolyBezier(segments);
  }

  outlineshapes(d1, d2, curveIntersectionThreshold) {
    d2 = d2 || d1;
    const outline = this.outline(d1, d2).curves;
    const shapes = [];
    for (let i = 1, len = outline.length; i < len / 2; i++) {
      const shape = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.makeshape(
        outline[i],
        outline[len - i],
        curveIntersectionThreshold
      );
      shape.startcap.virtual = i > 1;
      shape.endcap.virtual = i < len / 2 - 1;
      shapes.push(shape);
    }
    return shapes;
  }

  intersects(curve, curveIntersectionThreshold) {
    if (!curve) return this.selfintersects(curveIntersectionThreshold);
    if (curve.p1 && curve.p2) {
      return this.lineIntersects(curve);
    }
    if (curve instanceof Bezier) {
      curve = curve.reduce();
    }
    return this.curveintersects(
      this.reduce(),
      curve,
      curveIntersectionThreshold
    );
  }

  lineIntersects(line) {
    const mx = min(line.p1.x, line.p2.x),
      my = min(line.p1.y, line.p2.y),
      MX = max(line.p1.x, line.p2.x),
      MY = max(line.p1.y, line.p2.y);
    return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.roots(this.points, line).filter((t) => {
      var p = this.get(t);
      return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.between(p.x, mx, MX) && _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.between(p.y, my, MY);
    });
  }

  selfintersects(curveIntersectionThreshold) {
    // "simple" curves cannot intersect with their direct
    // neighbour, so for each segment X we check whether
    // it intersects [0:x-2][x+2:last].

    const reduced = this.reduce(),
      len = reduced.length - 2,
      results = [];

    for (let i = 0, result, left, right; i < len; i++) {
      left = reduced.slice(i, i + 1);
      right = reduced.slice(i + 2);
      result = this.curveintersects(left, right, curveIntersectionThreshold);
      results.push(...result);
    }
    return results;
  }

  curveintersects(c1, c2, curveIntersectionThreshold) {
    const pairs = [];
    // step 1: pair off any overlapping segments
    c1.forEach(function (l) {
      c2.forEach(function (r) {
        if (l.overlaps(r)) {
          pairs.push({ left: l, right: r });
        }
      });
    });
    // step 2: for each pairing, run through the convergence algorithm.
    let intersections = [];
    pairs.forEach(function (pair) {
      const result = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.pairiteration(
        pair.left,
        pair.right,
        curveIntersectionThreshold
      );
      if (result.length > 0) {
        intersections = intersections.concat(result);
      }
    });
    return intersections;
  }

  arcs(errorThreshold) {
    errorThreshold = errorThreshold || 0.5;
    return this._iterate(errorThreshold, []);
  }

  _error(pc, np1, s, e) {
    const q = (e - s) / 4,
      c1 = this.get(s + q),
      c2 = this.get(e - q),
      ref = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.dist(pc, np1),
      d1 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.dist(pc, c1),
      d2 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.dist(pc, c2);
    return abs(d1 - ref) + abs(d2 - ref);
  }

  _iterate(errorThreshold, circles) {
    let t_s = 0,
      t_e = 1,
      safety;
    // we do a binary search to find the "good `t` closest to no-longer-good"
    do {
      safety = 0;

      // step 1: start with the maximum possible arc
      t_e = 1;

      // points:
      let np1 = this.get(t_s),
        np2,
        np3,
        arc,
        prev_arc;

      // booleans:
      let curr_good = false,
        prev_good = false,
        done;

      // numbers:
      let t_m = t_e,
        prev_e = 1,
        step = 0;

      // step 2: find the best possible arc
      do {
        prev_good = curr_good;
        prev_arc = arc;
        t_m = (t_s + t_e) / 2;
        step++;

        np2 = this.get(t_m);
        np3 = this.get(t_e);

        arc = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.getccenter(np1, np2, np3);

        //also save the t values
        arc.interval = {
          start: t_s,
          end: t_e,
        };

        let error = this._error(arc, np1, t_s, t_e);
        curr_good = error <= errorThreshold;

        done = prev_good && !curr_good;
        if (!done) prev_e = t_e;

        // this arc is fine: we can move 'e' up to see if we can find a wider arc
        if (curr_good) {
          // if e is already at max, then we're done for this arc.
          if (t_e >= 1) {
            // make sure we cap at t=1
            arc.interval.end = prev_e = 1;
            prev_arc = arc;
            // if we capped the arc segment to t=1 we also need to make sure that
            // the arc's end angle is correct with respect to the bezier end point.
            if (t_e > 1) {
              let d = {
                x: arc.x + arc.r * cos(arc.e),
                y: arc.y + arc.r * sin(arc.e),
              };
              arc.e += _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));
            }
            break;
          }
          // if not, move it up by half the iteration distance
          t_e = t_e + (t_e - t_s) / 2;
        } else {
          // this is a bad arc: we need to move 'e' down to find a good arc
          t_e = t_m;
        }
      } while (!done && safety++ < 100);

      if (safety >= 100) {
        break;
      }

      // console.log("L835: [F] arc found", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);

      prev_arc = prev_arc ? prev_arc : arc;
      circles.push(prev_arc);
      t_s = prev_e;
    } while (t_e < 1);
    return circles;
  }
}




/***/ }),

/***/ "./node_modules/bezier-js/src/poly-bezier.js":
/*!***************************************************!*\
  !*** ./node_modules/bezier-js/src/poly-bezier.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PolyBezier: () => (/* binding */ PolyBezier)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/bezier-js/src/utils.js");


/**
 * Poly Bezier
 * @param {[type]} curves [description]
 */
class PolyBezier {
  constructor(curves) {
    this.curves = [];
    this._3d = false;
    if (!!curves) {
      this.curves = curves;
      this._3d = this.curves[0]._3d;
    }
  }

  valueOf() {
    return this.toString();
  }

  toString() {
    return (
      "[" +
      this.curves
        .map(function (curve) {
          return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.pointsToString(curve.points);
        })
        .join(", ") +
      "]"
    );
  }

  addCurve(curve) {
    this.curves.push(curve);
    this._3d = this._3d || curve._3d;
  }

  length() {
    return this.curves
      .map(function (v) {
        return v.length();
      })
      .reduce(function (a, b) {
        return a + b;
      });
  }

  curve(idx) {
    return this.curves[idx];
  }

  bbox() {
    const c = this.curves;
    var bbox = c[0].bbox();
    for (var i = 1; i < c.length; i++) {
      _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.expandbox(bbox, c[i].bbox());
    }
    return bbox;
  }

  offset(d) {
    const offset = [];
    this.curves.forEach(function (v) {
      offset.push(...v.offset(d));
    });
    return new PolyBezier(offset);
  }
}




/***/ }),

/***/ "./node_modules/bezier-js/src/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/bezier-js/src/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   utils: () => (/* binding */ utils)
/* harmony export */ });
/* harmony import */ var _bezier_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bezier.js */ "./node_modules/bezier-js/src/bezier.js");


// math-inlining.
const { abs, cos, sin, acos, atan2, sqrt, pow } = Math;

// cube root function yielding real roots
function crt(v) {
  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);
}

// trig constants
const pi = Math.PI,
  tau = 2 * pi,
  quart = pi / 2,
  // float precision significant decimal
  epsilon = 0.000001,
  // extremas used in bbox calculation and similar algorithms
  nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,
  nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,
  // a zero coordinate, which is surprisingly useful
  ZERO = { x: 0, y: 0, z: 0 };

// Bezier utility functions
const utils = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.0640568928626056260850430826247450385909,
    0.0640568928626056260850430826247450385909,
    -0.1911188674736163091586398207570696318404,
    0.1911188674736163091586398207570696318404,
    -0.3150426796961633743867932913198102407864,
    0.3150426796961633743867932913198102407864,
    -0.4337935076260451384870842319133497124524,
    0.4337935076260451384870842319133497124524,
    -0.5454214713888395356583756172183723700107,
    0.5454214713888395356583756172183723700107,
    -0.6480936519369755692524957869107476266696,
    0.6480936519369755692524957869107476266696,
    -0.7401241915785543642438281030999784255232,
    0.7401241915785543642438281030999784255232,
    -0.8200019859739029219539498726697452080761,
    0.8200019859739029219539498726697452080761,
    -0.8864155270044010342131543419821967550873,
    0.8864155270044010342131543419821967550873,
    -0.9382745520027327585236490017087214496548,
    0.9382745520027327585236490017087214496548,
    -0.9747285559713094981983919930081690617411,
    0.9747285559713094981983919930081690617411,
    -0.9951872199970213601799974097007368118745,
    0.9951872199970213601799974097007368118745,
  ],

  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.1279381953467521569740561652246953718517,
    0.1279381953467521569740561652246953718517,
    0.1258374563468282961213753825111836887264,
    0.1258374563468282961213753825111836887264,
    0.121670472927803391204463153476262425607,
    0.121670472927803391204463153476262425607,
    0.1155056680537256013533444839067835598622,
    0.1155056680537256013533444839067835598622,
    0.1074442701159656347825773424466062227946,
    0.1074442701159656347825773424466062227946,
    0.0976186521041138882698806644642471544279,
    0.0976186521041138882698806644642471544279,
    0.086190161531953275917185202983742667185,
    0.086190161531953275917185202983742667185,
    0.0733464814110803057340336152531165181193,
    0.0733464814110803057340336152531165181193,
    0.0592985849154367807463677585001085845412,
    0.0592985849154367807463677585001085845412,
    0.0442774388174198061686027482113382288593,
    0.0442774388174198061686027482113382288593,
    0.0285313886289336631813078159518782864491,
    0.0285313886289336631813078159518782864491,
    0.0123412297999871995468056670700372915759,
    0.0123412297999871995468056670700372915759,
  ],

  arcfn: function (t, derivativeFn) {
    const d = derivativeFn(t);
    let l = d.x * d.x + d.y * d.y;
    if (typeof d.z !== "undefined") {
      l += d.z * d.z;
    }
    return sqrt(l);
  },

  compute: function (t, points, _3d) {
    // shortcuts
    if (t === 0) {
      points[0].t = 0;
      return points[0];
    }

    const order = points.length - 1;

    if (t === 1) {
      points[order].t = 1;
      return points[order];
    }

    const mt = 1 - t;
    let p = points;

    // constant?
    if (order === 0) {
      points[0].t = t;
      return points[0];
    }

    // linear?
    if (order === 1) {
      const ret = {
        x: mt * p[0].x + t * p[1].x,
        y: mt * p[0].y + t * p[1].y,
        t: t,
      };
      if (_3d) {
        ret.z = mt * p[0].z + t * p[1].z;
      }
      return ret;
    }

    // quadratic/cubic curve?
    if (order < 4) {
      let mt2 = mt * mt,
        t2 = t * t,
        a,
        b,
        c,
        d = 0;
      if (order === 2) {
        p = [p[0], p[1], p[2], ZERO];
        a = mt2;
        b = mt * t * 2;
        c = t2;
      } else if (order === 3) {
        a = mt2 * mt;
        b = mt2 * t * 3;
        c = mt * t2 * 3;
        d = t * t2;
      }
      const ret = {
        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,
        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,
        t: t,
      };
      if (_3d) {
        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;
      }
      return ret;
    }

    // higher order curves: use de Casteljau's computation
    const dCpts = JSON.parse(JSON.stringify(points));
    while (dCpts.length > 1) {
      for (let i = 0; i < dCpts.length - 1; i++) {
        dCpts[i] = {
          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,
          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t,
        };
        if (typeof dCpts[i].z !== "undefined") {
          dCpts[i] = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;
        }
      }
      dCpts.splice(dCpts.length - 1, 1);
    }
    dCpts[0].t = t;
    return dCpts[0];
  },

  computeWithRatios: function (t, points, ratios, _3d) {
    const mt = 1 - t,
      r = ratios,
      p = points;

    let f1 = r[0],
      f2 = r[1],
      f3 = r[2],
      f4 = r[3],
      d;

    // spec for linear
    f1 *= mt;
    f2 *= t;

    if (p.length === 2) {
      d = f1 + f2;
      return {
        x: (f1 * p[0].x + f2 * p[1].x) / d,
        y: (f1 * p[0].y + f2 * p[1].y) / d,
        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,
        t: t,
      };
    }

    // upgrade to quadratic
    f1 *= mt;
    f2 *= 2 * mt;
    f3 *= t * t;

    if (p.length === 3) {
      d = f1 + f2 + f3;
      return {
        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,
        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,
        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,
        t: t,
      };
    }

    // upgrade to cubic
    f1 *= mt;
    f2 *= 1.5 * mt;
    f3 *= 3 * mt;
    f4 *= t * t * t;

    if (p.length === 4) {
      d = f1 + f2 + f3 + f4;
      return {
        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,
        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,
        z: !_3d
          ? false
          : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,
        t: t,
      };
    }
  },

  derive: function (points, _3d) {
    const dpoints = [];
    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {
      const list = [];
      for (let j = 0, dpt; j < c; j++) {
        dpt = {
          x: c * (p[j + 1].x - p[j].x),
          y: c * (p[j + 1].y - p[j].y),
        };
        if (_3d) {
          dpt.z = c * (p[j + 1].z - p[j].z);
        }
        list.push(dpt);
      }
      dpoints.push(list);
      p = list;
    }
    return dpoints;
  },

  between: function (v, m, M) {
    return (
      (m <= v && v <= M) ||
      utils.approximately(v, m) ||
      utils.approximately(v, M)
    );
  },

  approximately: function (a, b, precision) {
    return abs(a - b) <= (precision || epsilon);
  },

  length: function (derivativeFn) {
    const z = 0.5,
      len = utils.Tvalues.length;

    let sum = 0;

    for (let i = 0, t; i < len; i++) {
      t = z * utils.Tvalues[i] + z;
      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);
    }
    return z * sum;
  },

  map: function (v, ds, de, ts, te) {
    const d1 = de - ds,
      d2 = te - ts,
      v2 = v - ds,
      r = v2 / d1;
    return ts + d2 * r;
  },

  lerp: function (r, v1, v2) {
    const ret = {
      x: v1.x + r * (v2.x - v1.x),
      y: v1.y + r * (v2.y - v1.y),
    };
    if (v1.z !== undefined && v2.z !== undefined) {
      ret.z = v1.z + r * (v2.z - v1.z);
    }
    return ret;
  },

  pointToString: function (p) {
    let s = p.x + "/" + p.y;
    if (typeof p.z !== "undefined") {
      s += "/" + p.z;
    }
    return s;
  },

  pointsToString: function (points) {
    return "[" + points.map(utils.pointToString).join(", ") + "]";
  },

  copy: function (obj) {
    return JSON.parse(JSON.stringify(obj));
  },

  angle: function (o, v1, v2) {
    const dx1 = v1.x - o.x,
      dy1 = v1.y - o.y,
      dx2 = v2.x - o.x,
      dy2 = v2.y - o.y,
      cross = dx1 * dy2 - dy1 * dx2,
      dot = dx1 * dx2 + dy1 * dy2;
    return atan2(cross, dot);
  },

  // round as string, to avoid rounding errors
  round: function (v, d) {
    const s = "" + v;
    const pos = s.indexOf(".");
    return parseFloat(s.substring(0, pos + 1 + d));
  },

  dist: function (p1, p2) {
    const dx = p1.x - p2.x,
      dy = p1.y - p2.y;
    return sqrt(dx * dx + dy * dy);
  },

  closest: function (LUT, point) {
    let mdist = pow(2, 63),
      mpos,
      d;
    LUT.forEach(function (p, idx) {
      d = utils.dist(point, p);
      if (d < mdist) {
        mdist = d;
        mpos = idx;
      }
    });
    return { mdist: mdist, mpos: mpos };
  },

  abcratio: function (t, n) {
    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc
    if (n !== 2 && n !== 3) {
      return false;
    }
    if (typeof t === "undefined") {
      t = 0.5;
    } else if (t === 0 || t === 1) {
      return t;
    }
    const bottom = pow(t, n) + pow(1 - t, n),
      top = bottom - 1;
    return abs(top / bottom);
  },

  projectionratio: function (t, n) {
    // see u(t) note on http://pomax.github.io/bezierinfo/#abc
    if (n !== 2 && n !== 3) {
      return false;
    }
    if (typeof t === "undefined") {
      t = 0.5;
    } else if (t === 0 || t === 1) {
      return t;
    }
    const top = pow(1 - t, n),
      bottom = pow(t, n) + top;
    return top / bottom;
  },

  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {
    const nx =
        (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
      d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (d == 0) {
      return false;
    }
    return { x: nx / d, y: ny / d };
  },

  lli4: function (p1, p2, p3, p4) {
    const x1 = p1.x,
      y1 = p1.y,
      x2 = p2.x,
      y2 = p2.y,
      x3 = p3.x,
      y3 = p3.y,
      x4 = p4.x,
      y4 = p4.y;
    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);
  },

  lli: function (v1, v2) {
    return utils.lli4(v1, v1.c, v2, v2.c);
  },

  makeline: function (p1, p2) {
    return new _bezier_js__WEBPACK_IMPORTED_MODULE_0__.Bezier(
      p1.x,
      p1.y,
      (p1.x + p2.x) / 2,
      (p1.y + p2.y) / 2,
      p2.x,
      p2.y
    );
  },

  findbbox: function (sections) {
    let mx = nMax,
      my = nMax,
      MX = nMin,
      MY = nMin;
    sections.forEach(function (s) {
      const bbox = s.bbox();
      if (mx > bbox.x.min) mx = bbox.x.min;
      if (my > bbox.y.min) my = bbox.y.min;
      if (MX < bbox.x.max) MX = bbox.x.max;
      if (MY < bbox.y.max) MY = bbox.y.max;
    });
    return {
      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },
      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my },
    };
  },

  shapeintersections: function (
    s1,
    bbox1,
    s2,
    bbox2,
    curveIntersectionThreshold
  ) {
    if (!utils.bboxoverlap(bbox1, bbox2)) return [];
    const intersections = [];
    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];
    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];
    a1.forEach(function (l1) {
      if (l1.virtual) return;
      a2.forEach(function (l2) {
        if (l2.virtual) return;
        const iss = l1.intersects(l2, curveIntersectionThreshold);
        if (iss.length > 0) {
          iss.c1 = l1;
          iss.c2 = l2;
          iss.s1 = s1;
          iss.s2 = s2;
          intersections.push(iss);
        }
      });
    });
    return intersections;
  },

  makeshape: function (forward, back, curveIntersectionThreshold) {
    const bpl = back.points.length;
    const fpl = forward.points.length;
    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);
    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);
    const shape = {
      startcap: start,
      forward: forward,
      back: back,
      endcap: end,
      bbox: utils.findbbox([start, forward, back, end]),
    };
    shape.intersections = function (s2) {
      return utils.shapeintersections(
        shape,
        shape.bbox,
        s2,
        s2.bbox,
        curveIntersectionThreshold
      );
    };
    return shape;
  },

  getminmax: function (curve, d, list) {
    if (!list) return { min: 0, max: 0 };
    let min = nMax,
      max = nMin,
      t,
      c;
    if (list.indexOf(0) === -1) {
      list = [0].concat(list);
    }
    if (list.indexOf(1) === -1) {
      list.push(1);
    }
    for (let i = 0, len = list.length; i < len; i++) {
      t = list[i];
      c = curve.get(t);
      if (c[d] < min) {
        min = c[d];
      }
      if (c[d] > max) {
        max = c[d];
      }
    }
    return { min: min, mid: (min + max) / 2, max: max, size: max - min };
  },

  align: function (points, line) {
    const tx = line.p1.x,
      ty = line.p1.y,
      a = -atan2(line.p2.y - ty, line.p2.x - tx),
      d = function (v) {
        return {
          x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),
          y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a),
        };
      };
    return points.map(d);
  },

  roots: function (points, line) {
    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };

    const order = points.length - 1;
    const aligned = utils.align(points, line);
    const reduce = function (t) {
      return 0 <= t && t <= 1;
    };

    if (order === 2) {
      const a = aligned[0].y,
        b = aligned[1].y,
        c = aligned[2].y,
        d = a - 2 * b + c;
      if (d !== 0) {
        const m1 = -sqrt(b * b - a * c),
          m2 = -a + b,
          v1 = -(m1 + m2) / d,
          v2 = -(-m1 + m2) / d;
        return [v1, v2].filter(reduce);
      } else if (b !== c && d === 0) {
        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);
      }
      return [];
    }

    // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm
    const pa = aligned[0].y,
      pb = aligned[1].y,
      pc = aligned[2].y,
      pd = aligned[3].y;

    let d = -pa + 3 * pb - 3 * pc + pd,
      a = 3 * pa - 6 * pb + 3 * pc,
      b = -3 * pa + 3 * pb,
      c = pa;

    if (utils.approximately(d, 0)) {
      // this is not a cubic curve.
      if (utils.approximately(a, 0)) {
        // in fact, this is not a quadratic curve either.
        if (utils.approximately(b, 0)) {
          // in fact in fact, there are no solutions.
          return [];
        }
        // linear solution:
        return [-c / b].filter(reduce);
      }
      // quadratic solution:
      const q = sqrt(b * b - 4 * a * c),
        a2 = 2 * a;
      return [(q - b) / a2, (-b - q) / a2].filter(reduce);
    }

    // at this point, we know we need a cubic solution:

    a /= d;
    b /= d;
    c /= d;

    const p = (3 * b - a * a) / 3,
      p3 = p / 3,
      q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,
      q2 = q / 2,
      discriminant = q2 * q2 + p3 * p3 * p3;

    let u1, v1, x1, x2, x3;
    if (discriminant < 0) {
      const mp3 = -p / 3,
        mp33 = mp3 * mp3 * mp3,
        r = sqrt(mp33),
        t = -q / (2 * r),
        cosphi = t < -1 ? -1 : t > 1 ? 1 : t,
        phi = acos(cosphi),
        crtr = crt(r),
        t1 = 2 * crtr;
      x1 = t1 * cos(phi / 3) - a / 3;
      x2 = t1 * cos((phi + tau) / 3) - a / 3;
      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;
      return [x1, x2, x3].filter(reduce);
    } else if (discriminant === 0) {
      u1 = q2 < 0 ? crt(-q2) : -crt(q2);
      x1 = 2 * u1 - a / 3;
      x2 = -u1 - a / 3;
      return [x1, x2].filter(reduce);
    } else {
      const sd = sqrt(discriminant);
      u1 = crt(-q2 + sd);
      v1 = crt(q2 + sd);
      return [u1 - v1 - a / 3].filter(reduce);
    }
  },

  droots: function (p) {
    // quadratic roots are easy
    if (p.length === 3) {
      const a = p[0],
        b = p[1],
        c = p[2],
        d = a - 2 * b + c;
      if (d !== 0) {
        const m1 = -sqrt(b * b - a * c),
          m2 = -a + b,
          v1 = -(m1 + m2) / d,
          v2 = -(-m1 + m2) / d;
        return [v1, v2];
      } else if (b !== c && d === 0) {
        return [(2 * b - c) / (2 * (b - c))];
      }
      return [];
    }

    // linear roots are even easier
    if (p.length === 2) {
      const a = p[0],
        b = p[1];
      if (a !== b) {
        return [a / (a - b)];
      }
      return [];
    }

    return [];
  },

  curvature: function (t, d1, d2, _3d, kOnly) {
    let num,
      dnm,
      adk,
      dk,
      k = 0,
      r = 0;

    //
    // We're using the following formula for curvature:
    //
    //              x'y" - y'x"
    //   k(t) = ------------------
    //           (x'² + y'²)^(3/2)
    //
    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition
    //
    // With it corresponding 3D counterpart:
    //
    //          sqrt( (y'z" - y"z')² + (z'x" - z"x')² + (x'y" - x"y')²)
    //   k(t) = -------------------------------------------------------
    //                     (x'² + y'² + z'²)^(3/2)
    //

    const d = utils.compute(t, d1);
    const dd = utils.compute(t, d2);
    const qdsum = d.x * d.x + d.y * d.y;

    if (_3d) {
      num = sqrt(
        pow(d.y * dd.z - dd.y * d.z, 2) +
          pow(d.z * dd.x - dd.z * d.x, 2) +
          pow(d.x * dd.y - dd.x * d.y, 2)
      );
      dnm = pow(qdsum + d.z * d.z, 3 / 2);
    } else {
      num = d.x * dd.y - d.y * dd.x;
      dnm = pow(qdsum, 3 / 2);
    }

    if (num === 0 || dnm === 0) {
      return { k: 0, r: 0 };
    }

    k = num / dnm;
    r = dnm / num;

    // We're also computing the derivative of kappa, because
    // there is value in knowing the rate of change for the
    // curvature along the curve. And we're just going to
    // ballpark it based on an epsilon.
    if (!kOnly) {
      // compute k'(t) based on the interval before, and after it,
      // to at least try to not introduce forward/backward pass bias.
      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;
      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;
      dk = (nk - k + (k - pk)) / 2;
      adk = (abs(nk - k) + abs(k - pk)) / 2;
    }

    return { k: k, r: r, dk: dk, adk: adk };
  },

  inflections: function (points) {
    if (points.length < 4) return [];

    // FIXME: TODO: add in inflection abstraction for quartic+ curves?

    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),
      a = p[2].x * p[1].y,
      b = p[3].x * p[1].y,
      c = p[1].x * p[2].y,
      d = p[3].x * p[2].y,
      v1 = 18 * (-3 * a + 2 * b + 3 * c - d),
      v2 = 18 * (3 * a - b - 3 * c),
      v3 = 18 * (c - a);

    if (utils.approximately(v1, 0)) {
      if (!utils.approximately(v2, 0)) {
        let t = -v3 / v2;
        if (0 <= t && t <= 1) return [t];
      }
      return [];
    }

    const d2 = 2 * v1;

    if (utils.approximately(d2, 0)) return [];

    const trm = v2 * v2 - 4 * v1 * v3;

    if (trm < 0) return [];

    const sq = Math.sqrt(trm);

    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {
      return 0 <= r && r <= 1;
    });
  },

  bboxoverlap: function (b1, b2) {
    const dims = ["x", "y"],
      len = dims.length;

    for (let i = 0, dim, l, t, d; i < len; i++) {
      dim = dims[i];
      l = b1[dim].mid;
      t = b2[dim].mid;
      d = (b1[dim].size + b2[dim].size) / 2;
      if (abs(l - t) >= d) return false;
    }
    return true;
  },

  expandbox: function (bbox, _bbox) {
    if (_bbox.x.min < bbox.x.min) {
      bbox.x.min = _bbox.x.min;
    }
    if (_bbox.y.min < bbox.y.min) {
      bbox.y.min = _bbox.y.min;
    }
    if (_bbox.z && _bbox.z.min < bbox.z.min) {
      bbox.z.min = _bbox.z.min;
    }
    if (_bbox.x.max > bbox.x.max) {
      bbox.x.max = _bbox.x.max;
    }
    if (_bbox.y.max > bbox.y.max) {
      bbox.y.max = _bbox.y.max;
    }
    if (_bbox.z && _bbox.z.max > bbox.z.max) {
      bbox.z.max = _bbox.z.max;
    }
    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;
    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;
    if (bbox.z) {
      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;
    }
    bbox.x.size = bbox.x.max - bbox.x.min;
    bbox.y.size = bbox.y.max - bbox.y.min;
    if (bbox.z) {
      bbox.z.size = bbox.z.max - bbox.z.min;
    }
  },

  pairiteration: function (c1, c2, curveIntersectionThreshold) {
    const c1b = c1.bbox(),
      c2b = c2.bbox(),
      r = 100000,
      threshold = curveIntersectionThreshold || 0.5;

    if (
      c1b.x.size + c1b.y.size < threshold &&
      c2b.x.size + c2b.y.size < threshold
    ) {
      return [
        (((r * (c1._t1 + c1._t2)) / 2) | 0) / r +
          "/" +
          (((r * (c2._t1 + c2._t2)) / 2) | 0) / r,
      ];
    }

    let cc1 = c1.split(0.5),
      cc2 = c2.split(0.5),
      pairs = [
        { left: cc1.left, right: cc2.left },
        { left: cc1.left, right: cc2.right },
        { left: cc1.right, right: cc2.right },
        { left: cc1.right, right: cc2.left },
      ];

    pairs = pairs.filter(function (pair) {
      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());
    });

    let results = [];

    if (pairs.length === 0) return results;

    pairs.forEach(function (pair) {
      results = results.concat(
        utils.pairiteration(pair.left, pair.right, threshold)
      );
    });

    results = results.filter(function (v, i) {
      return results.indexOf(v) === i;
    });

    return results;
  },

  getccenter: function (p1, p2, p3) {
    const dx1 = p2.x - p1.x,
      dy1 = p2.y - p1.y,
      dx2 = p3.x - p2.x,
      dy2 = p3.y - p2.y,
      dx1p = dx1 * cos(quart) - dy1 * sin(quart),
      dy1p = dx1 * sin(quart) + dy1 * cos(quart),
      dx2p = dx2 * cos(quart) - dy2 * sin(quart),
      dy2p = dx2 * sin(quart) + dy2 * cos(quart),
      // chord midpoints
      mx1 = (p1.x + p2.x) / 2,
      my1 = (p1.y + p2.y) / 2,
      mx2 = (p2.x + p3.x) / 2,
      my2 = (p2.y + p3.y) / 2,
      // midpoint offsets
      mx1n = mx1 + dx1p,
      my1n = my1 + dy1p,
      mx2n = mx2 + dx2p,
      my2n = my2 + dy2p,
      // intersection of these lines:
      arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),
      r = utils.dist(arc, p1);

    // arc start/end values, over mid point:
    let s = atan2(p1.y - arc.y, p1.x - arc.x),
      m = atan2(p2.y - arc.y, p2.x - arc.x),
      e = atan2(p3.y - arc.y, p3.x - arc.x),
      _;

    // determine arc direction (cw/ccw correction)
    if (s < e) {
      // if s<m<e, arc(s, e)
      // if m<s<e, arc(e, s + tau)
      // if s<e<m, arc(e, s + tau)
      if (s > m || m > e) {
        s += tau;
      }
      if (s > e) {
        _ = e;
        e = s;
        s = _;
      }
    } else {
      // if e<m<s, arc(e, s)
      // if m<e<s, arc(s, e + tau)
      // if e<s<m, arc(s, e + tau)
      if (e < m && m < s) {
        _ = e;
        e = s;
        s = _;
      } else {
        e += tau;
      }
    }
    // assign and done.
    arc.s = s;
    arc.e = e;
    arc.r = r;
    return arc;
  },

  numberSort: function (a, b) {
    return a - b;
  },
};




/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/Editor.mjs":
/*!**************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/Editor.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Editor: () => (/* binding */ Editor),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./image/EditorImage.mjs */ "./node_modules/js-draw/dist/mjs/image/EditorImage.mjs");
/* harmony import */ var _tools_ToolController_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tools/ToolController.mjs */ "./node_modules/js-draw/dist/mjs/tools/ToolController.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.mjs */ "./node_modules/js-draw/dist/mjs/types.mjs");
/* harmony import */ var _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./inputEvents.mjs */ "./node_modules/js-draw/dist/mjs/inputEvents.mjs");
/* harmony import */ var _UndoRedoHistory_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./UndoRedoHistory.mjs */ "./node_modules/js-draw/dist/mjs/UndoRedoHistory.mjs");
/* harmony import */ var _Viewport_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Viewport.mjs */ "./node_modules/js-draw/dist/mjs/Viewport.mjs");
/* harmony import */ var _EventDispatcher_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./EventDispatcher.mjs */ "./node_modules/js-draw/dist/mjs/EventDispatcher.mjs");
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _rendering_Display_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rendering/Display.mjs */ "./node_modules/js-draw/dist/mjs/rendering/Display.mjs");
/* harmony import */ var _SVGLoader_SVGLoader_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./SVGLoader/SVGLoader.mjs */ "./node_modules/js-draw/dist/mjs/SVGLoader/SVGLoader.mjs");
/* harmony import */ var _Pointer_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Pointer.mjs */ "./node_modules/js-draw/dist/mjs/Pointer.mjs");
/* harmony import */ var _localizations_getLocalizationTable_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./localizations/getLocalizationTable.mjs */ "./node_modules/js-draw/dist/mjs/localizations/getLocalizationTable.mjs");
/* harmony import */ var _toolbar_IconProvider_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./toolbar/IconProvider.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/IconProvider.mjs");
/* harmony import */ var _rendering_renderers_CanvasRenderer_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./rendering/renderers/CanvasRenderer.mjs */ "./node_modules/js-draw/dist/mjs/rendering/renderers/CanvasRenderer.mjs");
/* harmony import */ var _util_untilNextAnimationFrame_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./util/untilNextAnimationFrame.mjs */ "./node_modules/js-draw/dist/mjs/util/untilNextAnimationFrame.mjs");
/* harmony import */ var _commands_uniteCommands_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./commands/uniteCommands.mjs */ "./node_modules/js-draw/dist/mjs/commands/uniteCommands.mjs");
/* harmony import */ var _tools_SelectionTool_SelectionTool_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./tools/SelectionTool/SelectionTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionTool.mjs");
/* harmony import */ var _commands_Erase_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./commands/Erase.mjs */ "./node_modules/js-draw/dist/mjs/commands/Erase.mjs");
/* harmony import */ var _components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./components/BackgroundComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/BackgroundComponent.mjs");
/* harmony import */ var _testing_sendPenEvent_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./testing/sendPenEvent.mjs */ "./node_modules/js-draw/dist/mjs/testing/sendPenEvent.mjs");
/* harmony import */ var _shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./shortcuts/KeyboardShortcutManager.mjs */ "./node_modules/js-draw/dist/mjs/shortcuts/KeyboardShortcutManager.mjs");
/* harmony import */ var _toolbar_EdgeToolbar_mjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./toolbar/EdgeToolbar.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/EdgeToolbar.mjs");
/* harmony import */ var _tools_InputFilter_StrokeKeyboardControl_mjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./tools/InputFilter/StrokeKeyboardControl.mjs */ "./node_modules/js-draw/dist/mjs/tools/InputFilter/StrokeKeyboardControl.mjs");
/* harmony import */ var _util_guessKeyCodeFromKey_mjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./util/guessKeyCodeFromKey.mjs */ "./node_modules/js-draw/dist/mjs/util/guessKeyCodeFromKey.mjs");
/* harmony import */ var _dialogs_makeAboutDialog_mjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./dialogs/makeAboutDialog.mjs */ "./node_modules/js-draw/dist/mjs/dialogs/makeAboutDialog.mjs");
/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./version.mjs */ "./node_modules/js-draw/dist/mjs/version.mjs");
/* harmony import */ var _image_export_editorImageToSVG_mjs__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./image/export/editorImageToSVG.mjs */ "./node_modules/js-draw/dist/mjs/image/export/editorImageToSVG.mjs");
/* harmony import */ var _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./util/ReactiveValue.mjs */ "./node_modules/js-draw/dist/mjs/util/ReactiveValue.mjs");
/* harmony import */ var _util_listenForKeyboardEventsFrom_mjs__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./util/listenForKeyboardEventsFrom.mjs */ "./node_modules/js-draw/dist/mjs/util/listenForKeyboardEventsFrom.mjs");
/* harmony import */ var _util_mitLicenseAttribution_mjs__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./util/mitLicenseAttribution.mjs */ "./node_modules/js-draw/dist/mjs/util/mitLicenseAttribution.mjs");
/* harmony import */ var _util_ClipboardHandler_mjs__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./util/ClipboardHandler.mjs */ "./node_modules/js-draw/dist/mjs/util/ClipboardHandler.mjs");
/* harmony import */ var _tools_InputFilter_ContextMenuRecognizer_mjs__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./tools/InputFilter/ContextMenuRecognizer.mjs */ "./node_modules/js-draw/dist/mjs/tools/InputFilter/ContextMenuRecognizer.mjs");
































/**
 * The main entrypoint for the full editor.
 *
 * ## Example
 * To create an editor with a toolbar,
 * ```ts,runnable
 * import { Editor } from 'js-draw';
 *
 * const editor = new Editor(document.body);
 *
 * const toolbar = editor.addToolbar();
 * toolbar.addSaveButton(() => {
 *   const saveData = editor.toSVG().outerHTML;
 *   // Do something with saveData...
 * });
 * ```
 *
 * See also
 * * [`examples.md`](https://github.com/personalizedrefrigerator/js-draw/blob/main/docs/examples.md).
 */
class Editor {
    /**
     * @example
     * ```ts,runnable
     * import { Editor } from 'js-draw';
     *
     * const container = document.body;
     *
     * // Create an editor
     * const editor = new Editor(container, {
     *   // 2e-10 and 1e12 are the default values for minimum/maximum zoom.
     *   minZoom: 2e-10,
     *   maxZoom: 1e12,
     * });
     *
     * // Add the default toolbar
     * const toolbar = editor.addToolbar();
     *
     * const createCustomIcon = () => {
     *   // Create/return an icon here.
     * };
     *
     * // Add a custom button
     * toolbar.addActionButton({
     *   label: 'Custom Button'
     *   icon: createCustomIcon(),
     * }, () => {
     *   // Do something here
     * });
     * ```
     */
    constructor(parent, settings = {}) {
        this.eventListenerTargets = [];
        this.previousAccessibilityAnnouncement = '';
        this.pointers = {};
        this.announceUndoCallback = (command) => {
            this.announceForAccessibility(this.localization.undoAnnouncement(command.description(this, this.localization)));
        };
        this.announceRedoCallback = (command) => {
            this.announceForAccessibility(this.localization.redoAnnouncement(command.description(this, this.localization)));
        };
        // Listeners to be called once at the end of the next re-render.
        this.nextRerenderListeners = [];
        this.rerenderQueued = false;
        this.closeAboutDialog = null;
        this.localization = {
            ...(0,_localizations_getLocalizationTable_mjs__WEBPACK_IMPORTED_MODULE_11__["default"])(),
            ...settings.localization,
        };
        // Fill default settings.
        this.settings = {
            wheelEventsEnabled: settings.wheelEventsEnabled ?? true,
            renderingMode: settings.renderingMode ?? _rendering_Display_mjs__WEBPACK_IMPORTED_MODULE_8__.RenderingMode.CanvasRenderer,
            localization: this.localization,
            minZoom: settings.minZoom ?? 2e-10,
            maxZoom: settings.maxZoom ?? 1e12,
            keyboardShortcutOverrides: settings.keyboardShortcutOverrides ?? {},
            iconProvider: settings.iconProvider ?? new _toolbar_IconProvider_mjs__WEBPACK_IMPORTED_MODULE_12__["default"](),
            notices: settings.notices ?? [],
            appInfo: settings.appInfo ? { ...settings.appInfo } : null,
            pens: {
                additionalPenTypes: settings.pens?.additionalPenTypes ?? [],
                filterPenTypes: settings.pens?.filterPenTypes ?? (() => true),
            },
            text: {
                fonts: settings.text?.fonts ?? ['sans-serif', 'serif', 'monospace'],
            },
            image: {
                showImagePicker: settings.image?.showImagePicker ?? undefined,
            },
            clipboardApi: settings.clipboardApi ?? null,
        };
        // Validate settings
        if (this.settings.minZoom > this.settings.maxZoom) {
            throw new Error('Minimum zoom must be lesser than maximum zoom!');
        }
        this.readOnly = _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_27__.MutableReactiveValue.fromInitialValue(false);
        this.icons = this.settings.iconProvider;
        this.shortcuts = new _shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_20__["default"](this.settings.keyboardShortcutOverrides);
        this.container = document.createElement('div');
        this.renderingRegion = document.createElement('div');
        this.container.appendChild(this.renderingRegion);
        this.container.classList.add('imageEditorContainer', 'js-draw');
        this.loadingWarning = document.createElement('div');
        this.loadingWarning.classList.add('loadingMessage');
        this.loadingWarning.ariaLive = 'polite';
        this.container.appendChild(this.loadingWarning);
        this.accessibilityControlArea = document.createElement('textarea');
        this.accessibilityControlArea.setAttribute('placeholder', this.localization.accessibilityInputInstructions);
        this.accessibilityControlArea.style.opacity = '0';
        this.accessibilityControlArea.style.width = '0';
        this.accessibilityControlArea.style.height = '0';
        this.accessibilityControlArea.style.position = 'absolute';
        this.accessibilityAnnounceArea = document.createElement('div');
        this.accessibilityAnnounceArea.setAttribute('aria-live', 'assertive');
        this.accessibilityAnnounceArea.className = 'accessibilityAnnouncement';
        this.container.appendChild(this.accessibilityAnnounceArea);
        this.renderingRegion.style.touchAction = 'none';
        this.renderingRegion.className = 'imageEditorRenderArea';
        this.renderingRegion.appendChild(this.accessibilityControlArea);
        this.renderingRegion.setAttribute('tabIndex', '0');
        this.renderingRegion.setAttribute('alt', '');
        this.notifier = new _EventDispatcher_mjs__WEBPACK_IMPORTED_MODULE_6__["default"]();
        this.viewport = new _Viewport_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]((oldTransform, newTransform) => {
            this.notifier.dispatch(_types_mjs__WEBPACK_IMPORTED_MODULE_2__.EditorEventType.ViewportChanged, {
                kind: _types_mjs__WEBPACK_IMPORTED_MODULE_2__.EditorEventType.ViewportChanged,
                newTransform,
                oldTransform,
            });
        });
        this.display = new _rendering_Display_mjs__WEBPACK_IMPORTED_MODULE_8__["default"](this, this.settings.renderingMode, this.renderingRegion);
        this.image = new _image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this.history = new _UndoRedoHistory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"](this, this.announceRedoCallback, this.announceUndoCallback);
        this.toolController = new _tools_ToolController_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](this, this.localization);
        // TODO: Make this pipeline configurable (e.g. allow users to add global input stabilization)
        this.toolController.addInputMapper(_tools_InputFilter_StrokeKeyboardControl_mjs__WEBPACK_IMPORTED_MODULE_22__["default"].fromEditor(this));
        this.toolController.addInputMapper(new _tools_InputFilter_ContextMenuRecognizer_mjs__WEBPACK_IMPORTED_MODULE_31__["default"]());
        parent.appendChild(this.container);
        this.viewport.updateScreenSize(_js_draw_math__WEBPACK_IMPORTED_MODULE_7__.Vec2.of(this.display.width, this.display.height));
        this.registerListeners();
        this.queueRerender();
        this.hideLoadingWarning();
        // Enforce zoom limits.
        this.notifier.on(_types_mjs__WEBPACK_IMPORTED_MODULE_2__.EditorEventType.ViewportChanged, (evt) => {
            if (evt.kind !== _types_mjs__WEBPACK_IMPORTED_MODULE_2__.EditorEventType.ViewportChanged)
                return;
            const getZoom = (mat) => mat.transformVec3(_js_draw_math__WEBPACK_IMPORTED_MODULE_7__.Vec2.unitX).length();
            const zoom = getZoom(evt.newTransform);
            if (zoom > this.settings.maxZoom || zoom < this.settings.minZoom) {
                const oldZoom = getZoom(evt.oldTransform);
                let resetTransform = _js_draw_math__WEBPACK_IMPORTED_MODULE_7__.Mat33.identity;
                if (oldZoom <= this.settings.maxZoom && oldZoom >= this.settings.minZoom) {
                    resetTransform = evt.oldTransform;
                }
                else {
                    // If 1x zoom isn't acceptable, try a zoom between the minimum and maximum.
                    resetTransform = _js_draw_math__WEBPACK_IMPORTED_MODULE_7__.Mat33.scaling2D((this.settings.minZoom + this.settings.maxZoom) / 2);
                }
                this.viewport.resetTransform(resetTransform);
            }
            else if (!isFinite(zoom)) {
                // Recover from possible division-by-zero
                console.warn(`Non-finite zoom (${zoom}) detected. Resetting the viewport. This was likely caused by division by zero.`);
                if (isFinite(getZoom(evt.oldTransform))) {
                    this.viewport.resetTransform(evt.oldTransform);
                }
                else {
                    this.viewport.resetTransform();
                }
            }
        });
    }
    /**
     * @returns a shallow copy of the current settings of the editor.
     *
     * Do not modify.
     */
    getCurrentSettings() {
        return {
            ...this.settings,
        };
    }
    /**
     * @returns a reference to the editor's container.
     *
     * @example
     * ```
     *   // Set the editor's height to 500px
     *   editor.getRootElement().style.height = '500px';
     * ```
     */
    getRootElement() {
        return this.container;
    }
    /**
     * @returns the bounding box of the main rendering region of the editor in the HTML viewport.
     *
     * @internal
     */
    getOutputBBoxInDOM() {
        return _js_draw_math__WEBPACK_IMPORTED_MODULE_7__.Rect2.of(this.renderingRegion.getBoundingClientRect());
    }
    /**
     * Shows a "Loading..." message.
     * @param fractionLoaded - should be a number from 0 to 1, where 1 represents completely loaded.
     */
    showLoadingWarning(fractionLoaded) {
        const loadingPercent = Math.round(fractionLoaded * 100);
        this.loadingWarning.innerText = this.localization.loading(loadingPercent);
        this.loadingWarning.style.display = 'block';
    }
    /** @see {@link showLoadingWarning} */
    hideLoadingWarning() {
        this.loadingWarning.style.display = 'none';
        this.announceForAccessibility(this.localization.doneLoading);
    }
    /**
     * Announce `message` for screen readers. If `message` is the same as the previous
     * message, it is re-announced.
     */
    announceForAccessibility(message) {
        // Force re-announcing an announcement if announced again.
        if (message === this.previousAccessibilityAnnouncement) {
            message = message + '. ';
        }
        this.accessibilityAnnounceArea.innerText = message;
        this.previousAccessibilityAnnouncement = message;
    }
    /**
     * Creates a toolbar. If `defaultLayout` is true, default buttons are used.
     * @returns a reference to the toolbar.
     */
    addToolbar(defaultLayout = true) {
        const toolbar = new _toolbar_EdgeToolbar_mjs__WEBPACK_IMPORTED_MODULE_21__["default"](this, this.container, this.localization);
        if (defaultLayout) {
            toolbar.addDefaults();
        }
        return toolbar;
    }
    registerListeners() {
        this.handlePointerEventsFrom(this.renderingRegion);
        this.handleKeyEventsFrom(this.renderingRegion);
        this.handlePointerEventsFrom(this.accessibilityAnnounceArea);
        // Prevent selected text from control areas from being dragged.
        // See https://github.com/personalizedrefrigerator/joplin-plugin-freehand-drawing/issues/8
        const preventSelectionOf = [
            this.renderingRegion,
            this.accessibilityAnnounceArea,
            this.accessibilityControlArea,
            this.loadingWarning,
        ];
        for (const element of preventSelectionOf) {
            element.addEventListener('drag', (event) => {
                event.preventDefault();
                return false;
            });
            element.addEventListener('dragstart', (event) => {
                event.preventDefault();
                return false;
            });
        }
        this.container.addEventListener('wheel', (evt) => {
            this.handleHTMLWheelEvent(evt);
        });
        const handleResize = () => {
            this.viewport.updateScreenSize(_js_draw_math__WEBPACK_IMPORTED_MODULE_7__.Vec2.of(this.display.width, this.display.height));
            this.rerender();
            this.updateEditorSizeVariables();
        };
        if ('ResizeObserver' in window) {
            const resizeObserver = new ResizeObserver(handleResize);
            resizeObserver.observe(this.renderingRegion);
            resizeObserver.observe(this.container);
        }
        else {
            addEventListener('resize', handleResize);
        }
        this.accessibilityControlArea.addEventListener('input', () => {
            this.accessibilityControlArea.value = '';
        });
        const copyHandler = new _util_ClipboardHandler_mjs__WEBPACK_IMPORTED_MODULE_30__["default"](this);
        document.addEventListener('copy', async (evt) => {
            if (!this.isEventSink(document.querySelector(':focus'))) {
                return;
            }
            copyHandler.copy(evt);
        });
        document.addEventListener('paste', (evt) => {
            this.handlePaste(evt);
        });
    }
    updateEditorSizeVariables() {
        // Add CSS variables so that absolutely-positioned children of the editor can
        // still fill the screen.
        this.container.style.setProperty('--editor-current-width-px', `${this.container.clientWidth}px`);
        this.container.style.setProperty('--editor-current-height-px', `${this.container.clientHeight}px`);
        this.container.style.setProperty('--editor-current-display-width-px', `${this.renderingRegion.clientWidth}px`);
        this.container.style.setProperty('--editor-current-display-height-px', `${this.renderingRegion.clientHeight}px`);
    }
    /** @internal */
    handleHTMLWheelEvent(event) {
        let delta = _js_draw_math__WEBPACK_IMPORTED_MODULE_7__.Vec3.of(event.deltaX, event.deltaY, event.deltaZ);
        // Process wheel events if the ctrl key is down, even if disabled -- we do want to handle
        // pinch-zooming.
        if (!event.ctrlKey && !event.metaKey) {
            if (!this.settings.wheelEventsEnabled) {
                return;
            }
            else if (this.settings.wheelEventsEnabled === 'only-if-focused') {
                const focusedChild = this.container.querySelector(':focus');
                if (!focusedChild) {
                    return;
                }
            }
        }
        if (event.deltaMode === WheelEvent.DOM_DELTA_LINE) {
            delta = delta.times(15);
        }
        else if (event.deltaMode === WheelEvent.DOM_DELTA_PAGE) {
            delta = delta.times(100);
        }
        if (event.ctrlKey || event.metaKey) {
            delta = _js_draw_math__WEBPACK_IMPORTED_MODULE_7__.Vec3.of(0, 0, event.deltaY);
        }
        // Ensure that `pos` is relative to `this.renderingRegion`
        const bbox = this.getOutputBBoxInDOM();
        const pos = _js_draw_math__WEBPACK_IMPORTED_MODULE_7__.Vec2.of(event.clientX, event.clientY).minus(bbox.topLeft);
        if (this.toolController.dispatchInputEvent({
            kind: _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_3__.InputEvtType.WheelEvt,
            delta,
            screenPos: pos,
        })) {
            event.preventDefault();
            return true;
        }
        return false;
    }
    getPointerList() {
        const nowTime = performance.now();
        const res = [];
        for (const id in this.pointers) {
            const maxUnupdatedTime = 2000; // Maximum time without a pointer update (ms)
            if (this.pointers[id] && nowTime - this.pointers[id].timeStamp < maxUnupdatedTime) {
                res.push(this.pointers[id]);
            }
        }
        return res;
    }
    /**
     * A protected method that can override setPointerCapture in environments where it may fail
     * (e.g. with synthetic events). @internal
     */
    setPointerCapture(target, pointerId) {
        try {
            target.setPointerCapture(pointerId);
        }
        catch (error) {
            console.warn('Failed to setPointerCapture', error);
        }
    }
    /** Can be overridden in a testing environment to handle synthetic events. @internal */
    releasePointerCapture(target, pointerId) {
        try {
            target.releasePointerCapture(pointerId);
        }
        catch (error) {
            console.warn('Failed to releasePointerCapture', error);
        }
    }
    /**
     * Dispatches a `PointerEvent` to the editor. The target element for `evt` must have the same top left
     * as the content of the editor.
     */
    handleHTMLPointerEvent(eventType, evt) {
        const eventsRelativeTo = this.renderingRegion;
        const eventTarget = evt.target ?? this.renderingRegion;
        if (eventType === 'pointerdown') {
            const pointer = _Pointer_mjs__WEBPACK_IMPORTED_MODULE_10__["default"].ofEvent(evt, true, this.viewport, eventsRelativeTo);
            this.pointers[pointer.id] = pointer;
            this.setPointerCapture(eventTarget, pointer.id);
            const event = {
                kind: _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_3__.InputEvtType.PointerDownEvt,
                current: pointer,
                allPointers: this.getPointerList(),
            };
            this.toolController.dispatchInputEvent(event);
            return true;
        }
        else if (eventType === 'pointermove') {
            const pointer = _Pointer_mjs__WEBPACK_IMPORTED_MODULE_10__["default"].ofEvent(evt, this.pointers[evt.pointerId]?.down ?? false, this.viewport, eventsRelativeTo);
            if (pointer.down) {
                const prevData = this.pointers[pointer.id];
                if (prevData) {
                    const distanceMoved = pointer.screenPos.distanceTo(prevData.screenPos);
                    // If the pointer moved less than two pixels, don't send a new event.
                    if (distanceMoved < 2) {
                        return false;
                    }
                }
                this.pointers[pointer.id] = pointer;
                if (this.toolController.dispatchInputEvent({
                    kind: _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_3__.InputEvtType.PointerMoveEvt,
                    current: pointer,
                    allPointers: this.getPointerList(),
                })) {
                    evt.preventDefault();
                }
            }
            return true;
        }
        else if (eventType === 'pointercancel' || eventType === 'pointerup') {
            const pointer = _Pointer_mjs__WEBPACK_IMPORTED_MODULE_10__["default"].ofEvent(evt, false, this.viewport, eventsRelativeTo);
            if (!this.pointers[pointer.id]) {
                return false;
            }
            this.pointers[pointer.id] = pointer;
            this.releasePointerCapture(eventTarget, pointer.id);
            if (this.toolController.dispatchInputEvent({
                kind: _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_3__.InputEvtType.PointerUpEvt,
                current: pointer,
                allPointers: this.getPointerList(),
            })) {
                evt.preventDefault();
            }
            delete this.pointers[pointer.id];
            return true;
        }
        return eventType;
    }
    isEventSink(evtTarget) {
        let currentElem = evtTarget;
        while (currentElem !== null) {
            for (const elem of this.eventListenerTargets) {
                if (elem === currentElem) {
                    return true;
                }
            }
            currentElem = currentElem.parentElement;
        }
        return false;
    }
    /** @internal */
    async handleDrop(evt) {
        evt.preventDefault();
        await this.handlePaste(evt);
    }
    /** @internal */
    async handlePaste(evt) {
        const target = document.querySelector(':focus') ?? evt.target;
        if (!this.isEventSink(target)) {
            return;
        }
        return await new _util_ClipboardHandler_mjs__WEBPACK_IMPORTED_MODULE_30__["default"](this).paste(evt);
    }
    /**
     * Forward pointer events from `elem` to this editor. Such that right-click/right-click drag
     * events are also forwarded, `elem`'s contextmenu is disabled.
     *
     * `filter` is called once per pointer event, before doing any other processing. If `filter` returns `true` the event is
     * forwarded to the editor.
     *
     * **Note**: `otherEventsFilter` is like `filter`, but is called for other pointer-related
     * events that could also be forwarded to the editor. To forward just pointer events,
     * for example, `otherEventsFilter` could be given as `()=>false`.
     *
     * @example
     * ```ts
     * const overlay = document.createElement('div');
     * editor.createHTMLOverlay(overlay);
     *
     * // Send all pointer events that don't have the control key pressed
     * // to the editor.
     * editor.handlePointerEventsFrom(overlay, (event) => {
     *   if (event.ctrlKey) {
     *     return false;
     *   }
     *   return true;
     * });
     * ```
     */
    handlePointerEventsFrom(elem, filter, otherEventsFilter) {
        // May be required to prevent text selection on iOS/Safari:
        // See https://stackoverflow.com/a/70992717/17055750
        const touchstartListener = (evt) => {
            if (otherEventsFilter && !otherEventsFilter('touchstart', evt)) {
                return;
            }
            evt.preventDefault();
        };
        const contextmenuListener = (evt) => {
            if (otherEventsFilter && !otherEventsFilter('contextmenu', evt)) {
                return;
            }
            // Don't show a context menu
            evt.preventDefault();
        };
        const listeners = {
            touchstart: touchstartListener,
            contextmenu: contextmenuListener,
        };
        const eventNames = [
            'pointerdown',
            'pointermove',
            'pointerup',
            'pointercancel',
        ];
        for (const eventName of eventNames) {
            listeners[eventName] = (evt) => {
                // This listener will only be called in the context of PointerEvents.
                const event = evt;
                if (filter && !filter(eventName, event)) {
                    return undefined;
                }
                return this.handleHTMLPointerEvent(eventName, event);
            };
        }
        // Add all listeners.
        for (const eventName in listeners) {
            elem.addEventListener(eventName, listeners[eventName]);
        }
        return {
            /** Remove all event listeners registered by this function. */
            remove: () => {
                for (const eventName in listeners) {
                    elem.removeEventListener(eventName, listeners[eventName]);
                }
            },
        };
    }
    /**
     * Like {@link handlePointerEventsFrom} except ignores short input gestures like clicks.
     *
     * `filter` is called once per event, before doing any other processing. If `filter` returns `true` the event is
     * forwarded to the editor.
     *
     * `otherEventsFilter` is passed unmodified to `handlePointerEventsFrom`.
     */
    handlePointerEventsExceptClicksFrom(elem, filter, otherEventsFilter) {
        // Maps pointer IDs to gesture start points
        const gestureData = Object.create(null);
        return this.handlePointerEventsFrom(elem, (eventName, event) => {
            if (filter && !filter(eventName, event)) {
                return false;
            }
            // Position of the current event.
            // jsdom doesn't seem to support pageX/pageY -- use clientX/clientY if unavailable
            const currentPos = _js_draw_math__WEBPACK_IMPORTED_MODULE_7__.Vec2.of(event.pageX ?? event.clientX, event.pageY ?? event.clientY);
            const pointerId = event.pointerId ?? 0;
            // Whether to send the current event to the editor
            let sendToEditor = true;
            if (eventName === 'pointerdown') {
                // Buffer the event, but don't send it to the editor yet.
                // We don't want to send single-click events, but we do want to send full strokes.
                gestureData[pointerId] = {
                    eventBuffer: [[eventName, event]],
                    startPoint: currentPos,
                    hasMovedSignificantly: false,
                };
                // Capture the pointer so we receive future events even if the overlay is hidden.
                this.setPointerCapture(elem, event.pointerId);
                // Don't send to the editor.
                sendToEditor = false;
            }
            else if (eventName === 'pointermove' && gestureData[pointerId]) {
                const gestureStartPos = gestureData[pointerId].startPoint;
                const eventBuffer = gestureData[pointerId].eventBuffer;
                // Skip if the pointer hasn't moved enough to not be a "click".
                const strokeStartThreshold = 10;
                const isWithinClickThreshold = gestureStartPos && currentPos.distanceTo(gestureStartPos) < strokeStartThreshold;
                if (isWithinClickThreshold && !gestureData[pointerId].hasMovedSignificantly) {
                    eventBuffer.push([eventName, event]);
                    sendToEditor = false;
                }
                else {
                    // Send all buffered events to the editor -- start the stroke.
                    for (const [eventName, event] of eventBuffer) {
                        this.handleHTMLPointerEvent(eventName, event);
                    }
                    gestureData[pointerId].eventBuffer = [];
                    gestureData[pointerId].hasMovedSignificantly = true;
                    sendToEditor = true;
                }
            }
            // Pointers that aren't down -- send to the editor.
            else if (eventName === 'pointermove') {
                sendToEditor = true;
            }
            // Otherwise, if we received a pointerup/pointercancel without flushing all pointerevents from the
            // buffer, the gesture wasn't recognised as a stroke. Thus, the editor isn't expecting a pointerup/
            // pointercancel event.
            else if ((eventName === 'pointerup' || eventName === 'pointercancel') &&
                gestureData[pointerId] &&
                gestureData[pointerId].eventBuffer.length > 0) {
                this.releasePointerCapture(elem, event.pointerId);
                // Don't send to the editor.
                sendToEditor = false;
                delete gestureData[pointerId];
            }
            // Forward all other events to the editor.
            return sendToEditor;
        }, otherEventsFilter);
    }
    /** @internal */
    handleHTMLKeyDownEvent(htmlEvent) {
        console.assert(htmlEvent.type === 'keydown', `handling a keydown event with type ${htmlEvent.type}`);
        const event = (0,_inputEvents_mjs__WEBPACK_IMPORTED_MODULE_3__.keyPressEventFromHTMLEvent)(htmlEvent);
        if (this.toolController.dispatchInputEvent(event)) {
            htmlEvent.preventDefault();
            return true;
        }
        else if (event.key === 't' || event.key === 'T') {
            htmlEvent.preventDefault();
            this.display.rerenderAsText();
            return true;
        }
        else if (event.key === 'Escape') {
            this.renderingRegion.blur();
            return true;
        }
        return false;
    }
    /** @internal */
    handleHTMLKeyUpEvent(htmlEvent) {
        console.assert(htmlEvent.type === 'keyup', `Handling a keyup event with type ${htmlEvent.type}`);
        const event = (0,_inputEvents_mjs__WEBPACK_IMPORTED_MODULE_3__.keyUpEventFromHTMLEvent)(htmlEvent);
        if (this.toolController.dispatchInputEvent(event)) {
            htmlEvent.preventDefault();
            return true;
        }
        return false;
    }
    /**
     * Adds event listners for keypresses (and drop events) on `elem` and forwards those
     * events to the editor.
     *
     * If the given `filter` returns `false` for an event, the event is ignored and not
     * passed to the editor.
     */
    handleKeyEventsFrom(elem, filter = () => true) {
        (0,_util_listenForKeyboardEventsFrom_mjs__WEBPACK_IMPORTED_MODULE_28__["default"])(elem, {
            filter,
            handleKeyDown: (htmlEvent) => {
                this.handleHTMLKeyDownEvent(htmlEvent);
            },
            handleKeyUp: (htmlEvent) => {
                this.handleHTMLKeyUpEvent(htmlEvent);
            },
            getHandlesKeyEventsFrom: (element) => {
                return this.eventListenerTargets.includes(element);
            },
        });
        // Allow drop.
        elem.ondragover = (evt) => {
            evt.preventDefault();
        };
        elem.ondrop = (evt) => {
            this.handleDrop(evt);
        };
        this.eventListenerTargets.push(elem);
    }
    /**
     * Attempts to prevent **user-triggered** events from modifying
     * the content of the image.
     */
    setReadOnly(readOnly) {
        if (readOnly !== this.readOnly.get()) {
            this.readOnly.set(readOnly);
            this.notifier.dispatch(_types_mjs__WEBPACK_IMPORTED_MODULE_2__.EditorEventType.ReadOnlyModeToggled, {
                kind: _types_mjs__WEBPACK_IMPORTED_MODULE_2__.EditorEventType.ReadOnlyModeToggled,
                editorIsReadOnly: readOnly,
            });
        }
    }
    // @internal
    isReadOnlyReactiveValue() {
        return this.readOnly;
    }
    isReadOnly() {
        return this.readOnly;
    }
    /**
     * `apply` a command. `command` will be announced for accessibility.
     *
     * **Example**:
     * [[include:doc-pages/inline-examples/adding-a-stroke.md]]
     */
    dispatch(command, addToHistory = true) {
        const dispatchResult = this.dispatchNoAnnounce(command, addToHistory);
        const commandDescription = command.description(this, this.localization);
        this.announceForAccessibility(commandDescription);
        return dispatchResult;
    }
    /**
     * Dispatches a command without announcing it. By default, does not add to history.
     * Use this to show finalized commands that don't need to have `announceForAccessibility`
     * called.
     *
     * If `addToHistory` is `false`, this is equivalent to `command.apply(editor)`.
     *
     * @example
     * ```
     * const addToHistory = false;
     * editor.dispatchNoAnnounce(editor.viewport.zoomTo(someRectangle), addToHistory);
     * ```
     */
    dispatchNoAnnounce(command, addToHistory = false) {
        const result = command.apply(this);
        if (addToHistory) {
            const apply = false; // Don't double-apply
            this.history.push(command, apply);
        }
        return result;
    }
    /**
     * Apply a large transformation in chunks.
     * If `apply` is `false`, the commands are unapplied.
     * Triggers a re-render after each `updateChunkSize`-sized group of commands
     * has been applied.
     */
    async asyncApplyOrUnapplyCommands(commands, apply, updateChunkSize) {
        console.assert(updateChunkSize > 0);
        this.display.setDraftMode(true);
        for (let i = 0; i < commands.length; i += updateChunkSize) {
            this.showLoadingWarning(i / commands.length);
            for (let j = i; j < commands.length && j < i + updateChunkSize; j++) {
                const cmd = commands[j];
                if (apply) {
                    cmd.apply(this);
                }
                else {
                    cmd.unapply(this);
                }
            }
            // Re-render to show progress, but only if we're not done.
            if (i + updateChunkSize < commands.length) {
                await new Promise((resolve) => {
                    this.rerender();
                    requestAnimationFrame(resolve);
                });
            }
        }
        this.display.setDraftMode(false);
        this.hideLoadingWarning();
    }
    /** @see {@link asyncApplyOrUnapplyCommands } */
    asyncApplyCommands(commands, chunkSize) {
        return this.asyncApplyOrUnapplyCommands(commands, true, chunkSize);
    }
    /**
     * @see {@link asyncApplyOrUnapplyCommands}
     *
     * If `unapplyInReverseOrder`, commands are reversed before unapplying.
     */
    asyncUnapplyCommands(commands, chunkSize, unapplyInReverseOrder = false) {
        if (unapplyInReverseOrder) {
            commands = [...commands]; // copy
            commands.reverse();
        }
        return this.asyncApplyOrUnapplyCommands(commands, false, chunkSize);
    }
    /**
     * Schedule a re-render for some time in the near future. Does not schedule an additional
     * re-render if a re-render is already queued.
     *
     * @returns a promise that resolves when re-rendering has completed.
     */
    queueRerender() {
        if (!this.rerenderQueued) {
            this.rerenderQueued = true;
            requestAnimationFrame(() => {
                // If .rerender was called manually, we might not need to
                // re-render.
                if (this.rerenderQueued) {
                    this.rerender();
                    this.rerenderQueued = false;
                }
            });
        }
        return new Promise((resolve) => {
            this.nextRerenderListeners.push(() => resolve());
        });
    }
    // @internal
    isRerenderQueued() {
        return this.rerenderQueued;
    }
    /**
     * Re-renders the entire image.
     *
     * @see {@link Editor.queueRerender}
     */
    rerender(showImageBounds = true) {
        this.display.startRerender();
        // Don't render if the display has zero size.
        if (this.display.width === 0 || this.display.height === 0) {
            return;
        }
        const renderer = this.display.getDryInkRenderer();
        this.image.renderWithCache(renderer, this.display.getCache(), this.viewport);
        // Draw a rectangle around the region that will be visible on save
        if (showImageBounds && !this.image.getAutoresizeEnabled()) {
            const exportRectFill = { fill: _js_draw_math__WEBPACK_IMPORTED_MODULE_7__.Color4.fromHex('#44444455') };
            const exportRectStrokeWidth = 5 * this.viewport.getSizeOfPixelOnCanvas();
            renderer.drawRect(this.getImportExportRect(), exportRectStrokeWidth, exportRectFill);
        }
        this.rerenderQueued = false;
        this.nextRerenderListeners.forEach((listener) => listener());
        this.nextRerenderListeners = [];
    }
    /**
     * Draws the given path onto the wet ink renderer. The given path will
     * be displayed on top of the main image.
     *
     * @see {@link Display.getWetInkRenderer} {@link Display.flatten}
     */
    drawWetInk(...path) {
        for (const part of path) {
            this.display.getWetInkRenderer().drawPath(part);
        }
    }
    /**
     * Clears the wet ink display.
     *
     * The wet ink display can be used by the currently active tool to display a preview
     * of an in-progress action.
     *
     * @see {@link Display.getWetInkRenderer}
     */
    clearWetInk() {
        this.display.getWetInkRenderer().clear();
    }
    /**
     * Focuses the region used for text input/key commands.
     */
    focus() {
        this.renderingRegion.focus();
    }
    /**
     * Creates an element that will be positioned on top of the dry/wet ink
     * renderers.
     *
     * So as not to change the position of other overlays, `overlay` should either
     * be styled to have 0 height or have `position: absolute`.
     *
     * This is useful for displaying content on top of the rendered content
     * (e.g. a selection box).
     */
    createHTMLOverlay(overlay) {
        // TODO(v2): Fix conflict with toolbars that have been added to the editor.
        overlay.classList.add('overlay', 'js-draw-editor-overlay');
        this.container.appendChild(overlay);
        return {
            remove: () => overlay.remove(),
        };
    }
    /**
     * Anchors the given `element` to the canvas with a given position/transformation in canvas space.
     */
    anchorElementToCanvas(element, canvasTransform) {
        if (canvasTransform instanceof _js_draw_math__WEBPACK_IMPORTED_MODULE_7__.Mat33) {
            canvasTransform = _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_27__["default"].fromImmutable(canvasTransform);
        }
        // The element hierarchy looks like this:
        //   overlay > contentWrapper > content
        //
        // Both contentWrapper and overlay are present to:
        // 1. overlay: Positions the content at the top left of the viewport. The overlay
        //    has `height: 0` to allow other overlays to also be aligned with the viewport's
        //    top left.
        // 2. contentWrapper: Has the same width/height as the editor's visible region and
        //    has `overflow: hidden`. This prevents the anchored element from being visible
        //    when not in the visible region of the canvas.
        const overlay = document.createElement('div');
        overlay.classList.add('anchored-element-overlay');
        const contentWrapper = document.createElement('div');
        contentWrapper.classList.add('content-wrapper');
        element.classList.add('content');
        // Updates CSS variables that specify the position/rotation/scale of the content.
        const updateElementPositioning = () => {
            const transform = canvasTransform.get();
            const canvasRotation = transform.transformVec3(_js_draw_math__WEBPACK_IMPORTED_MODULE_7__.Vec2.unitX).angle();
            const screenRotation = canvasRotation + this.viewport.getRotationAngle();
            const screenTransform = this.viewport.canvasToScreenTransform.rightMul(canvasTransform.get());
            overlay.style.setProperty('--full-transform', screenTransform.toCSSMatrix());
            const translation = screenTransform.transformVec2(_js_draw_math__WEBPACK_IMPORTED_MODULE_7__.Vec2.zero);
            overlay.style.setProperty('--position-x', `${translation.x}px`);
            overlay.style.setProperty('--position-y', `${translation.y}px`);
            overlay.style.setProperty('--rotation', `${(screenRotation * 180) / Math.PI}deg`);
            overlay.style.setProperty('--scale', `${screenTransform.getScaleFactor()}`);
        };
        updateElementPositioning();
        // The anchored element needs to be updated both when the user moves the canvas
        // and when the anchored element's transform changes.
        const updateListener = canvasTransform.onUpdate(updateElementPositioning);
        const viewportListener = this.notifier.on(_types_mjs__WEBPACK_IMPORTED_MODULE_2__.EditorEventType.ViewportChanged, updateElementPositioning);
        contentWrapper.appendChild(element);
        overlay.appendChild(contentWrapper);
        overlay.classList.add('overlay', 'js-draw-editor-overlay');
        this.renderingRegion.insertAdjacentElement('afterend', overlay);
        return {
            remove: () => {
                overlay.remove();
                updateListener.remove();
                viewportListener.remove();
            },
        };
    }
    /**
     * Creates a CSS stylesheet with `content` and applies it to the document
     * (and thus, to this editor).
     */
    addStyleSheet(content) {
        const styleSheet = document.createElement('style');
        styleSheet.innerText = content;
        this.container.appendChild(styleSheet);
        return styleSheet;
    }
    /**
     * Dispatch a keyboard event to the currently selected tool.
     * Intended for unit testing.
     *
     * If `shiftKey` is undefined, it is guessed from `key`.
     *
     * At present, the **key code** dispatched is guessed from the given key and,
     * while this works for ASCII alphanumeric characters, this does not work for
     * most non-alphanumeric keys.
     *
     * Because guessing the key code from `key` is problematic, **only use this for testing**.
     */
    sendKeyboardEvent(eventType, key, ctrlKey = false, altKey = false, shiftKey = undefined) {
        shiftKey ??= key.toUpperCase() === key && key.toLowerCase() !== key;
        this.toolController.dispatchInputEvent({
            kind: eventType,
            key,
            code: (0,_util_guessKeyCodeFromKey_mjs__WEBPACK_IMPORTED_MODULE_23__["default"])(key),
            ctrlKey,
            altKey,
            shiftKey,
        });
    }
    /**
     * Dispatch a pen event to the currently selected tool.
     * Intended primarially for unit tests.
     *
     * @deprecated
     * @see {@link sendPenEvent} {@link sendTouchEvent}
     */
    sendPenEvent(eventType, point, 
    // @deprecated
    allPointers) {
        (0,_testing_sendPenEvent_mjs__WEBPACK_IMPORTED_MODULE_19__["default"])(this, eventType, point, allPointers);
    }
    /**
     * Adds all components in `components` such that they are in the center of the screen.
     * This is a convenience method that creates **and applies** a single command.
     *
     * If `selectComponents` is true (the default), the components are selected.
     *
     * `actionDescription`, if given, should be a screenreader-friendly description of the
     * reason components were added (e.g. "pasted").
     */
    async addAndCenterComponents(components, selectComponents = true, actionDescription) {
        let bbox = null;
        for (const component of components) {
            if (bbox) {
                bbox = bbox.union(component.getBBox());
            }
            else {
                bbox = component.getBBox();
            }
        }
        if (!bbox) {
            return;
        }
        // Find a transform that scales/moves bbox onto the screen.
        const visibleRect = this.viewport.visibleRect;
        const scaleRatioX = visibleRect.width / bbox.width;
        const scaleRatioY = visibleRect.height / bbox.height;
        let scaleRatio = scaleRatioX;
        if (bbox.width * scaleRatio > visibleRect.width ||
            bbox.height * scaleRatio > visibleRect.height) {
            scaleRatio = scaleRatioY;
        }
        scaleRatio *= 2 / 3;
        scaleRatio = _Viewport_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].roundScaleRatio(scaleRatio);
        const transfm = _js_draw_math__WEBPACK_IMPORTED_MODULE_7__.Mat33.translation(visibleRect.center.minus(bbox.center)).rightMul(_js_draw_math__WEBPACK_IMPORTED_MODULE_7__.Mat33.scaling2D(scaleRatio, bbox.center));
        const commands = [];
        for (const component of components) {
            // To allow deserialization, we need to add first, then transform.
            commands.push(_image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].addElement(component));
            commands.push(component.transformBy(transfm));
        }
        const applyChunkSize = 100;
        await this.dispatch((0,_commands_uniteCommands_mjs__WEBPACK_IMPORTED_MODULE_15__["default"])(commands, { applyChunkSize, description: actionDescription }), true);
        if (selectComponents) {
            for (const selectionTool of this.toolController.getMatchingTools(_tools_SelectionTool_SelectionTool_mjs__WEBPACK_IMPORTED_MODULE_16__["default"])) {
                selectionTool.setEnabled(true);
                selectionTool.setSelection(components);
            }
        }
    }
    /**
     * Get a data URL (e.g. as produced by `HTMLCanvasElement::toDataURL`).
     * If `format` is not `image/png`, a PNG image URL may still be returned (as in the
     * case of `HTMLCanvasElement::toDataURL`).
     *
     * The export resolution is the same as the size of the drawing canvas, unless `outputSize`
     * is given.
     *
     * **Example**:
     * [[include:doc-pages/inline-examples/adding-an-image-and-data-urls.md]]
     */
    toDataURL(format = 'image/png', outputSize) {
        const { element: canvas, renderer } = _rendering_renderers_CanvasRenderer_mjs__WEBPACK_IMPORTED_MODULE_13__["default"].fromViewport(this.image.getImportExportViewport(), { canvasSize: outputSize });
        this.image.renderAll(renderer);
        const dataURL = canvas.toDataURL(format);
        return dataURL;
    }
    /**
     * Converts the editor's content into an SVG image.
     *
     * If the output SVG has width or height less than `options.minDimension`, its size
     * will be increased.
     *
     * @see
     * {@link SVGRenderer}
     */
    toSVG(options) {
        return (0,_image_export_editorImageToSVG_mjs__WEBPACK_IMPORTED_MODULE_26__.editorImageToSVGSync)(this.image, options ?? {});
    }
    /**
     * Converts the editor's content into an SVG image in an asynchronous,
     * but **potentially lossy** way.
     *
     * **Warning**: If the image is being edited during an async rendering, edited components
     * may not be rendered.
     *
     * Like {@link toSVG}, but can be configured to briefly pause after processing every
     * `pauseAfterCount` items. This can prevent the editor from becoming unresponsive
     * when saving very large images.
     */
    async toSVGAsync(options = {}) {
        const pauseAfterCount = options.pauseAfterCount ?? 100;
        return await (0,_image_export_editorImageToSVG_mjs__WEBPACK_IMPORTED_MODULE_26__.editorImageToSVGAsync)(this.image, async (_component, processedCount, totalComponents) => {
            if (options.onProgress) {
                const shouldContinue = await options.onProgress(processedCount, totalComponents);
                if (shouldContinue === false) {
                    return false;
                }
            }
            if (processedCount % pauseAfterCount === 0) {
                await (0,_util_untilNextAnimationFrame_mjs__WEBPACK_IMPORTED_MODULE_14__["default"])();
            }
            return true;
        }, {
            minDimension: options.minDimension,
        });
    }
    /**
     * Load editor data from an `ImageLoader` (e.g. an {@link SVGLoader}).
     *
     * @see loadFromSVG
     */
    async loadFrom(loader) {
        this.showLoadingWarning(0);
        this.display.setDraftMode(true);
        const originalBackgrounds = this.image.getBackgroundComponents();
        const eraseBackgroundCommand = new _commands_Erase_mjs__WEBPACK_IMPORTED_MODULE_17__["default"](originalBackgrounds);
        await loader.start(async (component) => {
            await this.dispatchNoAnnounce(_image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].addElement(component));
        }, (countProcessed, totalToProcess) => {
            if (countProcessed % 500 === 0) {
                this.showLoadingWarning(countProcessed / totalToProcess);
                this.rerender();
                return (0,_util_untilNextAnimationFrame_mjs__WEBPACK_IMPORTED_MODULE_14__["default"])();
            }
            return null;
        }, (importExportRect, options) => {
            this.dispatchNoAnnounce(this.setImportExportRect(importExportRect), false);
            this.dispatchNoAnnounce(this.viewport.zoomTo(importExportRect), false);
            if (options) {
                this.dispatchNoAnnounce(this.image.setAutoresizeEnabled(options.autoresize), false);
            }
        });
        // Ensure that we don't have multiple overlapping BackgroundComponents. Remove
        // old BackgroundComponents.
        // Overlapping BackgroundComponents may cause changing the background color to
        // not work properly.
        if (this.image.getBackgroundComponents().length !== originalBackgrounds.length) {
            await this.dispatchNoAnnounce(eraseBackgroundCommand);
        }
        this.hideLoadingWarning();
        this.display.setDraftMode(false);
        this.queueRerender();
    }
    getTopmostBackgroundComponent() {
        let background = null;
        // Find a background component, if one exists.
        // Use the last (topmost) background component if there are multiple.
        for (const component of this.image.getBackgroundComponents()) {
            if (component instanceof _components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_18__["default"]) {
                background = component;
            }
        }
        return background;
    }
    /**
     * This is a convenience method for adding or updating the {@link BackgroundComponent}
     * and {@link EditorImage.setAutoresizeEnabled} for the current image.
     *
     * If there are multiple {@link BackgroundComponent}s in the image, this only modifies
     * the topmost such element.
     *
     * **Example**:
     * ```ts,runnable
     * import { Editor, Color4, BackgroundComponentBackgroundType } from 'js-draw';
     * const editor = new Editor(document.body);
     * editor.dispatch(editor.setBackgroundStyle({
     *     color: Color4.orange,
     *     type: BackgroundComponentBackgroundType.Grid,
     *     autoresize: true,
     * }));
     * ```
     *
     * To change the background size, see {@link EditorImage.setImportExportRect}.
     */
    setBackgroundStyle(style) {
        const originalBackground = this.getTopmostBackgroundComponent();
        const commands = [];
        if (originalBackground) {
            commands.push(new _commands_Erase_mjs__WEBPACK_IMPORTED_MODULE_17__["default"]([originalBackground]));
        }
        const originalType = originalBackground?.getBackgroundType?.() ?? _components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_18__.BackgroundType.None;
        const originalColor = originalBackground?.getStyle?.().color ?? _js_draw_math__WEBPACK_IMPORTED_MODULE_7__.Color4.transparent;
        const originalFillsScreen = this.image.getAutoresizeEnabled();
        const defaultType = style.color && originalType === _components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_18__.BackgroundType.None
            ? _components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_18__.BackgroundType.SolidColor
            : originalType;
        const backgroundType = style.type ?? defaultType;
        const backgroundColor = style.color ?? originalColor;
        const fillsScreen = style.autoresize ?? originalFillsScreen;
        if (backgroundType !== _components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_18__.BackgroundType.None) {
            const newBackground = new _components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_18__["default"](backgroundType, backgroundColor);
            commands.push(_image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].addElement(newBackground));
        }
        if (fillsScreen !== originalFillsScreen) {
            commands.push(this.image.setAutoresizeEnabled(fillsScreen));
            // Avoid 0x0 backgrounds
            if (!fillsScreen && this.image.getImportExportRect().maxDimension === 0) {
                commands.push(this.image.setImportExportRect(this.image.getImportExportRect().resizedTo(_js_draw_math__WEBPACK_IMPORTED_MODULE_7__.Vec2.of(500, 500))));
            }
        }
        return (0,_commands_uniteCommands_mjs__WEBPACK_IMPORTED_MODULE_15__["default"])(commands);
    }
    /**
     * Set the background color of the image.
     *
     * This is a convenience method for adding or updating the {@link BackgroundComponent}
     * for the current image.
     *
     * @see {@link setBackgroundStyle}
     */
    setBackgroundColor(color) {
        let background = this.getTopmostBackgroundComponent();
        if (!background) {
            const backgroundType = color.eq(_js_draw_math__WEBPACK_IMPORTED_MODULE_7__.Color4.transparent)
                ? _components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_18__.BackgroundType.None
                : _components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_18__.BackgroundType.SolidColor;
            background = new _components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_18__["default"](backgroundType, color);
            return this.image.addElement(background);
        }
        else {
            return background.updateStyle({ color });
        }
    }
    /**
     * @returns the average of the colors of all background components. Use this to get the current background
     * color.
     */
    estimateBackgroundColor() {
        const backgroundColors = [];
        for (const component of this.image.getBackgroundComponents()) {
            if (component instanceof _components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_18__["default"]) {
                backgroundColors.push(component.getStyle().color ?? _js_draw_math__WEBPACK_IMPORTED_MODULE_7__.Color4.transparent);
            }
        }
        return _js_draw_math__WEBPACK_IMPORTED_MODULE_7__.Color4.average(backgroundColors);
    }
    // Returns the size of the visible region of the output SVG
    getImportExportRect() {
        return this.image.getImportExportViewport().visibleRect;
    }
    // Resize the output SVG to match `imageRect`.
    setImportExportRect(imageRect) {
        return this.image.setImportExportRect(imageRect);
    }
    /**
     * Alias for `loadFrom(SVGLoader.fromString)`.
     *
     * @example
     * ```ts,runnable
     * import {Editor} from 'js-draw';
     * const editor = new Editor(document.body);
     *
     * ---visible---
     * await editor.loadFromSVG(`
     *   <svg viewBox="5 23 52 30" width="52" height="16" version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
     *     <text style="
     *       transform: matrix(0.181846, 0.1, 0, 0.181846, 11.4, 33.2);
     *       font-family: serif;
     *       font-size: 32px;
     *       fill: rgb(100, 140, 61);
     *     ">An SVG image!</text>
     *   </svg>
     * `);
     * ```
     */
    async loadFromSVG(svgData, sanitize = false) {
        const loader = _SVGLoader_SVGLoader_mjs__WEBPACK_IMPORTED_MODULE_9__["default"].fromString(svgData, sanitize);
        await this.loadFrom(loader);
    }
    /**
     * Shows an information dialog with legal notices.
     */
    showAboutDialog() {
        const iconLicenseText = this.icons.licenseInfo();
        const notices = [];
        if (this.settings.appInfo) {
            const descriptionLines = [];
            if (this.settings.appInfo.version) {
                descriptionLines.push(`v${this.settings.appInfo.version}`, '');
            }
            if (this.settings.appInfo.description) {
                descriptionLines.push(this.settings.appInfo.description + '\n');
            }
            else {
                descriptionLines.push(`js-draw v${_version_mjs__WEBPACK_IMPORTED_MODULE_25__["default"].number}`);
            }
            notices.push({
                heading: `${this.settings.appInfo.name}`,
                text: descriptionLines.join('\n'),
            });
        }
        else {
            notices.push({
                heading: 'js-draw',
                text: `v${_version_mjs__WEBPACK_IMPORTED_MODULE_25__["default"].number}`,
            });
        }
        const screenSize = this.viewport.getScreenRectSize();
        notices.push({
            heading: this.localization.developerInformation,
            text: [
                'Image debug information (from when this dialog was opened):',
                `    ${this.viewport.getScaleFactor()}x zoom, ${(180 / Math.PI) * this.viewport.getRotationAngle()}° rotation`,
                `    ${this.image.estimateNumElements()} components`,
                `    auto-resize: ${this.image.getAutoresizeEnabled() ? 'enabled' : 'disabled'}`,
                `    image size: ${this.getImportExportRect().w}x${this.getImportExportRect().h}`,
                `    screen size: ${screenSize.x}x${screenSize.y}`,
                `    device pixel ratio: ${this.display.getDevicePixelRatio()}`,
                '    cache:',
                `        ${this.display
                    .getCache()
                    .getDebugInfo()
                    // Indent
                    .replace(/([\n])/g, '\n        ')}`,
            ].join('\n'),
            minimized: true,
        });
        notices.push({
            heading: this.localization.softwareLibraries,
            text: [
                `This image editor is powered by js-draw v${_version_mjs__WEBPACK_IMPORTED_MODULE_25__["default"].number}.`,
                '',
                'At runtime, js-draw uses',
                ' - The Coloris color picker: https://github.com/mdbassit/Coloris',
                ' - The bezier.js Bézier curve library: https://github.com/Pomax/bezierjs',
                '',
                'Both are licensed under the MIT license:',
                '',
                '',
                '== Coloris ==',
                (0,_util_mitLicenseAttribution_mjs__WEBPACK_IMPORTED_MODULE_29__["default"])('2021 Mohammed Bassit'),
                '',
                '',
                '== Bezier.js ==',
                (0,_util_mitLicenseAttribution_mjs__WEBPACK_IMPORTED_MODULE_29__["default"])('2023 Mike "Pomax" Kamermans'),
                '',
                '',
                '== js-draw ==',
                (0,_util_mitLicenseAttribution_mjs__WEBPACK_IMPORTED_MODULE_29__["default"])('2023-2025 Henry Heino'),
                '',
            ].join('\n'),
            minimized: true,
        });
        if (iconLicenseText) {
            notices.push({
                heading: 'Icon Pack',
                text: iconLicenseText,
                minimized: true,
            });
        }
        notices.push(...this.settings.notices);
        this.closeAboutDialog?.();
        this.closeAboutDialog = (0,_dialogs_makeAboutDialog_mjs__WEBPACK_IMPORTED_MODULE_24__["default"])(this, notices).close;
    }
    /**
     * Removes and **destroys** the editor. The editor cannot be added to a parent
     * again after calling this method.
     */
    remove() {
        this.container.remove();
        // TODO: Is additional cleanup necessary here?
        this.toolController.onEditorDestroyed();
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Editor);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/EventDispatcher.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/EventDispatcher.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EventDispatcher)
/* harmony export */ });
// Code shared with Joplin (from when it was MIT licensed)
// (js-draw was originally intended to be part of Joplin).
/**
 * Handles notifying listeners of events.
 *
 * `EventKeyType` is used to distinguish events (e.g. a `ClickEvent` vs a `TouchEvent`)
 * while `EventMessageType` is the type of the data sent with an event (can be `void`).
 *
 * @example
 * ```
 * const dispatcher = new EventDispatcher<'event1'|'event2'|'event3', void>();
 * dispatcher.on('event1', () => {
 *   console.log('Event 1 triggered.');
 * });
 * dispatcher.dispatch('event1');
 * ```
 *
 */
class EventDispatcher {
    constructor() {
        this.listeners = {};
    }
    dispatch(eventName, event) {
        const listenerList = this.listeners[eventName];
        if (listenerList) {
            for (let i = 0; i < listenerList.length; i++) {
                listenerList[i](event);
            }
        }
    }
    on(eventName, callback) {
        if (!this.listeners[eventName])
            this.listeners[eventName] = [];
        this.listeners[eventName].push(callback);
        return {
            // Retuns false if the listener has already been removed, true otherwise.
            remove: () => {
                const originalListeners = this.listeners[eventName];
                this.off(eventName, callback);
                return originalListeners.length !== this.listeners[eventName].length;
            },
        };
    }
    /** Removes an event listener. This is equivalent to calling `.remove()` on the object returned by `.on`. */
    off(eventName, callback) {
        const listeners = this.listeners[eventName];
        if (!listeners)
            return;
        // Replace the current list of listeners with a new, shortened list.
        // This allows any iterators over this.listeners to continue iterating
        // without skipping elements.
        this.listeners[eventName] = listeners.filter((otherCallback) => otherCallback !== callback);
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/Pointer.mjs":
/*!***************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/Pointer.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PointerDevice: () => (/* binding */ PointerDevice),
/* harmony export */   "default": () => (/* binding */ Pointer)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");

var PointerDevice;
(function (PointerDevice) {
    PointerDevice[PointerDevice["Pen"] = 0] = "Pen";
    PointerDevice[PointerDevice["Eraser"] = 1] = "Eraser";
    PointerDevice[PointerDevice["Touch"] = 2] = "Touch";
    PointerDevice[PointerDevice["PrimaryButtonMouse"] = 3] = "PrimaryButtonMouse";
    PointerDevice[PointerDevice["RightButtonMouse"] = 4] = "RightButtonMouse";
    PointerDevice[PointerDevice["Other"] = 5] = "Other";
})(PointerDevice || (PointerDevice = {}));
// Provides a snapshot containing information about a pointer. A Pointer
// object is immutable — it will not be updated when the pointer's information changes.
class Pointer {
    constructor(
    // The (x, y) position of the pointer relative to the top-left corner
    // of the visible canvas.
    screenPos, 
    // Position of the pointer relative to the top left corner of the drawing
    // surface.
    canvasPos, pressure, isPrimary, down, device, 
    // Unique ID for the pointer
    id, 
    // Numeric timestamp (milliseconds, as from `performance.now()`).
    timeStamp) {
        this.screenPos = screenPos;
        this.canvasPos = canvasPos;
        this.pressure = pressure;
        this.isPrimary = isPrimary;
        this.down = down;
        this.device = device;
        this.id = id;
        this.timeStamp = timeStamp;
    }
    /**
     * Snaps this pointer to the nearest grid point (rounds the coordinates of this
     * pointer based on the current zoom). Returns a new Pointer and does not modify
     * this.
     */
    snappedToGrid(viewport) {
        const snappedCanvasPos = viewport.snapToGrid(this.canvasPos);
        return this.withCanvasPosition(snappedCanvasPos, viewport);
    }
    // Snap this pointer to the X or Y axis (whichever is closer), where (0,0)
    // is considered to be at `originPointScreen`.
    // @internal
    lockedToXYAxesScreen(originPointScreen, viewport) {
        const current = this.screenPos;
        const currentFromStart = current.minus(originPointScreen);
        // Determine whether the last point was closer to being on the
        // x- or y- axis.
        const projOntoXAxis = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.unitX.times(currentFromStart.x);
        const projOntoYAxis = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.unitY.times(currentFromStart.y);
        let pos;
        if (currentFromStart.dot(projOntoXAxis) > currentFromStart.dot(projOntoYAxis)) {
            pos = projOntoXAxis;
        }
        else {
            pos = projOntoYAxis;
        }
        pos = pos.plus(originPointScreen);
        return this.withScreenPosition(pos, viewport);
    }
    /** @see {@link withCanvasPosition} */
    withScreenPosition(screenPos, viewport) {
        const canvasPos = viewport.screenToCanvas(screenPos);
        return this.withCanvasPosition(canvasPos, viewport);
    }
    /** Returns a copy of this pointer with a changed timestamp. */
    withTimestamp(timeStamp) {
        return new Pointer(this.screenPos, this.canvasPos, this.pressure, this.isPrimary, this.down, this.device, this.id, timeStamp);
    }
    /**
     * Returns a copy of this pointer with a new position. The screen position is determined
     * by the given `canvasPos`.
     */
    withCanvasPosition(canvasPos, viewport) {
        const screenPos = viewport.canvasToScreen(canvasPos);
        return new Pointer(screenPos, canvasPos, this.pressure, this.isPrimary, this.down, this.device, this.id, this.timeStamp);
    }
    // Creates a Pointer from a DOM event. If `relativeTo` is given, (0, 0) in screen coordinates is
    // considered the top left of `relativeTo`.
    static ofEvent(evt, isDown, viewport, relativeTo) {
        let screenPos = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(evt.clientX, evt.clientY);
        if (relativeTo) {
            const bbox = relativeTo.getBoundingClientRect();
            screenPos = screenPos.minus(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(bbox.left, bbox.top));
        }
        const pointerTypeToDevice = {
            mouse: PointerDevice.PrimaryButtonMouse,
            pen: PointerDevice.Pen,
            touch: PointerDevice.Touch,
        };
        let device = pointerTypeToDevice[evt.pointerType] ?? PointerDevice.Other;
        const eraserButtonMask = 0x20;
        if (device === PointerDevice.Pen && (evt.buttons & eraserButtonMask) !== 0) {
            device = PointerDevice.Eraser;
        }
        const timeStamp = evt.timeStamp;
        const canvasPos = viewport.roundPoint(viewport.screenToCanvas(screenPos));
        if (device === PointerDevice.PrimaryButtonMouse) {
            if (evt.buttons & 0x2) {
                device = PointerDevice.RightButtonMouse;
            }
            // Commented out: Mouse up events seem to not satisfy this condition on mouse up.
            // else if (!(evt.buttons & 0x1)) {
            //	device = PointerDevice.Other;
            //}
        }
        return new Pointer(screenPos, canvasPos, evt.pressure ?? null, evt.isPrimary, isDown, device, evt.pointerId, timeStamp);
    }
    // Create a new Pointer from a point on the canvas.
    // Intended for unit tests.
    static ofCanvasPoint(canvasPos, isDown, viewport, id = 0, device = PointerDevice.Pen, isPrimary = true, pressure = null, timeStamp = null) {
        const screenPos = viewport.canvasToScreen(canvasPos);
        timeStamp ??= performance.now();
        return new Pointer(screenPos, canvasPos, pressure, isPrimary, isDown, device, id, timeStamp);
    }
    // Create a new Pointer from a point on the screen.
    // Intended for unit tests.
    static ofScreenPoint(screenPos, isDown, viewport, id = 0, device = PointerDevice.Pen, isPrimary = true, pressure = null, timeStamp = null) {
        const canvasPos = viewport.screenToCanvas(screenPos);
        timeStamp ??= performance.now();
        return new Pointer(screenPos, canvasPos, pressure, isPrimary, isDown, device, id, timeStamp);
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/SVGLoader/SVGLoader.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/SVGLoader/SVGLoader.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SVGLoaderLoadMethod: () => (/* binding */ SVGLoaderLoadMethod),
/* harmony export */   "default": () => (/* binding */ SVGLoader),
/* harmony export */   defaultSVGViewRect: () => (/* binding */ defaultSVGViewRect),
/* harmony export */   svgAttributesDataKey: () => (/* binding */ svgAttributesDataKey),
/* harmony export */   svgLoaderAttributeContainerID: () => (/* binding */ svgLoaderAttributeContainerID),
/* harmony export */   svgLoaderAutoresizeClassName: () => (/* binding */ svgLoaderAutoresizeClassName),
/* harmony export */   svgStyleAttributesDataKey: () => (/* binding */ svgStyleAttributesDataKey)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/BackgroundComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/BackgroundComponent.mjs");
/* harmony import */ var _components_ImageComponent_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/ImageComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/ImageComponent.mjs");
/* harmony import */ var _components_Stroke_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/Stroke.mjs */ "./node_modules/js-draw/dist/mjs/components/Stroke.mjs");
/* harmony import */ var _components_SVGGlobalAttributesObject_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/SVGGlobalAttributesObject.mjs */ "./node_modules/js-draw/dist/mjs/components/SVGGlobalAttributesObject.mjs");
/* harmony import */ var _components_TextComponent_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/TextComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/TextComponent.mjs");
/* harmony import */ var _components_UnknownSVGObject_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../components/UnknownSVGObject.mjs */ "./node_modules/js-draw/dist/mjs/components/UnknownSVGObject.mjs");
/* harmony import */ var _rendering_RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../rendering/RenderablePathSpec.mjs */ "./node_modules/js-draw/dist/mjs/rendering/RenderablePathSpec.mjs");
/* harmony import */ var _rendering_renderers_SVGRenderer_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../rendering/renderers/SVGRenderer.mjs */ "./node_modules/js-draw/dist/mjs/rendering/renderers/SVGRenderer.mjs");
/* harmony import */ var _utils_determineFontSize_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/determineFontSize.mjs */ "./node_modules/js-draw/dist/mjs/SVGLoader/utils/determineFontSize.mjs");










// Size of a loaded image if no size is specified.
const defaultSVGViewRect = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2(0, 0, 500, 500);
// Key to retrieve unrecognised attributes from an AbstractComponent
const svgAttributesDataKey = 'svgAttrs';
// Like {@link svgAttributesDataKey}, but for styles
const svgStyleAttributesDataKey = 'svgStyleAttrs';
// Key that specifies the ID of an SVG element that contained a given node when the image
// was first loaded.
const svgLoaderAttributeContainerID = 'svgContainerID';
// If present in the exported SVG's class list, the image will be
// autoresized when components are added/removed.
const svgLoaderAutoresizeClassName = 'js-draw--autoresize';
// @internal
var SVGLoaderLoadMethod;
(function (SVGLoaderLoadMethod) {
    SVGLoaderLoadMethod["IFrame"] = "iframe";
    SVGLoaderLoadMethod["DOMParser"] = "domparser";
})(SVGLoaderLoadMethod || (SVGLoaderLoadMethod = {}));
const supportedStrokeFillStyleAttrs = ['stroke', 'fill', 'stroke-width'];
// Handles loading images from SVG.
class SVGLoader {
    constructor(source, onFinish, options) {
        this.source = source;
        this.onFinish = onFinish;
        this.onAddComponent = null;
        this.onProgress = null;
        this.onDetermineExportRect = null;
        this.processedCount = 0;
        this.totalToProcess = 0;
        this.containerGroupIDs = [];
        this.encounteredIDs = [];
        this.storeUnknown = !(options.sanitize ?? false);
        this.disableUnknownObjectWarnings = !!options.disableUnknownObjectWarnings;
    }
    // If [computedStyles] is given, it is preferred to directly accessing node's style object.
    getStyle(node, computedStyles) {
        let fill = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.transparent;
        let stroke;
        // If possible, use computedStyles (allows property inheritance).
        // Chromium, however, sets .fill to a falsy, but not undefined value in some cases where
        // styles are available. As such, use || instead of ??.
        const fillAttribute = node.getAttribute('fill') ?? (computedStyles?.fill || node.style?.fill);
        if (fillAttribute) {
            try {
                fill = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.fromString(fillAttribute);
            }
            catch {
                console.error('Unknown fill color,', fillAttribute);
            }
        }
        const strokeAttribute = node.getAttribute('stroke') ?? computedStyles?.stroke ?? node.style?.stroke ?? '';
        const strokeWidthAttr = node.getAttribute('stroke-width') ??
            computedStyles?.strokeWidth ??
            node.style?.strokeWidth ??
            '';
        if (strokeAttribute && strokeWidthAttr) {
            try {
                let width = parseFloat(strokeWidthAttr ?? '1');
                if (!isFinite(width)) {
                    width = 0;
                }
                const strokeColor = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.fromString(strokeAttribute);
                if (strokeColor.a > 0) {
                    stroke = {
                        width,
                        color: strokeColor,
                    };
                }
            }
            catch (e) {
                console.error('Error parsing stroke data:', e);
            }
        }
        const style = {
            fill,
            stroke,
        };
        return style;
    }
    strokeDataFromElem(node) {
        const result = [];
        const pathData = node.getAttribute('d') ?? '';
        const style = this.getStyle(node);
        // Break the path into chunks at each moveTo ('M') command:
        const parts = pathData.split('M');
        let isFirst = true;
        for (const part of parts) {
            // Skip effective no-ops -- moveTos without additional commands.
            const isNoOpMoveTo = /^[0-9., \t\n]+$/.exec(part);
            if (part !== '' && !isNoOpMoveTo) {
                // We split the path by moveTo commands, so add the 'M' back in
                // if it was present.
                const current = !isFirst ? `M${part}` : part;
                const path = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Path.fromString(current);
                const spec = (0,_rendering_RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_7__.pathToRenderable)(path, style);
                result.push(spec);
            }
            isFirst = false;
        }
        return result;
    }
    attachUnrecognisedAttrs(elem, node, supportedAttrs, supportedStyleAttrs) {
        if (!this.storeUnknown) {
            return;
        }
        for (const attr of node.getAttributeNames()) {
            if (supportedAttrs.has(attr) || (attr === 'style' && supportedStyleAttrs)) {
                continue;
            }
            elem.attachLoadSaveData(svgAttributesDataKey, [
                attr,
                node.getAttribute(attr),
            ]);
        }
        if (supportedStyleAttrs && node.style) {
            // Use a for loop instead of an iterator: js-dom seems to not
            // support using node.style as an iterator.
            for (let i = 0; i < node.style.length; i++) {
                const attr = node.style[i];
                if (attr === '' || !attr) {
                    continue;
                }
                if (supportedStyleAttrs.has(attr)) {
                    continue;
                }
                // TODO: Do we need special logic for !important properties?
                elem.attachLoadSaveData(svgStyleAttributesDataKey, {
                    key: attr,
                    value: node.style.getPropertyValue(attr),
                    priority: node.style.getPropertyPriority(attr),
                });
            }
        }
    }
    // Adds a stroke with a single path
    async addPath(node) {
        let elem;
        try {
            const strokeData = this.strokeDataFromElem(node);
            elem = new _components_Stroke_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](strokeData);
            this.attachUnrecognisedAttrs(elem, node, new Set([...supportedStrokeFillStyleAttrs, 'd']), new Set(supportedStrokeFillStyleAttrs));
        }
        catch (e) {
            console.error('Invalid path in node', node, '\nError:', e, '\nAdding as an unknown object.');
            if (this.storeUnknown) {
                elem = new _components_UnknownSVGObject_mjs__WEBPACK_IMPORTED_MODULE_6__["default"](node);
            }
            else {
                return;
            }
        }
        await this.addComponent(elem);
    }
    async addBackground(node) {
        // If a grid background,
        if (node.classList.contains(_components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_1__.backgroundTypeToClassNameMap[_components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_1__.BackgroundType.Grid])) {
            let foregroundStr;
            let backgroundStr;
            let gridStrokeWidthStr;
            // If a group,
            if (node.tagName.toLowerCase() === 'g') {
                // We expect exactly two children. One of these is the solid
                // background of the grid
                if (node.children.length !== 2) {
                    await this.addUnknownNode(node);
                    return;
                }
                const background = node.children[0];
                const grid = node.children[1];
                backgroundStr = background.getAttribute('fill');
                foregroundStr = grid.getAttribute('stroke');
                gridStrokeWidthStr = grid.getAttribute('stroke-width');
            }
            else {
                backgroundStr = node.getAttribute('fill');
                foregroundStr = node.getAttribute('stroke');
                gridStrokeWidthStr = node.getAttribute('stroke-width');
            }
            // Default to a transparent background.
            backgroundStr ??= _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.transparent.toHexString();
            // A grid must have a foreground color specified.
            if (!foregroundStr) {
                await this.addUnknownNode(node);
                return;
            }
            // Extract the grid size from the class name
            let gridSize = undefined;
            for (const className of node.classList) {
                if (className.startsWith(_components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_1__.imageBackgroundGridSizeCSSPrefix)) {
                    const sizeStr = className.substring(_components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_1__.imageBackgroundGridSizeCSSPrefix.length);
                    gridSize = parseFloat(sizeStr.replace(/p/g, '.'));
                }
            }
            let gridStrokeWidth = undefined;
            if (gridStrokeWidthStr) {
                gridStrokeWidth = parseFloat(gridStrokeWidthStr);
            }
            const backgroundColor = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.fromString(backgroundStr);
            let foregroundColor = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.fromString(foregroundStr);
            // Should the foreground color be determined automatically?
            if (!node.classList.contains(_components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_1__.imageBackgroundNonAutomaticSecondaryColorCSSClassName)) {
                foregroundColor = undefined;
            }
            const elem = _components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].ofGrid(backgroundColor, gridSize, foregroundColor, gridStrokeWidth);
            await this.addComponent(elem);
        }
        // Otherwise, if just a <path/>, it's a solid color background.
        else if (node.tagName.toLowerCase() === 'path') {
            const fill = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.fromString(node.getAttribute('fill') ?? node.style.fill ?? 'black');
            const elem = new _components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](_components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_1__.BackgroundType.SolidColor, fill);
            await this.addComponent(elem);
        }
        else {
            await this.addUnknownNode(node);
        }
    }
    getComputedStyle(element) {
        try {
            // getComputedStyle may fail in jsdom when using a DOMParser.
            return window.getComputedStyle(element);
        }
        catch (error) {
            console.warn('Error computing style', error);
            return undefined;
        }
    }
    // If given, 'supportedAttrs' will have x, y, etc. attributes that were used in computing the transform added to it,
    // to prevent storing duplicate transform information when saving the component.
    getTransform(elem, supportedAttrs, computedStyles) {
        // If possible, load the js-draw specific transform attribute
        const highpTransformAttribute = 'data-highp-transform';
        const rawTransformData = elem.getAttribute(highpTransformAttribute);
        let transform;
        if (rawTransformData) {
            try {
                transform = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.fromCSSMatrix(rawTransformData);
                supportedAttrs?.push(highpTransformAttribute);
            }
            catch (e) {
                console.warn(`Unable to parse raw transform data, ${rawTransformData}. Falling back to CSS data. Error:`, e);
            }
        }
        if (!transform) {
            computedStyles ??= this.getComputedStyle(elem);
            let transformProperty = computedStyles?.transform;
            if (!transformProperty || transformProperty === 'none') {
                transformProperty = elem.style?.transform || 'none';
            }
            // Prefer the actual .style.transform
            // to the computed stylesheet -- in some browsers, the computedStyles version
            // can have lower precision.
            try {
                transform = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.fromCSSMatrix(elem.style.transform);
            }
            catch (_e) {
                console.warn('matrix parse error', _e);
                transform = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.fromCSSMatrix(transformProperty);
            }
            const elemX = elem.getAttribute('x');
            const elemY = elem.getAttribute('y');
            if (elemX || elemY) {
                const x = parseFloat(elemX ?? '0');
                const y = parseFloat(elemY ?? '0');
                if (!isNaN(x) && !isNaN(y)) {
                    supportedAttrs?.push('x', 'y');
                    transform = transform.rightMul(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.translation(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(x, y)));
                }
            }
        }
        return transform;
    }
    makeText(elem) {
        const contentList = [];
        for (const child of elem.childNodes) {
            if (child.nodeType === Node.TEXT_NODE) {
                contentList.push(child.nodeValue ?? '');
            }
            else if (child.nodeType === Node.ELEMENT_NODE) {
                const subElem = child;
                if (subElem.tagName.toLowerCase() === 'tspan') {
                    // FIXME: tspan's (x, y) components are absolute, not relative to the parent.
                    contentList.push(this.makeText(subElem));
                }
                else {
                    throw new Error(`Unrecognized text child element: ${subElem}`);
                }
            }
            else {
                throw new Error(`Unrecognized text child node: ${child}.`);
            }
        }
        // If no content, the content is an empty string.
        if (contentList.length === 0) {
            contentList.push('');
        }
        // Compute styles.
        const computedStyles = this.getComputedStyle(elem);
        const supportedStyleAttrs = new Set([
            'fontFamily',
            'transform',
            ...supportedStrokeFillStyleAttrs,
        ]);
        const style = {
            size: (0,_utils_determineFontSize_mjs__WEBPACK_IMPORTED_MODULE_9__["default"])(elem, computedStyles, supportedStyleAttrs),
            fontFamily: computedStyles?.fontFamily || elem.style?.fontFamily || 'sans-serif',
            fontWeight: computedStyles?.fontWeight || elem.style?.fontWeight || undefined,
            fontStyle: computedStyles?.fontStyle || elem.style?.fontStyle || undefined,
            renderingStyle: this.getStyle(elem, computedStyles),
        };
        const supportedAttrs = [];
        let transform = this.getTransform(elem, supportedAttrs, computedStyles);
        let transformMode = _components_TextComponent_mjs__WEBPACK_IMPORTED_MODULE_5__.TextTransformMode.ABSOLUTE_XY;
        const elemDX = elem.getAttribute('dx');
        if (elemDX) {
            transformMode = _components_TextComponent_mjs__WEBPACK_IMPORTED_MODULE_5__.TextTransformMode.RELATIVE_X_ABSOLUTE_Y;
            transform = transform.rightMul(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.translation(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(parseFloat(elemDX), 0)));
            supportedAttrs.push('dx');
        }
        const elemDY = elem.getAttribute('dy');
        if (elemDY) {
            if (transformMode === _components_TextComponent_mjs__WEBPACK_IMPORTED_MODULE_5__.TextTransformMode.RELATIVE_X_ABSOLUTE_Y) {
                transformMode = _components_TextComponent_mjs__WEBPACK_IMPORTED_MODULE_5__.TextTransformMode.RELATIVE_XY;
            }
            else {
                transformMode = _components_TextComponent_mjs__WEBPACK_IMPORTED_MODULE_5__.TextTransformMode.RELATIVE_Y_ABSOLUTE_X;
            }
            transform = transform.rightMul(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.translation(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(0, parseFloat(elemDY))));
            supportedAttrs.push('dy');
        }
        const result = new _components_TextComponent_mjs__WEBPACK_IMPORTED_MODULE_5__["default"](contentList, transform, style, transformMode);
        this.attachUnrecognisedAttrs(result, elem, new Set(supportedAttrs), new Set(supportedStyleAttrs));
        return result;
    }
    async addText(elem) {
        try {
            const textElem = this.makeText(elem);
            await this.addComponent(textElem);
        }
        catch (e) {
            console.error('Invalid text object in node', elem, '. Continuing.... Error:', e);
            this.addUnknownNode(elem);
        }
    }
    async addImage(elem) {
        const image = new Image();
        image.src = elem.getAttribute('xlink:href') ?? elem.href.baseVal;
        image.setAttribute('alt', elem.getAttribute('aria-label') ?? '');
        try {
            const supportedAttrs = [];
            const transform = this.getTransform(elem, supportedAttrs);
            const imageElem = await _components_ImageComponent_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].fromImage(image, transform);
            this.attachUnrecognisedAttrs(imageElem, elem, new Set(supportedAttrs), new Set(['transform']));
            await this.addComponent(imageElem);
        }
        catch (e) {
            console.error('Error loading image:', e, '. Element: ', elem, '. Continuing...');
            await this.addUnknownNode(elem);
        }
    }
    async addUnknownNode(node) {
        if (this.storeUnknown) {
            const component = new _components_UnknownSVGObject_mjs__WEBPACK_IMPORTED_MODULE_6__["default"](node);
            await this.addComponent(component);
        }
    }
    async startGroup(node) {
        node = node.cloneNode(false);
        // Select a unique ID based on the node's ID property (if it exists).
        // Use `||` and not `??` so that empty string IDs are also replaced.
        let id = node.id || `id-${this.encounteredIDs.length}`;
        // Make id unique.
        let idSuffixCounter = 0;
        let suffix = '';
        while (this.encounteredIDs.includes(id + suffix)) {
            idSuffixCounter++;
            suffix = '--' + idSuffixCounter;
        }
        id += suffix;
        // Remove all children from the node -- children will be handled separately
        // (not removing children here could cause duplicates in the result, when rendered).
        node.replaceChildren();
        node.id = id;
        const component = new _components_UnknownSVGObject_mjs__WEBPACK_IMPORTED_MODULE_6__["default"](node);
        this.addComponent(component);
        // Add to IDs after -- we don't want the <g> element to be marked
        // as its own container.
        this.containerGroupIDs.push(node.id);
        this.encounteredIDs.push(node.id);
    }
    // Ends the most recent group started by .startGroup
    async endGroup() {
        this.containerGroupIDs.pop();
    }
    async addComponent(component) {
        // Attach the stack of container IDs
        if (this.containerGroupIDs.length > 0) {
            component.attachLoadSaveData(svgLoaderAttributeContainerID, [...this.containerGroupIDs]);
        }
        await this.onAddComponent?.(component);
    }
    updateViewBox(node) {
        const viewBoxAttr = node.getAttribute('viewBox');
        if (this.rootViewBox || !viewBoxAttr) {
            return;
        }
        const components = viewBoxAttr.split(/[ \t\n,]+/);
        const x = parseFloat(components[0]);
        const y = parseFloat(components[1]);
        const width = parseFloat(components[2]);
        const height = parseFloat(components[3]);
        if (isNaN(x) || isNaN(y) || isNaN(width) || isNaN(height)) {
            console.warn(`node ${node} has an unparsable viewbox. Viewbox: ${viewBoxAttr}. Match: ${components}.`);
            return;
        }
        const autoresize = node.classList.contains(svgLoaderAutoresizeClassName);
        this.rootViewBox = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2(x, y, width, height);
        this.onDetermineExportRect?.(this.rootViewBox, { autoresize });
    }
    async updateSVGAttrs(node) {
        if (this.storeUnknown) {
            await this.onAddComponent?.(new _components_SVGGlobalAttributesObject_mjs__WEBPACK_IMPORTED_MODULE_4__["default"](this.getSourceAttrs(node)));
        }
    }
    async visit(node) {
        this.totalToProcess += node.childElementCount;
        let visitChildren = true;
        switch (node.tagName.toLowerCase()) {
            case 'g':
                if (node.classList.contains(_components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_1__.imageBackgroundCSSClassName)) {
                    await this.addBackground(node);
                    visitChildren = false;
                }
                else {
                    await this.startGroup(node);
                }
                // Otherwise, continue -- visit the node's children.
                break;
            case 'path':
                if (node.classList.contains(_components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_1__.imageBackgroundCSSClassName)) {
                    await this.addBackground(node);
                }
                else {
                    await this.addPath(node);
                }
                break;
            case 'text':
                await this.addText(node);
                visitChildren = false;
                break;
            case 'image':
                await this.addImage(node);
                // Images should not have children.
                visitChildren = false;
                break;
            case 'svg':
                this.updateViewBox(node);
                this.updateSVGAttrs(node);
                break;
            case 'style':
                // Keeping unnecessary style sheets can cause the browser to keep all
                // SVG elements *referenced* by the style sheet in some browsers.
                //
                // Only keep the style sheet if it won't be discarded on save.
                if (node.getAttribute('id') !== _rendering_renderers_SVGRenderer_mjs__WEBPACK_IMPORTED_MODULE_8__.renderedStylesheetId) {
                    await this.addUnknownNode(node);
                }
                break;
            default:
                if (!this.disableUnknownObjectWarnings) {
                    console.warn('Unknown SVG element,', node, node.tagName);
                    if (!(node instanceof SVGElement)) {
                        console.warn('Element', node, 'is not an SVGElement!', this.storeUnknown ? 'Continuing anyway.' : 'Skipping.');
                    }
                }
                await this.addUnknownNode(node);
                return;
        }
        if (visitChildren) {
            for (const child of node.children) {
                await this.visit(child);
            }
            if (node.tagName.toLowerCase() === 'g') {
                await this.endGroup();
            }
        }
        this.processedCount++;
        await this.onProgress?.(this.processedCount, this.totalToProcess);
    }
    // Get SVG element attributes (e.g. xlink=...)
    getSourceAttrs(node) {
        return node.getAttributeNames().map((attr) => {
            return [attr, node.getAttribute(attr)];
        });
    }
    async start(onAddComponent, onProgress, onDetermineExportRect = null) {
        this.onAddComponent = onAddComponent;
        this.onProgress = onProgress;
        this.onDetermineExportRect = onDetermineExportRect;
        // Estimate the number of tags to process.
        this.totalToProcess = this.source.childElementCount;
        this.processedCount = 0;
        this.rootViewBox = null;
        await this.visit(this.source);
        const viewBox = this.rootViewBox;
        if (!viewBox) {
            this.onDetermineExportRect?.(defaultSVGViewRect);
        }
        this.onFinish?.();
        this.onFinish = null;
    }
    /**
     * Create an `SVGLoader` from the content of an SVG image. SVGs are loaded within a sandboxed
     * iframe with `sandbox="allow-same-origin"`
     * [thereby disabling JavaScript](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#sandbox).
     *
     * @see {@link Editor.loadFrom}
     * @param text - Textual representation of the SVG (e.g. `<svg viewbox='...'>...</svg>`).
     * @param options - if `true` or `false`, treated as the `sanitize` option -- don't store unknown attributes.
     */
    static fromString(text, options = false) {
        const domParserLoad = typeof options !== 'boolean' && options?.loadMethod === SVGLoaderLoadMethod.DOMParser;
        const { svgElem, cleanUp } = (() => {
            // If the user requested an iframe load (the default) try to load with an iframe.
            // There are some cases (e.g. in a sandboxed iframe) where this doesn't work.
            // TODO(v2): Use domParserLoad by default.
            if (!domParserLoad) {
                try {
                    const sandbox = document.createElement('iframe');
                    sandbox.src = 'about:blank';
                    // allow-same-origin is necessary for how we interact with the sandbox. As such,
                    // DO NOT ENABLE ALLOW-SCRIPTS.
                    sandbox.setAttribute('sandbox', 'allow-same-origin');
                    sandbox.setAttribute('csp', "default-src 'about:blank'");
                    sandbox.style.display = 'none';
                    // Required to access the frame's DOM. See https://stackoverflow.com/a/17777943/17055750
                    document.body.appendChild(sandbox);
                    if (!sandbox.hasAttribute('sandbox')) {
                        sandbox.remove();
                        throw new Error('SVG loading iframe is not sandboxed.');
                    }
                    const sandboxDoc = sandbox.contentWindow?.document ?? sandbox.contentDocument;
                    if (sandboxDoc == null)
                        throw new Error('Unable to open a sandboxed iframe!');
                    sandboxDoc.open();
                    sandboxDoc.write(`
						<!DOCTYPE html>
						<html>
							<head>
								<title>SVG Loading Sandbox</title>
								<meta name='viewport' conent='width=device-width,initial-scale=1.0'/>
								<meta charset='utf-8'/>
							</head>
							<body style='font-size: 12px;'>
								<script>
									console.error('JavaScript should not be able to run here!');
									throw new Error(
										'The SVG sandbox is broken! Please double-check the sandboxing setting.'
									);
								</script>
							</body>
						</html>
					`);
                    sandboxDoc.close();
                    const svgElem = sandboxDoc.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    // eslint-disable-next-line no-unsanitized/property -- setting innerHTML in a sandboxed document.
                    svgElem.innerHTML = text;
                    sandboxDoc.body.appendChild(svgElem);
                    const cleanUp = () => {
                        svgElem.remove();
                        sandbox.remove();
                        sandbox.src = '';
                    };
                    return { svgElem, cleanUp };
                }
                catch (error) {
                    console.warn('Failed loading SVG via a sandboxed iframe. Some styles may not be loaded correctly. Error: ', error);
                }
            }
            // Fall back to creating a DOMParser
            const parser = new DOMParser();
            const doc = parser.parseFromString(`<svg xmlns="http://www.w3.org/2000/svg">${text}</svg>`, 'text/html');
            const svgElem = doc.querySelector('svg');
            // Handle error messages reported while parsing. See
            // https://developer.mozilla.org/en-US/docs/Web/Guide/Parsing_and_serializing_XML
            const errorReportNode = doc.querySelector('parsererror');
            if (errorReportNode) {
                throw new Error('Parse error: ' + errorReportNode.textContent);
            }
            const cleanUp = () => { };
            return { svgElem, cleanUp };
        })();
        // Handle options
        let sanitize;
        let disableUnknownObjectWarnings;
        if (typeof options === 'boolean') {
            sanitize = options;
            disableUnknownObjectWarnings = false;
        }
        else {
            sanitize = options.sanitize ?? false;
            disableUnknownObjectWarnings = options.disableUnknownObjectWarnings ?? false;
        }
        return new SVGLoader(svgElem, cleanUp, {
            sanitize,
            disableUnknownObjectWarnings,
        });
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/SVGLoader/utils/determineFontSize.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/SVGLoader/utils/determineFontSize.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Computes the font size of a text element, based on style information. */
const determineFontSize = (elem, computedStyles, 
// output: Written to to update supported style attributes
supportedStyleAttrs) => {
    const fontSizeExp = /^([-0-9.e]+)px/i;
    // In some environments, computedStyles.fontSize can be increased by the system.
    // Thus, to prevent text from growing on load/save, prefer .style.fontSize.
    let fontSizeMatch = fontSizeExp.exec(elem.style?.fontSize ?? '');
    if (!fontSizeMatch && elem.tagName.toLowerCase() === 'tspan' && elem.parentElement) {
        // Try to inherit the font size of the parent text element.
        fontSizeMatch = fontSizeExp.exec(elem.parentElement.style?.fontSize ?? '');
    }
    // If we still couldn't find a font size, try to use computedStyles (which can be
    // wrong).
    if (!fontSizeMatch && computedStyles) {
        fontSizeMatch = fontSizeExp.exec(computedStyles.fontSize);
    }
    let fontSize = 12;
    if (fontSizeMatch) {
        supportedStyleAttrs.add('fontSize');
        fontSize = parseFloat(fontSizeMatch[1]);
    }
    return fontSize;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (determineFontSize);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/UndoRedoHistory.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/UndoRedoHistory.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.mjs */ "./node_modules/js-draw/dist/mjs/types.mjs");
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _UndoRedoHistory_undoStack, _UndoRedoHistory_redoStack;

class UndoRedoHistory {
    // @internal
    constructor(editor, announceRedoCallback, announceUndoCallback) {
        this.editor = editor;
        this.announceRedoCallback = announceRedoCallback;
        this.announceUndoCallback = announceUndoCallback;
        _UndoRedoHistory_undoStack.set(this, void 0);
        _UndoRedoHistory_redoStack.set(this, void 0);
        this.maxUndoRedoStackSize = 700;
        __classPrivateFieldSet(this, _UndoRedoHistory_undoStack, [], "f");
        __classPrivateFieldSet(this, _UndoRedoHistory_redoStack, [], "f");
    }
    fireUpdateEvent(stackUpdateType, triggeringCommand) {
        this.editor.notifier.dispatch(_types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.UndoRedoStackUpdated, {
            kind: _types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.UndoRedoStackUpdated,
            undoStackSize: __classPrivateFieldGet(this, _UndoRedoHistory_undoStack, "f").length,
            redoStackSize: __classPrivateFieldGet(this, _UndoRedoHistory_redoStack, "f").length,
            command: triggeringCommand,
            stackUpdateType,
        });
    }
    // Adds the given command to this and applies it to the editor.
    push(command, apply = true) {
        if (apply) {
            command.apply(this.editor);
        }
        __classPrivateFieldGet(this, _UndoRedoHistory_undoStack, "f").push(command);
        for (const elem of __classPrivateFieldGet(this, _UndoRedoHistory_redoStack, "f")) {
            elem.onDrop(this.editor);
        }
        __classPrivateFieldSet(this, _UndoRedoHistory_redoStack, [], "f");
        if (__classPrivateFieldGet(this, _UndoRedoHistory_undoStack, "f").length > this.maxUndoRedoStackSize) {
            const removeAtOnceCount = Math.ceil(this.maxUndoRedoStackSize / 100);
            const removedElements = __classPrivateFieldGet(this, _UndoRedoHistory_undoStack, "f").splice(0, removeAtOnceCount);
            removedElements.forEach((elem) => elem.onDrop(this.editor));
        }
        this.fireUpdateEvent(_types_mjs__WEBPACK_IMPORTED_MODULE_0__.UndoEventType.CommandDone, command);
        this.editor.notifier.dispatch(_types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.CommandDone, {
            kind: _types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.CommandDone,
            command,
        });
    }
    // Remove the last command from this' undo stack and apply it.
    undo() {
        const command = __classPrivateFieldGet(this, _UndoRedoHistory_undoStack, "f").pop();
        if (command) {
            __classPrivateFieldGet(this, _UndoRedoHistory_redoStack, "f").push(command);
            const result = command.unapply(this.editor);
            this.announceUndoCallback(command);
            this.fireUpdateEvent(_types_mjs__WEBPACK_IMPORTED_MODULE_0__.UndoEventType.CommandUndone, command);
            this.editor.notifier.dispatch(_types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.CommandUndone, {
                kind: _types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.CommandUndone,
                command,
            });
            return result;
        }
    }
    redo() {
        const command = __classPrivateFieldGet(this, _UndoRedoHistory_redoStack, "f").pop();
        if (command) {
            __classPrivateFieldGet(this, _UndoRedoHistory_undoStack, "f").push(command);
            const result = command.apply(this.editor);
            this.announceRedoCallback(command);
            this.fireUpdateEvent(_types_mjs__WEBPACK_IMPORTED_MODULE_0__.UndoEventType.CommandRedone, command);
            this.editor.notifier.dispatch(_types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.CommandDone, {
                kind: _types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.CommandDone,
                command,
            });
            return result;
        }
    }
    get undoStackSize() {
        return __classPrivateFieldGet(this, _UndoRedoHistory_undoStack, "f").length;
    }
    get redoStackSize() {
        return __classPrivateFieldGet(this, _UndoRedoHistory_redoStack, "f").length;
    }
}
_UndoRedoHistory_undoStack = new WeakMap(), _UndoRedoHistory_redoStack = new WeakMap();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (UndoRedoHistory);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/Viewport.mjs":
/*!****************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/Viewport.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Viewport: () => (/* binding */ Viewport),
/* harmony export */   ViewportTransform: () => (/* binding */ ViewportTransform),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _commands_Command_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commands/Command.mjs */ "./node_modules/js-draw/dist/mjs/commands/Command.mjs");
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _inverseTransform, _a;


class ViewportTransform extends _commands_Command_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
}
class Viewport {
    // @internal
    constructor(onTransformChangeCallback) {
        this.onTransformChangeCallback = onTransformChangeCallback;
        this.resetTransform(_js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Mat33.identity);
        this.screenRect = _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Rect2.empty;
    }
    /**
     * @returns a temporary copy of `this` that does not notify when modified. This is
     * useful when rendering with a temporarily different viewport.
     */
    getTemporaryClone() {
        const result = new Viewport(() => { });
        result.transform = this.transform;
        result.inverseTransform = this.inverseTransform;
        result.screenRect = this.screenRect;
        return result;
    }
    /** Resizes the screen rect to the given size. @internal */
    updateScreenSize(screenSize) {
        this.screenRect = this.screenRect.resizedTo(screenSize);
    }
    /** Get the screen's visible region transformed into canvas space. */
    get visibleRect() {
        return this.screenRect.transformedBoundingBox(this.inverseTransform);
    }
    /** @returns the given point, but in canvas coordinates */
    screenToCanvas(screenPoint) {
        return this.inverseTransform.transformVec2(screenPoint);
    }
    /** @returns the given point transformed into screen coordinates. */
    canvasToScreen(canvasPoint) {
        return this.transform.transformVec2(canvasPoint);
    }
    /** @returns a command that transforms the canvas by `transform`. */
    static transformBy(transform) {
        return new Viewport.ViewportTransform(transform);
    }
    /**
     * Updates the transformation directly. Using `transformBy` is preferred.
     * @param newTransform - should map from canvas coordinates to screen coordinates.
     */
    resetTransform(newTransform = _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Mat33.identity) {
        const oldTransform = this.transform;
        this.transform = newTransform;
        this.inverseTransform = newTransform.inverse();
        this.onTransformChangeCallback?.(oldTransform, newTransform);
    }
    get screenToCanvasTransform() {
        return this.inverseTransform;
    }
    get canvasToScreenTransform() {
        return this.transform;
    }
    /** @returns the size of the visible region in pixels (screen units). */
    getScreenRectSize() {
        return this.screenRect.size;
    }
    /** Alias for `getScreenRectSize`. @deprecated */
    getResolution() {
        return this.getScreenRectSize();
    }
    /** @returns the amount a vector on the canvas is scaled to become a vector on the screen. */
    getScaleFactor() {
        // Use transformVec3 to avoid translating the vector
        return this.transform.transformVec3(_js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Vec3.unitX).magnitude();
    }
    /**
     * @returns `getScaleFactor()` rounded to the nearest power of 10.
     * For example, if `getScaleFactor()` returns 101, `getScaleFactorToNearestPowerOfTen()`
     * should return `100` because `100` is the nearest power of 10 to 101.
     */
    getScaleFactorToNearestPowerOfTen() {
        return this.getScaleFactorToNearestPowerOf(10);
    }
    getScaleFactorToNearestPowerOf(powerOf) {
        const scaleFactor = this.getScaleFactor();
        return Math.pow(powerOf, Math.round(Math.log(scaleFactor) / Math.log(powerOf)));
    }
    /** Returns the size of a grid cell (in canvas units) as used by {@link snapToGrid}. */
    static getGridSize(scaleFactor) {
        return 50 / scaleFactor;
    }
    /**
     * Snaps `canvasPos` to the nearest grid cell corner.
     *
     * @see {@link getGridSize}.
     */
    snapToGrid(canvasPos) {
        const scaleFactor = this.getScaleFactorToNearestPowerOf(2);
        const snapCoordinate = (coordinate) => {
            const roundFactor = 1 / Viewport.getGridSize(scaleFactor);
            const snapped = Math.round(coordinate * roundFactor) / roundFactor;
            return snapped;
        };
        const snappedCanvasPos = _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(snapCoordinate(canvasPos.x), snapCoordinate(canvasPos.y));
        return snappedCanvasPos;
    }
    /** Returns the size of one screen pixel in canvas units. */
    getSizeOfPixelOnCanvas() {
        return 1 / this.getScaleFactor();
    }
    /**
     * @returns the angle of the canvas in radians.
     * This is the angle by which the canvas is rotated relative to the screen.
     *
     * Returns an angle in the range $[-\pi, \pi]$ (the same range as {@link Vec3.angle}).
     */
    getRotationAngle() {
        return this.transform.transformVec3(_js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Vec3.unitX).angle();
    }
    // The separate function type definition seems necessary here.
    // See https://stackoverflow.com/a/58163623/17055750.
    static roundPoint(point, tolerance) {
        const scaleFactor = 10 ** Math.floor(Math.log10(tolerance));
        const roundComponent = (component) => {
            return Math.round(component / scaleFactor) * scaleFactor;
        };
        if (typeof point === 'number') {
            return roundComponent(point);
        }
        return point.map(roundComponent);
    }
    /** Round a point with a tolerance of ±1 screen unit. */
    roundPoint(point) {
        return Viewport.roundPoint(point, 1 / this.getScaleFactor());
    }
    // `roundAmount`: An integer >= 0, larger numbers cause less rounding. Smaller numbers cause more
    // (as such `roundAmount = 0` does the most rounding).
    static roundScaleRatio(scaleRatio, roundAmount = 1) {
        if (Math.abs(scaleRatio) <= 1e-12) {
            return 0;
        }
        // Represent as k 10ⁿ for some n, k ∈ ℤ.
        const decimalComponent = 10 ** Math.floor(Math.log10(Math.abs(scaleRatio)));
        const roundAmountFactor = 2 ** roundAmount;
        scaleRatio =
            (Math.round((scaleRatio / decimalComponent) * roundAmountFactor) / roundAmountFactor) *
                decimalComponent;
        return scaleRatio;
    }
    // Computes and returns an affine transformation that makes `toMakeVisible` visible and roughly centered on the screen.
    computeZoomToTransform(toMakeVisible, allowZoomIn = true, allowZoomOut = true) {
        let transform = _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Mat33.identity;
        // Invalid size? (Would divide by zero)
        if (toMakeVisible.w === 0 || toMakeVisible.h === 0) {
            // Create a new rectangle with a valid size
            let newSize = Math.max(toMakeVisible.w, toMakeVisible.h);
            // Choose a reasonable default size, but don't zoom.
            if (newSize === 0) {
                newSize = 50;
                allowZoomIn = false;
                allowZoomOut = false;
            }
            toMakeVisible = new _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Rect2(toMakeVisible.x, toMakeVisible.y, newSize, newSize);
        }
        if (isNaN(toMakeVisible.size.magnitude())) {
            throw new Error(`${toMakeVisible.toString()} rectangle has NaN size! Cannot zoom to!`);
        }
        // Try to move the selection within the center 4/5ths of the viewport.
        const recomputeTargetRect = () => {
            // transform transforms objects on the canvas. As such, we need to invert it
            // to transform the viewport.
            const visibleRect = this.visibleRect.transformedBoundingBox(transform.inverse());
            return visibleRect.transformedBoundingBox(_js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Mat33.scaling2D(4 / 5, visibleRect.center));
        };
        let targetRect = recomputeTargetRect();
        const largerThanTarget = targetRect.w < toMakeVisible.w || targetRect.h < toMakeVisible.h;
        // Ensure that toMakeVisible is at least 1/3rd of the visible region.
        const muchSmallerThanTarget = toMakeVisible.maxDimension / targetRect.maxDimension < 1 / 3;
        if ((largerThanTarget && allowZoomOut) || (muchSmallerThanTarget && allowZoomIn)) {
            const multiplier = Math.max(toMakeVisible.w / targetRect.w, toMakeVisible.h / targetRect.h);
            const visibleRectTransform = _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Mat33.scaling2D(multiplier, targetRect.topLeft);
            const viewportContentTransform = visibleRectTransform.inverse();
            transform = transform.rightMul(viewportContentTransform);
        }
        targetRect = recomputeTargetRect();
        // Ensure that the center of the region is visible
        if (!targetRect.containsRect(toMakeVisible)) {
            // target position - current position
            const translation = toMakeVisible.center.minus(targetRect.center);
            const visibleRectTransform = _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Mat33.translation(translation);
            const viewportContentTransform = visibleRectTransform.inverse();
            transform = transform.rightMul(viewportContentTransform);
        }
        if (!transform.invertable()) {
            console.warn('Unable to zoom to ', toMakeVisible, '! Computed transform', transform, 'is singular.');
            transform = _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Mat33.identity;
        }
        return transform;
    }
    // Returns a Command that transforms the view such that [rect] is visible, and perhaps
    // centered in the viewport.
    // Returns null if no transformation is necessary
    //
    // @see {@link computeZoomToTransform}
    zoomTo(toMakeVisible, allowZoomIn = true, allowZoomOut = true) {
        const transform = this.computeZoomToTransform(toMakeVisible, allowZoomIn, allowZoomOut);
        return new Viewport.ViewportTransform(transform);
    }
}
// Command that translates/scales the viewport.
Viewport.ViewportTransform = (_a = class extends ViewportTransform {
        constructor(transform) {
            super();
            this.transform = transform;
            _inverseTransform.set(this, void 0);
            __classPrivateFieldSet(this, _inverseTransform, transform.inverse(), "f");
        }
        apply(editor) {
            const viewport = editor.viewport;
            viewport.resetTransform(viewport.transform.rightMul(this.transform));
            editor.queueRerender();
        }
        unapply(editor) {
            const viewport = editor.viewport;
            viewport.resetTransform(viewport.transform.rightMul(__classPrivateFieldGet(this, _inverseTransform, "f")));
            editor.queueRerender();
        }
        description(editor, localizationTable) {
            const result = [];
            // Describe the transformation's affect on the viewport (note that transformation transforms
            // the **elements** within the viewport). Assumes the transformation only does rotation/scale/translation.
            const origVec = editor.viewport.visibleRect.center;
            const linearTransformedVec = this.transform.transformVec3(_js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Vec2.unitX);
            const affineTransformedVec = this.transform.transformVec2(origVec);
            const scale = linearTransformedVec.magnitude();
            const rotation = (180 / Math.PI) * linearTransformedVec.angle();
            const translation = affineTransformedVec.minus(origVec);
            if (scale > 1.2) {
                result.push(localizationTable.zoomedIn);
            }
            else if (scale < 0.8) {
                result.push(localizationTable.zoomedOut);
            }
            if (Math.floor(Math.abs(rotation)) > 0) {
                result.push(localizationTable.rotatedBy(Math.round(rotation)));
            }
            const minTranslation = 1e-4;
            if (translation.x > minTranslation) {
                result.push(localizationTable.movedLeft);
            }
            else if (translation.x < -minTranslation) {
                result.push(localizationTable.movedRight);
            }
            if (translation.y < -minTranslation) {
                result.push(localizationTable.movedDown);
            }
            else if (translation.y > minTranslation) {
                result.push(localizationTable.movedUp);
            }
            return result.join('; ');
        }
    },
    _inverseTransform = new WeakMap(),
    _a);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Viewport);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/commands/Command.mjs":
/*!************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/commands/Command.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Command: () => (/* binding */ Command),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * A `Command` is an action that can be done, redone, and undone. It's used to enable undo/redo.
 *
 * See {@link Editor.dispatch}.
 */
class Command {
    // Called when the command is being deleted
    onDrop(_editor) { }
    /** @deprecated Use {@link uniteCommands} */
    static union(a, b) {
        return new (class extends Command {
            apply(editor) {
                a.apply(editor);
                b.apply(editor);
            }
            unapply(editor) {
                b.unapply(editor);
                a.unapply(editor);
            }
            description(editor, localizationTable) {
                const aDescription = a.description(editor, localizationTable);
                const bDescription = b.description(editor, localizationTable);
                if (aDescription === bDescription) {
                    return aDescription;
                }
                return `${aDescription}, ${bDescription}`;
            }
        })();
    }
}
Command.empty = new (class extends Command {
    description(_editor, _localizationTable) {
        return '';
    }
    apply(_editor) { }
    unapply(_editor) { }
})();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Command);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/commands/Duplicate.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/commands/Duplicate.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _components_util_describeComponentList_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/util/describeComponentList.mjs */ "./node_modules/js-draw/dist/mjs/components/util/describeComponentList.mjs");
/* harmony import */ var _Erase_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Erase.mjs */ "./node_modules/js-draw/dist/mjs/commands/Erase.mjs");
/* harmony import */ var _SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SerializableCommand.mjs */ "./node_modules/js-draw/dist/mjs/commands/SerializableCommand.mjs");



/**
 * A command that duplicates the {@link AbstractComponent}s it's given. This command
 * is the reverse of an {@link Erase} command.
 *
 * @example
 * ```ts
 * // Given some editor...
 *
 * // Find all elements intersecting the rectangle with top left (0,0) and
 * // (width,height)=(100,100).
 * const elems = editor.image.getElementsIntersectingRegion(
 * 	new Rect2(0, 0, 100, 100)
 * );
 *
 * // Create a command that, when applied, will duplicate the elements.
 * const duplicateElems = new Duplicate(elems);
 *
 * // Apply the command (and make it undoable)
 * editor.dispatch(duplicateElems);
 * ```
 *
 * @see {@link Editor.dispatch} {@link EditorImage.getElementsIntersectingRegion}
 */
class Duplicate extends _SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(toDuplicate) {
        super('duplicate');
        this.toDuplicate = toDuplicate;
        this.duplicates = toDuplicate.map((elem) => elem.clone());
        this.reverse = new _Erase_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](this.duplicates);
    }
    apply(editor) {
        this.reverse.unapply(editor);
    }
    unapply(editor) {
        this.reverse.apply(editor);
    }
    onDrop(editor) {
        this.reverse.onDrop(editor);
    }
    description(_editor, localizationTable) {
        if (this.duplicates.length === 0) {
            return localizationTable.duplicatedNoElements;
        }
        return localizationTable.duplicateAction((0,_components_util_describeComponentList_mjs__WEBPACK_IMPORTED_MODULE_0__["default"])(localizationTable, this.duplicates) ?? localizationTable.elements, this.duplicates.length);
    }
    serializeToJSON() {
        return this.toDuplicate.map((elem) => elem.getId());
    }
}
(() => {
    _SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].register('duplicate', (json, editor) => {
        const elems = json.map((id) => editor.image.lookupElement(id));
        return new Duplicate(elems);
    });
})();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Duplicate);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/commands/Erase.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/commands/Erase.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _components_AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/AbstractComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/AbstractComponent.mjs");
/* harmony import */ var _components_util_describeComponentList_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/util/describeComponentList.mjs */ "./node_modules/js-draw/dist/mjs/components/util/describeComponentList.mjs");
/* harmony import */ var _image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../image/EditorImage.mjs */ "./node_modules/js-draw/dist/mjs/image/EditorImage.mjs");
/* harmony import */ var _SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SerializableCommand.mjs */ "./node_modules/js-draw/dist/mjs/commands/SerializableCommand.mjs");




/**
 * Removes the given {@link AbstractComponent}s from the image.
 *
 * **Example**:
 * ```ts,runnable
 * import { Editor, Erase, uniteCommands, Color4, Path, Stroke, Rect2, pathToRenderable } from 'js-draw';
 *
 * const editor = new Editor(document.body);
 * editor.addToolbar();
 *
 * // Add a large number of strokes
 * const commands = [];
 * for (let x = -20; x < 20; x++) {
 *   for (let y = 0; y < 60; y++) {
 *     const stroke = new Stroke([
 *       pathToRenderable(
 *         Path.fromString(`m${x * 5},${y * 5}l1,1`),
 *         { fill: Color4.transparent, stroke: {width: 2, color: Color4.ofRGB(x / 10, y / 10, 0.5)}} )
 *       ]);
 *     commands.push(editor.image.addElement(stroke));
 *   }
 * }
 * await editor.dispatch(uniteCommands(commands, 100));
 *
 * ---visible---
 * // Given some editor...
 *
 * // Find all elements intersecting the rectangle with top left (-10,-30) and
 * // (width,height)=(50,100).
 * const elems = editor.image.getElementsIntersectingRegion(
 * 	new Rect2(-10, -30, 50, 100)
 * );
 *
 * // Create a command that erases [elems] when applied
 * const eraseElemsCmd = new Erase(elems);
 *
 * // Apply the command (and make it undoable)
 * editor.dispatch(eraseElemsCmd);
 * ```
 */
class Erase extends _SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(toRemove) {
        super('erase');
        // Clone the list
        this.toRemove = toRemove.map((elem) => elem);
        this.applied = false;
    }
    apply(editor) {
        for (const part of this.toRemove) {
            const parent = editor.image.findParent(part);
            if (parent) {
                parent.remove();
                editor.image.onDestroyElement(part);
            }
        }
        this.applied = true;
        editor.queueRerender();
    }
    unapply(editor) {
        for (const part of this.toRemove) {
            if (!editor.image.findParent(part)) {
                _image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].addElement(part).apply(editor);
            }
        }
        this.applied = false;
        editor.queueRerender();
    }
    onDrop(editor) {
        if (this.applied) {
            for (const part of this.toRemove) {
                editor.image.onDestroyElement(part);
            }
        }
    }
    description(_editor, localizationTable) {
        if (this.toRemove.length === 0) {
            return localizationTable.erasedNoElements;
        }
        const description = (0,_components_util_describeComponentList_mjs__WEBPACK_IMPORTED_MODULE_1__["default"])(localizationTable, this.toRemove) ?? localizationTable.elements;
        return localizationTable.eraseAction(description, this.toRemove.length);
    }
    serializeToJSON() {
        // If applied, the elements can't be fetched from the image because they're
        // erased. Serialize and return the elements themselves.
        const elems = this.toRemove.map((elem) => elem.serialize());
        return elems;
    }
}
(() => {
    _SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].register('erase', (json, editor) => {
        if (!Array.isArray(json)) {
            throw new Error('seralized erase data must be an array');
        }
        const elems = json.map((elemData) => {
            const componentId = typeof elemData === 'string' ? elemData : `${elemData.id}`;
            const component = editor.image.lookupElement(componentId) ?? _components_AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].deserialize(elemData);
            return component;
        });
        return new Erase(elems);
    });
})();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Erase);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/commands/SerializableCommand.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/commands/SerializableCommand.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Command_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Command.mjs */ "./node_modules/js-draw/dist/mjs/commands/Command.mjs");
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SerializableCommand_commandTypeId;

/**
 * A command that can be serialized to or deserialized from JSON. To allow a command to be deserialized, {@link SerializableCommand.register}
 * must be called for each {@link SerializableCommand}.
 *
 * This is used to [allow collaborative editing](https://github.com/personalizedrefrigerator/js-draw/tree/main/docs/examples/example-collaborative).
 */
class SerializableCommand extends _Command_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /** @param commandTypeId - A unique identifier for this command. */
    constructor(commandTypeId) {
        super();
        _SerializableCommand_commandTypeId.set(this, void 0);
        if (!(commandTypeId in SerializableCommand.deserializationCallbacks)) {
            throw new Error(`Command ${commandTypeId} must have a registered deserialization callback. To do this, call SerializableCommand.register.`);
        }
        __classPrivateFieldSet(this, _SerializableCommand_commandTypeId, commandTypeId, "f");
    }
    // Convert this command to an object that can be passed to `JSON.stringify`.
    //
    // Do not rely on the stability of the optupt of this function — it can change
    // form without a major version increase.
    serialize() {
        return {
            data: this.serializeToJSON(),
            commandType: __classPrivateFieldGet(this, _SerializableCommand_commandTypeId, "f"),
        };
    }
    // Convert a `string` containing JSON data (or the output of `JSON.parse`) into a
    // `Command`.
    //
    // Implementations should assume that `data` is untrusted.
    static deserialize(data, editor) {
        const json = typeof data === 'string' ? JSON.parse(data) : data;
        const commandType = json.commandType;
        if (!(commandType in SerializableCommand.deserializationCallbacks)) {
            throw new Error(`Unrecognised command type ${commandType}!`);
        }
        return SerializableCommand.deserializationCallbacks[commandType](json.data, editor);
    }
    // Register a deserialization callback. This must be called at least once for every subclass of
    // `SerializableCommand`.
    static register(commandTypeId, deserialize) {
        SerializableCommand.deserializationCallbacks[commandTypeId] = deserialize;
    }
}
_SerializableCommand_commandTypeId = new WeakMap();
SerializableCommand.deserializationCallbacks = {};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SerializableCommand);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/commands/UnresolvedCommand.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/commands/UnresolvedCommand.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ UnresolvedSerializableCommand)
/* harmony export */ });
/* harmony import */ var _SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SerializableCommand.mjs */ "./node_modules/js-draw/dist/mjs/commands/SerializableCommand.mjs");

/**
 * A command that requires a component that may or may not be present in the editor when
 * the command is created.
 */
class UnresolvedSerializableCommand extends _SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(commandId, componentID, component) {
        super(commandId);
        this.component = component ?? null;
        this.componentID = componentID;
    }
    resolveComponent(image) {
        if (this.component) {
            return;
        }
        const component = image.lookupElement(this.componentID);
        if (!component) {
            throw new Error(`Unable to resolve component with ID ${this.componentID}`);
        }
        this.component = component;
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/commands/invertCommand.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/commands/invertCommand.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Command_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Command.mjs */ "./node_modules/js-draw/dist/mjs/commands/Command.mjs");
/* harmony import */ var _SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SerializableCommand.mjs */ "./node_modules/js-draw/dist/mjs/commands/SerializableCommand.mjs");


// Returns a command that does the opposite of the given command --- `result.apply()` calls
// `command.unapply()` and `result.unapply()` calls `command.apply()`.
const invertCommand = (command) => {
    if (command instanceof _SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]) {
        // SerializableCommand that does the inverse of [command]
        return new (class extends _SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
            constructor() {
                super(...arguments);
                // For debugging
                this._command = command;
            }
            serializeToJSON() {
                return command.serialize();
            }
            apply(editor) {
                command.unapply(editor);
            }
            unapply(editor) {
                command.apply(editor);
            }
            onDrop(editor) {
                command.onDrop(editor);
            }
            description(editor, localizationTable) {
                return localizationTable.inverseOf(command.description(editor, localizationTable));
            }
        })('inverse');
    }
    else {
        // Command that does the inverse of [command].
        const result = new (class extends _Command_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
            apply(editor) {
                command.unapply(editor);
            }
            unapply(editor) {
                command.apply(editor);
            }
            onDrop(editor) {
                command.onDrop(editor);
            }
            description(editor, localizationTable) {
                return localizationTable.inverseOf(command.description(editor, localizationTable));
            }
        })();
        // We know that T does not extend SerializableCommand, and thus returning a Command
        // is appropriate.
        return result;
    }
};
_SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].register('inverse', (data, editor) => {
    return invertCommand(_SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].deserialize(data, editor));
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (invertCommand);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/commands/lib.mjs":
/*!********************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/commands/lib.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Command: () => (/* reexport safe */ _Command_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   Duplicate: () => (/* reexport safe */ _Duplicate_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   Erase: () => (/* reexport safe */ _Erase_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   SerializableCommand: () => (/* reexport safe */ _SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   invertCommand: () => (/* reexport safe */ _invertCommand_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   uniteCommands: () => (/* reexport safe */ _uniteCommands_mjs__WEBPACK_IMPORTED_MODULE_5__["default"])
/* harmony export */ });
/* harmony import */ var _Command_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Command.mjs */ "./node_modules/js-draw/dist/mjs/commands/Command.mjs");
/* harmony import */ var _Duplicate_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Duplicate.mjs */ "./node_modules/js-draw/dist/mjs/commands/Duplicate.mjs");
/* harmony import */ var _Erase_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Erase.mjs */ "./node_modules/js-draw/dist/mjs/commands/Erase.mjs");
/* harmony import */ var _invertCommand_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./invertCommand.mjs */ "./node_modules/js-draw/dist/mjs/commands/invertCommand.mjs");
/* harmony import */ var _SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SerializableCommand.mjs */ "./node_modules/js-draw/dist/mjs/commands/SerializableCommand.mjs");
/* harmony import */ var _uniteCommands_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./uniteCommands.mjs */ "./node_modules/js-draw/dist/mjs/commands/uniteCommands.mjs");









/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/commands/localization.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/commands/localization.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultCommandLocalization: () => (/* binding */ defaultCommandLocalization)
/* harmony export */ });
const defaultCommandLocalization = {
    updatedViewport: 'Transformed Viewport',
    transformedElements: (elemCount) => `Transformed ${elemCount} element${elemCount === 1 ? '' : 's'}`,
    resizeOutputCommand: (newSize) => `Resized image to ${newSize.w}x${newSize.h}`,
    enabledAutoresizeOutputCommand: 'Enabled output autoresize',
    disabledAutoresizeOutputCommand: 'Disabled output autoresize',
    addElementAction: (componentDescription) => `Added ${componentDescription}`,
    eraseAction: (componentDescription, numElems) => `Erased ${numElems} ${componentDescription}`,
    duplicateAction: (componentDescription, numElems) => `Duplicated ${numElems} ${componentDescription}`,
    unionOf: (actionDescription, actionCount) => `Union: ${actionCount} ${actionDescription}`,
    inverseOf: (actionDescription) => `Inverse of ${actionDescription}`,
    elements: 'Elements',
    erasedNoElements: 'Erased nothing',
    duplicatedNoElements: 'Duplicated nothing',
    rotatedBy: (degrees) => `Rotated by ${Math.abs(degrees)} degrees ${degrees < 0 ? 'clockwise' : 'counter-clockwise'}`,
    movedLeft: 'Moved left',
    movedUp: 'Moved up',
    movedDown: 'Moved down',
    movedRight: 'Moved right',
    zoomedOut: 'Zoomed out',
    zoomedIn: 'Zoomed in',
    andNMoreCommands: (count) => `And ${count} more commands.`,
    selectedElements: (count) => `Selected ${count} element${count === 1 ? '' : 's'}`,
};


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/commands/uniteCommands.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/commands/uniteCommands.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_waitForAll_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/waitForAll.mjs */ "./node_modules/js-draw/dist/mjs/util/waitForAll.mjs");
/* harmony import */ var _Command_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Command.mjs */ "./node_modules/js-draw/dist/mjs/commands/Command.mjs");
/* harmony import */ var _SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SerializableCommand.mjs */ "./node_modules/js-draw/dist/mjs/commands/SerializableCommand.mjs");



class NonSerializableUnion extends _Command_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(commands, applyChunkSize, descriptionOverride) {
        super();
        this.commands = commands;
        this.applyChunkSize = applyChunkSize;
        this.descriptionOverride = descriptionOverride;
    }
    apply(editor) {
        if (this.applyChunkSize === undefined) {
            const results = this.commands.map((cmd) => cmd.apply(editor));
            return (0,_util_waitForAll_mjs__WEBPACK_IMPORTED_MODULE_0__["default"])(results);
        }
        else {
            return editor.asyncApplyCommands(this.commands, this.applyChunkSize);
        }
    }
    unapply(editor) {
        const commands = [...this.commands];
        commands.reverse();
        if (this.applyChunkSize === undefined) {
            const results = commands.map((cmd) => cmd.unapply(editor));
            return (0,_util_waitForAll_mjs__WEBPACK_IMPORTED_MODULE_0__["default"])(results);
        }
        else {
            return editor.asyncUnapplyCommands(commands, this.applyChunkSize, false);
        }
    }
    onDrop(editor) {
        this.commands.forEach((command) => command.onDrop(editor));
    }
    description(editor, localizationTable) {
        if (this.descriptionOverride) {
            return this.descriptionOverride;
        }
        const descriptions = [];
        let lastDescription = null;
        let duplicateDescriptionCount = 0;
        let handledCommandCount = 0;
        for (const part of this.commands) {
            const description = part.description(editor, localizationTable);
            if (description !== lastDescription && lastDescription !== null) {
                descriptions.push(localizationTable.unionOf(lastDescription, duplicateDescriptionCount));
                lastDescription = null;
                duplicateDescriptionCount = 0;
            }
            duplicateDescriptionCount++;
            handledCommandCount++;
            lastDescription ??= description;
            // Long descriptions aren't very useful to the user.
            const maxDescriptionLength = 12;
            if (descriptions.length > maxDescriptionLength) {
                break;
            }
        }
        if (duplicateDescriptionCount > 1) {
            descriptions.push(localizationTable.unionOf(lastDescription, duplicateDescriptionCount));
        }
        else if (duplicateDescriptionCount === 1) {
            descriptions.push(lastDescription);
        }
        if (handledCommandCount < this.commands.length) {
            descriptions.push(localizationTable.andNMoreCommands(this.commands.length - handledCommandCount));
        }
        return descriptions.join(', ');
    }
}
class SerializableUnion extends _SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(commands, applyChunkSize, descriptionOverride) {
        super('union');
        this.commands = commands;
        this.applyChunkSize = applyChunkSize;
        this.descriptionOverride = descriptionOverride;
        this.nonserializableCommand = new NonSerializableUnion(commands, applyChunkSize, descriptionOverride);
    }
    serializeToJSON() {
        if (this.serializedData) {
            return this.serializedData;
        }
        return {
            applyChunkSize: this.applyChunkSize,
            data: this.commands.map((command) => command.serialize()),
            description: this.descriptionOverride,
        };
    }
    apply(editor) {
        // Cache this' serialized form -- applying this may change how commands serialize.
        this.serializedData = this.serializeToJSON();
        return this.nonserializableCommand.apply(editor);
    }
    unapply(editor) {
        return this.nonserializableCommand.unapply(editor);
    }
    onDrop(editor) {
        this.nonserializableCommand.onDrop(editor);
    }
    description(editor, localizationTable) {
        return this.nonserializableCommand.description(editor, localizationTable);
    }
}
/**
 * Creates a single command from `commands`. This is useful when undoing should undo *all* commands
 * in `commands` at once, rather than one at a time.
 *
 * @example
 *
 * ```ts,runnable
 * import { Editor, pathToRenderable, Stroke, uniteCommands } from 'js-draw';
 * import { Path, Color4 } from '@js-draw/math';
 *
 * const editor = new Editor(document.body);
 * editor.addToolbar();
 *
 * // Create strokes!
 * const strokes = [];
 * for (let i = 0; i < 10; i++) {
 *   const renderablePath = pathToRenderable(
 *     Path.fromString(`M0,${i * 10} L100,100 L300,30 z`),
 *     { fill: Color4.transparent, stroke: { color: Color4.red, width: 1, } }
 *   );
 *   strokes.push(new Stroke([ renderablePath ]));
 * }
 *
 * // Convert to commands
 * const addStrokesCommands = strokes.map(stroke => editor.image.addElement(stroke));
 *
 * // Apply all as a single undoable command (try applying each in a loop instead!)
 * await editor.dispatch(uniteCommands(addStrokesCommands));
 *
 * // The second parameter to uniteCommands is for very large numbers of commands, when
 * // applying them shouldn't be done all at once (which would block the UI).
 *
 * // The second parameter to uniteCommands is for very large numbers of commands, when
 * // applying them shouldn't be done all at once (which would block the UI).
 * ```
 */
const uniteCommands = (commands, options) => {
    let allSerializable = true;
    for (const command of commands) {
        if (!(command instanceof _SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_2__["default"])) {
            allSerializable = false;
            break;
        }
    }
    let applyChunkSize;
    let description;
    if (typeof options === 'number') {
        applyChunkSize = options;
    }
    else {
        applyChunkSize = options?.applyChunkSize;
        description = options?.description;
    }
    if (!allSerializable) {
        return new NonSerializableUnion(commands, applyChunkSize, description);
    }
    else {
        const castedCommands = commands;
        return new SerializableUnion(castedCommands, applyChunkSize, description);
    }
};
_SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].register('union', (data, editor) => {
    if (typeof data.data.length !== 'number') {
        throw new Error('Unions of commands must serialize to lists of serialization data.');
    }
    const applyChunkSize = data.applyChunkSize;
    if (typeof applyChunkSize !== 'number' && applyChunkSize !== undefined) {
        throw new Error('serialized applyChunkSize is neither undefined nor a number.');
    }
    const description = typeof data.description === 'string' ? data.description : undefined;
    const commands = [];
    for (const part of data.data) {
        commands.push(_SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].deserialize(part, editor));
    }
    return uniteCommands(commands, { applyChunkSize, description });
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (uniteCommands);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/components/AbstractComponent.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/components/AbstractComponent.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ComponentSizingMode: () => (/* binding */ ComponentSizingMode),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _commands_SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../commands/SerializableCommand.mjs */ "./node_modules/js-draw/dist/mjs/commands/SerializableCommand.mjs");
/* harmony import */ var _image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../image/EditorImage.mjs */ "./node_modules/js-draw/dist/mjs/image/EditorImage.mjs");
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _commands_UnresolvedCommand_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../commands/UnresolvedCommand.mjs */ "./node_modules/js-draw/dist/mjs/commands/UnresolvedCommand.mjs");
var __setFunctionName = (undefined && undefined.__setFunctionName) || function (f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};
var _a;




var ComponentSizingMode;
(function (ComponentSizingMode) {
    /** The default. The compnent gets its size from its bounding box. */
    ComponentSizingMode[ComponentSizingMode["BoundingBox"] = 0] = "BoundingBox";
    /** Causes the component to fill the entire visible region of the screen */
    ComponentSizingMode[ComponentSizingMode["FillScreen"] = 1] = "FillScreen";
    /**
     * Displays the component anywhere (arbitrary location) on the
     * canvas. (Ignoring the bounding box).
     *
     * These components may be ignored unless a full render is done.
     *
     * Intended for compnents that need to be rendered on a full export,
     * but won't be visible to the user.
     *
     * For example, a metadata component.
     */
    ComponentSizingMode[ComponentSizingMode["Anywhere"] = 2] = "Anywhere";
})(ComponentSizingMode || (ComponentSizingMode = {}));
/**
 * A base class for everything that can be added to an {@link EditorImage}.
 */
class AbstractComponent {
    constructor(
    // A unique identifier for the type of component
    componentKind, initialZIndex) {
        this.componentKind = componentKind;
        // Stores data attached by a loader.
        this.loadSaveData = {};
        this.lastChangedTime = new Date().getTime();
        if (initialZIndex !== undefined) {
            this.zIndex = initialZIndex;
        }
        else {
            this.zIndex = AbstractComponent.zIndexCounter++;
        }
        // Create a unique ID.
        this.id = `${new Date().getTime()}-${Math.random()}`;
        if (AbstractComponent.deserializationCallbacks[componentKind] === undefined) {
            throw new Error(`Component ${componentKind} has not been registered using AbstractComponent.registerComponent`);
        }
    }
    // Returns a unique ID for this element.
    // @see { @link EditorImage.lookupElement }
    getId() {
        return this.id;
    }
    // Store the deserialization callback (or lack of it) for [componentKind].
    // If components are registered multiple times (as may be done in automated tests),
    // the most recent deserialization callback is used.
    static registerComponent(componentKind, deserialize) {
        this.deserializationCallbacks[componentKind] = deserialize ?? null;
    }
    /**
     * Attach data that can be used while exporting the component (e.g. to SVG).
     *
     * This is intended for use by an {@link ImageLoader}.
     */
    attachLoadSaveData(key, data) {
        if (!this.loadSaveData[key]) {
            this.loadSaveData[key] = [];
        }
        this.loadSaveData[key].push(data);
    }
    /** See {@link attachLoadSaveData} */
    getLoadSaveData() {
        return this.loadSaveData;
    }
    getZIndex() {
        return this.zIndex;
    }
    /**
     * @returns the bounding box of this. This can be a slight overestimate if doing so
     * 			significantly improves performance.
     */
    getBBox() {
        return this.contentBBox;
    }
    /**
     * @returns the bounding box of this. Unlike `getBBox`, this should **not** be a rough estimate.
     */
    getExactBBox() {
        return this.getBBox();
    }
    /**
     * Returns information about how this component should be displayed
     * (e.g. fill the screen or get its size from {@link getBBox}).
     *
     * {@link EditorImage.queueRerenderOf} must be called to apply changes to
     * the output of this method if this component has already been added to an
     * {@link EditorImage}.
     */
    getSizingMode() {
        return ComponentSizingMode.BoundingBox;
    }
    /**
     * **Optimization**
     *
     * Should return `true` if this component covers the entire `visibleRect`
     * and would prevent anything below this component from being visible.
     *
     * Should return `false` otherwise.
     */
    occludesEverythingBelowWhenRenderedInRect(_visibleRect) {
        return false;
    }
    /** Called when this component is added to the given image. */
    onAddToImage(_image) { }
    onRemoveFromImage() { }
    /**
     * @returns true if this component intersects `rect` -- it is entirely contained
     *  within the rectangle or one of the rectangle's edges intersects this component.
     *
     * The default implementation assumes that `this.getExactBBox()` returns a tight bounding box
     * -- that any horiziontal/vertical line that intersects this' boounding box also
     * intersects a point in this component. If this is not the case, components must override
     * this function.
     */
    intersectsRect(rect) {
        // If this component intersects the given rectangle,
        // it is either contained entirely within rect or intersects one of rect's edges.
        // If contained within,
        if (rect.containsRect(this.getExactBBox())) {
            return true;
        }
        // Otherwise check if it intersects one of the rectangle's edges.
        const testLines = rect.getEdges();
        return testLines.some((edge) => this.intersects(edge));
    }
    // @returns true iff this component can be selected (e.g. by the selection tool.)
    isSelectable() {
        return true;
    }
    // @returns true iff this component should be added to the background, rather than the
    // foreground of the image.
    isBackground() {
        return false;
    }
    // @returns an approximation of the proportional time it takes to render this component.
    // This is intended to be a rough estimate, but, for example, a stroke with two points sould have
    // a renderingWeight approximately twice that of a stroke with one point.
    getProportionalRenderingTime() {
        return 1;
    }
    /**
     * Returns a command that, when applied, transforms this by [affineTransfm] and
     * updates the editor.
     *
     * The transformed component is also moved to the top (use
     * {@link AbstractComponent#setZIndexAndTransformBy} to avoid this behavior).
     */
    transformBy(affineTransfm) {
        return new AbstractComponent.TransformElementCommand(affineTransfm, this.getId(), this);
    }
    // Returns a command that updates this component's z-index.
    setZIndex(newZIndex) {
        return new AbstractComponent.TransformElementCommand(_js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Mat33.identity, this.getId(), this, newZIndex);
    }
    /**
     * Combines {@link transformBy} and {@link setZIndex} into a single command.
     *
     * @param newZIndex - The z-index this component should have after applying this command.
     * @param originalZIndex - @internal The z-index the component should revert to after unapplying
     *                         this command.
     */
    setZIndexAndTransformBy(affineTransfm, newZIndex, originalZIndex) {
        return new AbstractComponent.TransformElementCommand(affineTransfm, this.getId(), this, newZIndex, originalZIndex);
    }
    // Returns a copy of this component.
    clone() {
        const clone = this.createClone();
        for (const attachmentKey in this.loadSaveData) {
            for (const val of this.loadSaveData[attachmentKey]) {
                clone.attachLoadSaveData(attachmentKey, val);
            }
        }
        return clone;
    }
    // Convert the component to an object that can be passed to
    // `JSON.stringify`.
    //
    // Do not rely on the output of this function to take a particular form —
    // this function's output can change form without a major version increase.
    serialize() {
        const data = this.serializeToJSON();
        if (data === null) {
            throw new Error(`${this} cannot be serialized.`);
        }
        return {
            name: this.componentKind,
            zIndex: this.zIndex,
            id: this.id,
            loadSaveData: this.loadSaveData,
            data,
        };
    }
    // Returns true if `data` is not deserializable. May return false even if [data]
    // is not deserializable.
    static isNotDeserializable(json) {
        if (typeof json === 'string') {
            json = JSON.parse(json);
        }
        if (typeof json !== 'object') {
            return true;
        }
        if (!this.deserializationCallbacks[json?.name]) {
            return true;
        }
        if (!json.data) {
            return true;
        }
        return false;
    }
    // Convert a string or an object produced by `JSON.parse` into an `AbstractComponent`.
    static deserialize(json) {
        if (typeof json === 'string') {
            json = JSON.parse(json);
        }
        if (AbstractComponent.isNotDeserializable(json)) {
            throw new Error(`Element with data ${json} cannot be deserialized.`);
        }
        const instance = this.deserializationCallbacks[json.name](json.data);
        instance.id = json.id;
        if (isFinite(json.zIndex)) {
            instance.zIndex = json.zIndex;
            // Ensure that new components will be added on top.
            AbstractComponent.zIndexCounter = Math.max(AbstractComponent.zIndexCounter, instance.zIndex + 1);
        }
        // TODO: What should we do with json.loadSaveData?
        //       If we attach it to [instance], we create a potential security risk — loadSaveData
        //       is often used to store unrecognised attributes so they can be preserved on output.
        //       ...but what if we're deserializing data sent across the network?
        return instance;
    }
}
// Topmost z-index
// TODO: Should be a property of the EditorImage.
AbstractComponent.zIndexCounter = 0;
AbstractComponent.deserializationCallbacks = {};
AbstractComponent.transformElementCommandId = 'transform-element';
AbstractComponent.TransformElementCommand = (_a = class extends _commands_UnresolvedCommand_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
        // Construct a new TransformElementCommand. `component`, while optional, should
        // be provided if available. If not provided, it will be fetched from the editor's
        // document when the command is applied.
        constructor(affineTransfm, componentID, component, targetZIndex, origZIndex) {
            super(AbstractComponent.transformElementCommandId, componentID, component);
            this.affineTransfm = affineTransfm;
            this.origZIndex = origZIndex;
            this.targetZIndex = targetZIndex ?? AbstractComponent.zIndexCounter++;
            // Ensure that we keep drawing on top even after changing the z-index.
            if (this.targetZIndex >= AbstractComponent.zIndexCounter) {
                AbstractComponent.zIndexCounter = this.targetZIndex + 1;
            }
            if (component && origZIndex === undefined) {
                this.origZIndex = component.getZIndex();
            }
        }
        resolveComponent(image) {
            if (this.component) {
                return;
            }
            super.resolveComponent(image);
            this.origZIndex ??= this.component.getZIndex();
        }
        updateTransform(editor, newTransfm, targetZIndex) {
            if (!this.component) {
                throw new Error('this.component is undefined or null!');
            }
            // Any parent should have only one direct child.
            const parent = editor.image.findParent(this.component);
            let hadParent = false;
            if (parent) {
                parent.remove();
                hadParent = true;
            }
            this.component.applyTransformation(newTransfm);
            this.component.zIndex = targetZIndex;
            this.component.lastChangedTime = new Date().getTime();
            // Ensure that new components are automatically drawn above the current component.
            if (targetZIndex >= AbstractComponent.zIndexCounter) {
                AbstractComponent.zIndexCounter = targetZIndex + 1;
            }
            // Add the element back to the document.
            if (hadParent) {
                _image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].addElement(this.component).apply(editor);
            }
        }
        apply(editor) {
            this.resolveComponent(editor.image);
            this.updateTransform(editor, this.affineTransfm, this.targetZIndex);
            editor.queueRerender();
        }
        unapply(editor) {
            this.resolveComponent(editor.image);
            this.updateTransform(editor, this.affineTransfm.inverse(), this.origZIndex);
            editor.queueRerender();
        }
        description(_editor, localizationTable) {
            return localizationTable.transformedElements(1);
        }
        serializeToJSON() {
            return {
                id: this.componentID,
                transfm: this.affineTransfm.toArray(),
                targetZIndex: this.targetZIndex,
                origZIndex: this.origZIndex,
            };
        }
    },
    __setFunctionName(_a, "TransformElementCommand"),
    (() => {
        _commands_SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].register(AbstractComponent.transformElementCommandId, (json, editor) => {
            const elem = editor.image.lookupElement(json.id) ?? undefined;
            const transform = new _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Mat33(...json.transfm);
            const targetZIndex = json.targetZIndex;
            const origZIndex = json.origZIndex ?? undefined;
            return new AbstractComponent.TransformElementCommand(transform, json.id, elem, targetZIndex, origZIndex);
        });
    })(),
    _a);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AbstractComponent);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/components/BackgroundComponent.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/components/BackgroundComponent.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BackgroundType: () => (/* binding */ BackgroundType),
/* harmony export */   backgroundTypeToClassNameMap: () => (/* binding */ backgroundTypeToClassNameMap),
/* harmony export */   "default": () => (/* binding */ BackgroundComponent),
/* harmony export */   imageBackgroundCSSClassName: () => (/* binding */ imageBackgroundCSSClassName),
/* harmony export */   imageBackgroundGridSizeCSSPrefix: () => (/* binding */ imageBackgroundGridSizeCSSPrefix),
/* harmony export */   imageBackgroundNonAutomaticSecondaryColorCSSClassName: () => (/* binding */ imageBackgroundNonAutomaticSecondaryColorCSSClassName)
/* harmony export */ });
/* harmony import */ var _image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../image/EditorImage.mjs */ "./node_modules/js-draw/dist/mjs/image/EditorImage.mjs");
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbstractComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/AbstractComponent.mjs");
/* harmony import */ var _RestylableComponent_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RestylableComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/RestylableComponent.mjs");
/* harmony import */ var _Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Viewport.mjs */ "./node_modules/js-draw/dist/mjs/Viewport.mjs");
/* harmony import */ var _rendering_RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../rendering/RenderablePathSpec.mjs */ "./node_modules/js-draw/dist/mjs/rendering/RenderablePathSpec.mjs");






var BackgroundType;
(function (BackgroundType) {
    BackgroundType[BackgroundType["SolidColor"] = 0] = "SolidColor";
    BackgroundType[BackgroundType["Grid"] = 1] = "Grid";
    BackgroundType[BackgroundType["None"] = 2] = "None";
})(BackgroundType || (BackgroundType = {}));
const imageBackgroundCSSClassName = 'js-draw-image-background';
// Class name prefix indicating the size of the background's grid cells (if present).
const imageBackgroundGridSizeCSSPrefix = 'js-draw-image-background-grid-';
// Flag included in rendered SVGs (etc) that indicates that the secondary color of the
// background has been manually set.
const imageBackgroundNonAutomaticSecondaryColorCSSClassName = 'js-draw-image-background-non-automatic-secondary-color';
const backgroundTypeToClassNameMap = {
    [BackgroundType.Grid]: 'js-draw-image-background-grid',
    [BackgroundType.SolidColor]: imageBackgroundCSSClassName,
    [BackgroundType.None]: '',
};
// Represents the background of the editor's canvas.
class BackgroundComponent extends _AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(backgroundType, mainColor) {
        super('image-background', 0);
        this.backgroundType = backgroundType;
        this.mainColor = mainColor;
        this.viewportSizeChangeListener = null;
        this.autoresizeChangedListener = null;
        // Whether the background should grow/shrink to match the screen size,
        // rather than being clipped to the image boundaries.
        this.fillsScreen = false;
        this.gridSize = _Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getGridSize(2);
        this.gridStrokeWidth = 0.7;
        this.secondaryColor = null;
        // eslint-disable-next-line @typescript-eslint/prefer-as-const
        this.isRestylableComponent = true;
        this.contentBBox = _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Rect2.empty;
    }
    static ofGrid(backgroundColor, gridSize, gridColor, gridStrokeWidth) {
        const background = new BackgroundComponent(BackgroundType.Grid, backgroundColor);
        if (gridSize !== undefined) {
            background.gridSize = gridSize;
        }
        if (gridColor !== undefined) {
            background.secondaryColor = gridColor;
        }
        if (gridStrokeWidth !== undefined) {
            background.gridStrokeWidth = gridStrokeWidth;
        }
        return background;
    }
    getBackgroundType() {
        return this.backgroundType;
    }
    // @internal
    getMainColor() {
        return this.mainColor;
    }
    // @internal
    getSecondaryColor() {
        return this.secondaryColor;
    }
    // @internal
    getGridSize() {
        return this.gridSize;
    }
    getStyle() {
        let color = this.mainColor;
        if (this.backgroundType === BackgroundType.None) {
            color = undefined;
        }
        return {
            color,
        };
    }
    updateStyle(style) {
        return (0,_RestylableComponent_mjs__WEBPACK_IMPORTED_MODULE_3__.createRestyleComponentCommand)(this.getStyle(), style, this);
    }
    // @internal
    forceStyle(style, editor) {
        const fill = style.color;
        if (!fill) {
            return;
        }
        this.mainColor = fill;
        // A solid background and transparent fill is equivalent to no background.
        if (fill.eq(_js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Color4.transparent) && this.backgroundType === BackgroundType.SolidColor) {
            this.backgroundType = BackgroundType.None;
        }
        else if (this.backgroundType === BackgroundType.None) {
            this.backgroundType = BackgroundType.SolidColor;
        }
        if (editor) {
            editor.image.queueRerenderOf(this);
            editor.queueRerender();
        }
    }
    onAddToImage(image) {
        if (this.viewportSizeChangeListener) {
            console.warn('onAddToImage called when background is already in an image');
            this.onRemoveFromImage();
        }
        this.viewportSizeChangeListener = image.notifier.on(_image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorImageEventType.ExportViewportChanged, () => {
            this.recomputeBBox(image);
        });
        this.autoresizeChangedListener = image.notifier.on(_image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorImageEventType.AutoresizeModeChanged, () => {
            this.recomputeBBox(image);
        });
        this.recomputeBBox(image);
    }
    onRemoveFromImage() {
        this.viewportSizeChangeListener?.remove();
        this.autoresizeChangedListener?.remove();
        this.viewportSizeChangeListener = null;
        this.autoresizeChangedListener = null;
    }
    recomputeBBox(image) {
        const importExportRect = image.getImportExportViewport().visibleRect;
        let needsRerender = false;
        if (!this.contentBBox.eq(importExportRect)) {
            this.contentBBox = importExportRect;
            // If the box already fills the screen, rerendering it will have
            // no visual effect.
            //
            // TODO: This decision should be made by queueRerenderOf and not here.
            //
            needsRerender ||= !this.fillsScreen;
        }
        const imageAutoresizes = image.getAutoresizeEnabled();
        if (imageAutoresizes !== this.fillsScreen) {
            this.fillsScreen = imageAutoresizes;
            needsRerender = true;
        }
        if (needsRerender) {
            // Re-renders this if already added to the EditorImage.
            image.queueRerenderOf(this);
        }
    }
    generateGridPath(visibleRect) {
        const contentBBox = this.getFullBoundingBox(visibleRect);
        // .grownBy acts on all sides, so we need only grow by strokeWidth / 2 (1 * the stroke radius)
        const targetRect = (visibleRect?.intersection(contentBBox) ?? contentBBox).grownBy(this.gridStrokeWidth / 2);
        const roundDownToGrid = (coord) => Math.floor(coord / this.gridSize) * this.gridSize;
        const roundUpToGrid = (coord) => Math.ceil(coord / this.gridSize) * this.gridSize;
        const startY = roundUpToGrid(targetRect.y);
        const endY = roundDownToGrid(targetRect.y + targetRect.h);
        const startX = roundUpToGrid(targetRect.x);
        const endX = roundDownToGrid(targetRect.x + targetRect.w);
        const result = [];
        // Don't generate grids with a huge number of rows/columns -- such grids
        // take a long time to render and are likely invisible due to the number of
        // cells.
        const rowCount = (endY - startY) / this.gridSize;
        const colCount = (endX - startX) / this.gridSize;
        const maxGridCols = 1000;
        const maxGridRows = 1000;
        if (rowCount > maxGridRows || colCount > maxGridCols) {
            return _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Path.empty;
        }
        const startPoint = _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(targetRect.x, startY);
        for (let y = startY; y <= endY; y += this.gridSize) {
            result.push({
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.PathCommandType.MoveTo,
                point: _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(targetRect.x, y),
            });
            result.push({
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.PathCommandType.LineTo,
                point: _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(targetRect.x + targetRect.w, y),
            });
        }
        for (let x = startX; x <= endX; x += this.gridSize) {
            result.push({
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.PathCommandType.MoveTo,
                point: _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(x, targetRect.y),
            });
            result.push({
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.PathCommandType.LineTo,
                point: _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(x, targetRect.y + targetRect.h),
            });
        }
        return new _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Path(startPoint, result);
    }
    /**
     * @returns this background's bounding box if the screen size is taken into
     * account (which may be necessary if this component is configured to fill the
     * entire screen).
     */
    getFullBoundingBox(visibleRect) {
        return (this.fillsScreen ? visibleRect : this.contentBBox) ?? this.contentBBox;
    }
    render(canvas, visibleRect) {
        if (this.backgroundType === BackgroundType.None) {
            return;
        }
        // If visibleRect is null, components should render everything.
        // In that case, a full render is being done.
        const mustRender = !visibleRect;
        // If this.fillsScreen, the visibleRect needs to be known.
        // Use the screen rect.
        if (this.fillsScreen) {
            visibleRect ??= canvas.getVisibleRect();
        }
        const clip = this.backgroundType === BackgroundType.Grid;
        const contentBBox = this.getFullBoundingBox(visibleRect);
        canvas.startObject(contentBBox, clip);
        if (this.backgroundType === BackgroundType.SolidColor ||
            this.backgroundType === BackgroundType.Grid) {
            // If the rectangle for this region contains the visible rect,
            // we can fill the entire visible rectangle (which may be more efficient than
            // filling the entire region for this.)
            const intersection = visibleRect?.intersection(contentBBox);
            if (intersection) {
                canvas.fillRect(intersection, this.mainColor);
            }
            else if (mustRender) {
                canvas.fillRect(contentBBox, this.mainColor);
            }
        }
        if (this.backgroundType === BackgroundType.Grid) {
            let gridColor = this.secondaryColor;
            gridColor ??= _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Color4.ofRGBA(1 - this.mainColor.r, 1 - this.mainColor.g, 1 - this.mainColor.b, 0.2);
            // If the background fill is completely transparent, ensure visibility on otherwise light
            // and dark backgrounds.
            if (this.mainColor.a === 0) {
                gridColor = _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Color4.ofRGBA(0.5, 0.5, 0.5, 0.2);
            }
            const style = {
                fill: _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Color4.transparent,
                stroke: { width: this.gridStrokeWidth, color: gridColor },
            };
            canvas.drawPath((0,_rendering_RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_5__.pathToRenderable)(this.generateGridPath(visibleRect), style));
        }
        const backgroundTypeCSSClass = backgroundTypeToClassNameMap[this.backgroundType];
        const classNames = [imageBackgroundCSSClassName];
        if (backgroundTypeCSSClass !== imageBackgroundCSSClassName) {
            classNames.push(backgroundTypeCSSClass);
            const gridSizeStr = (0,_js_draw_math__WEBPACK_IMPORTED_MODULE_1__.toRoundedString)(this.gridSize).replace(/[.]/g, 'p');
            classNames.push(imageBackgroundGridSizeCSSPrefix + gridSizeStr);
        }
        if (this.secondaryColor !== null) {
            classNames.push(imageBackgroundNonAutomaticSecondaryColorCSSClassName);
        }
        canvas.endObject(this.getLoadSaveData(), classNames);
    }
    intersects(lineSegment) {
        return this.contentBBox.getEdges().some((edge) => edge.intersects(lineSegment));
    }
    isSelectable() {
        return false;
    }
    isBackground() {
        return true;
    }
    getSizingMode() {
        return this.fillsScreen ? _AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_2__.ComponentSizingMode.FillScreen : _AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_2__.ComponentSizingMode.BoundingBox;
    }
    serializeToJSON() {
        return {
            mainColor: this.mainColor.toHexString(),
            secondaryColor: this.secondaryColor?.toHexString(),
            backgroundType: this.backgroundType,
            gridSize: this.gridSize,
            gridStrokeWidth: this.gridStrokeWidth,
        };
    }
    applyTransformation(_affineTransfm) {
        // Do nothing — it doesn't make sense to transform the background.
    }
    description(localizationTable) {
        if (this.backgroundType === BackgroundType.SolidColor) {
            return localizationTable.filledBackgroundWithColor(this.mainColor.toString());
        }
        else if (this.backgroundType === BackgroundType.None) {
            return localizationTable.emptyBackground;
        }
        else if (this.backgroundType === BackgroundType.Grid) {
            return localizationTable.gridBackground;
        }
        else {
            const exhaustivenessCheck = this.backgroundType;
            return exhaustivenessCheck;
        }
    }
    createClone() {
        return new BackgroundComponent(this.backgroundType, this.mainColor);
    }
    // @internal
    static deserializeFromJSON(json) {
        if (typeof json === 'string') {
            json = JSON.parse(json);
        }
        if (typeof json.mainColor !== 'string') {
            throw new Error('Error deserializing — mainColor must be of type string.');
        }
        let backgroundType;
        const jsonBackgroundType = json.backgroundType;
        if (jsonBackgroundType === BackgroundType.None ||
            jsonBackgroundType === BackgroundType.Grid ||
            jsonBackgroundType === BackgroundType.SolidColor) {
            backgroundType = jsonBackgroundType;
        }
        else {
            const exhaustivenessCheck = jsonBackgroundType;
            return exhaustivenessCheck;
        }
        const mainColor = _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Color4.fromHex(json.mainColor);
        const secondaryColor = json.secondaryColor ? _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Color4.fromHex(json.secondaryColor) : null;
        const gridSize = json.gridSize ?? undefined;
        const gridStrokeWidth = json.gridStrokeWidth ?? undefined;
        const result = new BackgroundComponent(backgroundType, mainColor);
        result.secondaryColor = secondaryColor;
        if (gridSize) {
            result.gridSize = gridSize;
        }
        if (gridStrokeWidth) {
            result.gridStrokeWidth = gridStrokeWidth;
        }
        return result;
    }
}
_AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].registerComponent('image-background', BackgroundComponent.deserializeFromJSON);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/components/ImageComponent.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/components/ImageComponent.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ImageComponent)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _util_assertions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/assertions.mjs */ "./node_modules/js-draw/dist/mjs/util/assertions.mjs");
/* harmony import */ var _AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbstractComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/AbstractComponent.mjs");
/* harmony import */ var _util_waitForImageLoaded_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/waitForImageLoaded.mjs */ "./node_modules/js-draw/dist/mjs/util/waitForImageLoaded.mjs");




/**
 * Represents a raster image.
 *
 * **Example: Adding images**:
 * [[include:doc-pages/inline-examples/adding-an-image-and-data-urls.md]]
 */
class ImageComponent extends _AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(image) {
        super('image-component');
        this.image = {
            ...image,
            label: image.label ??
                image.image.getAttribute('alt') ??
                image.image.getAttribute('aria-label') ??
                undefined,
        };
        const isHTMLImageElem = (elem) => {
            return elem.getAttribute('src') !== undefined;
        };
        if (isHTMLImageElem(image.image) && !image.image.complete) {
            image.image.onload = () => this.recomputeBBox();
        }
        this.recomputeBBox();
    }
    getImageRect() {
        return new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2(0, 0, this.image.image.width, this.image.image.height);
    }
    recomputeBBox() {
        this.contentBBox = this.getImageRect();
        this.contentBBox = this.contentBBox.transformedBoundingBox(this.image.transform);
    }
    /**
     * Load from an image. Waits for the image to load if incomplete.
     *
     * The image, `elem`, must not [taint](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image#security_and_tainted_canvases)
     * an HTMLCanvasElement when rendered.
     */
    static async fromImage(elem, transform) {
        await (0,_util_waitForImageLoaded_mjs__WEBPACK_IMPORTED_MODULE_3__["default"])(elem);
        let width, height;
        if (typeof elem.width === 'number' &&
            typeof elem.height === 'number' &&
            elem.width !== 0 &&
            elem.height !== 0) {
            width = elem.width;
            height = elem.height;
        }
        else {
            width = elem.clientWidth;
            height = elem.clientHeight;
        }
        let image;
        let url = elem.src ?? '';
        if (!url.startsWith('data:image/')) {
            // Convert to a data URL:
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(elem, 0, 0, canvas.width, canvas.height);
            url = canvas.toDataURL();
            image = canvas;
        }
        else {
            image = new Image();
            image.src = url;
            image.width = width;
            image.height = height;
        }
        image.setAttribute('alt', elem.getAttribute('alt') ?? '');
        image.setAttribute('aria-label', elem.getAttribute('aria-label') ?? '');
        return new ImageComponent({
            image,
            base64Url: url,
            transform: transform,
        });
    }
    render(canvas, _visibleRect) {
        canvas.startObject(this.contentBBox);
        canvas.drawImage(this.image);
        canvas.endObject(this.getLoadSaveData());
    }
    // A *very* rough estimate of how long it takes to render this component
    getProportionalRenderingTime() {
        // Estimate: Equivalent to a stroke with 10 segments.
        return 10;
    }
    intersects(lineSegment) {
        const rect = this.getImageRect();
        const edges = rect.getEdges().map((edge) => edge.transformedBy(this.image.transform));
        for (const edge of edges) {
            if (edge.intersects(lineSegment)) {
                return true;
            }
        }
        return false;
    }
    applyTransformation(affineTransfm) {
        this.image.transform = affineTransfm.rightMul(this.image.transform);
        this.recomputeBBox();
    }
    description(localizationTable) {
        return this.image.label
            ? localizationTable.imageNode(this.image.label)
            : localizationTable.unlabeledImageNode;
    }
    getAltText() {
        return this.image.label;
    }
    // The base64 image URL of this image.
    getURL() {
        return this.image.base64Url;
    }
    getTransformation() {
        return this.image.transform;
    }
    createClone() {
        return new ImageComponent({
            ...this.image,
        });
    }
    serializeToJSON() {
        return {
            src: this.image.base64Url,
            label: this.image.label,
            // Store the width and height for bounding box computations while the image is loading.
            width: this.image.image.width,
            height: this.image.image.height,
            transform: this.image.transform.toArray(),
        };
    }
    static deserializeFromJSON(data) {
        if (!(typeof data.src === 'string')) {
            throw new Error(`${data} has invalid format! Expected src property.`);
        }
        (0,_util_assertions_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIsNumberArray)(data.transform);
        (0,_util_assertions_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIsNumber)(data.width);
        (0,_util_assertions_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIsNumber)(data.height);
        const image = new Image();
        image.src = data.src;
        image.width = data.width;
        image.height = data.height;
        const transform = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33(...data.transform);
        return new ImageComponent({
            image: image,
            base64Url: data.src,
            label: data.label,
            transform,
        });
    }
}
_AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].registerComponent('image-component', ImageComponent.deserializeFromJSON);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/components/RestylableComponent.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/components/RestylableComponent.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createRestyleComponentCommand: () => (/* binding */ createRestyleComponentCommand),
/* harmony export */   isRestylableComponent: () => (/* binding */ isRestylableComponent)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _commands_SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../commands/SerializableCommand.mjs */ "./node_modules/js-draw/dist/mjs/commands/SerializableCommand.mjs");
/* harmony import */ var _commands_UnresolvedCommand_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../commands/UnresolvedCommand.mjs */ "./node_modules/js-draw/dist/mjs/commands/UnresolvedCommand.mjs");
/* harmony import */ var _rendering_TextRenderingStyle_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rendering/TextRenderingStyle.mjs */ "./node_modules/js-draw/dist/mjs/rendering/TextRenderingStyle.mjs");




const serializeComponentStyle = (style) => {
    const result = {};
    if (style.color) {
        result.color = style.color.toHexString();
    }
    if (style.textStyle) {
        result.textStyle = (0,_rendering_TextRenderingStyle_mjs__WEBPACK_IMPORTED_MODULE_3__.textStyleToJSON)(style.textStyle);
    }
    return result;
};
const deserializeComponentStyle = (json) => {
    const color = json.color ? _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.fromHex(json.color) : undefined;
    const textStyle = json.textStyle ? (0,_rendering_TextRenderingStyle_mjs__WEBPACK_IMPORTED_MODULE_3__.textStyleFromJSON)(json.textStyle) : undefined;
    return {
        color,
        textStyle,
    };
};
// For internal use by Components implementing `updateStyle`:
const createRestyleComponentCommand = (initialStyle, newStyle, component) => {
    return new DefaultRestyleComponentCommand(initialStyle, newStyle, component.getId(), component);
};
// Returns true if `component` is a `RestylableComponent`.
const isRestylableComponent = (component) => {
    const hasMethods = 'getStyle' in component && 'updateStyle' in component && 'forceStyle' in component;
    if (!hasMethods) {
        return false;
    }
    if (!('isRestylableComponent' in component) || !component['isRestylableComponent']) {
        return false;
    }
    return true;
};
const defaultRestyleComponentCommandId = 'default-restyle-element';
class DefaultRestyleComponentCommand extends _commands_UnresolvedCommand_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(originalStyle, newStyle, componentID, component) {
        super(defaultRestyleComponentCommandId, componentID, component);
        this.originalStyle = originalStyle;
        this.newStyle = newStyle;
    }
    getComponent(editor) {
        this.resolveComponent(editor.image);
        const component = this.component;
        if (!component || !component['forceStyle'] || !component['updateStyle']) {
            throw new Error('this.component is missing forceStyle and/or updateStyle methods!');
        }
        return component;
    }
    apply(editor) {
        this.getComponent(editor).forceStyle(this.newStyle, editor);
    }
    unapply(editor) {
        this.getComponent(editor).forceStyle(this.originalStyle, editor);
    }
    description(editor, localizationTable) {
        return localizationTable.restyledElement(this.getComponent(editor).description(localizationTable));
    }
    serializeToJSON() {
        return {
            id: this.componentID,
            originalStyle: serializeComponentStyle(this.originalStyle),
            newStyle: serializeComponentStyle(this.newStyle),
        };
    }
}
(() => {
    _commands_SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].register(defaultRestyleComponentCommandId, (json, _editor) => {
        const origStyle = deserializeComponentStyle(json.originalStyle);
        const newStyle = deserializeComponentStyle(json.newStyle);
        const id = json.id;
        if (typeof json.id !== 'string') {
            throw new Error(`json.id is of type ${typeof json.id}, not string.`);
        }
        return new DefaultRestyleComponentCommand(origStyle, newStyle, id);
    });
})();


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/components/SVGGlobalAttributesObject.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/components/SVGGlobalAttributesObject.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SVGGlobalAttributesObject)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _rendering_renderers_SVGRenderer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rendering/renderers/SVGRenderer.mjs */ "./node_modules/js-draw/dist/mjs/rendering/renderers/SVGRenderer.mjs");
/* harmony import */ var _AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbstractComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/AbstractComponent.mjs");
//
// Used by `SVGLoader`s to store unrecognised global attributes
// (e.g. unrecognised XML namespace declarations).
// @internal
// @packageDocumentation
//



const componentKind = 'svg-global-attributes';
// Stores global SVG attributes (e.g. namespace identifiers.)
class SVGGlobalAttributesObject extends _AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    // Does not modify `attrs`
    constructor(attrs) {
        super(componentKind);
        this.contentBBox = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2.empty;
        // Already stored/managed in `editor.image`.
        const attrsManagedByRenderer = ['viewBox', 'width', 'height'];
        // Only store attributes that aren't managed by other parts of the app.
        this.attrs = attrs.filter(([attr, _value]) => {
            return !attrsManagedByRenderer.includes(attr);
        });
    }
    render(canvas, _visibleRect) {
        if (!(canvas instanceof _rendering_renderers_SVGRenderer_mjs__WEBPACK_IMPORTED_MODULE_1__["default"])) {
            // Don't draw unrenderable objects if we can't
            return;
        }
        for (const [attr, value] of this.attrs) {
            canvas.setRootSVGAttribute(attr, value);
        }
    }
    intersects(_lineSegment) {
        return false;
    }
    applyTransformation(_affineTransfm) { }
    isSelectable() {
        return false;
    }
    getSizingMode() {
        // This component can be shown anywhere (it won't be
        // visible to the user, it just needs to be saved with
        // the image).
        return _AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_2__.ComponentSizingMode.Anywhere;
    }
    createClone() {
        return new SVGGlobalAttributesObject(this.attrs);
    }
    description(localization) {
        return localization.svgObject;
    }
    serializeToJSON() {
        return JSON.stringify(this.attrs);
    }
    static deserializeFromString(_data) {
        // To be safe, don't deserialize any attributes
        return new SVGGlobalAttributesObject([]);
    }
}
_AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].registerComponent(componentKind, SVGGlobalAttributesObject.deserializeFromString);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/components/Stroke.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/components/Stroke.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Stroke)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _rendering_RenderingStyle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rendering/RenderingStyle.mjs */ "./node_modules/js-draw/dist/mjs/rendering/RenderingStyle.mjs");
/* harmony import */ var _AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbstractComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/AbstractComponent.mjs");
/* harmony import */ var _RestylableComponent_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RestylableComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/RestylableComponent.mjs");
/* harmony import */ var _rendering_RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../rendering/RenderablePathSpec.mjs */ "./node_modules/js-draw/dist/mjs/rendering/RenderablePathSpec.mjs");





/**
 * Represents an {@link AbstractComponent} made up of one or more {@link Path}s.
 *
 * @example
 * For some {@link Editor} editor and `Stroke` stroke,
 *
 * **Restyling**:
 * ```ts
 * editor.dispatch(stroke.updateStyle({ color: Color4.red }));
 * ```
 *
 * **Transforming**:
 * ```ts
 * editor.dispatch(stroke.transformBy(Mat33.translation(Vec2.of(10, 0))));
 * ```
 *
 * **Adding**:
 * [[include:doc-pages/inline-examples/adding-a-stroke.md]]
 */
class Stroke extends _AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /**
     * Creates a `Stroke` from the given `parts`. All parts should have the
     * same color.
     *
     * @example
     * ```ts
     * // A path that starts at (1,1), moves to the right by (2, 0),
     * // then moves down and right by (3, 3)
     * const path = Path.fromString('m1,1 2,0 3,3');
     *
     * const stroke = new Stroke([
     *     // Fill with red
     *     pathToRenderable(path, { fill: Color4.red })
     * ]);
     * ```
     */
    constructor(parts, initialZIndex) {
        super('stroke', initialZIndex);
        // @internal
        // eslint-disable-next-line @typescript-eslint/prefer-as-const
        this.isRestylableComponent = true;
        // A simplification of the path for a given visibleRect. Intended
        // to help check for occlusion.
        this.simplifiedPath = null;
        this.approximateRenderingTime = 0;
        this.parts = [];
        for (const section of parts) {
            const path = (0,_rendering_RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_4__.pathFromRenderable)(section);
            const pathBBox = this.bboxForPart(path.bbox, section.style);
            if (!this.contentBBox) {
                this.contentBBox = pathBBox;
            }
            else {
                this.contentBBox = this.contentBBox.union(pathBBox);
            }
            this.parts.push({
                path,
                // To implement RenderablePathSpec
                startPoint: path.startPoint,
                style: section.style,
                commands: path.parts,
            });
            this.approximateRenderingTime += path.parts.length;
        }
        this.contentBBox ??= _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2.empty;
    }
    getStyle() {
        if (this.parts.length === 0) {
            return {};
        }
        const firstPart = this.parts[0];
        if (firstPart.style.stroke === undefined || firstPart.style.stroke.width === 0) {
            return {
                color: firstPart.style.fill,
            };
        }
        return {
            color: firstPart.style.stroke.color,
        };
    }
    updateStyle(style) {
        return (0,_RestylableComponent_mjs__WEBPACK_IMPORTED_MODULE_3__.createRestyleComponentCommand)(this.getStyle(), style, this);
    }
    forceStyle(style, editor) {
        if (!style.color) {
            return;
        }
        this.parts = this.parts.map((part) => {
            const newStyle = {
                ...part.style,
                stroke: part.style.stroke
                    ? {
                        ...part.style.stroke,
                    }
                    : undefined,
            };
            // Change the stroke color if a stroked shape. Else,
            // change the fill.
            if (newStyle.stroke && newStyle.stroke.width > 0) {
                newStyle.stroke.color = style.color;
            }
            else {
                newStyle.fill = style.color;
            }
            return {
                path: part.path,
                startPoint: part.startPoint,
                commands: part.commands,
                style: newStyle,
            };
        });
        if (editor) {
            editor.image.queueRerenderOf(this);
            editor.queueRerender();
        }
    }
    /** @beta -- May fail for concave `path`s */
    withRegionErased(eraserPath, viewport) {
        const polyline = eraserPath.polylineApproximation();
        const isPointInsideEraser = (point) => {
            return eraserPath.closedContainsPoint(point);
        };
        const newStrokes = [];
        let failedAssertions = false;
        for (const part of this.parts) {
            const path = part.path;
            const makeStroke = (path) => {
                if (part.style.fill.a > 0) {
                    // Remove visually empty paths.
                    if (path.parts.length < 1 ||
                        (path.parts.length === 1 && path.parts[0].kind === _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo)) {
                        // TODO: If this isn't present, a very large number of strokes are created while erasing.
                        return null;
                    }
                    else {
                        // Filled paths must be closed (allows for optimizations elsewhere)
                        path = path.asClosed();
                    }
                }
                if (isNaN(path.getExactBBox().area)) {
                    console.warn('Prevented creating a stroke with NaN area');
                    failedAssertions = true;
                    return null;
                }
                return new Stroke([(0,_rendering_RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_4__.pathToRenderable)(path, part.style)], this.getZIndex());
            };
            const intersectionPoints = [];
            // If stroked, finds intersections with the middle of the stroke.
            // If filled, finds intersections with the edge of the stroke.
            for (const segment of polyline) {
                intersectionPoints.push(...path.intersection(segment));
            }
            // When stroked, if the stroke width is significantly larger than the eraser,
            // it can't intersect both the edge of the stroke and its middle at the same time
            // (generally, erasing is triggered by the eraser touching the edge of this stroke).
            //
            // As such, we also look for intersections along the edge of this, if none with the
            // center were found, but only within a certain range of sizes because:
            // 1. Intersection testing with stroked paths is generally much slower than with
            //    non-stroked paths.
            // 2. If zoomed in significantly, it's unlikely that the user wants to erase a large
            //    part of the stroke.
            let isErasingFromEdge = false;
            if (intersectionPoints.length === 0 &&
                part.style.stroke &&
                part.style.stroke.width > eraserPath.bbox.minDimension * 0.3 &&
                part.style.stroke.width < eraserPath.bbox.maxDimension * 30) {
                for (const segment of polyline) {
                    intersectionPoints.push(...path.intersection(segment, part.style.stroke.width / 2));
                }
                isErasingFromEdge = true;
            }
            // Sort first by curve index, then by parameter value
            intersectionPoints.sort(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.comparePathIndices);
            const isInsideJustBeforeFirst = (() => {
                if (intersectionPoints.length === 0) {
                    return false;
                }
                // The eraser may not be near the center of the curve -- approximate.
                if (isErasingFromEdge) {
                    return (intersectionPoints[0].curveIndex === 0 && intersectionPoints[0].parameterValue <= 0);
                }
                const justBeforeFirstIntersection = (0,_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.stepPathIndexBy)(intersectionPoints[0], -1e-10);
                return isPointInsideEraser(path.at(justBeforeFirstIntersection));
            })();
            let intersectionCount = isInsideJustBeforeFirst ? 1 : 0;
            const addNewPath = (path, knownToBeInside) => {
                const component = makeStroke(path);
                let isInside = intersectionCount % 2 === 1;
                intersectionCount++;
                if (knownToBeInside !== undefined) {
                    isInside = knownToBeInside;
                }
                // Here, we work around bugs in the underlying Bezier curve library
                // (including https://github.com/Pomax/bezierjs/issues/179).
                // Even if not all intersections are returned correctly, we still want
                // isInside to be roughly correct.
                if (knownToBeInside === undefined &&
                    !isInside &&
                    eraserPath.closedContainsPoint(path.getExactBBox().center)) {
                    isInside = !isInside;
                }
                if (!component) {
                    return;
                }
                // Assertion: Avoid deleting sections that are much larger than the eraser.
                failedAssertions ||=
                    isInside && path.getExactBBox().maxDimension > eraserPath.getExactBBox().maxDimension * 2;
                if (!isInside) {
                    newStrokes.push(component);
                }
            };
            if (part.style.fill.a === 0) {
                // Not filled?
                // An additional case where we erase completely -- without the padding of the stroke,
                // the path is smaller than the eraser (allows us to erase dots completely).
                const shouldEraseCompletely = eraserPath.getExactBBox().maxDimension / 10 > path.getExactBBox().maxDimension;
                if (!shouldEraseCompletely) {
                    const split = path.splitAt(intersectionPoints, {
                        mapNewPoint: (p) => viewport.roundPoint(p),
                    });
                    for (const splitPart of split) {
                        addNewPath(splitPart);
                    }
                }
            }
            else if (intersectionPoints.length >= 2 && intersectionPoints.length % 2 === 0) {
                // TODO: Support subtractive erasing on small scales -- see https://github.com/personalizedrefrigerator/js-draw/pull/63/commits/568686e2384219ad0bb07617ea4efff1540aed00
                //       for a broken implementation.
                //
                // We currently assume that a 4-point intersection means that the intersection
                // looks similar to this:
                //   -----------
                //  |   STROKE  |
                //  |           |
                //%%x-----------x%%%%%%%
                //%                    %
                //%      ERASER        %
                //%                    %
                //%%x-----------x%%%%%%%
                //  |   STROKE  |
                //   -----------
                //
                // Our goal is to separate STROKE into the contiguous parts outside
                // of the eraser (as shown above).
                //
                // To do this, we split STROKE at each intersection:
                //   3 3 3 3 3 3
                //  3   STROKE  3
                //  3           3
                //  x           x
                //  2           4
                //  2   STROKE  4
                //  2           4
                //  x           x
                //  1   STROKE  5
                //   . 5 5 5 5 5
                //   ^
                // Start
                //
                // The difficulty here is correctly pairing edges to create the the output
                // strokes, particularly because we don't know the order of intersection points.
                const parts = path.splitAt(intersectionPoints, {
                    mapNewPoint: (p) => viewport.roundPoint(p),
                });
                for (let i = 0; i < Math.floor(parts.length / 2); i++) {
                    addNewPath(parts[i].union(parts[parts.length - i - 1]).asClosed());
                }
                if (parts.length % 2 !== 0) {
                    addNewPath(parts[Math.floor(parts.length / 2)].asClosed());
                }
            }
            else {
                addNewPath(path, false);
            }
        }
        if (failedAssertions) {
            return [this];
        }
        return newStrokes;
    }
    intersects(line) {
        for (const part of this.parts) {
            const strokeWidth = part.style.stroke?.width;
            const strokeRadius = strokeWidth ? strokeWidth / 2 : undefined;
            if (part.path.intersection(line, strokeRadius).length > 0) {
                return true;
            }
        }
        return false;
    }
    intersectsRect(rect) {
        // AbstractComponent::intersectsRect can be inexact for strokes with non-zero
        // stroke radius (has many false negatives). As such, additional checks are
        // done here, before passing to the superclass.
        if (!rect.intersects(this.getBBox())) {
            return false;
        }
        // The following check only checks for the positive case:
        // Sample a set of points that are known to be within each part of this
        // stroke. For example, the points marked with an "x" below:
        //   ___________________
        //  /                   \
        //  | x              x  |
        //  \_____________      |
        //                |  x  |
        //                \_____/
        //
        // Because we don't want the following case to result in selection,
        //   __________________
        //  /.___.             \
        //  || x |          x  |    <-  /* The
        //  |·---·             |            .___.
        //  \____________      |            |   |
        //               |  x  |            ·---·
        //               \_____/           denotes the input rectangle */
        //
        // we need to ensure that the rectangle intersects each point **and** the
        // edge of the rectangle.
        for (const part of this.parts) {
            // As such, we need to shrink the input rectangle to verify that the original,
            // unshrunken rectangle would have intersected the edge of the stroke if it
            // intersects a point within the stroke.
            const interiorRect = rect.grownBy(-(part.style.stroke?.width ?? 0));
            if (interiorRect.area === 0) {
                continue;
            }
            for (const point of part.path.startEndPoints()) {
                if (interiorRect.containsPoint(point)) {
                    return true;
                }
            }
        }
        return super.intersectsRect(rect);
    }
    computeSimplifiedPathFor(visibleRect) {
        const simplifiedParts = [];
        let occludes = false;
        let skipSimplification = false;
        for (const part of this.parts) {
            if (skipSimplification ||
                // Simplification currently only works for stroked paths
                !part.style.stroke ||
                // One of the main purposes of this is to check for occlusion.
                // We can't occlude things if the stroke is partially transparent.
                part.style.stroke.color.a < 0.99) {
                simplifiedParts.push(part);
                continue;
            }
            const mapping = (0,_rendering_RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_4__.simplifyPathToFullScreenOrEmpty)(part, visibleRect);
            if (mapping) {
                simplifiedParts.push(mapping.path);
                if (mapping.fullScreen) {
                    occludes = true;
                    skipSimplification = true;
                }
            }
            else {
                simplifiedParts.push(part);
            }
        }
        return {
            forVisibleRect: visibleRect,
            parts: simplifiedParts,
            occludes,
        };
    }
    occludesEverythingBelowWhenRenderedInRect(rect) {
        // Can't occlude if doesn't contain.
        if (!this.getBBox().containsRect(rect)) {
            return false;
        }
        if (!this.simplifiedPath || !this.simplifiedPath.forVisibleRect.eq(rect)) {
            this.simplifiedPath = this.computeSimplifiedPathFor(rect);
        }
        return this.simplifiedPath.occludes;
    }
    render(canvas, visibleRect) {
        canvas.startObject(this.getBBox());
        // Can we use a cached simplified path for faster rendering?
        let parts = this.parts;
        if (visibleRect && this.simplifiedPath?.forVisibleRect?.containsRect(visibleRect)) {
            parts = this.simplifiedPath.parts;
        }
        else {
            // Save memory
            this.simplifiedPath = null;
        }
        for (const part of parts) {
            const bbox = this.bboxForPart(part.path.bbox, part.style);
            if (visibleRect) {
                if (!bbox.intersects(visibleRect)) {
                    continue;
                }
                const muchBiggerThanVisible = bbox.size.x > visibleRect.size.x * 3 || bbox.size.y > visibleRect.size.y * 3;
                if (muchBiggerThanVisible &&
                    !part.path.roughlyIntersects(visibleRect, part.style.stroke?.width ?? 0)) {
                    continue;
                }
            }
            canvas.drawPath(part);
        }
        canvas.endObject(this.getLoadSaveData());
    }
    getProportionalRenderingTime() {
        return this.approximateRenderingTime;
    }
    // Grows the bounding box for a given stroke part based on that part's style.
    bboxForPart(origBBox, style) {
        if (!style.stroke) {
            return origBBox;
        }
        return origBBox.grownBy(style.stroke.width / 2);
    }
    getExactBBox() {
        let bbox = null;
        for (const { path, style } of this.parts) {
            // Paths' default .bbox can be
            const partBBox = this.bboxForPart(path.getExactBBox(), style);
            bbox ??= partBBox;
            bbox = bbox.union(partBBox);
        }
        return bbox ?? _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2.empty;
    }
    applyTransformation(affineTransfm) {
        this.contentBBox = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2.empty;
        let isFirstPart = true;
        // Update each part
        this.parts = this.parts.map((part) => {
            const newPath = part.path.transformedBy(affineTransfm);
            const newStyle = {
                ...part.style,
                stroke: part.style.stroke
                    ? {
                        ...part.style.stroke,
                    }
                    : undefined,
            };
            // Approximate the scale factor.
            if (newStyle.stroke) {
                const scaleFactor = affineTransfm.getScaleFactor();
                newStyle.stroke.width *= scaleFactor;
            }
            const newBBox = this.bboxForPart(newPath.bbox, newStyle);
            if (isFirstPart) {
                this.contentBBox = newBBox;
                isFirstPart = false;
            }
            else {
                this.contentBBox = this.contentBBox.union(newBBox);
            }
            return {
                path: newPath,
                startPoint: newPath.startPoint,
                commands: newPath.parts,
                style: newStyle,
            };
        });
    }
    /**
     * @returns A list of the parts that make up this path. Many paths only have one part.
     *
     * Each part (a {@link RenderablePathSpec}) contains information about the style and geometry
     * of that part of the stroke. Use the `.path` property to do collision detection and other
     * operations involving the stroke's geometry.
     *
     * Note that many of {@link Path}'s methods (e.g. {@link Path.intersection}) take a
     * `strokeWidth` parameter that can be gotten from {@link RenderablePathSpec.style} `.stroke.width`.
     */
    getParts() {
        return [...this.parts];
    }
    /**
     * @returns the {@link Path.union} of all paths that make up this stroke.
     */
    getPath() {
        let result = null;
        for (const part of this.parts) {
            if (result) {
                result = result.union(part.path);
            }
            else {
                result ??= part.path;
            }
        }
        return result ?? _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Path.empty;
    }
    description(localization) {
        return localization.stroke;
    }
    createClone() {
        return new Stroke(this.parts);
    }
    serializeToJSON() {
        return this.parts.map((part) => {
            return {
                style: (0,_rendering_RenderingStyle_mjs__WEBPACK_IMPORTED_MODULE_1__.styleToJSON)(part.style),
                path: part.path.serialize(),
            };
        });
    }
    /** @internal */
    static deserializeFromJSON(json) {
        if (typeof json === 'string') {
            json = JSON.parse(json);
        }
        if (typeof json !== 'object' || typeof json.length !== 'number') {
            throw new Error(`${json} is missing required field, parts, or parts is of the wrong type.`);
        }
        const pathSpec = json.map((part) => {
            const style = (0,_rendering_RenderingStyle_mjs__WEBPACK_IMPORTED_MODULE_1__.styleFromJSON)(part.style);
            return (0,_rendering_RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_4__.pathToRenderable)(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Path.fromString(part.path), style);
        });
        return new Stroke(pathSpec);
    }
}
_AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].registerComponent('stroke', Stroke.deserializeFromJSON);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/components/TextComponent.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/components/TextComponent.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextTransformMode: () => (/* binding */ TextTransformMode),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _rendering_TextRenderingStyle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rendering/TextRenderingStyle.mjs */ "./node_modules/js-draw/dist/mjs/rendering/TextRenderingStyle.mjs");
/* harmony import */ var _AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbstractComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/AbstractComponent.mjs");
/* harmony import */ var _RestylableComponent_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RestylableComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/RestylableComponent.mjs");




const componentTypeId = 'text';
var TextTransformMode;
(function (TextTransformMode) {
    /** Absolutely positioned in both the X and Y dimensions. */
    TextTransformMode[TextTransformMode["ABSOLUTE_XY"] = 0] = "ABSOLUTE_XY";
    /** Relatively positioned in both the X and Y dimensions. */
    TextTransformMode[TextTransformMode["RELATIVE_XY"] = 1] = "RELATIVE_XY";
    /**Relatively positioned in the X direction, absolutely positioned in the Y direction. */
    TextTransformMode[TextTransformMode["RELATIVE_X_ABSOLUTE_Y"] = 2] = "RELATIVE_X_ABSOLUTE_Y";
    /**Relatively positioned in the Y direction, absolutely positioned in the X direction. */
    TextTransformMode[TextTransformMode["RELATIVE_Y_ABSOLUTE_X"] = 3] = "RELATIVE_Y_ABSOLUTE_X";
})(TextTransformMode || (TextTransformMode = {}));
const defaultTextStyle = {
    fontFamily: 'sans',
    size: 12,
    renderingStyle: { fill: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.purple },
};
/**
 * Displays text.
 *
 * A `TextComponent` is a collection of `TextElement`s (`string`s or {@link TextComponent}s).
 *
 * **Example**:
 *
 * ```ts,runnable
 * import { Editor, TextComponent, Mat33, Vec2, Color4, TextRenderingStyle } from 'js-draw';
 * const editor = new Editor(document.body);
 * editor.dispatch(editor.setBackgroundStyle({ color: Color4.black, autoresize: true ));
 * ---visible---
 * /// Adding a simple TextComponent
 * ///------------------------------
 *
 * const positioning1 = Mat33.translation(Vec2.of(10, 10));
 * const style: TextRenderingStyle = {
 *     fontFamily: 'sans', size: 12, renderingStyle: { fill: Color4.green },
 * };
 *
 * editor.dispatch(
 *     editor.image.addElement(new TextComponent(['Hello, world'], positioning1, style)),
 * );
 *
 *
 * /// Adding nested TextComponents
 * ///-----------------------------
 *
 * // Add another TextComponent that contains text and a TextComponent. Observe that '[Test]'
 * // is placed directly after 'Test'.
 * const positioning2 = Mat33.translation(Vec2.of(10, 50));
 * editor.dispatch(
 *     editor.image.addElement(
 *         new TextComponent([ new TextComponent(['Test'], positioning1, style), '[Test]' ], positioning2, style)
 *     ),
 * );
 * ```
 */
class TextComponent extends _AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /**
     * Creates a new text object from a list of component text or child TextComponents.
     *
     * @see {@link fromLines}
     */
    constructor(textObjects, 
    // Transformation relative to this component's parent element.
    transform, style = defaultTextStyle, 
    // @internal
    transformMode = TextTransformMode.ABSOLUTE_XY) {
        super(componentTypeId);
        this.textObjects = textObjects;
        this.transform = transform;
        this.style = style;
        this.transformMode = transformMode;
        // eslint-disable-next-line @typescript-eslint/prefer-as-const
        this.isRestylableComponent = true;
        this.recomputeBBox();
        // If this has no direct children, choose a style representative of this' content
        // (useful for estimating the style of the TextComponent).
        const hasDirectContent = textObjects.some((obj) => typeof obj === 'string');
        if (!hasDirectContent && textObjects.length > 0) {
            this.style = textObjects[0].getTextStyle();
        }
    }
    static applyTextStyles(ctx, style) {
        // Quote the font family if necessary.
        const hasSpaces = style.fontFamily.match(/\s/);
        const isQuoted = style.fontFamily.match(/^".*"$/);
        const fontFamily = hasSpaces && !isQuoted ? `"${style.fontFamily.replace(/["]/g, '\\"')}"` : style.fontFamily;
        ctx.font = [
            style.fontStyle ?? '',
            style.fontWeight ?? '',
            (style.size ?? 12) + 'px',
            `${fontFamily}`,
        ].join(' ');
        // TODO: Support RTL
        ctx.textAlign = 'left';
    }
    // Roughly estimate the bounding box of `text`. Use if no CanvasRenderingContext2D is available.
    static estimateTextDimens(text, style) {
        const widthEst = text.length * style.size;
        const heightEst = style.size;
        // Text is drawn with (0, 0) as its baseline. As such, the majority of the text's height should
        // be above (0, 0).
        return new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2(0, (-heightEst * 2) / 3, widthEst, heightEst);
    }
    // Returns a set of TextMetrics for the given text, if a canvas is available.
    static getTextMetrics(text, style) {
        TextComponent.textMeasuringCtx ??= document.createElement('canvas').getContext('2d') ?? null;
        if (!TextComponent.textMeasuringCtx) {
            return null;
        }
        const ctx = TextComponent.textMeasuringCtx;
        TextComponent.applyTextStyles(ctx, style);
        return ctx.measureText(text);
    }
    // Returns the bounding box of `text`. This is approximate if no Canvas is available.
    static getTextDimens(text, style) {
        const metrics = this.getTextMetrics(text, style);
        if (!metrics) {
            return this.estimateTextDimens(text, style);
        }
        // Text is drawn with (0,0) at the bottom left of the baseline.
        const textY = -metrics.actualBoundingBoxAscent;
        const textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
        return new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2(0, textY, metrics.width, textHeight);
    }
    static getFontHeight(style) {
        return style.size;
    }
    computeUntransformedBBoxOfPart(part) {
        if (typeof part === 'string') {
            return TextComponent.getTextDimens(part, this.style);
        }
        else {
            return part.contentBBox;
        }
    }
    recomputeBBox() {
        let bbox = null;
        const cursor = new TextComponent.TextCursor(this.transform, this.style);
        for (const textObject of this.textObjects) {
            const transform = cursor.update(textObject).transform;
            const currentBBox = this.computeUntransformedBBoxOfPart(textObject).transformedBoundingBox(transform);
            bbox ??= currentBBox;
            bbox = bbox.union(currentBBox);
        }
        this.contentBBox = bbox ?? _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2.empty;
    }
    /**
     * Renders a TextComponent or a TextComponent child onto a `canvas`.
     *
     * `visibleRect` can be provided as a performance optimization. If not the top-level
     * text node, `baseTransform` (specifies the transformation of the parent text component
     * in canvas space) should also be provided.
     *
     * Note that passing a `baseTransform` is preferable to transforming `visibleRect`. At high
     * zoom levels, transforming `visibleRect` by the inverse of the parent transform can lead to
     * inaccuracy due to precision loss.
     */
    renderInternal(canvas, visibleRect, baseTransform = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.identity) {
        const cursor = new TextComponent.TextCursor(this.transform, this.style);
        for (const textObject of this.textObjects) {
            const { transform, bbox } = cursor.update(textObject);
            if (visibleRect && !visibleRect.intersects(bbox.transformedBoundingBox(baseTransform))) {
                continue;
            }
            if (typeof textObject === 'string') {
                canvas.drawText(textObject, transform, this.style);
            }
            else {
                canvas.pushTransform(transform);
                textObject.renderInternal(canvas, visibleRect, baseTransform.rightMul(transform));
                canvas.popTransform();
            }
        }
    }
    render(canvas, visibleRect) {
        canvas.startObject(this.contentBBox);
        this.renderInternal(canvas, visibleRect);
        canvas.endObject(this.getLoadSaveData());
    }
    getProportionalRenderingTime() {
        return this.textObjects.length;
    }
    intersects(lineSegment) {
        const cursor = new TextComponent.TextCursor(this.transform, this.style);
        for (const subObject of this.textObjects) {
            // Convert canvas space to internal space relative to the current object.
            const invTransform = cursor.update(subObject).transform.inverse();
            const transformedLine = lineSegment.transformedBy(invTransform);
            if (typeof subObject === 'string') {
                const textBBox = TextComponent.getTextDimens(subObject, this.style);
                // TODO: Use a better intersection check. Perhaps draw the text onto a CanvasElement and
                // use pixel-testing to check for intersection with its contour.
                if (textBBox.getEdges().some((edge) => transformedLine.intersection(edge) !== null)) {
                    return true;
                }
            }
            else {
                if (subObject.intersects(transformedLine)) {
                    return true;
                }
            }
        }
        return false;
    }
    getStyle() {
        return {
            color: this.style.renderingStyle.fill,
            // Make a copy
            textStyle: {
                ...this.style,
                renderingStyle: {
                    ...this.style.renderingStyle,
                },
            },
        };
    }
    updateStyle(style) {
        return (0,_RestylableComponent_mjs__WEBPACK_IMPORTED_MODULE_3__.createRestyleComponentCommand)(this.getStyle(), style, this);
    }
    forceStyle(style, editor) {
        if (style.textStyle) {
            this.style = (0,_rendering_TextRenderingStyle_mjs__WEBPACK_IMPORTED_MODULE_1__.cloneTextStyle)(style.textStyle);
        }
        else if (style.color) {
            this.style = {
                ...this.style,
                renderingStyle: {
                    ...this.style.renderingStyle,
                    fill: style.color,
                },
            };
        }
        else {
            return;
        }
        for (const child of this.textObjects) {
            if (child instanceof TextComponent) {
                child.forceStyle(style, editor);
            }
        }
        if (editor) {
            editor.image.queueRerenderOf(this);
            editor.queueRerender();
        }
    }
    // See {@link getStyle}
    getTextStyle() {
        return (0,_rendering_TextRenderingStyle_mjs__WEBPACK_IMPORTED_MODULE_1__.cloneTextStyle)(this.style);
    }
    getBaselinePos() {
        return this.transform.transformVec2(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.zero);
    }
    getTransform() {
        return this.transform;
    }
    applyTransformation(affineTransfm) {
        this.transform = affineTransfm.rightMul(this.transform);
        this.recomputeBBox();
    }
    createClone() {
        const clonedTextObjects = this.textObjects.map((obj) => {
            if (typeof obj === 'string') {
                return obj;
            }
            else {
                return obj.createClone();
            }
        });
        return new TextComponent(clonedTextObjects, this.transform, this.style);
    }
    getText() {
        const result = [];
        for (const textObject of this.textObjects) {
            if (typeof textObject === 'string') {
                result.push(textObject);
            }
            else {
                result.push(textObject.getText());
            }
        }
        return result.join('\n');
    }
    description(localizationTable) {
        return localizationTable.text(this.getText());
    }
    // Do not rely on the output of `serializeToJSON` taking any particular format.
    serializeToJSON() {
        const serializableStyle = (0,_rendering_TextRenderingStyle_mjs__WEBPACK_IMPORTED_MODULE_1__.textStyleToJSON)(this.style);
        const serializedTextObjects = this.textObjects.map((text) => {
            if (typeof text === 'string') {
                return {
                    text,
                };
            }
            else {
                return {
                    json: text.serializeToJSON(),
                };
            }
        });
        return {
            textObjects: serializedTextObjects,
            transform: this.transform.toArray(),
            style: serializableStyle,
        };
    }
    // @internal
    static deserializeFromString(json) {
        if (typeof json === 'string') {
            json = JSON.parse(json);
        }
        const style = (0,_rendering_TextRenderingStyle_mjs__WEBPACK_IMPORTED_MODULE_1__.textStyleFromJSON)(json.style);
        const textObjects = json.textObjects.map((data) => {
            if ((data.text ?? null) !== null) {
                return data.text;
            }
            return TextComponent.deserializeFromString(data.json);
        });
        json.transform = json.transform.filter((elem) => typeof elem === 'number');
        if (json.transform.length !== 9) {
            throw new Error(`Unable to deserialize transform, ${json.transform}.`);
        }
        const transformData = json.transform;
        const transform = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33(...transformData);
        return new TextComponent(textObjects, transform, style);
    }
    /**
     * Creates a `TextComponent` from `lines`.
     *
     * @example
     * ```ts
     * const textStyle = {
     *   size: 12,
     *   fontFamily: 'serif',
     *   renderingStyle: { fill: Color4.black },
     * };
     *
     * const text = TextComponent.fromLines('foo\nbar'.split('\n'), Mat33.identity, textStyle);
     * ```
     */
    static fromLines(lines, transform, style) {
        let lastComponent = null;
        const components = [];
        const lineMargin = Math.round(this.getFontHeight(style));
        let position = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.zero;
        for (const line of lines) {
            if (lastComponent) {
                position = position.plus(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.unitY.times(lineMargin));
            }
            const component = new TextComponent([line], _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.translation(position), style);
            components.push(component);
            lastComponent = component;
        }
        return new TextComponent(components, transform, style);
    }
}
TextComponent.textMeasuringCtx = null;
TextComponent.TextCursor = class {
    constructor(parentTransform = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.identity, parentStyle) {
        this.parentTransform = parentTransform;
        this.parentStyle = parentStyle;
        this.transform = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.identity;
    }
    /**
     * Based on previous calls to `update`, returns the transformation and bounding box (relative
     * to the parent element, or if none, the canvas) of the given `element`. Note that
     * this is computed in part using the `parentTransform` provivded to this cursor's constructor.
     *
     * Warning: There may be edge cases here that are not taken into account.
     */
    update(elem) {
        let elementTransform = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.identity;
        let elemInternalTransform = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.identity;
        let textSize;
        if (typeof elem === 'string') {
            textSize = TextComponent.getTextDimens(elem, this.parentStyle);
        }
        else {
            // TODO: Double-check whether we need to take elem.transform into account here.
            // elementTransform = elem.transform;
            elemInternalTransform = elem.transform;
            textSize = elem.getBBox();
        }
        const positioning = typeof elem === 'string' ? TextTransformMode.RELATIVE_XY : elem.transformMode;
        if (positioning === TextTransformMode.RELATIVE_XY) {
            // Position relative to the previous element's transform.
            elementTransform = this.transform.rightMul(elementTransform);
        }
        else if (positioning === TextTransformMode.RELATIVE_X_ABSOLUTE_Y ||
            positioning === TextTransformMode.RELATIVE_Y_ABSOLUTE_X) {
            // Zero the absolute component of this.transform's translation
            const transform = this.transform.mapEntries((component, [row, col]) => {
                if (positioning === TextTransformMode.RELATIVE_X_ABSOLUTE_Y) {
                    // Zero the y component of this.transform's translation
                    return row === 1 && col === 2 ? 0 : component;
                }
                else if (positioning === TextTransformMode.RELATIVE_Y_ABSOLUTE_X) {
                    // Zero the x component of this.transform's translation
                    return row === 0 && col === 2 ? 0 : component;
                }
                throw new Error('Unreachable');
                return 0;
            });
            elementTransform = transform.rightMul(elementTransform);
        }
        // Update this.transform so that future calls to update return correct values.
        const endShiftTransform = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.translation(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(textSize.width, 0));
        this.transform = elementTransform.rightMul(elemInternalTransform).rightMul(endShiftTransform);
        const transform = this.parentTransform.rightMul(elementTransform);
        return {
            transform,
            bbox: textSize.transformedBoundingBox(transform),
        };
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TextComponent);
_AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].registerComponent(componentTypeId, (data) => TextComponent.deserializeFromString(data));


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/components/UnknownSVGObject.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/components/UnknownSVGObject.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ UnknownSVGObject)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _rendering_renderers_SVGRenderer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rendering/renderers/SVGRenderer.mjs */ "./node_modules/js-draw/dist/mjs/rendering/renderers/SVGRenderer.mjs");
/* harmony import */ var _AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbstractComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/AbstractComponent.mjs");
//
// Stores objects loaded from an SVG that aren't recognised by the editor.
// @internal
// @packageDocumentation
//



const componentId = 'unknown-svg-object';
class UnknownSVGObject extends _AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(svgObject) {
        super(componentId);
        this.svgObject = svgObject;
        this.contentBBox = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2.of(svgObject.getBoundingClientRect());
    }
    render(canvas, _visibleRect) {
        if (!(canvas instanceof _rendering_renderers_SVGRenderer_mjs__WEBPACK_IMPORTED_MODULE_1__["default"])) {
            // Don't draw unrenderable objects if we can't
            return;
        }
        canvas.startObject(this.contentBBox);
        canvas.drawSVGElem(this.svgObject);
        canvas.endObject(this.getLoadSaveData());
    }
    intersects(lineSegment) {
        return this.contentBBox.getEdges().some((edge) => edge.intersection(lineSegment) !== null);
    }
    applyTransformation(_affineTransfm) { }
    isSelectable() {
        return false;
    }
    getSizingMode() {
        // This component can be shown anywhere (it won't be
        // visible to the user, it just needs to be saved with
        // the image).
        return _AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_2__.ComponentSizingMode.Anywhere;
    }
    createClone() {
        return new UnknownSVGObject(this.svgObject.cloneNode(true));
    }
    description(localization) {
        return localization.svgObject;
    }
    serializeToJSON() {
        return JSON.stringify({
            html: this.svgObject.outerHTML,
        });
    }
}
// null: Do not deserialize UnknownSVGObjects.
_AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].registerComponent(componentId, null);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/components/builders/ArrowBuilder.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/components/builders/ArrowBuilder.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ArrowBuilder),
/* harmony export */   makeArrowBuilder: () => (/* binding */ makeArrowBuilder)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _Stroke_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Stroke.mjs */ "./node_modules/js-draw/dist/mjs/components/Stroke.mjs");
/* harmony import */ var _autocorrect_makeSnapToGridAutocorrect_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./autocorrect/makeSnapToGridAutocorrect.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/autocorrect/makeSnapToGridAutocorrect.mjs");



/**
 * Creates a stroke builder that generates arrows.
 *
 * Example:
 * [[include:doc-pages/inline-examples/changing-pen-types.md]]
 */
const makeArrowBuilder = (0,_autocorrect_makeSnapToGridAutocorrect_mjs__WEBPACK_IMPORTED_MODULE_2__["default"])((initialPoint, viewport) => {
    return new ArrowBuilder(initialPoint, viewport);
});
class ArrowBuilder {
    constructor(startPoint, viewport) {
        this.startPoint = startPoint;
        this.viewport = viewport;
        this.endPoint = startPoint;
    }
    getLineWidth() {
        return Math.max(this.endPoint.width, this.startPoint.width);
    }
    getBBox() {
        const preview = this.buildPreview();
        return preview.getBBox();
    }
    buildPreview() {
        const lineStartPoint = this.startPoint.pos;
        const endPoint = this.endPoint.pos;
        const toEnd = endPoint.minus(lineStartPoint).normalized();
        const arrowLength = endPoint.distanceTo(lineStartPoint);
        // Ensure that the arrow tip is smaller than the arrow.
        const arrowTipSize = Math.min(this.getLineWidth(), arrowLength / 2);
        const startSize = this.startPoint.width / 2;
        const endSize = this.endPoint.width / 2;
        const arrowTipBase = endPoint.minus(toEnd.times(arrowTipSize));
        // Scaled normal vectors.
        const lineNormal = toEnd.orthog();
        const scaledStartNormal = lineNormal.times(startSize);
        const scaledBaseNormal = lineNormal.times(endSize);
        const path = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Path(arrowTipBase.minus(scaledBaseNormal), [
            // Stem
            {
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,
                point: lineStartPoint.minus(scaledStartNormal),
            },
            {
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,
                point: lineStartPoint.plus(scaledStartNormal),
            },
            {
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,
                point: arrowTipBase.plus(scaledBaseNormal),
            },
            // Head
            {
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,
                point: arrowTipBase.plus(lineNormal.times(arrowTipSize).plus(scaledBaseNormal)),
            },
            {
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,
                point: endPoint.plus(toEnd.times(endSize)),
            },
            {
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,
                point: arrowTipBase.plus(lineNormal.times(-arrowTipSize).minus(scaledBaseNormal)),
            },
            {
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,
                point: arrowTipBase.minus(scaledBaseNormal),
            },
            // Round all points in the arrow (to remove unnecessary decimal places)
        ]).mapPoints((point) => this.viewport.roundPoint(point));
        const preview = new _Stroke_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]([
            {
                startPoint: path.startPoint,
                commands: path.parts,
                style: {
                    fill: this.startPoint.color,
                },
            },
        ]);
        return preview;
    }
    build() {
        return this.buildPreview();
    }
    preview(renderer) {
        this.buildPreview().render(renderer);
    }
    addPoint(point) {
        this.endPoint = point;
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/components/builders/CircleBuilder.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/components/builders/CircleBuilder.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   makeOutlinedCircleBuilder: () => (/* binding */ makeOutlinedCircleBuilder)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _rendering_RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../rendering/RenderablePathSpec.mjs */ "./node_modules/js-draw/dist/mjs/rendering/RenderablePathSpec.mjs");
/* harmony import */ var _Viewport_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Viewport.mjs */ "./node_modules/js-draw/dist/mjs/Viewport.mjs");
/* harmony import */ var _Stroke_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Stroke.mjs */ "./node_modules/js-draw/dist/mjs/components/Stroke.mjs");
/* harmony import */ var _autocorrect_makeSnapToGridAutocorrect_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./autocorrect/makeSnapToGridAutocorrect.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/autocorrect/makeSnapToGridAutocorrect.mjs");





/**
 * Creates a stroke builder that generates outlined circles.
 *
 * Example:
 * [[include:doc-pages/inline-examples/changing-pen-types.md]]
 */
const makeOutlinedCircleBuilder = (0,_autocorrect_makeSnapToGridAutocorrect_mjs__WEBPACK_IMPORTED_MODULE_4__["default"])((initialPoint, viewport) => {
    return new CircleBuilder(initialPoint, viewport);
});
class CircleBuilder {
    constructor(startPoint, viewport) {
        this.startPoint = startPoint;
        this.viewport = viewport;
        // Initially, the start and end points are the same.
        this.endPoint = startPoint;
    }
    getBBox() {
        const preview = this.buildPreview();
        return preview.getBBox();
    }
    buildPreview() {
        const pathCommands = [];
        const numDivisions = 6;
        const stepSize = (Math.PI * 2) / numDivisions;
        // Round the stroke width so that when exported it doesn't have unnecessary trailing decimals.
        const strokeWidth = _Viewport_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].roundPoint(this.endPoint.width, 5 / this.viewport.getScaleFactor());
        const center = this.startPoint.pos.lerp(this.endPoint.pos, 0.5);
        const startEndDelta = this.endPoint.pos.minus(center);
        const radius = startEndDelta.length() - strokeWidth / 2;
        const startPoint = center.plus(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(radius, 0));
        for (let t = stepSize; t <= Math.PI * 2; t += stepSize) {
            const endPoint = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(radius * Math.cos(t), -radius * Math.sin(t)).plus(center);
            // controlPointRadiusScale is selected to make the circles appear circular and
            // **does** depend on stepSize.
            const controlPointRadiusScale = 1.141;
            const controlPoint = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(Math.cos(t - stepSize / 2), -Math.sin(t - stepSize / 2))
                .times(radius * controlPointRadiusScale)
                .plus(center);
            pathCommands.push({
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.QuadraticBezierTo,
                controlPoint,
                endPoint,
            });
        }
        pathCommands.push({
            kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,
            point: startPoint,
        });
        const path = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Path(startPoint, pathCommands).mapPoints((point) => this.viewport.roundPoint(point));
        const preview = new _Stroke_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]([
            (0,_rendering_RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_1__.pathToRenderable)(path, {
                fill: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.transparent,
                stroke: {
                    width: strokeWidth,
                    color: this.endPoint.color,
                },
            }),
        ]);
        return preview;
    }
    build() {
        return this.buildPreview();
    }
    preview(renderer) {
        this.buildPreview().render(renderer);
    }
    addPoint(point) {
        this.endPoint = point;
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/components/builders/FreehandLineBuilder.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/components/builders/FreehandLineBuilder.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FreehandLineBuilder),
/* harmony export */   makeFreehandLineBuilder: () => (/* binding */ makeFreehandLineBuilder)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _Stroke_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Stroke.mjs */ "./node_modules/js-draw/dist/mjs/components/Stroke.mjs");
/* harmony import */ var _Viewport_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Viewport.mjs */ "./node_modules/js-draw/dist/mjs/Viewport.mjs");
/* harmony import */ var _util_StrokeSmoother_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/StrokeSmoother.mjs */ "./node_modules/js-draw/dist/mjs/components/util/StrokeSmoother.mjs");
/* harmony import */ var _autocorrect_makeShapeFitAutocorrect_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./autocorrect/makeShapeFitAutocorrect.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/autocorrect/makeShapeFitAutocorrect.mjs");





/**
 * Creates a stroke builder that draws freehand lines.
 *
 * Example:
 * [[include:doc-pages/inline-examples/changing-pen-types.md]]
 */
const makeFreehandLineBuilder = (0,_autocorrect_makeShapeFitAutocorrect_mjs__WEBPACK_IMPORTED_MODULE_4__["default"])((initialPoint, viewport) => {
    // Don't smooth if input is more than ± 3 pixels from the true curve, do smooth if
    // less than ±1 px from the curve.
    const maxSmoothingDist = viewport.getSizeOfPixelOnCanvas() * 3;
    const minSmoothingDist = viewport.getSizeOfPixelOnCanvas();
    return new FreehandLineBuilder(initialPoint, minSmoothingDist, maxSmoothingDist, viewport);
});
// Handles stroke smoothing and creates Strokes from user/stylus input.
class FreehandLineBuilder {
    constructor(startPoint, minFitAllowed, maxFitAllowed, viewport) {
        this.startPoint = startPoint;
        this.minFitAllowed = minFitAllowed;
        this.viewport = viewport;
        this.isFirstSegment = true;
        this.parts = [];
        this.widthAverageNumSamples = 1;
        this.curveFitter = new _util_StrokeSmoother_mjs__WEBPACK_IMPORTED_MODULE_3__.StrokeSmoother(startPoint, minFitAllowed, maxFitAllowed, (curve) => this.addCurve(curve));
        this.averageWidth = startPoint.width;
        this.bbox = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2(this.startPoint.pos.x, this.startPoint.pos.y, 0, 0);
    }
    getBBox() {
        return this.bbox;
    }
    getRenderingStyle() {
        return {
            fill: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.transparent,
            stroke: {
                color: this.startPoint.color,
                width: this.roundDistance(this.averageWidth),
            },
        };
    }
    previewCurrentPath() {
        const path = this.parts.slice();
        const commands = [...path, ...this.curveToPathCommands(this.curveFitter.preview())];
        const startPoint = this.startPoint.pos;
        return {
            startPoint,
            commands,
            style: this.getRenderingStyle(),
        };
    }
    previewFullPath() {
        const preview = this.previewCurrentPath();
        if (preview) {
            return [preview];
        }
        return null;
    }
    previewStroke() {
        const pathPreview = this.previewFullPath();
        if (pathPreview) {
            return new _Stroke_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](pathPreview);
        }
        return null;
    }
    preview(renderer) {
        const paths = this.previewFullPath();
        if (paths) {
            const approxBBox = this.viewport.visibleRect;
            renderer.startObject(approxBBox);
            for (const path of paths) {
                renderer.drawPath(path);
            }
            renderer.endObject();
        }
    }
    build() {
        this.curveFitter.finalizeCurrentCurve();
        return this.previewStroke();
    }
    getMinFit() {
        let minFit = Math.min(this.minFitAllowed, this.averageWidth / 3);
        if (minFit < 1e-10) {
            minFit = this.minFitAllowed;
        }
        return minFit;
    }
    roundPoint(point) {
        const minFit = this.getMinFit();
        return _Viewport_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].roundPoint(point, minFit);
    }
    roundDistance(dist) {
        const minFit = this.getMinFit();
        return _Viewport_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].roundPoint(dist, minFit);
    }
    curveToPathCommands(curve) {
        // Case where no points have been added
        if (!curve) {
            // Don't create a circle around the initial point if the stroke has more than one point.
            if (!this.isFirstSegment) {
                return [];
            }
            // Make the circle small -- because of the stroke style, we'll be drawing a stroke around it.
            const width = _Viewport_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].roundPoint(this.averageWidth / 10, Math.min(this.minFitAllowed, this.averageWidth / 10));
            const center = this.roundPoint(this.startPoint.pos);
            // Start on the right, cycle clockwise:
            //    |
            //  ----- ←
            //    |
            // Draw a circle-ish shape around the start point
            return [
                {
                    kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.QuadraticBezierTo,
                    controlPoint: center.plus(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(width, width)),
                    // Bottom of the circle
                    //    |
                    //  -----
                    //    |
                    //    ↑
                    endPoint: center.plus(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(0, width)),
                },
                {
                    kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.QuadraticBezierTo,
                    controlPoint: center.plus(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(-width, width)),
                    endPoint: center.plus(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(-width, 0)),
                },
                {
                    kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.QuadraticBezierTo,
                    controlPoint: center.plus(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(-width, -width)),
                    endPoint: center.plus(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(0, -width)),
                },
                {
                    kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.QuadraticBezierTo,
                    controlPoint: center.plus(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(width, -width)),
                    endPoint: center.plus(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(width, 0)),
                },
            ];
        }
        const result = [];
        if (this.isFirstSegment) {
            result.push({
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.MoveTo,
                point: this.roundPoint(curve.startPoint),
            });
        }
        result.push({
            kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.QuadraticBezierTo,
            controlPoint: this.roundPoint(curve.controlPoint),
            endPoint: this.roundPoint(curve.endPoint),
        });
        return result;
    }
    addCurve(curve) {
        const parts = this.curveToPathCommands(curve);
        this.parts.push(...parts);
        if (this.isFirstSegment) {
            this.isFirstSegment = false;
        }
    }
    addPoint(newPoint) {
        this.curveFitter.addPoint(newPoint);
        this.widthAverageNumSamples++;
        this.averageWidth =
            (this.averageWidth * (this.widthAverageNumSamples - 1)) / this.widthAverageNumSamples +
                newPoint.width / this.widthAverageNumSamples;
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/components/builders/LineBuilder.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/components/builders/LineBuilder.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LineBuilder),
/* harmony export */   makeLineBuilder: () => (/* binding */ makeLineBuilder)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _rendering_RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../rendering/RenderablePathSpec.mjs */ "./node_modules/js-draw/dist/mjs/rendering/RenderablePathSpec.mjs");
/* harmony import */ var _Stroke_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Stroke.mjs */ "./node_modules/js-draw/dist/mjs/components/Stroke.mjs");
/* harmony import */ var _autocorrect_makeSnapToGridAutocorrect_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./autocorrect/makeSnapToGridAutocorrect.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/autocorrect/makeSnapToGridAutocorrect.mjs");




/**
 * Creates a stroke builder that generates filled lines.
 *
 * Example:
 * [[include:doc-pages/inline-examples/changing-pen-types.md]]
 */
const makeLineBuilder = (0,_autocorrect_makeSnapToGridAutocorrect_mjs__WEBPACK_IMPORTED_MODULE_3__["default"])((initialPoint, viewport) => {
    return new LineBuilder(initialPoint, viewport);
});
class LineBuilder {
    constructor(startPoint, viewport) {
        this.startPoint = startPoint;
        this.viewport = viewport;
        this.endPoint = startPoint;
    }
    getBBox() {
        const preview = this.buildPreview();
        return preview.getBBox();
    }
    buildPreview() {
        const startPoint = this.startPoint.pos;
        const endPoint = this.endPoint.pos;
        const toEnd = endPoint.minus(startPoint).normalized();
        const startSize = this.startPoint.width / 2;
        const endSize = this.endPoint.width / 2;
        const lineNormal = toEnd.orthog();
        const scaledStartNormal = lineNormal.times(startSize);
        const scaledEndNormal = lineNormal.times(endSize);
        const strokeStartPoint = startPoint.minus(scaledStartNormal);
        const path = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Path(strokeStartPoint, [
            {
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,
                point: startPoint.plus(scaledStartNormal),
            },
            {
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,
                point: endPoint.plus(scaledEndNormal),
            },
            {
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,
                point: endPoint.minus(scaledEndNormal),
            },
            {
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,
                point: startPoint.minus(scaledStartNormal),
            },
        ]).mapPoints((point) => this.viewport.roundPoint(point));
        const preview = new _Stroke_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]([(0,_rendering_RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_1__.pathToRenderable)(path, { fill: this.startPoint.color })]);
        return preview;
    }
    build() {
        return this.buildPreview();
    }
    preview(renderer) {
        this.buildPreview().render(renderer);
    }
    addPoint(point) {
        this.endPoint = point;
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/components/builders/PolylineBuilder.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/components/builders/PolylineBuilder.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PolylineBuilder),
/* harmony export */   makePolylineBuilder: () => (/* binding */ makePolylineBuilder)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _Stroke_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Stroke.mjs */ "./node_modules/js-draw/dist/mjs/components/Stroke.mjs");
/* harmony import */ var _Viewport_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Viewport.mjs */ "./node_modules/js-draw/dist/mjs/Viewport.mjs");
/* harmony import */ var _autocorrect_makeShapeFitAutocorrect_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./autocorrect/makeShapeFitAutocorrect.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/autocorrect/makeShapeFitAutocorrect.mjs");




/**
 * Creates a freehand line builder that creates strokes from line segments
 * rather than Bézier curves.
 *
 * Example:
 * [[include:doc-pages/inline-examples/changing-pen-types.md]]
 */
const makePolylineBuilder = (0,_autocorrect_makeShapeFitAutocorrect_mjs__WEBPACK_IMPORTED_MODULE_3__["default"])((initialPoint, viewport) => {
    // Fit to a value slightly smaller than the pixel size. A larger value can
    // cause the stroke to appear jagged at some zoom levels.
    const minFit = viewport.getSizeOfPixelOnCanvas() * 0.75;
    return new PolylineBuilder(initialPoint, minFit, viewport);
});
class PolylineBuilder {
    constructor(startPoint, minFitAllowed, viewport) {
        this.minFitAllowed = minFitAllowed;
        this.viewport = viewport;
        this.parts = [];
        this.widthAverageNumSamples = 1;
        this.lastLineSegment = null;
        this.averageWidth = startPoint.width;
        this.startPoint = {
            ...startPoint,
            pos: this.roundPoint(startPoint.pos),
        };
        this.lastPoint = this.startPoint.pos;
        this.bbox = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2(this.startPoint.pos.x, this.startPoint.pos.y, 0, 0);
        this.parts = [
            {
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.MoveTo,
                point: this.startPoint.pos,
            },
        ];
    }
    getBBox() {
        return this.bbox.grownBy(this.averageWidth);
    }
    getRenderingStyle() {
        return {
            fill: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.transparent,
            stroke: {
                color: this.startPoint.color,
                width: this.roundDistance(this.averageWidth),
            },
        };
    }
    previewCurrentPath() {
        const startPoint = this.startPoint.pos;
        const commands = [...this.parts];
        // TODO: For now, this is necesary for the path to be visible.
        if (commands.length <= 1) {
            commands.push({
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,
                point: startPoint.plus(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(this.averageWidth / 4, 0)),
            });
        }
        return {
            startPoint,
            commands,
            style: this.getRenderingStyle(),
        };
    }
    previewFullPath() {
        return [this.previewCurrentPath()];
    }
    preview(renderer) {
        const paths = this.previewFullPath();
        if (paths) {
            const approxBBox = this.viewport.visibleRect;
            renderer.startObject(approxBBox);
            for (const path of paths) {
                renderer.drawPath(path);
            }
            renderer.endObject();
        }
    }
    build() {
        return new _Stroke_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](this.previewFullPath());
    }
    getMinFit() {
        let minFit = Math.min(this.minFitAllowed, this.averageWidth / 4);
        if (minFit < 1e-10) {
            minFit = this.minFitAllowed;
        }
        return minFit;
    }
    roundPoint(point) {
        const minFit = this.getMinFit();
        return _Viewport_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].roundPoint(point, minFit);
    }
    roundDistance(dist) {
        const minFit = this.getMinFit();
        return _Viewport_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].roundPoint(dist, minFit);
    }
    addPoint(newPoint) {
        this.widthAverageNumSamples++;
        this.averageWidth =
            (this.averageWidth * (this.widthAverageNumSamples - 1)) / this.widthAverageNumSamples +
                newPoint.width / this.widthAverageNumSamples;
        const roundedPoint = this.roundPoint(newPoint.pos);
        if (!roundedPoint.eq(this.lastPoint)) {
            // If almost exactly in the same line as the previous
            if (this.lastLineSegment &&
                this.lastLineSegment.direction.dot(roundedPoint.minus(this.lastPoint).normalized()) > 0.997) {
                this.parts.pop();
                this.lastPoint = this.lastLineSegment.p1;
            }
            this.parts.push({
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,
                point: this.roundPoint(newPoint.pos),
            });
            this.bbox = this.bbox.grownToPoint(roundedPoint);
            this.lastLineSegment = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.LineSegment2(this.lastPoint, roundedPoint);
            this.lastPoint = roundedPoint;
        }
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/components/builders/PressureSensitiveFreehandLineBuilder.mjs":
/*!****************************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/components/builders/PressureSensitiveFreehandLineBuilder.mjs ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PressureSensitiveFreehandLineBuilder),
/* harmony export */   makePressureSensitiveFreehandLineBuilder: () => (/* binding */ makePressureSensitiveFreehandLineBuilder)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _Stroke_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Stroke.mjs */ "./node_modules/js-draw/dist/mjs/components/Stroke.mjs");
/* harmony import */ var _Viewport_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Viewport.mjs */ "./node_modules/js-draw/dist/mjs/Viewport.mjs");
/* harmony import */ var _util_StrokeSmoother_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/StrokeSmoother.mjs */ "./node_modules/js-draw/dist/mjs/components/util/StrokeSmoother.mjs");
/* harmony import */ var _autocorrect_makeShapeFitAutocorrect_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./autocorrect/makeShapeFitAutocorrect.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/autocorrect/makeShapeFitAutocorrect.mjs");





const makePressureSensitiveFreehandLineBuilder = (0,_autocorrect_makeShapeFitAutocorrect_mjs__WEBPACK_IMPORTED_MODULE_4__["default"])((initialPoint, viewport) => {
    // Don't smooth if input is more than ± 3 pixels from the true curve, do smooth if
    // less than ±1 px from the curve.
    const maxSmoothingDist = viewport.getSizeOfPixelOnCanvas() * 3;
    const minSmoothingDist = viewport.getSizeOfPixelOnCanvas();
    return new PressureSensitiveFreehandLineBuilder(initialPoint, minSmoothingDist, maxSmoothingDist, viewport);
});
// Handles stroke smoothing and creates Strokes from user/stylus input.
class PressureSensitiveFreehandLineBuilder {
    constructor(startPoint, 
    // Maximum distance from the actual curve (irrespective of stroke width)
    // for which a point is considered 'part of the curve'.
    // Note that the maximum will be smaller if the stroke width is less than
    // [maxFitAllowed].
    minFitAllowed, maxFitAllowed, viewport) {
        this.startPoint = startPoint;
        this.minFitAllowed = minFitAllowed;
        this.viewport = viewport;
        this.isFirstSegment = true;
        this.pathStartConnector = null;
        this.mostRecentConnector = null;
        this.nextCurveStartConnector = null;
        this.lastUpperBezier = null;
        this.lastLowerBezier = null;
        this.parts = [];
        this.upperSegments = [];
        this.lowerSegments = [];
        this.curveFitter = new _util_StrokeSmoother_mjs__WEBPACK_IMPORTED_MODULE_3__.StrokeSmoother(startPoint, minFitAllowed, maxFitAllowed, (curve) => this.addCurve(curve));
        this.curveStartWidth = startPoint.width;
        this.bbox = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2(this.startPoint.pos.x, this.startPoint.pos.y, 0, 0);
    }
    getBBox() {
        return this.bbox;
    }
    getRenderingStyle() {
        return {
            fill: this.startPoint.color ?? null,
        };
    }
    previewCurrentPath(extendWithLatest = true) {
        const upperPath = this.upperSegments.slice();
        const lowerPath = this.lowerSegments.slice();
        let lowerToUpperCap;
        let pathStartConnector;
        const currentCurve = this.curveFitter.preview();
        if (currentCurve && extendWithLatest) {
            const { upperCurveCommand, lowerToUpperConnector, upperToLowerConnector, lowerCurveCommand } = this.segmentToPath(currentCurve);
            upperPath.push(upperCurveCommand);
            lowerPath.push(lowerCurveCommand);
            lowerToUpperCap = lowerToUpperConnector;
            pathStartConnector = this.pathStartConnector ?? [upperToLowerConnector];
        }
        else {
            if (this.mostRecentConnector === null || this.pathStartConnector === null) {
                return null;
            }
            lowerToUpperCap = this.mostRecentConnector;
            pathStartConnector = this.pathStartConnector;
        }
        let startPoint;
        const lastLowerSegment = lowerPath[lowerPath.length - 1];
        if (lastLowerSegment.kind === _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo ||
            lastLowerSegment.kind === _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.MoveTo) {
            startPoint = lastLowerSegment.point;
        }
        else {
            startPoint = lastLowerSegment.endPoint;
        }
        return {
            // Start at the end of the lower curve:
            //    Start point
            //     ↓
            //  __/  __/ ← Most recent points on this end
            // /___ /
            //  ↑
            //  Oldest points
            startPoint,
            commands: [
                // Move to the most recent point on the upperPath:
                //     ----→•
                //  __/  __/
                // /___ /
                lowerToUpperCap,
                // Move to the beginning of the upperPath:
                //  __/  __/
                // /___ /
                //     • ←-
                ...upperPath.reverse(),
                // Move to the beginning of the lowerPath:
                //  __/  __/
                // /___ /
                // •
                ...pathStartConnector,
                // Move back to the start point:
                //     •
                //  __/  __/
                // /___ /
                ...lowerPath,
            ],
            style: this.getRenderingStyle(),
        };
    }
    previewFullPath() {
        const preview = this.previewCurrentPath();
        if (preview) {
            return [...this.parts, preview];
        }
        return null;
    }
    preview(renderer) {
        const paths = this.previewFullPath();
        if (paths) {
            const approxBBox = this.viewport.visibleRect;
            renderer.startObject(approxBBox);
            for (const path of paths) {
                renderer.drawPath(path);
            }
            renderer.endObject();
        }
    }
    build() {
        this.curveFitter.finalizeCurrentCurve();
        if (this.isFirstSegment) {
            // Ensure we have something.
            this.addCurve(null);
        }
        return new _Stroke_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](this.previewFullPath());
    }
    roundPoint(point) {
        let minFit = Math.min(this.minFitAllowed, this.curveStartWidth / 3);
        if (minFit < 1e-10) {
            minFit = this.minFitAllowed;
        }
        return _Viewport_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].roundPoint(point, minFit);
    }
    // Returns true if, due to overlap with previous segments, a new RenderablePathSpec should be created.
    shouldStartNewSegment(lowerCurve, upperCurve) {
        if (!this.lastLowerBezier || !this.lastUpperBezier) {
            return false;
        }
        const getIntersection = (curve1, curve2) => {
            const intersections = curve1.intersectsBezier(curve2);
            if (!intersections.length)
                return null;
            return intersections[0].point;
        };
        const getExitDirection = (curve) => {
            return curve.p2.minus(curve.p1).normalized();
        };
        const getEnterDirection = (curve) => {
            return curve.p1.minus(curve.p0).normalized();
        };
        // Prevent
        //         /
        //       / /
        //      /  /  /|
        //    /    /   |
        //  /          |
        // where the next stroke and the previous stroke are in different directions.
        //
        // Are the exit/enter directions of the previous and current curves in different enough directions?
        if (getEnterDirection(upperCurve).dot(getExitDirection(this.lastUpperBezier)) < 0.35 ||
            getEnterDirection(lowerCurve).dot(getExitDirection(this.lastLowerBezier)) < 0.35 ||
            // Also handle if the curves exit/enter directions differ
            getEnterDirection(upperCurve).dot(getExitDirection(upperCurve)) < 0 ||
            getEnterDirection(lowerCurve).dot(getExitDirection(lowerCurve)) < 0) {
            return true;
        }
        // Check whether the lower curve intersects the other wall:
        //       /    / ← lower
        //    / /   /
        // /   / /
        //   //
        // / /
        const lowerIntersection = getIntersection(lowerCurve, this.lastUpperBezier);
        const upperIntersection = getIntersection(upperCurve, this.lastLowerBezier);
        if (lowerIntersection || upperIntersection) {
            return true;
        }
        return false;
    }
    addCurve(curve) {
        // Case where no points have been added
        if (!curve) {
            // Don't create a circle around the initial point if the stroke has more than one point.
            if (!this.isFirstSegment) {
                return;
            }
            const width = _Viewport_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].roundPoint(this.startPoint.width / 2.2, Math.min(this.minFitAllowed, this.startPoint.width / 4));
            const center = this.roundPoint(this.startPoint.pos);
            // Start on the right, cycle clockwise:
            //    |
            //  ----- ←
            //    |
            const startPoint = this.startPoint.pos.plus(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(width, 0));
            // Draw a circle-ish shape around the start point
            this.lowerSegments.push({
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.QuadraticBezierTo,
                controlPoint: center.plus(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(width, width)),
                // Bottom of the circle
                //    |
                //  -----
                //    |
                //    ↑
                endPoint: center.plus(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(0, width)),
            }, {
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.QuadraticBezierTo,
                controlPoint: center.plus(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(-width, width)),
                endPoint: center.plus(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(-width, 0)),
            }, {
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.QuadraticBezierTo,
                controlPoint: center.plus(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(-width, -width)),
                endPoint: center.plus(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(0, -width)),
            }, {
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.QuadraticBezierTo,
                controlPoint: center.plus(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(width, -width)),
                endPoint: center.plus(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(width, 0)),
            });
            const connector = {
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,
                point: startPoint,
            };
            this.pathStartConnector = [connector];
            this.mostRecentConnector = connector;
            return;
        }
        const { upperCurveCommand, lowerToUpperConnector, upperToLowerConnector, lowerCurveCommand, lowerCurve, upperCurve, nextCurveStartConnector, } = this.segmentToPath(curve);
        let shouldStartNew = this.shouldStartNewSegment(lowerCurve, upperCurve);
        if (shouldStartNew) {
            const part = this.previewCurrentPath(false);
            if (part) {
                this.parts.push(part);
                this.upperSegments = [];
                this.lowerSegments = [];
            }
            else {
                shouldStartNew = false;
            }
        }
        if (this.isFirstSegment || shouldStartNew) {
            // We draw the upper path (reversed), then the lower path, so we need the
            // upperToLowerConnector to join the two paths.
            this.pathStartConnector = this.nextCurveStartConnector ?? [upperToLowerConnector];
            this.isFirstSegment = false;
        }
        // With the most recent connector, we're joining the end of the lowerPath to the most recent
        // upperPath:
        this.mostRecentConnector = lowerToUpperConnector;
        this.nextCurveStartConnector = nextCurveStartConnector;
        this.lowerSegments.push(lowerCurveCommand);
        this.upperSegments.push(upperCurveCommand);
        this.lastLowerBezier = lowerCurve;
        this.lastUpperBezier = upperCurve;
        this.curveStartWidth = curve.startWidth;
    }
    // Returns [upper curve, connector, lower curve]
    segmentToPath(curve) {
        const bezier = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.QuadraticBezier(curve.startPoint, curve.controlPoint, curve.endPoint);
        let startVec = bezier.normal(0);
        let endVec = bezier.normal(1);
        startVec = startVec.times(curve.startWidth / 2);
        endVec = endVec.times(curve.endWidth / 2);
        if (!isFinite(startVec.magnitude())) {
            console.error('Warning: startVec is NaN or ∞', startVec, endVec, curve);
            startVec = endVec;
        }
        const startPt = curve.startPoint;
        const endPt = curve.endPoint;
        const controlPoint = curve.controlPoint;
        // Approximate the normal at the location of the control point
        const projectionT = bezier.nearestPointTo(controlPoint).parameterValue;
        const halfVecT = projectionT;
        const halfVec = bezier
            .normal(halfVecT)
            .times((curve.startWidth / 2) * halfVecT + (curve.endWidth / 2) * (1 - halfVecT));
        // Each starts at startPt ± startVec
        const lowerCurveStartPoint = this.roundPoint(startPt.plus(startVec));
        const lowerCurveControlPoint = this.roundPoint(controlPoint.plus(halfVec));
        const lowerCurveEndPoint = this.roundPoint(endPt.plus(endVec));
        const upperCurveControlPoint = this.roundPoint(controlPoint.minus(halfVec));
        const upperCurveStartPoint = this.roundPoint(endPt.minus(endVec));
        const upperCurveEndPoint = this.roundPoint(startPt.minus(startVec));
        const lowerCurveCommand = {
            kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.QuadraticBezierTo,
            controlPoint: lowerCurveControlPoint,
            endPoint: lowerCurveEndPoint,
        };
        // From the end of the upperCurve to the start of the lowerCurve:
        const upperToLowerConnector = {
            kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,
            point: lowerCurveStartPoint,
        };
        // From the end of lowerCurve to the start of upperCurve:
        const lowerToUpperConnector = {
            kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,
            point: upperCurveStartPoint,
        };
        // The segment to be used to start the next path (to insert to connect the start of its
        // lower and the end of its upper).
        const nextCurveStartConnector = [
            {
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,
                point: upperCurveStartPoint,
            },
            {
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,
                point: lowerCurveEndPoint,
            },
        ];
        const upperCurveCommand = {
            kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.QuadraticBezierTo,
            controlPoint: upperCurveControlPoint,
            endPoint: upperCurveEndPoint,
        };
        const upperCurve = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.QuadraticBezier(upperCurveStartPoint, upperCurveControlPoint, upperCurveEndPoint);
        const lowerCurve = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.QuadraticBezier(lowerCurveStartPoint, lowerCurveControlPoint, lowerCurveEndPoint);
        return {
            upperCurveCommand,
            upperToLowerConnector,
            lowerToUpperConnector,
            lowerCurveCommand,
            upperCurve,
            lowerCurve,
            nextCurveStartConnector,
        };
    }
    addPoint(newPoint) {
        this.curveFitter.addPoint(newPoint);
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/components/builders/RectangleBuilder.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/components/builders/RectangleBuilder.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RectangleBuilder),
/* harmony export */   makeFilledRectangleBuilder: () => (/* binding */ makeFilledRectangleBuilder),
/* harmony export */   makeOutlinedRectangleBuilder: () => (/* binding */ makeOutlinedRectangleBuilder)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _rendering_RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../rendering/RenderablePathSpec.mjs */ "./node_modules/js-draw/dist/mjs/rendering/RenderablePathSpec.mjs");
/* harmony import */ var _Stroke_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Stroke.mjs */ "./node_modules/js-draw/dist/mjs/components/Stroke.mjs");
/* harmony import */ var _autocorrect_makeSnapToGridAutocorrect_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./autocorrect/makeSnapToGridAutocorrect.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/autocorrect/makeSnapToGridAutocorrect.mjs");




/**
 * Creates filled rectangles with sharp corners.
 *
 * Example:
 * [[include:doc-pages/inline-examples/changing-pen-types.md]]
 */
const makeFilledRectangleBuilder = (0,_autocorrect_makeSnapToGridAutocorrect_mjs__WEBPACK_IMPORTED_MODULE_3__["default"])((initialPoint, viewport) => {
    return new RectangleBuilder(initialPoint, true, viewport);
});
/**
 * Creates outlined rectangles with sharp corners.
 *
 * Example:
 * [[include:doc-pages/inline-examples/changing-pen-types.md]]
 */
const makeOutlinedRectangleBuilder = (0,_autocorrect_makeSnapToGridAutocorrect_mjs__WEBPACK_IMPORTED_MODULE_3__["default"])((initialPoint, viewport) => {
    return new RectangleBuilder(initialPoint, false, viewport);
});
class RectangleBuilder {
    constructor(startPoint, filled, viewport) {
        this.startPoint = startPoint;
        this.filled = filled;
        this.viewport = viewport;
        // Initially, the start and end points are the same.
        this.endPoint = startPoint;
    }
    getBBox() {
        const preview = this.buildPreview();
        return preview.getBBox();
    }
    buildPreview() {
        const canvasAngle = this.viewport.getRotationAngle();
        const rotationMat = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.zRotation(-canvasAngle);
        // Adjust startPoint and endPoint such that applying [rotationMat] to them
        // brings them to this.startPoint and this.endPoint.
        const startPoint = rotationMat.inverse().transformVec2(this.startPoint.pos);
        const endPoint = rotationMat.inverse().transformVec2(this.endPoint.pos);
        const rect = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2.fromCorners(startPoint, endPoint);
        const path = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Path.fromRect(rect, this.filled ? null : this.endPoint.width)
            .transformedBy(
        // Rotate the canvas rectangle so that its rotation matches the screen
        rotationMat)
            .mapPoints((point) => this.viewport.roundPoint(point));
        const preview = new _Stroke_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]([
            (0,_rendering_RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_1__.pathToRenderable)(path, {
                fill: this.endPoint.color,
            }),
        ]);
        return preview;
    }
    build() {
        return this.buildPreview();
    }
    preview(renderer) {
        this.buildPreview().render(renderer);
    }
    addPoint(point) {
        this.endPoint = point;
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/components/builders/autocorrect/makeShapeFitAutocorrect.mjs":
/*!***************************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/components/builders/autocorrect/makeShapeFitAutocorrect.mjs ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");

const makeShapeFitAutocorrect = (sourceFactory) => {
    return (startPoint, viewport) => {
        return new ShapeFitBuilder(sourceFactory, startPoint, viewport);
    };
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (makeShapeFitAutocorrect);
const makeLineTemplate = (startPoint, points, _bbox) => {
    const templatePoints = [startPoint, points[points.length - 1]];
    return { points: templatePoints };
};
const makeRectangleTemplate = (_startPoint, _points, bbox) => {
    return { points: [...bbox.corners, bbox.corners[0]] };
};
class ShapeFitBuilder {
    constructor(sourceFactory, startPoint, viewport) {
        this.sourceFactory = sourceFactory;
        this.startPoint = startPoint;
        this.viewport = viewport;
        this.builder = sourceFactory(startPoint, viewport);
        this.points = [startPoint];
    }
    getBBox() {
        return this.builder.getBBox();
    }
    build() {
        return this.builder.build();
    }
    preview(renderer) {
        this.builder.preview(renderer);
    }
    addPoint(point) {
        this.points.push(point);
        this.builder.addPoint(point);
    }
    async autocorrectShape() {
        // Use screen points so that autocorrected shapes rotate with the screen.
        const startPoint = this.viewport.canvasToScreen(this.startPoint.pos);
        const points = this.points.map((point) => this.viewport.canvasToScreen(point.pos));
        const bbox = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2.bboxOf(points);
        const snappedStartPoint = this.viewport.canvasToScreen(this.viewport.snapToGrid(this.startPoint.pos));
        const snappedPoints = this.points.map((point) => this.viewport.canvasToScreen(this.viewport.snapToGrid(point.pos)));
        const snappedBBox = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2.bboxOf(snappedPoints);
        // Only fit larger shapes
        if (bbox.maxDimension < 32) {
            return null;
        }
        const maxError = Math.min(30, bbox.maxDimension / 4);
        // Create templates
        const templates = [
            {
                ...makeLineTemplate(snappedStartPoint, snappedPoints, snappedBBox),
                toleranceMultiplier: 0.5,
            },
            makeLineTemplate(startPoint, points, bbox),
            {
                ...makeRectangleTemplate(snappedStartPoint, snappedPoints, snappedBBox),
                toleranceMultiplier: 0.6,
            },
            makeRectangleTemplate(startPoint, points, bbox),
        ];
        // Find a good fit fit
        const selectTemplate = (maximumAllowedError) => {
            for (const template of templates) {
                const templatePoints = template.points;
                // Maximum square error to accept the template
                const acceptMaximumSquareError = maximumAllowedError * maximumAllowedError * (template.toleranceMultiplier ?? 1);
                // Gets the point at index, wrapping the the start of the template if
                // outside the array of points.
                const templateAt = (index) => {
                    while (index < 0) {
                        index += templatePoints.length;
                    }
                    index %= templatePoints.length;
                    return templatePoints[index];
                };
                let closestToFirst = null;
                let closestToFirstSqrDist = Infinity;
                let templateStartIndex = 0;
                // Find the closest point to the startPoint
                for (let i = 0; i < templatePoints.length; i++) {
                    const current = templatePoints[i];
                    const currentSqrDist = current.squareDistanceTo(startPoint);
                    if (!closestToFirst || currentSqrDist < closestToFirstSqrDist) {
                        closestToFirstSqrDist = currentSqrDist;
                        closestToFirst = current;
                        templateStartIndex = i;
                    }
                }
                // Walk through the points and find the maximum error
                let maximumSqrError = 0;
                let templateIndex = templateStartIndex;
                for (const point of points) {
                    let minimumCurrentSqrError = Infinity;
                    let minimumErrorAtIndex = templateIndex;
                    const windowRadius = 6;
                    for (let i = -windowRadius; i <= windowRadius; i++) {
                        const index = templateIndex + i;
                        const prevTemplatePoint = templateAt(index - 1);
                        const currentTemplatePoint = templateAt(index);
                        const nextTemplatePoint = templateAt(index + 1);
                        const prevToCurrent = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.LineSegment2(prevTemplatePoint, currentTemplatePoint);
                        const currentToNext = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.LineSegment2(currentTemplatePoint, nextTemplatePoint);
                        const prevToCurrentDist = prevToCurrent.distance(point);
                        const nextToCurrentDist = currentToNext.distance(point);
                        const error = Math.min(prevToCurrentDist, nextToCurrentDist);
                        const squareError = error * error;
                        if (squareError < minimumCurrentSqrError) {
                            minimumCurrentSqrError = squareError;
                            minimumErrorAtIndex = index;
                        }
                    }
                    templateIndex = minimumErrorAtIndex;
                    maximumSqrError = Math.max(minimumCurrentSqrError, maximumSqrError);
                    if (maximumSqrError > acceptMaximumSquareError) {
                        break;
                    }
                }
                if (maximumSqrError < acceptMaximumSquareError) {
                    return templatePoints;
                }
            }
            return null;
        };
        const template = selectTemplate(maxError);
        if (!template) {
            return null;
        }
        const lastDataPoint = this.points[this.points.length - 1];
        const startWidth = this.startPoint.width;
        const endWidth = lastDataPoint.width;
        const startColor = this.startPoint.color;
        const endColor = lastDataPoint.color;
        const startTime = this.startPoint.time;
        const endTime = lastDataPoint.time;
        const templateIndexToStrokeDataPoint = (index) => {
            const prevPoint = template[Math.max(0, Math.floor(index))];
            const nextPoint = template[Math.min(Math.ceil(index), template.length - 1)];
            const point = prevPoint.lerp(nextPoint, index - Math.floor(index));
            const fractionToEnd = index / template.length;
            return {
                pos: this.viewport.screenToCanvas(point),
                width: startWidth * (1 - fractionToEnd) + endWidth * fractionToEnd,
                color: startColor.mix(endColor, fractionToEnd),
                time: startTime * (1 - fractionToEnd) + endTime * fractionToEnd,
            };
        };
        const builder = this.sourceFactory(templateIndexToStrokeDataPoint(0), this.viewport);
        // Prevent the original builder from doing stroke smoothing if the template is short
        // enough to likely have sharp corners.
        const preventSmoothing = template.length < 10;
        for (let i = 0; i < template.length; i++) {
            if (preventSmoothing) {
                builder.addPoint(templateIndexToStrokeDataPoint(i - 0.001));
            }
            builder.addPoint(templateIndexToStrokeDataPoint(i));
            if (preventSmoothing) {
                builder.addPoint(templateIndexToStrokeDataPoint(i + 0.001));
            }
        }
        return builder.build();
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/components/builders/autocorrect/makeSnapToGridAutocorrect.mjs":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/components/builders/autocorrect/makeSnapToGridAutocorrect.mjs ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const makeSnapToGridAutocorrect = (sourceFactory) => {
    return (startPoint, viewport) => {
        return new SnapToGridAutocompleteBuilder(sourceFactory, startPoint, viewport);
    };
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (makeSnapToGridAutocorrect);
class SnapToGridAutocompleteBuilder {
    constructor(sourceFactory, startPoint, viewport) {
        this.sourceFactory = sourceFactory;
        this.startPoint = startPoint;
        this.viewport = viewport;
        this.builder = sourceFactory(startPoint, viewport);
        this.points = [startPoint];
    }
    getBBox() {
        return this.builder.getBBox();
    }
    build() {
        return this.builder.build();
    }
    preview(renderer) {
        this.builder.preview(renderer);
    }
    addPoint(point) {
        this.points.push(point);
        this.builder.addPoint(point);
    }
    async autocorrectShape() {
        const snapToGrid = (point) => {
            return {
                ...point,
                pos: this.viewport.snapToGrid(point.pos),
            };
        };
        // Use screen points so that snapped shapes rotate with the screen.
        const startPoint = snapToGrid(this.startPoint);
        const builder = this.sourceFactory(startPoint, this.viewport);
        const points = this.points.map((point) => snapToGrid(point));
        for (const point of points) {
            builder.addPoint(point);
        }
        return builder.build();
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/components/builders/lib.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/components/builders/lib.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   makeArrowBuilder: () => (/* reexport safe */ _ArrowBuilder_mjs__WEBPACK_IMPORTED_MODULE_4__.makeArrowBuilder),
/* harmony export */   makeFilledRectangleBuilder: () => (/* reexport safe */ _RectangleBuilder_mjs__WEBPACK_IMPORTED_MODULE_6__.makeFilledRectangleBuilder),
/* harmony export */   makeFreehandLineBuilder: () => (/* reexport safe */ _FreehandLineBuilder_mjs__WEBPACK_IMPORTED_MODULE_0__.makeFreehandLineBuilder),
/* harmony export */   makeLineBuilder: () => (/* reexport safe */ _LineBuilder_mjs__WEBPACK_IMPORTED_MODULE_5__.makeLineBuilder),
/* harmony export */   makeOutlinedCircleBuilder: () => (/* reexport safe */ _CircleBuilder_mjs__WEBPACK_IMPORTED_MODULE_3__.makeOutlinedCircleBuilder),
/* harmony export */   makeOutlinedRectangleBuilder: () => (/* reexport safe */ _RectangleBuilder_mjs__WEBPACK_IMPORTED_MODULE_6__.makeOutlinedRectangleBuilder),
/* harmony export */   makePolylineBuilder: () => (/* reexport safe */ _PolylineBuilder_mjs__WEBPACK_IMPORTED_MODULE_1__.makePolylineBuilder),
/* harmony export */   makePressureSensitiveFreehandLineBuilder: () => (/* reexport safe */ _PressureSensitiveFreehandLineBuilder_mjs__WEBPACK_IMPORTED_MODULE_2__.makePressureSensitiveFreehandLineBuilder)
/* harmony export */ });
/* harmony import */ var _FreehandLineBuilder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FreehandLineBuilder.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/FreehandLineBuilder.mjs");
/* harmony import */ var _PolylineBuilder_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PolylineBuilder.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/PolylineBuilder.mjs");
/* harmony import */ var _PressureSensitiveFreehandLineBuilder_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PressureSensitiveFreehandLineBuilder.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/PressureSensitiveFreehandLineBuilder.mjs");
/* harmony import */ var _CircleBuilder_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CircleBuilder.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/CircleBuilder.mjs");
/* harmony import */ var _ArrowBuilder_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ArrowBuilder.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/ArrowBuilder.mjs");
/* harmony import */ var _LineBuilder_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./LineBuilder.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/LineBuilder.mjs");
/* harmony import */ var _RectangleBuilder_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./RectangleBuilder.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/RectangleBuilder.mjs");









/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/components/builders/types.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/components/builders/types.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/components/lib.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/components/lib.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractComponent: () => (/* reexport safe */ _AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   BackgroundComponent: () => (/* reexport safe */ _BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   BackgroundComponentBackgroundType: () => (/* reexport safe */ _BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_8__.BackgroundType),
/* harmony export */   ComponentSizingMode: () => (/* reexport safe */ _AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_3__.ComponentSizingMode),
/* harmony export */   ImageComponent: () => (/* reexport safe */ _ImageComponent_mjs__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   Stroke: () => (/* reexport safe */ _Stroke_mjs__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   StrokeComponent: () => (/* reexport safe */ _Stroke_mjs__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   StrokeSmoother: () => (/* reexport safe */ _util_StrokeSmoother_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   Text: () => (/* reexport safe */ _TextComponent_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   TextComponent: () => (/* reexport safe */ _TextComponent_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   createRestyleComponentCommand: () => (/* reexport safe */ _RestylableComponent_mjs__WEBPACK_IMPORTED_MODULE_7__.createRestyleComponentCommand),
/* harmony export */   isRestylableComponent: () => (/* reexport safe */ _RestylableComponent_mjs__WEBPACK_IMPORTED_MODULE_7__.isRestylableComponent),
/* harmony export */   makeArrowBuilder: () => (/* reexport safe */ _builders_lib_mjs__WEBPACK_IMPORTED_MODULE_1__.makeArrowBuilder),
/* harmony export */   makeFilledRectangleBuilder: () => (/* reexport safe */ _builders_lib_mjs__WEBPACK_IMPORTED_MODULE_1__.makeFilledRectangleBuilder),
/* harmony export */   makeFreehandLineBuilder: () => (/* reexport safe */ _builders_lib_mjs__WEBPACK_IMPORTED_MODULE_1__.makeFreehandLineBuilder),
/* harmony export */   makeLineBuilder: () => (/* reexport safe */ _builders_lib_mjs__WEBPACK_IMPORTED_MODULE_1__.makeLineBuilder),
/* harmony export */   makeOutlinedCircleBuilder: () => (/* reexport safe */ _builders_lib_mjs__WEBPACK_IMPORTED_MODULE_1__.makeOutlinedCircleBuilder),
/* harmony export */   makeOutlinedRectangleBuilder: () => (/* reexport safe */ _builders_lib_mjs__WEBPACK_IMPORTED_MODULE_1__.makeOutlinedRectangleBuilder),
/* harmony export */   makePolylineBuilder: () => (/* reexport safe */ _builders_lib_mjs__WEBPACK_IMPORTED_MODULE_1__.makePolylineBuilder),
/* harmony export */   makePressureSensitiveFreehandLineBuilder: () => (/* reexport safe */ _builders_lib_mjs__WEBPACK_IMPORTED_MODULE_1__.makePressureSensitiveFreehandLineBuilder)
/* harmony export */ });
/* harmony import */ var _builders_types_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./builders/types.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/types.mjs");
/* harmony import */ var _builders_lib_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./builders/lib.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/lib.mjs");
/* harmony import */ var _util_StrokeSmoother_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/StrokeSmoother.mjs */ "./node_modules/js-draw/dist/mjs/components/util/StrokeSmoother.mjs");
/* harmony import */ var _AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AbstractComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/AbstractComponent.mjs");
/* harmony import */ var _Stroke_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Stroke.mjs */ "./node_modules/js-draw/dist/mjs/components/Stroke.mjs");
/* harmony import */ var _TextComponent_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TextComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/TextComponent.mjs");
/* harmony import */ var _ImageComponent_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ImageComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/ImageComponent.mjs");
/* harmony import */ var _RestylableComponent_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./RestylableComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/RestylableComponent.mjs");
/* harmony import */ var _BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./BackgroundComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/BackgroundComponent.mjs");













/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/components/localization.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/components/localization.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultComponentLocalization: () => (/* binding */ defaultComponentLocalization)
/* harmony export */ });
const defaultComponentLocalization = {
    unlabeledImageNode: 'Unlabeled image node',
    stroke: 'Stroke',
    svgObject: 'SVG Object',
    emptyBackground: 'Empty background',
    gridBackground: 'Grid background',
    filledBackgroundWithColor: (color) => `Filled background (${color})`,
    text: (text) => `Text object: ${text}`,
    imageNode: (description) => `Image: ${description}`,
    restyledElement: (elementDescription) => `Restyled ${elementDescription}`,
};


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/components/util/StrokeSmoother.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/components/util/StrokeSmoother.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StrokeSmoother: () => (/* binding */ StrokeSmoother),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");

// Handles stroke smoothing
class StrokeSmoother {
    constructor(startPoint, 
    // Maximum distance from the actual curve (irrespective of stroke width)
    // for which a point is considered 'part of the curve'.
    // Note that the maximum will be smaller if the stroke width is less than
    // [maxFitAllowed].
    minFitAllowed, maxFitAllowed, onCurveAdded) {
        this.startPoint = startPoint;
        this.minFitAllowed = minFitAllowed;
        this.maxFitAllowed = maxFitAllowed;
        this.onCurveAdded = onCurveAdded;
        this.isFirstSegment = true;
        this.lastExitingVec = null;
        this.currentCurve = null;
        this.lastPoint = this.startPoint;
        this.buffer = [this.startPoint.pos];
        this.momentum = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.zero;
        this.currentCurve = null;
        this.curveStartWidth = startPoint.width;
        this.bbox = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2(this.startPoint.pos.x, this.startPoint.pos.y, 0, 0);
    }
    getBBox() {
        return this.bbox;
    }
    preview() {
        if (!this.currentCurve) {
            return null;
        }
        return this.currentSegmentToPath();
    }
    // Returns the distance between the start, control, and end points of the curve.
    approxCurrentCurveLength() {
        if (!this.currentCurve) {
            return 0;
        }
        const startPt = this.currentCurve.p0;
        const controlPt = this.currentCurve.p1;
        const endPt = this.currentCurve.p2;
        const toControlDist = startPt.distanceTo(controlPt);
        const toEndDist = endPt.distanceTo(controlPt);
        return toControlDist + toEndDist;
    }
    finalizeCurrentCurve() {
        // Case where no points have been added
        if (!this.currentCurve) {
            return;
        }
        this.onCurveAdded(this.currentSegmentToPath());
        const lastPoint = this.buffer[this.buffer.length - 1];
        this.lastExitingVec = this.currentCurve.p2.minus(this.currentCurve.p1);
        console.assert(this.lastExitingVec.magnitude() !== 0, 'lastExitingVec has zero length!');
        // Use the last two points to start a new curve (the last point isn't used
        // in the current curve and we want connected curves to share end points)
        this.buffer = [this.buffer[this.buffer.length - 2], lastPoint];
        this.currentCurve = null;
        this.isFirstSegment = false;
    }
    // Returns [upper curve, connector, lower curve]
    currentSegmentToPath() {
        if (this.currentCurve == null) {
            throw new Error('Invalid State: currentCurve is null!');
        }
        const startVec = this.currentCurve.normal(0).normalized();
        if (!isFinite(startVec.magnitude())) {
            throw new Error(`startVec(${startVec}) is NaN or ∞`);
        }
        const startPt = this.currentCurve.at(0);
        const endPt = this.currentCurve.at(1);
        const controlPoint = this.currentCurve.p1;
        return {
            startPoint: startPt,
            controlPoint,
            endPoint: endPt,
            startWidth: this.curveStartWidth,
            endWidth: this.curveEndWidth,
        };
    }
    // Compute the direction of the velocity at the end of this.buffer
    computeExitingVec() {
        return this.momentum.normalized().times(this.lastPoint.width / 2);
    }
    addPoint(newPoint) {
        if (this.lastPoint) {
            // Ignore points that are identical
            const fuzzEq = 1e-10;
            const deltaTime = newPoint.time - this.lastPoint.time;
            if (newPoint.pos.eq(this.lastPoint.pos, fuzzEq) || deltaTime === 0) {
                return;
            }
            else if (isNaN(newPoint.pos.magnitude())) {
                console.warn('Discarding NaN point.', newPoint);
                return;
            }
            const threshold = Math.min(this.lastPoint.width, newPoint.width) / 3;
            const shouldSnapToInitial = this.startPoint.pos.distanceTo(newPoint.pos) < threshold && this.isFirstSegment;
            // Snap to the starting point if the stroke is contained within a small ball centered
            // at the starting point.
            // This allows us to create a circle/dot at the start of the stroke.
            if (shouldSnapToInitial) {
                return;
            }
            const deltaTimeSeconds = deltaTime / 1000;
            const velocity = newPoint.pos.minus(this.lastPoint.pos).times(1 / deltaTimeSeconds);
            // TODO: Do we need momentum smoothing? (this.momentum.lerp(velocity, 0.9);)
            this.momentum = velocity;
        }
        const lastPoint = this.lastPoint ?? newPoint;
        this.lastPoint = newPoint;
        this.buffer.push(newPoint.pos);
        const pointRadius = newPoint.width;
        const prevEndWidth = this.curveEndWidth;
        this.curveEndWidth = pointRadius;
        // recompute bbox
        this.bbox = this.bbox.grownToPoint(newPoint.pos, pointRadius);
        // If the last curve just ended or it's the first curve,
        if (this.currentCurve === null) {
            const p1 = lastPoint.pos;
            const p2 = lastPoint.pos.plus(this.lastExitingVec ?? _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.unitX);
            const p3 = newPoint.pos;
            // Quadratic Bézier curve
            this.currentCurve = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.QuadraticBezier(p1, p2, p3);
            console.assert(!isNaN(p1.magnitude()) && !isNaN(p2.magnitude()) && !isNaN(p3.magnitude()), 'Expected !NaN');
            if (this.isFirstSegment) {
                // The start of a curve often lacks accurate pressure information. Update it.
                this.curveStartWidth = (this.curveStartWidth + pointRadius) / 2;
            }
            else {
                this.curveStartWidth = prevEndWidth;
            }
        }
        // If there isn't an entering vector (e.g. because this.isFirstCurve), approximate it.
        let enteringVec = this.lastExitingVec;
        if (!enteringVec) {
            let sampleIdx = Math.ceil(this.buffer.length / 2);
            if (sampleIdx === 0 || sampleIdx >= this.buffer.length) {
                sampleIdx = this.buffer.length - 1;
            }
            enteringVec = this.buffer[sampleIdx].minus(this.buffer[0]);
        }
        let exitingVec = this.computeExitingVec();
        // Find the intersection between the entering vector and the exiting vector
        const maxRelativeLength = 1.7;
        const segmentStart = this.buffer[0];
        const segmentEnd = newPoint.pos;
        const startEndDist = segmentEnd.distanceTo(segmentStart);
        const maxControlPointDist = maxRelativeLength * startEndDist;
        // Exit in cases where we would divide by zero
        if (maxControlPointDist === 0 ||
            exitingVec.magnitude() === 0 ||
            !isFinite(exitingVec.magnitude())) {
            return;
        }
        console.assert(isFinite(enteringVec.magnitude()), 'Pre-normalized enteringVec has NaN or ∞ magnitude!');
        enteringVec = enteringVec.normalized();
        exitingVec = exitingVec.normalized();
        console.assert(isFinite(enteringVec.magnitude()), 'Normalized enteringVec has NaN or ∞ magnitude!');
        const lineFromStart = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.LineSegment2(segmentStart, segmentStart.plus(enteringVec.times(maxControlPointDist)));
        const lineFromEnd = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.LineSegment2(segmentEnd.minus(exitingVec.times(maxControlPointDist)), segmentEnd);
        const intersection = lineFromEnd.intersection(lineFromStart);
        // Position the control point at this intersection
        let controlPoint = null;
        if (intersection) {
            controlPoint = intersection.point;
        }
        // No intersection?
        if (!controlPoint) {
            // Estimate the control point position based on the entering tangent line
            controlPoint = segmentStart
                .lerp(segmentEnd, 0.5)
                .lerp(segmentStart.plus(enteringVec.times(startEndDist)), 0.1);
        }
        // Equal to an endpoint?
        if (segmentStart.eq(controlPoint) || segmentEnd.eq(controlPoint)) {
            // Position the control point closer to the first -- the connecting
            // segment will be roughly a line.
            controlPoint = segmentStart.plus(enteringVec.times(startEndDist / 5));
        }
        console.assert(!segmentStart.eq(controlPoint, 1e-11), 'Start and control points are equal!');
        console.assert(!controlPoint.eq(segmentEnd, 1e-11), 'Control and end points are equal!');
        const prevCurve = this.currentCurve;
        this.currentCurve = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.QuadraticBezier(segmentStart, controlPoint, segmentEnd);
        if (isNaN(this.currentCurve.normal(0).magnitude())) {
            console.error('NaN normal at 0. Curve:', this.currentCurve);
            this.currentCurve = prevCurve;
        }
        // Should we start making a new curve? Check whether all buffer points are within
        // ±strokeWidth of the curve.
        const curveMatchesPoints = (curve) => {
            const minFit = Math.min(Math.max(Math.min(this.curveStartWidth, this.curveEndWidth) / 4, this.minFitAllowed), this.maxFitAllowed);
            // The sum of distances greater than minFit must not exceed this:
            const maxNonMatchingDistSum = minFit;
            // Sum of distances greater than minFit.
            let nonMatchingDistSum = 0;
            for (const point of this.buffer) {
                let dist = curve.approximateDistance(point);
                if (dist > minFit) {
                    // Use the more accurate distance function
                    dist = curve.distance(point);
                    nonMatchingDistSum += Math.max(0, dist - minFit);
                    if (nonMatchingDistSum > maxNonMatchingDistSum) {
                        return false; // false: Curve doesn't match points well enough.
                    }
                }
            }
            return true;
        };
        if (this.buffer.length > 3 && this.approxCurrentCurveLength() > this.curveStartWidth / 2) {
            if (!curveMatchesPoints(this.currentCurve)) {
                // Use a curve that better fits the points
                this.currentCurve = prevCurve;
                this.curveEndWidth = prevEndWidth;
                // Reset the last point -- the current point was not added to the curve.
                this.lastPoint = lastPoint;
                this.finalizeCurrentCurve();
                return;
            }
        }
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StrokeSmoother);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/components/util/describeComponentList.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/components/util/describeComponentList.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Returns the description of all given elements, if identical, otherwise,
// returns null.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((localizationTable, elems) => {
    if (elems.length === 0) {
        return null;
    }
    const description = elems[0].description(localizationTable);
    for (const elem of elems) {
        if (elem.description(localizationTable) !== description) {
            return null;
        }
    }
    return description;
});


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/dialogs/makeAboutDialog.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/dialogs/makeAboutDialog.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _makeMessageDialog_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./makeMessageDialog.mjs */ "./node_modules/js-draw/dist/mjs/dialogs/makeMessageDialog.mjs");

const makeAboutDialog = (editor, entries) => {
    const dialog = (0,_makeMessageDialog_mjs__WEBPACK_IMPORTED_MODULE_0__["default"])(editor, {
        title: editor.localization.about,
        contentClassNames: ['about-dialog-content'],
    });
    for (const entry of entries) {
        const container = document.createElement(entry.minimized ? 'details' : 'div');
        container.classList.add('about-entry');
        const header = document.createElement(entry.minimized ? 'summary' : 'h2');
        if (typeof entry.heading === 'string') {
            header.innerText = entry.heading;
        }
        else {
            const link = document.createElement('a');
            link.href = entry.heading.href.replace(/^javascript:/i, '');
            link.text = entry.heading.text;
            header.appendChild(link);
        }
        container.appendChild(header);
        if (entry.text) {
            const bodyText = document.createElement('div');
            bodyText.innerText = entry.text;
            container.appendChild(bodyText);
        }
        dialog.appendChild(container);
    }
    return {
        close: () => {
            return dialog.close();
        },
    };
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (makeAboutDialog);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/dialogs/makeMessageDialog.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/dialogs/makeMessageDialog.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_waitForTimeout_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/waitForTimeout.mjs */ "./node_modules/js-draw/dist/mjs/util/waitForTimeout.mjs");

const makeAboutDialog = (editor, options) => {
    const overlay = document.createElement('div');
    const { remove: removeOverlay } = editor.createHTMLOverlay(overlay);
    overlay.classList.add('dialog-container', 'message-dialog-container', ...(options.classNames ?? []));
    const dialog = document.createElement('dialog');
    const contentWrapper = document.createElement('div');
    contentWrapper.classList.add('message-dialog-content', ...(options.contentClassNames ?? []));
    const heading = document.createElement('h1');
    heading.textContent = options.title;
    heading.setAttribute('autofocus', 'true');
    const closeButton = document.createElement('button');
    closeButton.innerText = editor.localization.closeDialog;
    closeButton.classList.add('close');
    const scrollRegion = document.createElement('div');
    scrollRegion.classList.add('scroll');
    // Allow scrolling in the scrollable container -- don't forward wheel events.
    scrollRegion.onwheel = (evt) => evt.stopPropagation();
    contentWrapper.replaceChildren(heading, scrollRegion, closeButton);
    dialog.replaceChildren(contentWrapper);
    overlay.replaceChildren(dialog);
    const closeTimeout = 300;
    dialog.style.setProperty('--close-delay', `${closeTimeout}ms`);
    const closeDialog = async () => {
        dialog.classList.add('-closing');
        await (0,_util_waitForTimeout_mjs__WEBPACK_IMPORTED_MODULE_0__["default"])(closeTimeout);
        dialog.close();
    };
    const addCloseListeners = () => {
        dialog.addEventListener('pointerdown', (event) => {
            if (event.target === dialog) {
                void closeDialog();
            }
        });
        dialog.onclose = () => {
            removeOverlay();
        };
        closeButton.onclick = () => closeDialog();
    };
    addCloseListeners();
    dialog.showModal();
    return {
        close: () => {
            return closeDialog();
        },
        appendChild: (child) => {
            scrollRegion.appendChild(child);
        },
    };
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (makeAboutDialog);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/image/EditorImage.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/image/EditorImage.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EditorImageEventType: () => (/* binding */ EditorImageEventType),
/* harmony export */   ImageNode: () => (/* binding */ ImageNode),
/* harmony export */   RootImageNode: () => (/* binding */ RootImageNode),
/* harmony export */   computeFirstIndexToRender: () => (/* binding */ computeFirstIndexToRender),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   sortLeavesByZIndex: () => (/* binding */ sortLeavesByZIndex)
/* harmony export */ });
/* harmony import */ var _Viewport_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Viewport.mjs */ "./node_modules/js-draw/dist/mjs/Viewport.mjs");
/* harmony import */ var _components_AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/AbstractComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/AbstractComponent.mjs");
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _commands_SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../commands/SerializableCommand.mjs */ "./node_modules/js-draw/dist/mjs/commands/SerializableCommand.mjs");
/* harmony import */ var _EventDispatcher_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../EventDispatcher.mjs */ "./node_modules/js-draw/dist/mjs/EventDispatcher.mjs");
/* harmony import */ var _util_assertions_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/assertions.mjs */ "./node_modules/js-draw/dist/mjs/util/assertions.mjs");
/* harmony import */ var _commands_Command_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../commands/Command.mjs */ "./node_modules/js-draw/dist/mjs/commands/Command.mjs");
var __setFunctionName = (undefined && undefined.__setFunctionName) || function (f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};
var _a, _b, _c;







// @internal Sort by z-index, low to high
const sortLeavesByZIndex = (leaves) => {
    leaves.sort((a, b) => a.getContent().getZIndex() - b.getContent().getZIndex());
};
var EditorImageEventType;
(function (EditorImageEventType) {
    EditorImageEventType[EditorImageEventType["ExportViewportChanged"] = 0] = "ExportViewportChanged";
    EditorImageEventType[EditorImageEventType["AutoresizeModeChanged"] = 1] = "AutoresizeModeChanged";
})(EditorImageEventType || (EditorImageEventType = {}));
let debugMode = false;
/**
 * @summary Handles lookup/storage of elements in the image.
 *
 * `js-draw` images are made up of a collection of {@link AbstractComponent}s (which
 * includes {@link Stroke}s, {@link TextComponent}s, etc.). An `EditorImage`
 * is the data structure that stores these components.
 *
 * Here's how to do a few common operations:
 * - **Get all components in a {@link @js-draw/math!Rect2 | Rect2}**:
 *    {@link EditorImage.getElementsIntersectingRegion}.
 * - **Draw an `EditorImage` onto a canvas/SVG**: {@link EditorImage.render}.
 * - **Adding a new component**: {@link EditorImage.addElement}.
 *
 * **Example**:
 * [[include:doc-pages/inline-examples/image-add-and-lookup.md]]
 */
class EditorImage {
    // @internal
    constructor() {
        this.componentCount = 0;
        this.settingExportRect = false;
        this.root = new RootImageNode();
        this.background = new RootImageNode();
        this.componentsById = Object.create(null);
        this.notifier = new _EventDispatcher_mjs__WEBPACK_IMPORTED_MODULE_4__["default"]();
        this.importExportViewport = new _Viewport_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](() => {
            this.onExportViewportChanged();
        });
        // Default to a 500x500 image
        this.importExportViewport.updateScreenSize(_js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Vec2.of(500, 500));
        this.shouldAutoresizeExportViewport = false;
    }
    // Returns all components that make up the background of this image. These
    // components are rendered below all other components.
    getBackgroundComponents() {
        const result = [];
        const leaves = this.background.getLeaves();
        sortLeavesByZIndex(leaves);
        for (const leaf of leaves) {
            const content = leaf.getContent();
            if (content) {
                result.push(content);
            }
        }
        return result;
    }
    // Returns the parent of the given element, if it exists.
    findParent(elem) {
        return this.background.getChildWithContent(elem) ?? this.root.getChildWithContent(elem);
    }
    // Forces a re-render of `elem` when the image is next re-rendered as a whole.
    // Does nothing if `elem` is not in this.
    queueRerenderOf(elem) {
        // TODO: Make more efficient (e.g. increase IDs of all parents,
        // make cache take into account last modified time instead of IDs, etc.)
        const parent = this.findParent(elem);
        if (parent) {
            parent.remove();
            this.addElementDirectly(elem);
        }
    }
    /** @internal */
    renderWithCache(screenRenderer, cache, viewport) {
        this.background.render(screenRenderer, viewport.visibleRect);
        // If in debug mode, avoid rendering with cache to show additional debug information
        if (!debugMode) {
            cache.render(screenRenderer, this.root, viewport);
        }
        else {
            this.root.render(screenRenderer, viewport.visibleRect);
        }
    }
    /**
     * Renders this image to the given `renderer`.
     *
     * If `viewport` is non-null, only components that can be seen from that viewport
     * will be rendered. If `viewport` is `null`, **all** components are rendered.
     *
     * **Example**:
     * [[include:doc-pages/inline-examples/canvas-renderer.md]]
     */
    render(renderer, viewport) {
        this.background.render(renderer, viewport?.visibleRect);
        this.root.render(renderer, viewport?.visibleRect);
    }
    /**
     * Like {@link renderAll}, but can be stopped early and paused.
     *
     * **Note**: If the image is being edited during an async rendering, there is no
     * guarantee that all nodes will be rendered correctly (some may be missing).
     *
     * @internal
     */
    async renderAllAsync(renderer, preRenderComponent) {
        const stoppedEarly = !(await this.background.renderAllAsync(renderer, preRenderComponent));
        if (!stoppedEarly) {
            return await this.root.renderAllAsync(renderer, preRenderComponent);
        }
        return false;
    }
    /**
     * Renders all nodes, even ones not within the viewport.
     *
     * This can be slow for large images
     * @internal
     */
    renderAll(renderer) {
        this.render(renderer, null);
    }
    /**
     * @returns all elements in the image, sorted by z-index (low to high).
     *
     * This can be slow for large images. If you only need all elemenst in part of the image,
     * consider using {@link getElementsIntersectingRegion} instead.
     *
     * **Note**: The result does not include background elements. See {@link getBackgroundComponents}.
     */
    getAllElements() {
        const leaves = this.root.getLeaves();
        sortLeavesByZIndex(leaves);
        return leaves.map((leaf) => leaf.getContent());
    }
    /** Returns the number of elements added to this image. @internal */
    estimateNumElements() {
        return this.componentCount;
    }
    /**
     * @returns a list of `AbstractComponent`s intersecting `region`, sorted by increasing z-index.
     *
     * Components in the background layer are only included if `includeBackground` is `true`.
     */
    getElementsIntersectingRegion(region, includeBackground = false) {
        let leaves = this.root.getLeavesIntersectingRegion(region);
        if (includeBackground) {
            leaves = leaves.concat(this.background.getLeavesIntersectingRegion(region));
        }
        sortLeavesByZIndex(leaves);
        return leaves.map((leaf) => leaf.getContent());
    }
    /** Called whenever (just after) an element is completely removed. @internal */
    onDestroyElement(elem) {
        this.componentCount--;
        delete this.componentsById[elem.getId()];
        this.autoresizeExportViewport();
    }
    /** Called just after an element is added. @internal */
    onElementAdded(elem) {
        this.componentCount++;
        this.componentsById[elem.getId()] = elem;
        this.autoresizeExportViewport();
    }
    /**
     * @returns the AbstractComponent with `id`, if it exists.
     *
     * @see {@link AbstractComponent.getId}
     */
    lookupElement(id) {
        return this.componentsById[id] ?? null;
    }
    addElementDirectly(elem) {
        // Because onAddToImage can affect the element's bounding box,
        // this needs to be called before parentTree.addLeaf.
        elem.onAddToImage(this);
        // If a background component, add to the background. Else,
        // add to the normal component tree.
        const parentTree = elem.isBackground() ? this.background : this.root;
        const result = parentTree.addLeaf(elem);
        this.onElementAdded(elem);
        return result;
    }
    removeElementDirectly(element) {
        const container = this.findParent(element);
        container?.remove();
        if (container) {
            this.onDestroyElement(element);
            return true;
        }
        return false;
    }
    /**
     * Returns a command that adds the given element to the `EditorImage`.
     * If `applyByFlattening` is true, the content of the wet ink renderer is
     * rendered onto the main rendering canvas instead of doing a full re-render.
     *
     * @see {@link Display.flatten}
     *
     * **Example**:
     *
     * [[include:doc-pages/inline-examples/adding-a-stroke.md]]
     */
    static addElement(elem, applyByFlattening = false) {
        return new _a.AddElementCommand(elem, applyByFlattening);
    }
    /** @see EditorImage.addElement */
    addElement(elem, applyByFlattening) {
        return _a.addElement(elem, applyByFlattening);
    }
    /**
     * @returns a `Viewport` for rendering the image when importing/exporting.
     */
    getImportExportViewport() {
        return this.importExportViewport;
    }
    /**
     * @see {@link setImportExportRect}
     */
    getImportExportRect() {
        return this.getImportExportViewport().visibleRect;
    }
    /**
     * Sets the import/export rectangle to the given `imageRect`. Disables
     * autoresize if it was previously enabled.
     *
     * **Note**: The import/export rectangle is the same as the size of any
     * {@link BackgroundComponent}s (and other components that auto-resize).
     */
    setImportExportRect(imageRect) {
        return _a.SetImportExportRectCommand.of(this, imageRect, false);
    }
    /** @see {@link setAutoresizeEnabled} */
    getAutoresizeEnabled() {
        return this.shouldAutoresizeExportViewport;
    }
    /**
     * Returns a `Command` that sets whether the image should autoresize when
     * {@link AbstractComponent}s are added/removed.
     *
     * @example
     *
     * ```ts,runnable
     * import { Editor } from 'js-draw';
     *
     * const editor = new Editor(document.body);
     * const toolbar = editor.addToolbar();
     *
     * // Add a save button to demonstrate what the output looks like
     * // (it should change size to fit whatever was drawn)
     * toolbar.addSaveButton(() => {
     *   document.body.replaceChildren(editor.toSVG({ sanitize: true }));
     * });
     *
     * // Actually using setAutoresizeEnabled:
     * //
     * // To set autoresize without announcing for accessibility/making undoable
     * const addToHistory = false;
     * editor.dispatchNoAnnounce(editor.image.setAutoresizeEnabled(true), addToHistory);
     *
     * // Add to undo history **and** announce for accessibility
     * //editor.dispatch(editor.image.setAutoresizeEnabled(true), true);
     * ```
     */
    setAutoresizeEnabled(autoresize) {
        if (autoresize === this.shouldAutoresizeExportViewport) {
            return _commands_Command_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].empty;
        }
        const newBBox = this.root.getBBox();
        return _a.SetImportExportRectCommand.of(this, newBBox, autoresize);
    }
    setAutoresizeEnabledDirectly(shouldAutoresize) {
        if (shouldAutoresize !== this.shouldAutoresizeExportViewport) {
            this.shouldAutoresizeExportViewport = shouldAutoresize;
            this.notifier.dispatch(EditorImageEventType.AutoresizeModeChanged, {
                image: this,
            });
        }
    }
    /** Updates the size/position of the viewport */
    autoresizeExportViewport() {
        // Only autoresize if in autoresize mode -- otherwise resizing the image
        // should be done with undoable commands.
        if (this.shouldAutoresizeExportViewport) {
            this.setExportRectDirectly(this.root.getBBox());
        }
    }
    /**
     * Sets the import/export viewport directly, without returning a `Command`.
     * As such, this is not undoable.
     *
     * See setImportExportRect
     *
     * Returns true if changes to the viewport were made (and thus
     * ExportViewportChanged was fired.)
     */
    setExportRectDirectly(newRect) {
        const viewport = this.getImportExportViewport();
        const lastSize = viewport.getScreenRectSize();
        const lastTransform = viewport.canvasToScreenTransform;
        const newTransform = _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Mat33.translation(newRect.topLeft.times(-1));
        if (!lastSize.eq(newRect.size) || !lastTransform.eq(newTransform)) {
            // Prevent the ExportViewportChanged event from being fired
            // multiple times for the same viewport change: Set settingExportRect
            // to true.
            this.settingExportRect = true;
            viewport.updateScreenSize(newRect.size);
            viewport.resetTransform(newTransform);
            this.settingExportRect = false;
            this.onExportViewportChanged();
            return true;
        }
        return false;
    }
    onExportViewportChanged() {
        // Prevent firing duplicate events -- changes
        // made by exportViewport.resetTransform may cause this method to be
        // called.
        if (!this.settingExportRect) {
            this.notifier.dispatch(EditorImageEventType.ExportViewportChanged, {
                image: this,
            });
        }
    }
    /**
     * @internal
     *
     * Enables debug mode for **all** `EditorImage`s.
     *
     * **Only use for debugging**.
     *
     * @internal
     */
    static setDebugMode(newDebugMode) {
        debugMode = newDebugMode;
    }
}
_a = EditorImage;
// A Command that can access private [EditorImage] functionality
EditorImage.AddElementCommand = (_b = class extends _commands_SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
        // If [applyByFlattening], then the rendered content of this element
        // is present on the display's wet ink canvas. As such, no re-render is necessary
        // the first time this command is applied (the surfaces are joined instead).
        constructor(element, applyByFlattening = false) {
            super('add-element');
            this.element = element;
            this.applyByFlattening = applyByFlattening;
            this.serializedElem = null;
            // FIXME: The serialized version of this command may be inaccurate if this is
            //        serialized when this command is not on the top of the undo stack.
            //
            // Caching the element's serialized data leads to additional memory usage *and*
            // sometimes incorrect behavior in collaborative editing.
            this.serializedElem = null;
            if (isNaN(element.getBBox().area)) {
                throw new Error('Elements in the image cannot have NaN bounding boxes');
            }
        }
        apply(editor) {
            editor.image.addElementDirectly(this.element);
            if (!this.applyByFlattening) {
                editor.queueRerender();
            }
            else {
                this.applyByFlattening = false;
                editor.display.flatten();
            }
        }
        unapply(editor) {
            editor.image.removeElementDirectly(this.element);
            editor.queueRerender();
        }
        description(_editor, localization) {
            return localization.addElementAction(this.element.description(localization));
        }
        serializeToJSON() {
            return {
                elemData: this.serializedElem ?? this.element.serialize(),
            };
        }
    },
    __setFunctionName(_b, "AddElementCommand"),
    (() => {
        _commands_SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].register('add-element', (json, editor) => {
            const id = json.elemData.id;
            const foundElem = editor.image.lookupElement(id);
            const elem = foundElem ?? _components_AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].deserialize(json.elemData);
            const result = new _a.AddElementCommand(elem);
            result.serializedElem = json.elemData;
            return result;
        });
    })(),
    _b);
// Handles resizing the background import/export region of the image.
EditorImage.SetImportExportRectCommand = (_c = class extends _commands_SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
        constructor(originalSize, originalTransform, originalAutoresize, newExportRect, newAutoresize) {
            super(_a.SetImportExportRectCommand.commandId);
            this.originalSize = originalSize;
            this.originalTransform = originalTransform;
            this.originalAutoresize = originalAutoresize;
            this.newExportRect = newExportRect;
            this.newAutoresize = newAutoresize;
        }
        // Uses `image` to store the original size/transform
        static of(image, newExportRect, newAutoresize) {
            const importExportViewport = image.getImportExportViewport();
            const originalSize = importExportViewport.visibleRect.size;
            const originalTransform = importExportViewport.canvasToScreenTransform;
            const originalAutoresize = image.getAutoresizeEnabled();
            return new _a.SetImportExportRectCommand(originalSize, originalTransform, originalAutoresize, newExportRect, newAutoresize);
        }
        apply(editor) {
            editor.image.setAutoresizeEnabledDirectly(this.newAutoresize);
            editor.image.setExportRectDirectly(this.newExportRect);
            editor.queueRerender();
        }
        unapply(editor) {
            const viewport = editor.image.getImportExportViewport();
            editor.image.setAutoresizeEnabledDirectly(this.originalAutoresize);
            viewport.updateScreenSize(this.originalSize);
            viewport.resetTransform(this.originalTransform);
            editor.queueRerender();
        }
        description(_editor, localization) {
            if (this.newAutoresize !== this.originalAutoresize) {
                if (this.newAutoresize) {
                    return localization.enabledAutoresizeOutputCommand;
                }
                else {
                    return localization.disabledAutoresizeOutputCommand;
                }
            }
            return localization.resizeOutputCommand(this.newExportRect);
        }
        serializeToJSON() {
            return {
                originalSize: this.originalSize.xy,
                originalTransform: this.originalTransform.toArray(),
                newRegion: {
                    x: this.newExportRect.x,
                    y: this.newExportRect.y,
                    w: this.newExportRect.w,
                    h: this.newExportRect.h,
                },
                autoresize: this.newAutoresize,
                originalAutoresize: this.originalAutoresize,
            };
        }
    },
    __setFunctionName(_c, "SetImportExportRectCommand"),
    _c.commandId = 'set-import-export-rect',
    (() => {
        const commandId = _c.commandId;
        _commands_SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].register(commandId, (json, _editor) => {
            (0,_util_assertions_mjs__WEBPACK_IMPORTED_MODULE_5__.assertIsNumber)(json.originalSize.x);
            (0,_util_assertions_mjs__WEBPACK_IMPORTED_MODULE_5__.assertIsNumber)(json.originalSize.y);
            (0,_util_assertions_mjs__WEBPACK_IMPORTED_MODULE_5__.assertIsNumberArray)(json.originalTransform);
            (0,_util_assertions_mjs__WEBPACK_IMPORTED_MODULE_5__.assertIsNumberArray)([
                json.newRegion.x,
                json.newRegion.y,
                json.newRegion.w,
                json.newRegion.h,
            ]);
            (0,_util_assertions_mjs__WEBPACK_IMPORTED_MODULE_5__.assertIsBoolean)(json.autoresize ?? false);
            (0,_util_assertions_mjs__WEBPACK_IMPORTED_MODULE_5__.assertIsBoolean)(json.originalAutoresize ?? false);
            const originalSize = _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Vec2.ofXY(json.originalSize);
            const originalTransform = new _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Mat33(...json.originalTransform);
            const finalRect = new _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Rect2(json.newRegion.x, json.newRegion.y, json.newRegion.w, json.newRegion.h);
            const autoresize = json.autoresize ?? false;
            const originalAutoresize = json.originalAutoresize ?? false;
            return new _a.SetImportExportRectCommand(originalSize, originalTransform, originalAutoresize, finalRect, autoresize);
        });
    })(),
    _c);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EditorImage);
/**
 * Determines the first index in `sortedLeaves` that needs to be rendered
 * (based on occlusion -- everything before that index can be skipped and
 * produce a visually-equivalent image).
 *
 * Does nothing if visibleRect is not provided
 *
 * @internal
 */
const computeFirstIndexToRender = (sortedLeaves, visibleRect) => {
    let startIndex = 0;
    if (visibleRect) {
        for (let i = sortedLeaves.length - 1; i >= 1; i--) {
            if (
            // Check for occlusion
            sortedLeaves[i].getBBox().containsRect(visibleRect) &&
                sortedLeaves[i].getContent()?.occludesEverythingBelowWhenRenderedInRect(visibleRect)) {
                startIndex = i;
                break;
            }
        }
    }
    return startIndex;
};
/**
 * Part of the Editor's image. Does not handle fullscreen/invisible components.
 * @internal
 */
class ImageNode {
    constructor(parent = null) {
        this.parent = parent;
        this.targetChildCount = 30;
        this.children = [];
        this.bbox = _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Rect2.empty;
        this.content = null;
        this.id = ImageNode.idCounter++;
    }
    getId() {
        return this.id;
    }
    onContentChange() {
        this.id = ImageNode.idCounter++;
    }
    getContent() {
        return this.content;
    }
    getParent() {
        return this.parent;
    }
    // Override this to change how children are considered within a given region.
    getChildrenIntersectingRegion(region, isTooSmallFilter) {
        return this.children.filter((child) => {
            const bbox = child.getBBox();
            return !isTooSmallFilter?.(bbox) && bbox.intersects(region);
        });
    }
    getChildrenOrSelfIntersectingRegion(region, isTooSmall) {
        if (this.content && this.bbox.intersects(region) && !isTooSmall?.(this.bbox)) {
            return [this];
        }
        return this.getChildrenIntersectingRegion(region, isTooSmall);
    }
    /**
     * Returns a list of `ImageNode`s with content (and thus no children).
     * Override getChildrenIntersectingRegion to customize how this method
     * determines whether/which children are in `region`.
     *
     * @paran region - All resultant `ImageNode`s must intersect `region`.
     * @param isTooSmall - If `isTooSmall` returns true for an image node, that node
     *                     is excluded from the output.
     *
     */
    getLeavesIntersectingRegion(region, isTooSmall) {
        const result = [];
        const workList = [];
        workList.push(this);
        while (workList.length > 0) {
            const current = workList.pop();
            // Split the children into leaves and non-leaves
            const processed = current.getChildrenOrSelfIntersectingRegion(region, isTooSmall);
            for (const item of processed) {
                if (item.content) {
                    result.push(item);
                }
                else {
                    // Non-leaves need to be processed
                    workList.push(item);
                }
            }
        }
        return result;
    }
    // Returns the child of this with the target content or `null` if no
    // such child exists.
    //
    // Note: Relies on all children to have valid bounding boxes.
    getChildWithContent(target) {
        const candidates = this.getLeavesIntersectingRegion(target.getBBox());
        for (const candidate of candidates) {
            if (candidate.getContent() === target) {
                return candidate;
            }
        }
        return null;
    }
    // Returns a list of leaves with this as an ancestor.
    // Like getLeavesInRegion, but does not check whether ancestors are in a given rectangle
    getLeaves() {
        if (this.content) {
            return [this];
        }
        const result = [];
        for (const child of this.children) {
            result.push(...child.getLeaves());
        }
        return result;
    }
    addLeaf(leaf) {
        this.onContentChange();
        if (this.content === null && this.children.length === 0) {
            this.content = leaf;
            this.recomputeBBox(true);
            return this;
        }
        if (this.content !== null) {
            console.assert(this.children.length === 0);
            const contentNode = new ImageNode(this);
            contentNode.content = this.content;
            this.content = null;
            this.children.push(contentNode);
            contentNode.recomputeBBox(false);
        }
        // If this node is contained within the leaf, make this and the leaf
        // share a parent.
        const leafBBox = leaf.getBBox();
        if (leafBBox.containsRect(this.getBBox())) {
            const nodeForNewLeaf = new ImageNode(this);
            if (this.children.length < this.targetChildCount) {
                this.children.push(nodeForNewLeaf);
            }
            else {
                const nodeForChildren = new ImageNode(this);
                nodeForChildren.children = this.children;
                this.children = [nodeForNewLeaf, nodeForChildren];
                nodeForChildren.updateParents();
                nodeForChildren.recomputeBBox(true);
            }
            return nodeForNewLeaf.addLeaf(leaf);
        }
        const containingNodes = this.children.filter((child) => child.getBBox().containsRect(leafBBox));
        // Does the leaf already fit within one of the children?
        if (containingNodes.length > 0 && this.children.length >= this.targetChildCount) {
            // Sort the containers in ascending order by area
            containingNodes.sort((a, b) => a.getBBox().area - b.getBBox().area);
            // Choose the smallest child that contains the new element.
            const result = containingNodes[0].addLeaf(leaf);
            result.rebalance();
            return result;
        }
        const newNode = ImageNode.createLeafNode(this, leaf);
        this.children.push(newNode);
        newNode.recomputeBBox(true);
        if (this.children.length >= this.targetChildCount) {
            this.rebalance();
        }
        return newNode;
    }
    // Creates a new leaf node with the given content.
    // This only establishes the parent-child linking in one direction. Callers
    // must add the resultant node to the list of children manually.
    static createLeafNode(parent, content) {
        const newNode = new ImageNode(parent);
        newNode.content = content;
        return newNode;
    }
    getBBox() {
        return this.bbox;
    }
    // Recomputes this' bounding box. If [bubbleUp], also recompute
    // this' ancestors bounding boxes. This also re-computes this' bounding box
    // in the z-direction (z-indicies).
    recomputeBBox(bubbleUp) {
        const oldBBox = this.bbox;
        if (this.content !== null) {
            this.bbox = this.content.getBBox();
        }
        else {
            this.bbox = _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Rect2.union(...this.children.map((child) => child.getBBox()));
        }
        if (bubbleUp && !oldBBox.eq(this.bbox)) {
            if (this.bbox.containsRect(oldBBox)) {
                this.parent?.unionBBoxWith(this.bbox);
            }
            else {
                this.parent?.recomputeBBox(true);
            }
        }
        this.checkRep();
    }
    // Grows this' bounding box to also include `other`.
    // Always bubbles up.
    unionBBoxWith(other) {
        this.bbox = this.bbox.union(other);
        this.parent?.unionBBoxWith(other);
    }
    updateParents(recursive = false) {
        for (const child of this.children) {
            child.parent = this;
            if (recursive) {
                child.updateParents(recursive);
            }
        }
    }
    rebalance() {
        // If the current node is its parent's only child,
        if (this.parent && this.parent.children.length === 1) {
            console.assert(this.parent.content === null);
            console.assert(this.parent.children[0] === this);
            // Remove this' parent, if this' parent isn't the root.
            const oldParent = this.parent;
            if (oldParent.parent !== null) {
                const newParent = oldParent.parent;
                newParent.children = newParent.children.filter((c) => c !== oldParent);
                oldParent.parent = null;
                oldParent.children = [];
                this.parent = newParent;
                newParent.children.push(this);
                this.parent.recomputeBBox(false);
            }
            else if (this.content === null) {
                // Remove this and transfer this' children to the parent.
                this.parent.children = this.children;
                this.parent.updateParents();
                this.parent = null;
            }
        }
        // Create virtual containers for children. Handles the case where there
        // are many small, often non-overlapping children that we still want to be grouped.
        if (this.children.length > this.targetChildCount * 10) {
            const grid = this.getBBox().divideIntoGrid(4, 4);
            const indexToCount = [];
            while (indexToCount.length < grid.length) {
                indexToCount.push(0);
            }
            for (const child of this.children) {
                for (let i = 0; i < grid.length; i++) {
                    if (grid[i].containsRect(child.getBBox())) {
                        indexToCount[i]++;
                    }
                }
            }
            let indexWithGreatest = 0;
            let greatestCount = indexToCount[0];
            for (let i = 1; i < indexToCount.length; i++) {
                if (indexToCount[i] > greatestCount) {
                    indexWithGreatest = i;
                    greatestCount = indexToCount[i];
                }
            }
            const targetGridSquare = grid[indexWithGreatest];
            // Avoid clustering if just a few children would be grouped.
            // Unnecessary clustering can lead to unnecessarily nested nodes.
            if (greatestCount > 4) {
                const newChildren = [];
                const childNodeChildren = [];
                for (const child of this.children) {
                    if (targetGridSquare.containsRect(child.getBBox())) {
                        childNodeChildren.push(child);
                    }
                    else {
                        newChildren.push(child);
                    }
                }
                if (childNodeChildren.length < this.children.length) {
                    this.children = newChildren;
                    const child = new ImageNode(this);
                    this.children.push(child);
                    child.children = childNodeChildren;
                    child.updateParents(false);
                    child.recomputeBBox(false);
                    child.rebalance();
                }
            }
        }
        // Empty?
        if (this.parent && this.children.length === 0 && this.content === null) {
            this.remove();
        }
    }
    // Removes the parent-to-child link.
    // Called internally by `.remove`
    removeChild(child) {
        this.checkRep();
        const oldChildCount = this.children.length;
        this.children = this.children.filter((node) => {
            return node !== child;
        });
        console.assert(this.children.length === oldChildCount - 1, `${oldChildCount - 1} ≠ ${this.children.length} after removing all nodes equal to ${child}. Nodes should only be removed once.`);
        this.children.forEach((child) => {
            child.rebalance();
        });
        this.recomputeBBox(true);
        this.rebalance();
        this.checkRep();
    }
    // Remove this node and all of its children
    remove() {
        this.content?.onRemoveFromImage();
        if (!this.parent) {
            this.content = null;
            this.children = [];
            return;
        }
        this.parent.removeChild(this);
        // Remove the child-to-parent link and invalid this
        this.parent = null;
        this.content = null;
        this.children = [];
        this.checkRep();
    }
    // Creates a (potentially incomplete) async rendering of this image.
    // Returns false if stopped early
    async renderAllAsync(renderer, 
    // Used to pause/stop the renderer process
    preRenderComponent) {
        const leaves = this.getLeaves();
        sortLeavesByZIndex(leaves);
        const totalLeaves = leaves.length;
        for (let leafIndex = 0; leafIndex < totalLeaves; leafIndex++) {
            const leaf = leaves[leafIndex];
            const component = leaf.getContent();
            // Even though leaf was originally a leaf, it might not be any longer --
            // rendering is async and the tree can change during that time.
            if (!component) {
                continue;
            }
            const shouldContinue = await preRenderComponent(component, leafIndex, totalLeaves);
            if (!shouldContinue) {
                return false;
            }
            component.render(renderer, undefined);
        }
        return true;
    }
    render(renderer, visibleRect) {
        let leaves;
        if (visibleRect) {
            leaves = this.getLeavesIntersectingRegion(visibleRect, (rect) => renderer.isTooSmallToRender(rect));
        }
        else {
            leaves = this.getLeaves();
        }
        sortLeavesByZIndex(leaves);
        // If some components hide others (and we're permitted to simplify,
        // which is true in the case of visibleRect being defined), then only
        // draw the non-hidden components:
        const startIndex = computeFirstIndexToRender(leaves);
        for (let i = startIndex; i < leaves.length; i++) {
            const leaf = leaves[i];
            // Leaves by definition have content
            leaf.getContent().render(renderer, visibleRect);
        }
        // Show debug information
        if (debugMode && visibleRect) {
            if (startIndex !== 0) {
                console.log('EditorImage: skipped ', startIndex, 'nodes due to occlusion');
            }
            this.renderDebugBoundingBoxes(renderer, visibleRect);
        }
    }
    // Debug only: Shows bounding boxes of this and all children.
    renderDebugBoundingBoxes(renderer, visibleRect, depth = 0) {
        const bbox = this.getBBox();
        const pixelSize = 1 / (renderer.getSizeOfCanvasPixelOnScreen() || 1);
        if (bbox.maxDimension < 3 * pixelSize || !bbox.intersects(visibleRect)) {
            return;
        }
        // Render debug information for this
        renderer.startObject(bbox);
        // Different styling for leaf nodes
        const isLeaf = !!this.content;
        const fill = isLeaf ? _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Color4.ofRGBA(1, 0, 1, 0.4) : _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Color4.ofRGBA(0, 1, Math.sin(depth), 0.6);
        const lineWidth = isLeaf ? 1 * pixelSize : 2 * pixelSize;
        renderer.drawRect(bbox.intersection(visibleRect), lineWidth, { fill });
        renderer.endObject();
        if (bbox.maxDimension > visibleRect.maxDimension / 3) {
            const textStyle = {
                fontFamily: 'monospace',
                size: bbox.minDimension / 20,
                renderingStyle: { fill: _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Color4.red },
            };
            renderer.drawText(`Depth: ${depth}`, _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Mat33.translation(bbox.bottomLeft), textStyle);
        }
        // Render debug information for children
        for (const child of this.children) {
            child.renderDebugBoundingBoxes(renderer, visibleRect, depth + 1);
        }
    }
    checkRep(depth = 0) {
        // Slow -- disabld by default
        if (debugMode) {
            if (this.parent && !this.parent.children.includes(this)) {
                throw new Error(`Parent does not have this node as a child. (depth: ${depth})`);
            }
            let expectedBBox = null;
            const seenChildren = new Set();
            for (const child of this.children) {
                expectedBBox ??= child.getBBox();
                expectedBBox = expectedBBox.union(child.getBBox());
                if (child.parent !== this) {
                    throw new Error(`Child with bbox ${child.getBBox()} and ${child.children.length} has wrong parent (was ${child.parent}).`);
                }
                // Children should only be present once
                if (seenChildren.has(child)) {
                    throw new Error(`Child ${child} is present twice or more in its parent's child list`);
                }
                seenChildren.add(child);
            }
            const tolerance = this.bbox.minDimension / 100;
            if (expectedBBox && !this.bbox.eq(expectedBBox, tolerance)) {
                throw new Error(`Wrong bounding box ${expectedBBox} \\neq ${this.bbox} (depth: ${depth})`);
            }
        }
    }
}
ImageNode.idCounter = 0;
/** An `ImageNode` that can properly handle fullscreen/data components. @internal */
class RootImageNode extends ImageNode {
    constructor() {
        super(...arguments);
        // Nodes that will always take up the entire screen
        this.fullscreenChildren = [];
        // Nodes that will never be visible unless a full render is done.
        this.dataComponents = [];
    }
    getChildrenIntersectingRegion(region, _isTooSmall) {
        const result = super.getChildrenIntersectingRegion(region);
        for (const node of this.fullscreenChildren) {
            result.push(node);
        }
        return result;
    }
    getChildrenOrSelfIntersectingRegion(region, _isTooSmall) {
        const content = this.getContent();
        // Fullscreen components always intersect/contain
        if (content && content.getSizingMode() === _components_AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_1__.ComponentSizingMode.FillScreen) {
            return [this];
        }
        return super.getChildrenOrSelfIntersectingRegion(region, _isTooSmall);
    }
    getLeaves() {
        const leaves = super.getLeaves();
        // Add fullscreen/data components — this method should
        // return *all* leaves.
        return this.dataComponents.concat(this.fullscreenChildren, leaves);
    }
    removeChild(child) {
        let removed = false;
        const checkTargetChild = (component) => {
            const isTarget = component === child;
            removed ||= isTarget;
            return !isTarget;
        };
        // Check whether the child is stored in the data/fullscreen
        // component arrays first.
        this.dataComponents = this.dataComponents.filter(checkTargetChild);
        this.fullscreenChildren = this.fullscreenChildren.filter(checkTargetChild);
        if (!removed) {
            super.removeChild(child);
        }
    }
    getChildWithContent(target) {
        const searchExtendedChildren = () => {
            // Search through all extended children
            const candidates = this.fullscreenChildren.concat(this.dataComponents);
            for (const candidate of candidates) {
                if (candidate.getContent() === target) {
                    return candidate;
                }
            }
            return null;
        };
        // If positioned as if a standard child, search using the superclass first.
        // Because it could be mislabeled, also search the extended children if the superclass
        // search fails.
        if (target.getSizingMode() === _components_AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_1__.ComponentSizingMode.BoundingBox) {
            return super.getChildWithContent(target) ?? searchExtendedChildren();
        }
        // Fall back to the superclass -- it's possible that the component has
        // changed labels.
        return super.getChildWithContent(target) ?? searchExtendedChildren();
    }
    addLeaf(leafContent) {
        const sizingMode = leafContent.getSizingMode();
        if (sizingMode === _components_AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_1__.ComponentSizingMode.BoundingBox) {
            return super.addLeaf(leafContent);
        }
        else if (sizingMode === _components_AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_1__.ComponentSizingMode.FillScreen) {
            this.onContentChange();
            const newNode = ImageNode.createLeafNode(this, leafContent);
            this.fullscreenChildren.push(newNode);
            return newNode;
        }
        else if (sizingMode === _components_AbstractComponent_mjs__WEBPACK_IMPORTED_MODULE_1__.ComponentSizingMode.Anywhere) {
            this.onContentChange();
            const newNode = ImageNode.createLeafNode(this, leafContent);
            this.dataComponents.push(newNode);
            return newNode;
        }
        else {
            const exhaustivenessCheck = sizingMode;
            throw new Error(`Invalid sizing mode, ${sizingMode}`);
            return exhaustivenessCheck;
        }
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/image/export/adjustExportedSVGSize.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/image/export/adjustExportedSVGSize.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");

// @internal
const adjustExportedSVGSize = (svg, exportRect, options) => {
    // Adjust the width/height as necessary
    let width = exportRect.w;
    let height = exportRect.h;
    if (options?.minDimension && width < options.minDimension) {
        const newWidth = options.minDimension;
        height *= newWidth / (width || 1);
        width = newWidth;
    }
    if (options?.minDimension && height < options.minDimension) {
        const newHeight = options.minDimension;
        width *= newHeight / (height || 1);
        height = newHeight;
    }
    svg.setAttribute('width', (0,_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.toRoundedString)(width));
    svg.setAttribute('height', (0,_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.toRoundedString)(height));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (adjustExportedSVGSize);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/image/export/editorImageToSVG.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/image/export/editorImageToSVG.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   editorImageToSVGAsync: () => (/* binding */ editorImageToSVGAsync),
/* harmony export */   editorImageToSVGSync: () => (/* binding */ editorImageToSVGSync)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _rendering_renderers_SVGRenderer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../rendering/renderers/SVGRenderer.mjs */ "./node_modules/js-draw/dist/mjs/rendering/renderers/SVGRenderer.mjs");
/* harmony import */ var _SVGLoader_SVGLoader_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../SVGLoader/SVGLoader.mjs */ "./node_modules/js-draw/dist/mjs/SVGLoader/SVGLoader.mjs");
/* harmony import */ var _adjustExportedSVGSize_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./adjustExportedSVGSize.mjs */ "./node_modules/js-draw/dist/mjs/image/export/adjustExportedSVGSize.mjs");




const toSVGInternal = (image, renderFunction, options) => {
    const importExportViewport = image.getImportExportViewport().getTemporaryClone();
    // If the rectangle has zero width or height, its size can't be increased
    // -- set its size to the minimum.
    if (options?.minDimension) {
        const originalRect = importExportViewport.visibleRect;
        let rect = originalRect;
        if (rect.w <= 0) {
            rect = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2(rect.x, rect.y, options.minDimension, rect.h);
        }
        if (rect.h <= 0) {
            rect = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2(rect.x, rect.y, rect.w, options.minDimension);
        }
        if (!rect.eq(originalRect)) {
            importExportViewport.updateScreenSize(rect.size);
        }
    }
    const { element: result, renderer } = _rendering_renderers_SVGRenderer_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].fromViewport(importExportViewport, {
        sanitize: options.sanitize ?? false,
        useViewBoxForPositioning: true,
    });
    // Use a callback rather than async/await to allow this function to create
    // both sync and async render functions
    renderFunction(renderer, () => {
        if (image.getAutoresizeEnabled()) {
            result.classList.add(_SVGLoader_SVGLoader_mjs__WEBPACK_IMPORTED_MODULE_2__.svgLoaderAutoresizeClassName);
        }
        else {
            result.classList.remove(_SVGLoader_SVGLoader_mjs__WEBPACK_IMPORTED_MODULE_2__.svgLoaderAutoresizeClassName);
        }
        const exportRect = importExportViewport.visibleRect;
        (0,_adjustExportedSVGSize_mjs__WEBPACK_IMPORTED_MODULE_3__["default"])(result, exportRect, options);
        return result;
    });
    return result;
};
const editorImageToSVGSync = (image, options) => {
    return toSVGInternal(image, (renderer, onComplete) => {
        image.renderAll(renderer);
        onComplete();
    }, options);
};
const editorImageToSVGAsync = (image, preRenderComponent, options) => {
    return new Promise((resolve) => {
        toSVGInternal(image, async (renderer, onComplete) => {
            await image.renderAllAsync(renderer, preRenderComponent);
            const result = onComplete();
            resolve(result);
        }, options);
    });
};


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/image/lib.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/image/lib.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EditorImage: () => (/* reexport safe */ _EditorImage_mjs__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _EditorImage_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditorImage.mjs */ "./node_modules/js-draw/dist/mjs/image/EditorImage.mjs");



/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/inputEvents.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/inputEvents.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InputEvtType: () => (/* binding */ InputEvtType),
/* harmony export */   isPointerEvt: () => (/* binding */ isPointerEvt),
/* harmony export */   keyPressEventFromHTMLEvent: () => (/* binding */ keyPressEventFromHTMLEvent),
/* harmony export */   keyUpEventFromHTMLEvent: () => (/* binding */ keyUpEventFromHTMLEvent)
/* harmony export */ });
var InputEvtType;
(function (InputEvtType) {
    InputEvtType[InputEvtType["PointerDownEvt"] = 0] = "PointerDownEvt";
    InputEvtType[InputEvtType["PointerMoveEvt"] = 1] = "PointerMoveEvt";
    InputEvtType[InputEvtType["PointerUpEvt"] = 2] = "PointerUpEvt";
    InputEvtType[InputEvtType["GestureCancelEvt"] = 3] = "GestureCancelEvt";
    InputEvtType[InputEvtType["WheelEvt"] = 4] = "WheelEvt";
    InputEvtType[InputEvtType["KeyPressEvent"] = 5] = "KeyPressEvent";
    InputEvtType[InputEvtType["KeyUpEvent"] = 6] = "KeyUpEvent";
    InputEvtType[InputEvtType["CopyEvent"] = 7] = "CopyEvent";
    InputEvtType[InputEvtType["PasteEvent"] = 8] = "PasteEvent";
    InputEvtType[InputEvtType["ContextMenu"] = 9] = "ContextMenu";
})(InputEvtType || (InputEvtType = {}));
// Constructor
const keyEventFromHTMLEvent = (kind, event) => {
    return {
        kind,
        key: event.key,
        code: event.code,
        ctrlKey: event.ctrlKey || event.metaKey,
        altKey: event.altKey,
        shiftKey: event.shiftKey,
    };
};
const keyUpEventFromHTMLEvent = (event) => {
    return keyEventFromHTMLEvent(InputEvtType.KeyUpEvent, event);
};
const keyPressEventFromHTMLEvent = (event) => {
    return keyEventFromHTMLEvent(InputEvtType.KeyPressEvent, event);
};
const isPointerEvt = (event) => {
    return (event.kind === InputEvtType.PointerDownEvt ||
        event.kind === InputEvtType.PointerMoveEvt ||
        event.kind === InputEvtType.PointerUpEvt);
};


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/lib.mjs":
/*!***********************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/lib.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Abstract2DShape: () => (/* reexport safe */ _js_draw_math__WEBPACK_IMPORTED_MODULE_8__.Abstract2DShape),
/* harmony export */   AbstractComponent: () => (/* reexport safe */ _components_lib_mjs__WEBPACK_IMPORTED_MODULE_9__.AbstractComponent),
/* harmony export */   AbstractRenderer: () => (/* reexport safe */ _rendering_lib_mjs__WEBPACK_IMPORTED_MODULE_13__.AbstractRenderer),
/* harmony export */   AbstractToolbar: () => (/* reexport safe */ _toolbar_AbstractToolbar_mjs__WEBPACK_IMPORTED_MODULE_21__["default"]),
/* harmony export */   ActionButtonWidget: () => (/* reexport safe */ _toolbar_lib_mjs__WEBPACK_IMPORTED_MODULE_12__.ActionButtonWidget),
/* harmony export */   BackgroundComponent: () => (/* reexport safe */ _components_lib_mjs__WEBPACK_IMPORTED_MODULE_9__.BackgroundComponent),
/* harmony export */   BackgroundComponentBackgroundType: () => (/* reexport safe */ _components_lib_mjs__WEBPACK_IMPORTED_MODULE_9__.BackgroundComponentBackgroundType),
/* harmony export */   BaseTool: () => (/* reexport safe */ _tools_lib_mjs__WEBPACK_IMPORTED_MODULE_11__.BaseTool),
/* harmony export */   BaseToolWidget: () => (/* reexport safe */ _toolbar_lib_mjs__WEBPACK_IMPORTED_MODULE_12__.BaseToolWidget),
/* harmony export */   BaseWidget: () => (/* reexport safe */ _toolbar_lib_mjs__WEBPACK_IMPORTED_MODULE_12__.BaseWidget),
/* harmony export */   CanvasRenderer: () => (/* reexport safe */ _rendering_lib_mjs__WEBPACK_IMPORTED_MODULE_13__.CanvasRenderer),
/* harmony export */   Color4: () => (/* reexport safe */ _js_draw_math__WEBPACK_IMPORTED_MODULE_8__.Color4),
/* harmony export */   Command: () => (/* reexport safe */ _commands_lib_mjs__WEBPACK_IMPORTED_MODULE_10__.Command),
/* harmony export */   ComponentSizingMode: () => (/* reexport safe */ _components_lib_mjs__WEBPACK_IMPORTED_MODULE_9__.ComponentSizingMode),
/* harmony export */   Display: () => (/* reexport safe */ _rendering_lib_mjs__WEBPACK_IMPORTED_MODULE_13__.Display),
/* harmony export */   DocumentPropertiesWidget: () => (/* reexport safe */ _toolbar_lib_mjs__WEBPACK_IMPORTED_MODULE_12__.DocumentPropertiesWidget),
/* harmony export */   DummyRenderer: () => (/* reexport safe */ _rendering_lib_mjs__WEBPACK_IMPORTED_MODULE_13__.DummyRenderer),
/* harmony export */   Duplicate: () => (/* reexport safe */ _commands_lib_mjs__WEBPACK_IMPORTED_MODULE_10__.Duplicate),
/* harmony export */   Editor: () => (/* reexport safe */ _Editor_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   EditorEventType: () => (/* reexport safe */ _types_mjs__WEBPACK_IMPORTED_MODULE_2__.EditorEventType),
/* harmony export */   EditorImage: () => (/* reexport safe */ _image_lib_mjs__WEBPACK_IMPORTED_MODULE_1__.EditorImage),
/* harmony export */   Erase: () => (/* reexport safe */ _commands_lib_mjs__WEBPACK_IMPORTED_MODULE_10__.Erase),
/* harmony export */   EraserMode: () => (/* reexport safe */ _tools_lib_mjs__WEBPACK_IMPORTED_MODULE_11__.EraserMode),
/* harmony export */   EraserTool: () => (/* reexport safe */ _tools_lib_mjs__WEBPACK_IMPORTED_MODULE_11__.EraserTool),
/* harmony export */   EraserToolWidget: () => (/* reexport safe */ _toolbar_lib_mjs__WEBPACK_IMPORTED_MODULE_12__.EraserToolWidget),
/* harmony export */   EventDispatcher: () => (/* reexport safe */ _EventDispatcher_mjs__WEBPACK_IMPORTED_MODULE_16__["default"]),
/* harmony export */   HTMLToolbar: () => (/* reexport safe */ _toolbar_AbstractToolbar_mjs__WEBPACK_IMPORTED_MODULE_21__["default"]),
/* harmony export */   HandToolWidget: () => (/* reexport safe */ _toolbar_lib_mjs__WEBPACK_IMPORTED_MODULE_12__.HandToolWidget),
/* harmony export */   IconProvider: () => (/* reexport safe */ _toolbar_lib_mjs__WEBPACK_IMPORTED_MODULE_12__.IconProvider),
/* harmony export */   ImageComponent: () => (/* reexport safe */ _components_lib_mjs__WEBPACK_IMPORTED_MODULE_9__.ImageComponent),
/* harmony export */   InputEvtType: () => (/* reexport safe */ _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_3__.InputEvtType),
/* harmony export */   InputMapper: () => (/* reexport safe */ _tools_lib_mjs__WEBPACK_IMPORTED_MODULE_11__.InputMapper),
/* harmony export */   InsertImageWidget: () => (/* reexport safe */ _toolbar_lib_mjs__WEBPACK_IMPORTED_MODULE_12__.InsertImageWidget),
/* harmony export */   KeyBinding: () => (/* reexport safe */ _shortcuts_lib_mjs__WEBPACK_IMPORTED_MODULE_15__.KeyBinding),
/* harmony export */   KeyboardShortcutManager: () => (/* reexport safe */ _shortcuts_lib_mjs__WEBPACK_IMPORTED_MODULE_15__.KeyboardShortcutManager),
/* harmony export */   LineSegment2: () => (/* reexport safe */ _js_draw_math__WEBPACK_IMPORTED_MODULE_8__.LineSegment2),
/* harmony export */   Mat33: () => (/* reexport safe */ _js_draw_math__WEBPACK_IMPORTED_MODULE_8__.Mat33),
/* harmony export */   MutableReactiveValue: () => (/* reexport safe */ _util_lib_mjs__WEBPACK_IMPORTED_MODULE_19__.MutableReactiveValue),
/* harmony export */   PanZoomMode: () => (/* reexport safe */ _tools_lib_mjs__WEBPACK_IMPORTED_MODULE_11__.PanZoomMode),
/* harmony export */   PanZoomTool: () => (/* reexport safe */ _tools_lib_mjs__WEBPACK_IMPORTED_MODULE_11__.PanZoomTool),
/* harmony export */   Parameterized2DShape: () => (/* reexport safe */ _js_draw_math__WEBPACK_IMPORTED_MODULE_8__.Parameterized2DShape),
/* harmony export */   PasteHandler: () => (/* reexport safe */ _tools_lib_mjs__WEBPACK_IMPORTED_MODULE_11__.PasteHandler),
/* harmony export */   Path: () => (/* reexport safe */ _js_draw_math__WEBPACK_IMPORTED_MODULE_8__.Path),
/* harmony export */   PathCommandType: () => (/* reexport safe */ _js_draw_math__WEBPACK_IMPORTED_MODULE_8__.PathCommandType),
/* harmony export */   PenTool: () => (/* reexport safe */ _tools_lib_mjs__WEBPACK_IMPORTED_MODULE_11__.PenTool),
/* harmony export */   PenToolWidget: () => (/* reexport safe */ _toolbar_lib_mjs__WEBPACK_IMPORTED_MODULE_12__.PenToolWidget),
/* harmony export */   Pointer: () => (/* reexport safe */ _Pointer_mjs__WEBPACK_IMPORTED_MODULE_17__["default"]),
/* harmony export */   PointerDevice: () => (/* reexport safe */ _Pointer_mjs__WEBPACK_IMPORTED_MODULE_17__.PointerDevice),
/* harmony export */   QuadraticBezier: () => (/* reexport safe */ _js_draw_math__WEBPACK_IMPORTED_MODULE_8__.QuadraticBezier),
/* harmony export */   ReactiveValue: () => (/* reexport safe */ _util_lib_mjs__WEBPACK_IMPORTED_MODULE_19__.ReactiveValue),
/* harmony export */   Rect2: () => (/* reexport safe */ _js_draw_math__WEBPACK_IMPORTED_MODULE_8__.Rect2),
/* harmony export */   RenderingMode: () => (/* reexport safe */ _rendering_lib_mjs__WEBPACK_IMPORTED_MODULE_13__.RenderingMode),
/* harmony export */   SVGLoader: () => (/* reexport safe */ _SVGLoader_SVGLoader_mjs__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   SVGRenderer: () => (/* reexport safe */ _rendering_lib_mjs__WEBPACK_IMPORTED_MODULE_13__.SVGRenderer),
/* harmony export */   SelectAllShortcutHandler: () => (/* reexport safe */ _tools_lib_mjs__WEBPACK_IMPORTED_MODULE_11__.SelectAllShortcutHandler),
/* harmony export */   SelectionTool: () => (/* reexport safe */ _tools_lib_mjs__WEBPACK_IMPORTED_MODULE_11__.SelectionTool),
/* harmony export */   SelectionToolWidget: () => (/* reexport safe */ _toolbar_lib_mjs__WEBPACK_IMPORTED_MODULE_12__.SelectionToolWidget),
/* harmony export */   SerializableCommand: () => (/* reexport safe */ _commands_lib_mjs__WEBPACK_IMPORTED_MODULE_10__.SerializableCommand),
/* harmony export */   SoundUITool: () => (/* reexport safe */ _tools_lib_mjs__WEBPACK_IMPORTED_MODULE_11__.SoundUITool),
/* harmony export */   Stroke: () => (/* reexport safe */ _components_lib_mjs__WEBPACK_IMPORTED_MODULE_9__.Stroke),
/* harmony export */   StrokeComponent: () => (/* reexport safe */ _components_lib_mjs__WEBPACK_IMPORTED_MODULE_9__.StrokeComponent),
/* harmony export */   StrokeSmoother: () => (/* reexport safe */ _components_lib_mjs__WEBPACK_IMPORTED_MODULE_9__.StrokeSmoother),
/* harmony export */   Text: () => (/* reexport safe */ _components_lib_mjs__WEBPACK_IMPORTED_MODULE_9__.Text),
/* harmony export */   TextComponent: () => (/* reexport safe */ _components_lib_mjs__WEBPACK_IMPORTED_MODULE_9__.TextComponent),
/* harmony export */   TextTool: () => (/* reexport safe */ _tools_lib_mjs__WEBPACK_IMPORTED_MODULE_11__.TextTool),
/* harmony export */   TextToolWidget: () => (/* reexport safe */ _toolbar_lib_mjs__WEBPACK_IMPORTED_MODULE_12__.TextToolWidget),
/* harmony export */   ToolController: () => (/* reexport safe */ _tools_lib_mjs__WEBPACK_IMPORTED_MODULE_11__.ToolController),
/* harmony export */   ToolEnabledGroup: () => (/* reexport safe */ _tools_lib_mjs__WEBPACK_IMPORTED_MODULE_11__.ToolEnabledGroup),
/* harmony export */   ToolSwitcherShortcut: () => (/* reexport safe */ _tools_lib_mjs__WEBPACK_IMPORTED_MODULE_11__.ToolSwitcherShortcut),
/* harmony export */   ToolbarShortcutHandler: () => (/* reexport safe */ _tools_lib_mjs__WEBPACK_IMPORTED_MODULE_11__.ToolbarShortcutHandler),
/* harmony export */   ToolbarWidgetTag: () => (/* reexport safe */ _toolbar_lib_mjs__WEBPACK_IMPORTED_MODULE_12__.ToolbarWidgetTag),
/* harmony export */   UndoEventType: () => (/* reexport safe */ _types_mjs__WEBPACK_IMPORTED_MODULE_2__.UndoEventType),
/* harmony export */   UndoRedoHistory: () => (/* reexport safe */ _UndoRedoHistory_mjs__WEBPACK_IMPORTED_MODULE_18__["default"]),
/* harmony export */   UndoRedoShortcut: () => (/* reexport safe */ _tools_lib_mjs__WEBPACK_IMPORTED_MODULE_11__.UndoRedoShortcut),
/* harmony export */   Vec2: () => (/* reexport safe */ _js_draw_math__WEBPACK_IMPORTED_MODULE_8__.Vec2),
/* harmony export */   Vec3: () => (/* reexport safe */ _js_draw_math__WEBPACK_IMPORTED_MODULE_8__.Vec3),
/* harmony export */   Viewport: () => (/* reexport safe */ _Viewport_mjs__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   __js_draw__version: () => (/* reexport safe */ _version_mjs__WEBPACK_IMPORTED_MODULE_20__["default"]),
/* harmony export */   adjustEditorThemeForContrast: () => (/* reexport safe */ _util_lib_mjs__WEBPACK_IMPORTED_MODULE_19__.adjustEditorThemeForContrast),
/* harmony export */   comparePathIndices: () => (/* reexport safe */ _js_draw_math__WEBPACK_IMPORTED_MODULE_8__.comparePathIndices),
/* harmony export */   createRestyleComponentCommand: () => (/* reexport safe */ _components_lib_mjs__WEBPACK_IMPORTED_MODULE_9__.createRestyleComponentCommand),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultEditorLocalization: () => (/* reexport safe */ _localization_mjs__WEBPACK_IMPORTED_MODULE_5__.defaultEditorLocalization),
/* harmony export */   getLocalizationTable: () => (/* reexport safe */ _localizations_getLocalizationTable_mjs__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   invertCommand: () => (/* reexport safe */ _commands_lib_mjs__WEBPACK_IMPORTED_MODULE_10__.invertCommand),
/* harmony export */   isPointerEvt: () => (/* reexport safe */ _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_3__.isPointerEvt),
/* harmony export */   isRestylableComponent: () => (/* reexport safe */ _components_lib_mjs__WEBPACK_IMPORTED_MODULE_9__.isRestylableComponent),
/* harmony export */   keyPressEventFromHTMLEvent: () => (/* reexport safe */ _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_3__.keyPressEventFromHTMLEvent),
/* harmony export */   keyUpEventFromHTMLEvent: () => (/* reexport safe */ _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_3__.keyUpEventFromHTMLEvent),
/* harmony export */   makeArrowBuilder: () => (/* reexport safe */ _components_lib_mjs__WEBPACK_IMPORTED_MODULE_9__.makeArrowBuilder),
/* harmony export */   makeColorInput: () => (/* reexport safe */ _toolbar_lib_mjs__WEBPACK_IMPORTED_MODULE_12__.makeColorInput),
/* harmony export */   makeDropdownToolbar: () => (/* reexport safe */ _toolbar_lib_mjs__WEBPACK_IMPORTED_MODULE_12__.makeDropdownToolbar),
/* harmony export */   makeEdgeToolbar: () => (/* reexport safe */ _toolbar_lib_mjs__WEBPACK_IMPORTED_MODULE_12__.makeEdgeToolbar),
/* harmony export */   makeFilledRectangleBuilder: () => (/* reexport safe */ _components_lib_mjs__WEBPACK_IMPORTED_MODULE_9__.makeFilledRectangleBuilder),
/* harmony export */   makeFreehandLineBuilder: () => (/* reexport safe */ _components_lib_mjs__WEBPACK_IMPORTED_MODULE_9__.makeFreehandLineBuilder),
/* harmony export */   makeLineBuilder: () => (/* reexport safe */ _components_lib_mjs__WEBPACK_IMPORTED_MODULE_9__.makeLineBuilder),
/* harmony export */   makeOutlinedCircleBuilder: () => (/* reexport safe */ _components_lib_mjs__WEBPACK_IMPORTED_MODULE_9__.makeOutlinedCircleBuilder),
/* harmony export */   makeOutlinedRectangleBuilder: () => (/* reexport safe */ _components_lib_mjs__WEBPACK_IMPORTED_MODULE_9__.makeOutlinedRectangleBuilder),
/* harmony export */   makePolylineBuilder: () => (/* reexport safe */ _components_lib_mjs__WEBPACK_IMPORTED_MODULE_9__.makePolylineBuilder),
/* harmony export */   makePressureSensitiveFreehandLineBuilder: () => (/* reexport safe */ _components_lib_mjs__WEBPACK_IMPORTED_MODULE_9__.makePressureSensitiveFreehandLineBuilder),
/* harmony export */   matchingLocalizationTable: () => (/* reexport safe */ _localizations_getLocalizationTable_mjs__WEBPACK_IMPORTED_MODULE_4__.matchingLocalizationTable),
/* harmony export */   pathFromRenderable: () => (/* reexport safe */ _rendering_lib_mjs__WEBPACK_IMPORTED_MODULE_13__.pathFromRenderable),
/* harmony export */   pathToRenderable: () => (/* reexport safe */ _rendering_lib_mjs__WEBPACK_IMPORTED_MODULE_13__.pathToRenderable),
/* harmony export */   pathVisualEquivalent: () => (/* reexport safe */ _rendering_lib_mjs__WEBPACK_IMPORTED_MODULE_13__.pathVisualEquivalent),
/* harmony export */   sendPenEvent: () => (/* reexport safe */ _testing_lib_mjs__WEBPACK_IMPORTED_MODULE_14__.sendPenEvent),
/* harmony export */   sendTouchEvent: () => (/* reexport safe */ _testing_lib_mjs__WEBPACK_IMPORTED_MODULE_14__.sendTouchEvent),
/* harmony export */   stepPathIndexBy: () => (/* reexport safe */ _js_draw_math__WEBPACK_IMPORTED_MODULE_8__.stepPathIndexBy),
/* harmony export */   toRoundedString: () => (/* reexport safe */ _js_draw_math__WEBPACK_IMPORTED_MODULE_8__.toRoundedString),
/* harmony export */   uniteCommands: () => (/* reexport safe */ _commands_lib_mjs__WEBPACK_IMPORTED_MODULE_10__.uniteCommands)
/* harmony export */ });
/* harmony import */ var _Editor_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Editor.mjs */ "./node_modules/js-draw/dist/mjs/Editor.mjs");
/* harmony import */ var _image_lib_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./image/lib.mjs */ "./node_modules/js-draw/dist/mjs/image/lib.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.mjs */ "./node_modules/js-draw/dist/mjs/types.mjs");
/* harmony import */ var _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./inputEvents.mjs */ "./node_modules/js-draw/dist/mjs/inputEvents.mjs");
/* harmony import */ var _localizations_getLocalizationTable_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./localizations/getLocalizationTable.mjs */ "./node_modules/js-draw/dist/mjs/localizations/getLocalizationTable.mjs");
/* harmony import */ var _localization_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./localization.mjs */ "./node_modules/js-draw/dist/mjs/localization.mjs");
/* harmony import */ var _SVGLoader_SVGLoader_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./SVGLoader/SVGLoader.mjs */ "./node_modules/js-draw/dist/mjs/SVGLoader/SVGLoader.mjs");
/* harmony import */ var _Viewport_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Viewport.mjs */ "./node_modules/js-draw/dist/mjs/Viewport.mjs");
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _components_lib_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./components/lib.mjs */ "./node_modules/js-draw/dist/mjs/components/lib.mjs");
/* harmony import */ var _commands_lib_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./commands/lib.mjs */ "./node_modules/js-draw/dist/mjs/commands/lib.mjs");
/* harmony import */ var _tools_lib_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./tools/lib.mjs */ "./node_modules/js-draw/dist/mjs/tools/lib.mjs");
/* harmony import */ var _toolbar_lib_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./toolbar/lib.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/lib.mjs");
/* harmony import */ var _rendering_lib_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./rendering/lib.mjs */ "./node_modules/js-draw/dist/mjs/rendering/lib.mjs");
/* harmony import */ var _testing_lib_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./testing/lib.mjs */ "./node_modules/js-draw/dist/mjs/testing/lib.mjs");
/* harmony import */ var _shortcuts_lib_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./shortcuts/lib.mjs */ "./node_modules/js-draw/dist/mjs/shortcuts/lib.mjs");
/* harmony import */ var _EventDispatcher_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./EventDispatcher.mjs */ "./node_modules/js-draw/dist/mjs/EventDispatcher.mjs");
/* harmony import */ var _Pointer_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./Pointer.mjs */ "./node_modules/js-draw/dist/mjs/Pointer.mjs");
/* harmony import */ var _UndoRedoHistory_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./UndoRedoHistory.mjs */ "./node_modules/js-draw/dist/mjs/UndoRedoHistory.mjs");
/* harmony import */ var _util_lib_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./util/lib.mjs */ "./node_modules/js-draw/dist/mjs/util/lib.mjs");
/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./version.mjs */ "./node_modules/js-draw/dist/mjs/version.mjs");
/* harmony import */ var _toolbar_AbstractToolbar_mjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./toolbar/AbstractToolbar.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/AbstractToolbar.mjs");
/**
 * The main entrypoint for the NPM package. Everything exported by this file
 * is available through the [`js-draw` package](https://www.npmjs.com/package/js-draw).
 *
 * ## Example
 *
 * [[include:doc-pages/inline-examples/main-js-draw-example.md]]
 *
 * @see
 * - {@link Editor}
 * - {@link Editor.loadFromSVG}
 * - {@link AbstractToolbar.addActionButton }
 * - {@link EditorSettings}
 *
 * @packageDocumentation
 */




















// @internal



/**
 * Using the HTMLToolbar alias is deprecated. Use
 * `AbstractToolbar` instead.
 * @deprecated
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_Editor_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/localization.mjs":
/*!********************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/localization.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultEditorLocalization: () => (/* binding */ defaultEditorLocalization)
/* harmony export */ });
/* harmony import */ var _commands_localization_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commands/localization.mjs */ "./node_modules/js-draw/dist/mjs/commands/localization.mjs");
/* harmony import */ var _components_localization_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/localization.mjs */ "./node_modules/js-draw/dist/mjs/components/localization.mjs");
/* harmony import */ var _rendering_localization_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rendering/localization.mjs */ "./node_modules/js-draw/dist/mjs/rendering/localization.mjs");
/* harmony import */ var _toolbar_localization_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./toolbar/localization.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/localization.mjs");
/* harmony import */ var _tools_localization_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tools/localization.mjs */ "./node_modules/js-draw/dist/mjs/tools/localization.mjs");





const defaultEditorLocalization = {
    ..._toolbar_localization_mjs__WEBPACK_IMPORTED_MODULE_3__.defaultToolbarLocalization,
    ..._tools_localization_mjs__WEBPACK_IMPORTED_MODULE_4__.defaultToolLocalization,
    ..._commands_localization_mjs__WEBPACK_IMPORTED_MODULE_0__.defaultCommandLocalization,
    ..._components_localization_mjs__WEBPACK_IMPORTED_MODULE_1__.defaultComponentLocalization,
    ..._rendering_localization_mjs__WEBPACK_IMPORTED_MODULE_2__.defaultTextRendererLocalization,
    accessibilityInputInstructions: [
        'Press "t" to read the contents of the viewport as text.',
        'Use the arrow keys to move the viewport, click and drag to draw strokes.',
        'Press "w" to zoom in and "s" to zoom out.',
    ].join(' '),
    loading: (percentage) => `Loading ${percentage}%...`,
    imageEditor: 'Image Editor',
    doneLoading: 'Done loading',
    undoAnnouncement: (commandDescription) => `Undid ${commandDescription}`,
    redoAnnouncement: (commandDescription) => `Redid ${commandDescription}`,
    softwareLibraries: 'Libraries',
    developerInformation: 'Developer information',
};


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/localizations/de.mjs":
/*!************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/localizations/de.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _localization_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../localization.mjs */ "./node_modules/js-draw/dist/mjs/localization.mjs");

// German localization
const localization = {
    ..._localization_mjs__WEBPACK_IMPORTED_MODULE_0__.defaultEditorLocalization,
    pen: 'Stift',
    eraser: 'Radierer',
    select: 'Auswahl',
    handTool: 'Verschieben',
    zoom: 'Vergrößerung',
    image: 'Bild',
    inputAltText: 'Alt-Text: ',
    chooseFile: 'Wähle Datei: ',
    submit: 'Absenden',
    cancel: 'Abbrechen',
    resetView: 'Ansicht zurücksetzen',
    thicknessLabel: 'Dicke: ',
    colorLabel: 'Farbe: ',
    fontLabel: 'Schriftart: ',
    textSize: 'Größe: ',
    resizeImageToSelection: 'Bildgröße an Auswahl anpassen',
    deleteSelection: 'Auswahl löschen',
    duplicateSelection: 'Auswahl duplizieren',
    undo: 'Rückgängig',
    redo: 'Wiederholen',
    pickColorFromScreen: 'Farbe von Bildschirm auswählen',
    clickToPickColorAnnouncement: 'Klicke auf den Bildschirm, um eine Farbe auszuwählen',
    selectionToolKeyboardShortcuts: 'Auswahl-Werkzeug: Verwende die Pfeiltasten, um ausgewählte Elemente zu verschieben und ‚i‘ und ‚o‘, um ihre Größe zu ändern.',
    touchPanning: 'Ansicht mit Touchscreen verschieben',
    anyDevicePanning: 'Ansicht mit jedem Eingabegerät verschieben',
    selectPenType: 'Objekt-Typ: ',
    roundedTipPen: 'Freihand',
    flatTipPen: 'Stift (druckempfindlich)',
    arrowPen: 'Pfeil',
    linePen: 'Linie',
    outlinedRectanglePen: 'Umrissenes Rechteck',
    filledRectanglePen: 'Ausgefülltes Rechteck',
    lockRotation: 'Sperre Rotation',
    paste: 'Einfügen',
    dropdownShown: (toolName) => `Dropdown-Menü für ${toolName} angezeigt`,
    dropdownHidden: (toolName) => `Dropdown-Menü für ${toolName} versteckt`,
    zoomLevel: (zoomPercent) => `Vergößerung: ${zoomPercent}%`,
    colorChangedAnnouncement: (color) => `Farbe zu ${color} geändert`,
    imageSize: (size, units) => `Bild-Größe: ${size} ${units}`,
    imageLoadError: (message) => `Fehler beim Laden des Bildes: ${message}`,
    errorImageHasZeroSize: 'Fehler: Bild hat Größe Null',
    penTool: (penNumber) => `Stift ${penNumber}`,
    selectionTool: 'Auswahl',
    eraserTool: 'Radiergummi',
    touchPanTool: 'Ansicht mit Touchscreen verschieben',
    twoFingerPanZoomTool: 'Ansicht verschieben und vergrößern',
    undoRedoTool: 'Rückgängig/Wiederholen',
    rightClickDragPanTool: 'Rechtsklick-Ziehen',
    pipetteTool: 'Farbe von Bildschirm auswählen',
    keyboardPanZoom: 'Tastaturkürzel zum Verschieben/Vergrößern der Ansicht',
    textTool: 'Text',
    enterTextToInsert: 'Einzufügender Text',
    changeTool: 'Wechsle Werkzeug',
    pasteHandler: 'Copy-Paste-Handler',
    findLabel: 'Finde',
    toNextMatch: 'Nächstes',
    closeDialog: 'Schließen',
    findDialogShown: 'Finde-Dialog angezeigt',
    findDialogHidden: 'Finde-Dialog versteckt',
    focusedFoundText: (matchIdx, totalMatches) => `Sieh Treffer ${matchIdx} von ${totalMatches} an`,
    toolEnabledAnnouncement: (toolName) => `${toolName} aktiviert`,
    toolDisabledAnnouncement: (toolName) => `${toolName} deaktiviert`,
    updatedViewport: 'Transformierte Ansicht',
    transformedElements: (elemCount) => `${elemCount} Element${1 === elemCount ? '' : 'e'} transformiert`,
    resizeOutputCommand: (newSize) => `Bildgröße auf ${newSize.w}x${newSize.h} geändert`,
    addElementAction: (componentDescription) => `${componentDescription} hinzugefügt`,
    eraseAction: (elemDescription, countErased) => `${countErased} ${elemDescription} gelöscht`,
    duplicateAction: (elemDescription, countErased) => `${countErased} ${elemDescription} dupliziert`,
    inverseOf: (actionDescription) => `${actionDescription} umgekehrt`,
    elements: 'Elemente',
    erasedNoElements: 'Nichts entfernt',
    duplicatedNoElements: 'Nichts dupliziert',
    rotatedBy: (degrees) => `${Math.abs(degrees)} Grad ${degrees < 0 ? 'im Uhrzeigersinn' : 'gegen den Uhrzeigersinn'} gedreht`,
    movedLeft: 'Nacht links bewegt',
    movedUp: 'Nacht oben bewegt',
    movedDown: 'Nacht unten bewegt',
    movedRight: 'Nacht rechts bewegt',
    zoomedOut: 'Ansicht verkleinert',
    zoomedIn: 'Ansicht vergrößert',
    selectedElements: (count) => `${count} Element${1 === count ? '' : 'e'} ausgewählt`,
    stroke: 'Strich',
    svgObject: 'SVG-Objekt',
    text: (text) => `Text-Objekt: ${text}`,
    pathNodeCount: (count) => `Es gibt ${count} sichtbare Pfad-Objekte.`,
    textNodeCount: (count) => `Es gibt ${count} sichtbare Text-Knotenpunkte.`,
    textNode: (content) => `Text: ${content}`,
    imageNodeCount: (nodeCount) => `Es gibt ${nodeCount} sichtbare Bild-Knoten.`,
    imageNode: (label) => `Bild: ${label}`,
    unlabeledImageNode: 'Bild ohne Label',
    rerenderAsText: 'Als Text darstellen',
    accessibilityInputInstructions: 'Drücke ‚t‘, um den Inhalt des Ansichtsfensters als Text zu lesen. Verwende die Pfeiltasten, um die Ansicht zu verschieben, und klicke und ziehe, um Striche zu zeichnen. Drücke ‚w‘ zum Vergrößern und ‚s‘ zum Verkleinern der Ansicht.',
    loading: (percentage) => `Laden ${percentage}%...`,
    doneLoading: 'Laden fertig',
    imageEditor: 'Bild-Editor',
    undoAnnouncement: (commandDescription) => `${commandDescription} rückgängig gemacht`,
    redoAnnouncement: (commandDescription) => `${commandDescription} wiederholt`,
    reformatSelection: 'Formatiere Auswahl',
    documentProperties: 'Seite',
    backgroundColor: 'Hintergrundfarbe: ',
    imageWidthOption: 'Breite: ',
    imageHeightOption: 'Höhe: ',
    useGridOption: 'Gitter: ',
    toggleOverflow: 'Mehr',
    selectAllTool: 'Alle auswählen',
    soundExplorer: 'Klangbasierte Bilderkundung',
    disableAccessibilityExploreTool: 'Deaktiviere klangbasierte Erkundung',
    enableAccessibilityExploreTool: 'Aktiviere klangbasierte Erkundung',
    unionOf: (actionDescription, actionCount) => `Vereinigung: ${actionCount} ${actionDescription}`,
    emptyBackground: 'Leerer Hintergrund',
    filledBackgroundWithColor: (color) => `Gefüllter Hintergrund (${color})`,
    restyledElement: (elementDescription) => `${elementDescription} umgestaltet`,
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (localization);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/localizations/en.mjs":
/*!************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/localizations/en.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _localization_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../localization.mjs */ "./node_modules/js-draw/dist/mjs/localization.mjs");

// Default localizations are already in English.
const localization = {
    ..._localization_mjs__WEBPACK_IMPORTED_MODULE_0__.defaultEditorLocalization,
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (localization);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/localizations/es.mjs":
/*!************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/localizations/es.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _localization_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../localization.mjs */ "./node_modules/js-draw/dist/mjs/localization.mjs");

// A partial Spanish localization
const localization = {
    ..._localization_mjs__WEBPACK_IMPORTED_MODULE_0__.defaultEditorLocalization,
    pen: 'Lapiz',
    eraser: 'Borrador',
    select: 'Selecciona',
    handTool: 'Mover',
    image: 'Imagen',
    inputAltText: 'Texto alternativo',
    resetImage: 'Reiniciar',
    chooseFile: 'Seleccionar archivo',
    cancel: 'Cancelar',
    resetView: 'Reiniciar vista',
    thicknessLabel: 'Tamaño',
    fontLabel: 'Fuente:',
    textSize: 'Tamaño',
    resizeImageToSelection: 'Redimensionar la imagen a lo que está seleccionado',
    deleteSelection: 'Borra la selección',
    duplicateSelection: 'Duplica la selección',
    exit: 'Salir',
    save: 'Guardar',
    undo: 'Deshace',
    redo: 'Rehace',
    selectPenType: 'Punta',
    selectShape: 'Forma',
    pickColorFromScreen: 'Selecciona un color de la pantalla',
    clickToPickColorAnnouncement: 'Haga un clic en la pantalla para seleccionar un color',
    documentProperties: 'Fondo',
    backgroundColor: 'Color de fondo',
    imageWidthOption: 'Ancho',
    imageHeightOption: 'Alto',
    enableAutoresizeOption: 'Redimensionar automático',
    toggleOverflow: 'Más',
    about: 'Acerca de',
    touchPanning: 'Mover la pantalla con un dedo',
    roundedTipPen: 'Lapiz Redondeado',
    arrowPen: 'Flecha',
    linePen: 'Línea',
    outlinedRectanglePen: 'Rectángulo delineado',
    filledRectanglePen: 'Rectángulo sin borde',
    lockRotation: 'Bloquea rotación',
    paste: 'Pegar',
    selectionMenu__paste: 'Pegar',
    selectionMenu__delete: 'Eliminar',
    selectionMenu__duplicate: 'Duplicar',
    closeSidebar: (toolName) => `Close sidebar for ${toolName}`,
    dropdownShown: (toolName) => `Menú por ${toolName} es visible`,
    dropdownHidden: (toolName) => {
        return `Menú por ${toolName} fue ocultado`;
    },
    zoomLevel: (zoomPercent) => `Zoom: ${zoomPercent}%`,
    colorChangedAnnouncement: (color) => {
        return `Color fue cambiado a ${color}`;
    },
    imageSize: (size, units) => `Tamaño del imagen: ${size} ${units}`,
    imageLoadError: (message) => `Error cargando imagen: ${message}`,
    penTool: (penId) => `Lapiz ${penId}`,
    selectionTool: 'Selecciona',
    eraserTool: 'Borrador',
    touchPanTool: 'Instrumento de mover la pantalla con un dedo',
    undoRedoTool: 'Deshace/rehace',
    pipetteTool: 'Seleccione un color de la pantalla',
    keyboardPanZoom: 'Mover la pantalla con el teclado',
    textTool: 'Texto',
    enterTextToInsert: 'Entra texto',
    findLabel: 'Buscar',
    toNextMatch: 'Próxima',
    closeDialog: 'Cerrar',
    anyDevicePanning: 'Mover la pantalla con todo dispotivo',
    copied: (count) => `${count} cosas fueron copiados`,
    pasted: (count) => (count === 1 ? 'Pegado' : `${count} cosas fueron pegados`),
    toolEnabledAnnouncement: (toolName) => `${toolName} fue activado`,
    toolDisabledAnnouncement: (toolName) => `${toolName} fue desactivado`,
    resizeOutputCommand: (newSize) => `Tamaño de imagen fue cambiado a ${newSize.w}x${newSize.h}`,
    eraseAction: (componentDescription, numElems) => `Borrado: ${numElems} ${componentDescription}`,
    rerenderAsText: 'Redibuja la pantalla al texto',
    loading: (percentage) => `Cargando: ${percentage}%...`,
    imageEditor: 'Editor de dibujos',
    doneLoading: 'El cargado terminó',
    undoAnnouncement: (commandDescription) => `${commandDescription} fue deshecho`,
    redoAnnouncement: (commandDescription) => `${commandDescription} fue rehecho`,
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (localization);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/localizations/getLocalizationTable.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/localizations/getLocalizationTable.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   allLocales: () => (/* binding */ allLocales),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   matchingLocalizationTable: () => (/* binding */ matchingLocalizationTable)
/* harmony export */ });
/* harmony import */ var _localization_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../localization.mjs */ "./node_modules/js-draw/dist/mjs/localization.mjs");
/* harmony import */ var _de_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./de.mjs */ "./node_modules/js-draw/dist/mjs/localizations/de.mjs");
/* harmony import */ var _en_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./en.mjs */ "./node_modules/js-draw/dist/mjs/localizations/en.mjs");
/* harmony import */ var _es_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./es.mjs */ "./node_modules/js-draw/dist/mjs/localizations/es.mjs");




const allLocales = {
    de: _de_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
    en: _en_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
    es: _es_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
};
// [locale]: A string in the format languageCode_Region or just languageCode. For example, en_US.
const languageFromLocale = (locale) => {
    const matches = /^(\w+)[_-](\w+)$/.exec(locale);
    if (!matches) {
        // If not in languageCode_region format, the locale should be the
        // languageCode. Return that.
        return locale;
    }
    return matches[1];
};
/**
 * Return the localization table in `localizationTables` that best matches
 * the list of `userLocales`. If there is no matching language, returns
 * `defaultLocalizationTable`.
 */
const matchingLocalizationTable = (userLocales, localizationTables, defaultLocalizationTable) => {
    let prevLanguage;
    for (const locale of userLocales) {
        const language = languageFromLocale(locale);
        // If the specific localization of the language is not available, but
        // a localization for the language is,
        if (prevLanguage && language !== prevLanguage) {
            if (prevLanguage in localizationTables) {
                return localizationTables[prevLanguage];
            }
        }
        // If the full locale (e.g. en_US) is available,
        if (locale in localizationTables) {
            return localizationTables[locale];
        }
        prevLanguage = language;
    }
    if (prevLanguage && prevLanguage in localizationTables) {
        return localizationTables[prevLanguage];
    }
    else {
        return defaultLocalizationTable;
    }
};
/**
 * Returns a localization table for the `Editor` that matches
 * the user's current locale.
 *
 * Returns the default localization table if no appropriate localization
 * exists.
 */
const getLocalizationTable = (userLocales) => {
    userLocales ??= navigator.languages;
    return matchingLocalizationTable(userLocales, allLocales, _localization_mjs__WEBPACK_IMPORTED_MODULE_0__.defaultEditorLocalization);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getLocalizationTable);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/rendering/Display.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/rendering/Display.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RenderingMode: () => (/* binding */ RenderingMode),
/* harmony export */   "default": () => (/* binding */ Display)
/* harmony export */ });
/* harmony import */ var _renderers_CanvasRenderer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./renderers/CanvasRenderer.mjs */ "./node_modules/js-draw/dist/mjs/rendering/renderers/CanvasRenderer.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types.mjs */ "./node_modules/js-draw/dist/mjs/types.mjs");
/* harmony import */ var _renderers_DummyRenderer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./renderers/DummyRenderer.mjs */ "./node_modules/js-draw/dist/mjs/rendering/renderers/DummyRenderer.mjs");
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _caching_RenderingCache_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./caching/RenderingCache.mjs */ "./node_modules/js-draw/dist/mjs/rendering/caching/RenderingCache.mjs");
/* harmony import */ var _renderers_TextOnlyRenderer_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./renderers/TextOnlyRenderer.mjs */ "./node_modules/js-draw/dist/mjs/rendering/renderers/TextOnlyRenderer.mjs");






var RenderingMode;
(function (RenderingMode) {
    RenderingMode[RenderingMode["DummyRenderer"] = 0] = "DummyRenderer";
    RenderingMode[RenderingMode["CanvasRenderer"] = 1] = "CanvasRenderer";
    // SVGRenderer is not supported by the main display
})(RenderingMode || (RenderingMode = {}));
/**
 * Handles `HTMLCanvasElement`s (or other drawing surfaces if being used) used to display the editor's contents.
 *
 * @example
 * ```
 * const editor = new Editor(document.body);
 * const w = editor.display.width;
 * const h = editor.display.height;
 * const center = Vec2.of(w / 2, h / 2);
 * const colorAtCenter = editor.display.getColorAt(center);
 * ```
 */
class Display {
    /** @internal */
    constructor(editor, mode, parent) {
        this.editor = editor;
        this.parent = parent;
        this.textRerenderOutput = null;
        this.devicePixelRatio = window.devicePixelRatio ?? 1;
        /**
         * @returns the color at the given point on the dry ink renderer, or `null` if `screenPos`
         * 	is not on the display.
         */
        this.getColorAt = (_screenPos) => {
            return null;
        };
        if (mode === RenderingMode.CanvasRenderer) {
            this.initializeCanvasRendering();
        }
        else if (mode === RenderingMode.DummyRenderer) {
            this.dryInkRenderer = new _renderers_DummyRenderer_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](editor.viewport);
            this.wetInkRenderer = new _renderers_DummyRenderer_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](editor.viewport);
        }
        else {
            throw new Error(`Unknown rendering mode, ${mode}!`);
        }
        this.textRenderer = new _renderers_TextOnlyRenderer_mjs__WEBPACK_IMPORTED_MODULE_5__["default"](editor.viewport, editor.localization);
        this.initializeTextRendering();
        const cacheBlockResolution = _js_draw_math__WEBPACK_IMPORTED_MODULE_3__.Vec2.of(600, 600);
        this.cache = new _caching_RenderingCache_mjs__WEBPACK_IMPORTED_MODULE_4__["default"]({
            createRenderer: () => {
                if (mode === RenderingMode.DummyRenderer) {
                    return new _renderers_DummyRenderer_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](editor.viewport);
                }
                else if (mode !== RenderingMode.CanvasRenderer) {
                    throw new Error('Unspported rendering mode');
                }
                // Make the canvas slightly larger than each cache block to prevent
                // seams.
                const canvas = document.createElement('canvas');
                canvas.width = cacheBlockResolution.x + 1;
                canvas.height = cacheBlockResolution.y + 1;
                const ctx = canvas.getContext('2d');
                return new _renderers_CanvasRenderer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](ctx, editor.viewport);
            },
            isOfCorrectType: (renderer) => {
                return this.dryInkRenderer.canRenderFromWithoutDataLoss(renderer);
            },
            blockResolution: cacheBlockResolution,
            cacheSize: 600 * 600 * 4 * 90,
            // On higher resolution displays, don't scale cache blocks as much to decrease blurriness.
            // TODO: Decrease the minimum cache scale as well.
            maxScale: Math.max(1, 1.3 / window.devicePixelRatio),
            // Require about 20 strokes with 4 parts each to cache an image in one of the
            // parts of the cache grid.
            minProportionalRenderTimePerCache: 20 * 4,
            // Require about 105 strokes with 4 parts each to use the cache at all.
            minProportionalRenderTimeToUseCache: 105 * 4,
        });
        this.editor.notifier.on(_types_mjs__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.DisplayResized, (event) => {
            if (event.kind !== _types_mjs__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.DisplayResized) {
                throw new Error('Mismatched event.kinds!');
            }
            this.resizeSurfacesCallback?.();
        });
    }
    /**
     * @returns the visible width of the display (e.g. how much
     * space the display's element takes up in the x direction
     * in the DOM).
     */
    get width() {
        return this.dryInkRenderer.displaySize().x;
    }
    /** @returns the visible height of the display. See {@link width}. */
    get height() {
        return this.dryInkRenderer.displaySize().y;
    }
    /** @internal */
    getCache() {
        return this.cache;
    }
    initializeCanvasRendering() {
        const dryInkCanvas = document.createElement('canvas');
        const wetInkCanvas = document.createElement('canvas');
        const dryInkCtx = dryInkCanvas.getContext('2d');
        const wetInkCtx = wetInkCanvas.getContext('2d');
        this.dryInkRenderer = new _renderers_CanvasRenderer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](dryInkCtx, this.editor.viewport);
        this.wetInkRenderer = new _renderers_CanvasRenderer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](wetInkCtx, this.editor.viewport);
        dryInkCanvas.className = 'dryInkCanvas';
        wetInkCanvas.className = 'wetInkCanvas';
        if (this.parent) {
            this.parent.appendChild(dryInkCanvas);
            this.parent.appendChild(wetInkCanvas);
        }
        this.resizeSurfacesCallback = () => {
            const expectedWidth = (canvas) => {
                const widthInPixels = Math.ceil(canvas.clientWidth * this.devicePixelRatio);
                // Avoid setting the canvas width to zero -- doing so can cause errors when attempting
                // to use the canvas:
                return widthInPixels || canvas.width;
            };
            const expectedHeight = (canvas) => {
                const heightInPixels = Math.ceil(canvas.clientHeight * this.devicePixelRatio);
                return heightInPixels || canvas.height; // Zero-size canvases can cause errors.
            };
            const hasSizeMismatch = (canvas) => {
                return expectedHeight(canvas) !== canvas.height || expectedWidth(canvas) !== canvas.width;
            };
            // Ensure that the drawing surfaces sizes match the
            // canvas' sizes to prevent stretching.
            if (hasSizeMismatch(dryInkCanvas) || hasSizeMismatch(wetInkCanvas)) {
                dryInkCanvas.width = expectedWidth(dryInkCanvas);
                dryInkCanvas.height = expectedHeight(dryInkCanvas);
                wetInkCanvas.width = expectedWidth(wetInkCanvas);
                wetInkCanvas.height = expectedHeight(wetInkCanvas);
                // Ensure correct drawing operations on high-resolution screens.
                // See
                // https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas#scaling_for_high_resolution_displays
                //
                // This scaling causes the rendering contexts to automatically convert
                // between screen coordinates and pixel coordinates.
                wetInkCtx.resetTransform();
                dryInkCtx.resetTransform();
                dryInkCtx.scale(this.devicePixelRatio, this.devicePixelRatio);
                wetInkCtx.scale(this.devicePixelRatio, this.devicePixelRatio);
                this.editor.notifier.dispatch(_types_mjs__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.DisplayResized, {
                    kind: _types_mjs__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.DisplayResized,
                    newSize: _js_draw_math__WEBPACK_IMPORTED_MODULE_3__.Vec2.of(this.width, this.height),
                });
            }
        };
        this.resizeSurfacesCallback();
        this.flattenCallback = () => {
            dryInkCtx.save();
            dryInkCtx.resetTransform();
            dryInkCtx.drawImage(wetInkCanvas, 0, 0);
            dryInkCtx.restore();
        };
        this.getColorAt = (screenPos) => {
            // getImageData isn't affected by a transformation matrix -- we need to
            // pre-transform screenPos to convert it from screen coordinates into pixel
            // coordinates.
            const adjustedScreenPos = screenPos.times(this.devicePixelRatio);
            const pixel = dryInkCtx.getImageData(adjustedScreenPos.x, adjustedScreenPos.y, 1, 1);
            const data = pixel?.data;
            if (data) {
                const color = _js_draw_math__WEBPACK_IMPORTED_MODULE_3__.Color4.ofRGBA(data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255);
                return color;
            }
            return null;
        };
    }
    initializeTextRendering() {
        const textRendererOutputContainer = document.createElement('div');
        textRendererOutputContainer.classList.add('textRendererOutputContainer');
        const rerenderButton = document.createElement('button');
        rerenderButton.classList.add('rerenderButton');
        rerenderButton.innerText = this.editor.localization.rerenderAsText;
        this.textRerenderOutput = document.createElement('div');
        this.textRerenderOutput.setAttribute('aria-live', 'polite');
        rerenderButton.onclick = () => {
            this.rerenderAsText();
        };
        textRendererOutputContainer.replaceChildren(rerenderButton, this.textRerenderOutput);
        this.editor.createHTMLOverlay(textRendererOutputContainer);
    }
    /**
     * Sets the device-pixel-ratio.
     *
     * Intended for debugging. Users do not need to call this manually.
     *
     * @internal
     */
    setDevicePixelRatio(dpr) {
        const minDpr = 0.001;
        const maxDpr = 10;
        if (isFinite(dpr) && dpr >= minDpr && dpr <= maxDpr && dpr !== this.devicePixelRatio) {
            this.devicePixelRatio = dpr;
            this.resizeSurfacesCallback?.();
            return this.editor.queueRerender();
        }
        return undefined;
    }
    /** @internal */
    getDevicePixelRatio() {
        return this.devicePixelRatio;
    }
    /**
     * Rerenders the text-based display.
     * The text-based display is intended for screen readers and can be navigated to by pressing `tab`.
     */
    rerenderAsText() {
        this.textRenderer.clear();
        this.editor.image.render(this.textRenderer, this.editor.viewport);
        if (this.textRerenderOutput) {
            this.textRerenderOutput.innerText = this.textRenderer.getDescription();
        }
    }
    /**
     * Clears the main drawing surface and otherwise prepares for a rerender.
     *
     * @returns the dry ink renderer.
     */
    startRerender() {
        this.resizeSurfacesCallback?.();
        this.dryInkRenderer.clear();
        return this.dryInkRenderer;
    }
    /**
     * If `draftMode`, the dry ink renderer is configured to render
     * low-quality output.
     */
    setDraftMode(draftMode) {
        this.dryInkRenderer.setDraftMode(draftMode);
    }
    /** @internal */
    getDryInkRenderer() {
        return this.dryInkRenderer;
    }
    /**
     * @returns The renderer used for showing action previews (e.g. an unfinished stroke).
     * The `wetInkRenderer`'s surface is stacked above the `dryInkRenderer`'s.
     */
    getWetInkRenderer() {
        return this.wetInkRenderer;
    }
    /** Re-renders the contents of the wetInkRenderer onto the dryInkRenderer. */
    flatten() {
        this.flattenCallback?.();
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/rendering/RenderablePathSpec.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/rendering/RenderablePathSpec.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   pathFromRenderable: () => (/* binding */ pathFromRenderable),
/* harmony export */   pathToRenderable: () => (/* binding */ pathToRenderable),
/* harmony export */   simplifyPathToFullScreenOrEmpty: () => (/* binding */ simplifyPathToFullScreenOrEmpty),
/* harmony export */   visualEquivalent: () => (/* binding */ visualEquivalent)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");

/** Converts a renderable path (a path with a `startPoint`, `commands`, and `style`). */
const pathFromRenderable = (renderable) => {
    if (renderable.path) {
        return renderable.path;
    }
    return new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Path(renderable.startPoint, renderable.commands);
};
/**
 * Converts `path` into a format that can be rendered (by passing to a {@link Stroke} constructor
 * or directly to an {@link AbstractRenderer.drawPath}).
 */
const pathToRenderable = (path, style) => {
    return {
        startPoint: path.startPoint,
        style,
        commands: path.parts,
        path,
    };
};
/**
 * Fills the optional `path` field in `RenderablePathSpec`
 * with `path` if not already filled
 */
const pathIncluded = (renderablePath, path) => {
    if (renderablePath.path) {
        return renderablePath;
    }
    return {
        ...renderablePath,
        path,
    };
};
/**
 * Tries to simplify the given path to a fullscreen rectangle.
 * Returns `null` on failure.
 *
 * @internal
 */
const simplifyPathToFullScreenOrEmpty = (renderablePath, visibleRect, options = {
    fastCheck: true,
    expensiveCheck: true,
}) => {
    const path = pathFromRenderable(renderablePath);
    const strokeWidth = renderablePath.style.stroke?.width ?? 0;
    const onlyStroked = strokeWidth > 0 && renderablePath.style.fill.a === 0;
    const styledPathBBox = path.bbox.grownBy(strokeWidth);
    // Are we close enough to the path that it fills the entire screen?
    const isOnlyStrokedAndCouldFillScreen = onlyStroked &&
        strokeWidth > visibleRect.maxDimension &&
        styledPathBBox.containsRect(visibleRect);
    if (options.fastCheck && isOnlyStrokedAndCouldFillScreen && renderablePath.style.stroke) {
        const strokeRadius = strokeWidth / 2;
        // Are we completely within the stroke?
        // Do a fast, but with many false negatives, check.
        for (const point of path.startEndPoints()) {
            // If within the strokeRadius of any point
            if (visibleRect.isWithinRadiusOf(strokeRadius, point)) {
                return {
                    rectangle: visibleRect,
                    path: pathToRenderable(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Path.fromRect(visibleRect), {
                        fill: renderablePath.style.stroke.color,
                    }),
                    fullScreen: true,
                };
            }
        }
    }
    // Try filtering again, but with slightly more expensive checks
    if (options.expensiveCheck &&
        isOnlyStrokedAndCouldFillScreen &&
        renderablePath.style.stroke &&
        strokeWidth > visibleRect.maxDimension * 3) {
        const signedDist = path.signedDistance(visibleRect.center, strokeWidth / 2);
        const margin = strokeWidth / 6;
        if (signedDist < -visibleRect.maxDimension / 2 - margin) {
            return {
                path: pathToRenderable(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Path.fromRect(visibleRect), {
                    fill: renderablePath.style.stroke.color,
                }),
                rectangle: visibleRect,
                fullScreen: true,
            };
        }
        else if (signedDist > visibleRect.maxDimension / 2 + margin) {
            return {
                path: pathToRenderable(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Path.empty, { fill: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.transparent }),
                rectangle: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2.empty,
                fullScreen: false,
            };
        }
    }
    return null;
};
/**
 * @returns a Path that, when rendered, looks roughly equivalent to the given path.
 */
const visualEquivalent = (renderablePath, visibleRect) => {
    const path = pathFromRenderable(renderablePath);
    const strokeWidth = renderablePath.style.stroke?.width ?? 0;
    const onlyStroked = strokeWidth > 0 && renderablePath.style.fill.a === 0;
    const styledPathBBox = path.bbox.grownBy(strokeWidth);
    let rectangleSimplification = simplifyPathToFullScreenOrEmpty(renderablePath, visibleRect, {
        fastCheck: true,
        expensiveCheck: false,
    });
    if (rectangleSimplification) {
        return rectangleSimplification.path;
    }
    // Scale the expanded rect --- the visual equivalent is only close for huge strokes.
    const expandedRect = visibleRect
        .grownBy(strokeWidth)
        .transformedBoundingBox(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.scaling2D(4, visibleRect.center));
    // TODO: Handle simplifying very small paths.
    if (expandedRect.containsRect(styledPathBBox)) {
        return pathIncluded(renderablePath, path);
    }
    const parts = [];
    let startPoint = path.startPoint;
    for (const part of path.parts) {
        const partBBox = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Path.computeBBoxForSegment(startPoint, part).grownBy(strokeWidth);
        let endPoint;
        if (part.kind === _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo || part.kind === _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.MoveTo) {
            endPoint = part.point;
        }
        else {
            endPoint = part.endPoint;
        }
        const intersectsVisible = partBBox.intersects(visibleRect);
        if (intersectsVisible) {
            // TODO: Can we trim parts of paths that intersect the visible rectangle?
            parts.push(part);
        }
        else if (onlyStroked || part.kind === _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.MoveTo) {
            // We're stroking (not filling) and the path doesn't intersect the bounding box.
            // Don't draw it, but preserve the endpoints.
            parts.push({
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.MoveTo,
                point: endPoint,
            });
        }
        else {
            // Otherwise, we may be filling. Try to roughly preserve the filled region.
            parts.push({
                kind: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,
                point: endPoint,
            });
        }
        startPoint = endPoint;
    }
    const newPath = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Path(path.startPoint, parts);
    const newStyle = renderablePath.style;
    rectangleSimplification = simplifyPathToFullScreenOrEmpty(renderablePath, visibleRect, {
        fastCheck: false,
        expensiveCheck: true,
    });
    if (rectangleSimplification) {
        return rectangleSimplification.path;
    }
    return pathToRenderable(newPath, newStyle);
};


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/rendering/RenderingStyle.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/rendering/RenderingStyle.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cloneStyle: () => (/* binding */ cloneStyle),
/* harmony export */   styleFromJSON: () => (/* binding */ styleFromJSON),
/* harmony export */   styleToJSON: () => (/* binding */ styleToJSON),
/* harmony export */   stylesEqual: () => (/* binding */ stylesEqual)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");

const cloneStyle = (style) => {
    return {
        fill: style.fill,
        stroke: style.stroke
            ? {
                ...style.stroke,
            }
            : undefined,
    };
};
const stylesEqual = (a, b) => {
    const result = a === b ||
        (a.fill.eq(b.fill) &&
            (a.stroke == undefined) === (b.stroke == undefined) &&
            (a.stroke?.color?.eq(b.stroke?.color) ?? true) &&
            a.stroke?.width === b.stroke?.width);
    // Map undefined/null -> false
    return result ?? false;
};
// Returns an object that can be converted to a JSON string with
// JSON.stringify.
const styleToJSON = (style) => {
    const stroke = !style.stroke
        ? undefined
        : {
            color: style.stroke.color.toHexString(),
            width: style.stroke.width,
        };
    return {
        fill: style.fill.toHexString(),
        stroke,
    };
};
const styleFromJSON = (json) => {
    const stroke = json.stroke
        ? {
            color: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.fromHex(json.stroke.color),
            width: json.stroke.width,
        }
        : undefined;
    return {
        fill: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.fromHex(json.fill),
        stroke,
    };
};


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/rendering/TextRenderingStyle.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/rendering/TextRenderingStyle.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cloneTextStyle: () => (/* binding */ cloneTextStyle),
/* harmony export */   textStyleFromJSON: () => (/* binding */ textStyleFromJSON),
/* harmony export */   textStyleToJSON: () => (/* binding */ textStyleToJSON)
/* harmony export */ });
/* harmony import */ var _RenderingStyle_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RenderingStyle.mjs */ "./node_modules/js-draw/dist/mjs/rendering/RenderingStyle.mjs");

const cloneTextStyle = (style) => {
    return {
        ...style,
        renderingStyle: (0,_RenderingStyle_mjs__WEBPACK_IMPORTED_MODULE_0__.cloneStyle)(style.renderingStyle),
    };
};
/** `json` can either be a `string` or an `object`. */
const textStyleFromJSON = (json) => {
    if (typeof json === 'string') {
        json = JSON.parse(json);
    }
    if (typeof json.fontFamily !== 'string') {
        throw new Error('Serialized textStyle missing string fontFamily attribute!');
    }
    const style = {
        renderingStyle: (0,_RenderingStyle_mjs__WEBPACK_IMPORTED_MODULE_0__.styleFromJSON)(json.renderingStyle),
        size: json.size,
        fontWeight: json.fontWeight,
        fontVariant: json.fontVariant,
        fontFamily: json.fontFamily,
    };
    return style;
};
const textStyleToJSON = (style) => {
    return {
        ...style,
        renderingStyle: (0,_RenderingStyle_mjs__WEBPACK_IMPORTED_MODULE_0__.styleToJSON)(style.renderingStyle),
    };
};


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/rendering/caching/CacheRecord.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/rendering/caching/CacheRecord.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CacheRecord)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");

// Represents a cached renderer/canvas
// This is not a [CacheNode] -- it handles cached renderers and does not have sub-renderers.
class CacheRecord {
    constructor(onBeforeDeallocCallback, cacheState) {
        this.onBeforeDeallocCallback = onBeforeDeallocCallback;
        this.cacheState = cacheState;
        this.allocd = false;
        // For debugging
        this.allocCount = 0;
        this.renderer = cacheState.props.createRenderer();
        this.lastUsedCycle = -1;
        this.allocd = true;
    }
    startRender() {
        this.lastUsedCycle = this.cacheState.currentRenderingCycle;
        if (!this.allocd) {
            throw new Error("Only alloc'd canvases can be rendered to");
        }
        return this.renderer;
    }
    dealloc() {
        this.onBeforeDeallocCallback?.();
        this.allocd = false;
        this.onBeforeDeallocCallback = null;
        this.lastUsedCycle = 0;
    }
    isAllocd() {
        return this.allocd;
    }
    realloc(newDeallocCallback) {
        if (this.allocd) {
            this.dealloc();
        }
        this.allocd = true;
        this.onBeforeDeallocCallback = newDeallocCallback;
        this.lastUsedCycle = this.cacheState.currentRenderingCycle;
        this.allocCount++;
    }
    getLastUsedCycle() {
        return this.lastUsedCycle;
    }
    // Returns the transformation that maps [drawTo] to this' renderable region
    // (i.e. a [cacheProps.blockResolution]-sized rectangle with top left at (0, 0))
    getTransform(drawTo) {
        const transform = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.scaling2D(this.cacheState.props.blockResolution.x / drawTo.size.x).rightMul(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.translation(drawTo.topLeft.times(-1)));
        return transform;
    }
    setRenderingRegion(drawTo) {
        const transform = this.getTransform(drawTo);
        this.renderer.setTransform(transform);
        // The visible region may be slightly larger than where we're actually drawing
        // to (because of rounding).
        this.renderer.overrideVisibleRect(drawTo.grownBy(1 / transform.getScaleFactor()));
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/rendering/caching/CacheRecordManager.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/rendering/caching/CacheRecordManager.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CacheRecordManager: () => (/* binding */ CacheRecordManager)
/* harmony export */ });
/* harmony import */ var _CacheRecord_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CacheRecord.mjs */ "./node_modules/js-draw/dist/mjs/rendering/caching/CacheRecord.mjs");

class CacheRecordManager {
    constructor(cacheProps) {
        // Fixed-size array: Cache blocks are assigned indicies into [cachedCanvases].
        this.cacheRecords = [];
        this.maxCanvases = Math.ceil(
        // Assuming four components per pixel:
        cacheProps.cacheSize / 4 / cacheProps.blockResolution.x / cacheProps.blockResolution.y);
    }
    setSharedState(state) {
        this.cacheState = state;
    }
    allocCanvas(drawTo, onDealloc) {
        if (this.cacheRecords.length < this.maxCanvases) {
            const record = new _CacheRecord_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](onDealloc, this.cacheState);
            record.setRenderingRegion(drawTo);
            this.cacheRecords.push(record);
            if (this.cacheState.debugMode) {
                console.log('[Cache] Cache spaces used: ', this.cacheRecords.length, ' of ', this.maxCanvases);
            }
            return record;
        }
        else {
            const lru = this.getLeastRecentlyUsedRecord();
            if (this.cacheState.debugMode) {
                console.log('[Cache] Re-alloc. Times allocated: ', lru.allocCount, '\nLast used cycle: ', lru.getLastUsedCycle(), '\nCurrent cycle: ', this.cacheState.currentRenderingCycle);
            }
            lru.realloc(onDealloc);
            lru.setRenderingRegion(drawTo);
            if (this.cacheState.debugMode) {
                console.log("[Cache] Now re-alloc'd. Last used cycle: ", lru.getLastUsedCycle());
                console.assert(lru['cacheState'] === this.cacheState, '[Cache] Unequal cache states! cacheState should be a shared object!');
            }
            return lru;
        }
    }
    // Returns null if there are no cache records. Returns an unalloc'd record if one exists.
    getLeastRecentlyUsedRecord() {
        this.cacheRecords.sort((a, b) => a.getLastUsedCycle() - b.getLastUsedCycle());
        return this.cacheRecords[0];
    }
    // Returns information to (hopefully) help debug performance issues
    getDebugInfo() {
        let numberAllocd = 0;
        let averageReassignedCount = 0;
        for (const cacheRecord of this.cacheRecords) {
            averageReassignedCount += cacheRecord.allocCount;
            if (cacheRecord.isAllocd()) {
                numberAllocd++;
            }
        }
        averageReassignedCount /= Math.max(this.cacheRecords.length, 1);
        const debugInfo = [
            `${this.cacheRecords.length} cache records (max ${this.maxCanvases})`,
            `${numberAllocd} assigned to screen regions`,
            `Average number of times reassigned: ${Math.round(averageReassignedCount * 100) / 100}`,
        ];
        return debugInfo.join('\n');
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/rendering/caching/RenderingCache.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/rendering/caching/RenderingCache.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RenderingCache)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _RenderingCacheNode_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RenderingCacheNode.mjs */ "./node_modules/js-draw/dist/mjs/rendering/caching/RenderingCacheNode.mjs");
/* harmony import */ var _CacheRecordManager_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CacheRecordManager.mjs */ "./node_modules/js-draw/dist/mjs/rendering/caching/CacheRecordManager.mjs");



class RenderingCache {
    constructor(cacheProps) {
        this.recordManager = new _CacheRecordManager_mjs__WEBPACK_IMPORTED_MODULE_2__.CacheRecordManager(cacheProps);
        this.sharedState = {
            props: cacheProps,
            currentRenderingCycle: 0,
            recordManager: this.recordManager,
            debugMode: false,
        };
        this.recordManager.setSharedState(this.sharedState);
    }
    render(screenRenderer, image, viewport) {
        const visibleRect = viewport.visibleRect;
        this.sharedState.currentRenderingCycle++;
        // If we can't use the cache,
        if (!this.sharedState.props.isOfCorrectType(screenRenderer)) {
            image.render(screenRenderer, visibleRect);
            return;
        }
        if (!this.rootNode) {
            // Adjust the node so that it has the correct aspect ratio
            const res = this.sharedState.props.blockResolution;
            const topLeft = visibleRect.topLeft;
            this.rootNode = new _RenderingCacheNode_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2(topLeft.x, topLeft.y, res.x, res.y), this.sharedState);
        }
        while (!this.rootNode.region.containsRect(visibleRect)) {
            this.rootNode = this.rootNode.generateParent();
        }
        this.rootNode = this.rootNode.smallestChildContaining(visibleRect) ?? this.rootNode;
        const visibleLeaves = image.getLeavesIntersectingRegion(viewport.visibleRect, (rect) => screenRenderer.isTooSmallToRender(rect));
        let approxVisibleRenderTime = 0;
        for (const leaf of visibleLeaves) {
            approxVisibleRenderTime += leaf.getContent().getProportionalRenderingTime();
        }
        if (approxVisibleRenderTime > this.sharedState.props.minProportionalRenderTimeToUseCache) {
            this.rootNode.renderItems(screenRenderer, [image], viewport);
        }
        else {
            image.render(screenRenderer, visibleRect);
        }
    }
    getDebugInfo() {
        return this.recordManager.getDebugInfo();
    }
    setIsDebugMode(debugMode) {
        this.sharedState.debugMode = debugMode;
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/rendering/caching/RenderingCacheNode.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/rendering/caching/RenderingCacheNode.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RenderingCacheNode)
/* harmony export */ });
/* harmony import */ var _image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../image/EditorImage.mjs */ "./node_modules/js-draw/dist/mjs/image/EditorImage.mjs");
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
// A cache record with sub-nodes.


// 3x3 divisions for each node.
const cacheDivisionSize = 3;
class RenderingCacheNode {
    constructor(region, cacheState) {
        this.region = region;
        this.cacheState = cacheState;
        // invariant: instantiatedChildren.length === 9
        this.instantiatedChildren = [];
        this.parent = null;
        this.cachedRenderer = null;
        // invariant: sortedInAscendingOrder(renderedIds)
        this.renderedIds = [];
        this.renderedMaxZIndex = null;
    }
    // Creates a previous layer of the cache tree and adds this as a child near the
    // center of the previous layer's children.
    // Returns this' parent if it already exists.
    generateParent() {
        if (this.parent) {
            return this.parent;
        }
        const parentRegion = _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Rect2.fromCorners(this.region.topLeft.minus(this.region.size), this.region.bottomRight.plus(this.region.size));
        const parent = new RenderingCacheNode(parentRegion, this.cacheState);
        parent.generateChildren();
        // Ensure the new node is matches the middle child's region.
        const checkTolerance = this.region.maxDimension / 100;
        const middleChildIdx = (parent.instantiatedChildren.length - 1) / 2;
        if (!parent.instantiatedChildren[middleChildIdx].region.eq(this.region, checkTolerance)) {
            console.error(parent.instantiatedChildren[middleChildIdx].region, '≠', this.region);
            throw new Error("Logic error: [this] is not contained within its parent's center child");
        }
        // Replace the middle child
        parent.instantiatedChildren[middleChildIdx] = this;
        this.parent = parent;
        return parent;
    }
    // Generates children, if missing.
    generateChildren() {
        if (this.instantiatedChildren.length === 0) {
            if (this.region.size.x / cacheDivisionSize === 0 ||
                this.region.size.y / cacheDivisionSize === 0) {
                console.warn('Cache element has zero size! Not generating children.');
                return;
            }
            const childRects = this.region.divideIntoGrid(cacheDivisionSize, cacheDivisionSize);
            console.assert(childRects.length === cacheDivisionSize * cacheDivisionSize, 'Warning: divideIntoGrid created the wrong number of subrectangles!');
            for (const rect of childRects) {
                const child = new RenderingCacheNode(rect, this.cacheState);
                child.parent = this;
                this.instantiatedChildren.push(child);
            }
        }
        this.checkRep();
    }
    // Returns CacheNodes directly contained within this.
    getChildren() {
        this.checkRep();
        this.generateChildren();
        return this.instantiatedChildren;
    }
    smallestChildContaining(rect) {
        const largerThanChildren = rect.maxDimension > this.region.maxDimension / cacheDivisionSize;
        if (!this.region.containsRect(rect) || largerThanChildren) {
            return null;
        }
        for (const child of this.getChildren()) {
            if (child.region.containsRect(rect)) {
                return child.smallestChildContaining(rect) ?? child;
            }
        }
        return null;
    }
    // => [true] iff [this] can be rendered without too much scaling
    renderingWouldBeHighEnoughResolution(viewport) {
        // Determine how 1px in this corresponds to 1px on the canvas.
        //  this.region.w is in canvas units. Thus,
        const sizeOfThisPixelOnCanvas = this.region.w / this.cacheState.props.blockResolution.x;
        const sizeOfThisPixelOnScreen = viewport.getScaleFactor() * sizeOfThisPixelOnCanvas;
        if (sizeOfThisPixelOnScreen > this.cacheState.props.maxScale) {
            return false;
        }
        return true;
    }
    // => [true] if all children of this can be rendered from their caches.
    allChildrenCanRender(viewport, leavesSortedById) {
        if (this.instantiatedChildren.length === 0) {
            return false;
        }
        for (const child of this.instantiatedChildren) {
            if (!child.region.intersects(viewport.visibleRect)) {
                continue;
            }
            if (!child.renderingIsUpToDate(this.idsOfIntersecting(leavesSortedById))) {
                return false;
            }
        }
        return true;
    }
    computeSortedByLeafIds(leaves) {
        const ids = leaves.slice();
        ids.sort((a, b) => a.getId() - b.getId());
        return ids;
    }
    // Returns a list of the ids of the nodes intersecting this
    idsOfIntersecting(nodes) {
        const result = [];
        for (const node of nodes) {
            if (node.getBBox().intersects(this.region)) {
                result.push(node.getId());
            }
        }
        return result;
    }
    // Returns true iff all elems of this.renderedIds are in sortedIds.
    // sortedIds should be sorted by z-index (or some other order, so long as they are
    // sorted by the same thing as this.renderedIds.)
    allRenderedIdsIn(sortedIds) {
        if (this.renderedIds.length > sortedIds.length) {
            return false;
        }
        for (let i = 0; i < this.renderedIds.length; i++) {
            if (sortedIds[i] !== this.renderedIds[i]) {
                return false;
            }
        }
        return true;
    }
    renderingIsUpToDate(sortedIds) {
        if (this.cachedRenderer === null || sortedIds.length !== this.renderedIds.length) {
            return false;
        }
        return this.allRenderedIdsIn(sortedIds);
    }
    // Render all [items] within [viewport]
    renderItems(screenRenderer, items, viewport) {
        if (!viewport.visibleRect.intersects(this.region) || items.length === 0) {
            return;
        }
        // Divide [items] until nodes are smaller than this, or are leaves.
        const divideUntilSmallerThanThis = (itemsToDivide) => {
            const newItems = [];
            for (const item of itemsToDivide) {
                const bbox = item.getBBox();
                if (!bbox.intersects(this.region)) {
                    continue;
                }
                if (bbox.maxDimension >= this.region.maxDimension) {
                    newItems.push(...item.getChildrenOrSelfIntersectingRegion(this.region));
                }
                else {
                    newItems.push(item);
                }
            }
            return newItems;
        };
        items = divideUntilSmallerThanThis(items);
        // Can we cache at all?
        if (!this.cacheState.props.isOfCorrectType(screenRenderer)) {
            for (const item of items) {
                item.render(screenRenderer, viewport.visibleRect);
            }
            return;
        }
        if (this.cacheState.debugMode) {
            screenRenderer.drawRect(this.region, viewport.getSizeOfPixelOnCanvas(), {
                fill: _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Color4.yellow,
            });
        }
        // Could we render direclty from [this] or do we need to recurse?
        const couldRender = this.renderingWouldBeHighEnoughResolution(viewport);
        if (!couldRender) {
            for (const child of this.getChildren()) {
                child.renderItems(screenRenderer, items.filter((item) => {
                    return item.getBBox().intersects(child.region);
                }), viewport);
            }
        }
        else {
            // Determine whether we already have rendered the items
            const tooSmallToRender = (rect) => rect.w / this.region.w < 1 / this.cacheState.props.blockResolution.x;
            const leaves = [];
            for (const item of items) {
                leaves.push(...item.getLeavesIntersectingRegion(this.region, tooSmallToRender));
            }
            (0,_image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_0__.sortLeavesByZIndex)(leaves);
            const leavesByIds = this.computeSortedByLeafIds(leaves);
            // No intersecting leaves? No need to render
            if (leavesByIds.length === 0) {
                return;
            }
            const leafIds = leavesByIds.map((leaf) => leaf.getId());
            let thisRenderer;
            if (!this.renderingIsUpToDate(leafIds)) {
                if (this.allChildrenCanRender(viewport, leavesByIds)) {
                    for (const child of this.getChildren()) {
                        child.renderItems(screenRenderer, items, viewport);
                    }
                    return;
                }
                let leafApproxRenderTime = 0;
                for (const leaf of leavesByIds) {
                    if (!tooSmallToRender(leaf.getBBox())) {
                        leafApproxRenderTime += leaf.getContent().getProportionalRenderingTime();
                    }
                }
                // Is it worth it to render the items?
                if (leafApproxRenderTime > this.cacheState.props.minProportionalRenderTimePerCache) {
                    let fullRerenderNeeded = true;
                    if (!this.cachedRenderer) {
                        this.cachedRenderer = this.cacheState.recordManager.allocCanvas(this.region, () => this.onRegionDealloc());
                    }
                    else if (leavesByIds.length > this.renderedIds.length &&
                        this.allRenderedIdsIn(leafIds) &&
                        this.renderedMaxZIndex !== null) {
                        // We often don't need to do a full re-render even if something's changed.
                        // Check whether we can just draw on top of the existing cache.
                        const newLeaves = [];
                        let minNewZIndex = null;
                        for (let i = 0; i < leavesByIds.length; i++) {
                            const leaf = leavesByIds[i];
                            const content = leaf.getContent();
                            const zIndex = content.getZIndex();
                            if (i >= this.renderedIds.length || leaf.getId() !== this.renderedIds[i]) {
                                newLeaves.push(leaf);
                                if (minNewZIndex === null || zIndex < minNewZIndex) {
                                    minNewZIndex = zIndex;
                                }
                            }
                        }
                        if (minNewZIndex !== null && minNewZIndex > this.renderedMaxZIndex) {
                            fullRerenderNeeded = false;
                            thisRenderer = this.cachedRenderer.startRender();
                            // Looping is faster than re-sorting.
                            for (let i = 0; i < leaves.length; i++) {
                                const leaf = leaves[i];
                                const zIndex = leaf.getContent().getZIndex();
                                if (zIndex > this.renderedMaxZIndex) {
                                    leaf.render(thisRenderer, this.region);
                                    this.renderedMaxZIndex = zIndex;
                                }
                            }
                            if (this.cacheState.debugMode) {
                                // Clay for adding new elements
                                screenRenderer.drawRect(this.region, 2 * viewport.getSizeOfPixelOnCanvas(), {
                                    fill: _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Color4.clay,
                                });
                            }
                        }
                    }
                    else if (this.cacheState.debugMode) {
                        console.log('Decided on a full re-render. Reason: At least one of the following is false:', '\n leafIds.length > this.renderedIds.length: ', leafIds.length > this.renderedIds.length, '\n this.allRenderedIdsIn(leafIds): ', this.allRenderedIdsIn(leafIds), '\n this.renderedMaxZIndex !== null: ', this.renderedMaxZIndex !== null, '\n\nthis.rerenderedIds: ', this.renderedIds, ', leafIds: ', leafIds);
                    }
                    if (fullRerenderNeeded) {
                        thisRenderer = this.cachedRenderer.startRender();
                        thisRenderer.clear();
                        this.renderedMaxZIndex = null;
                        const startIndex = (0,_image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_0__.computeFirstIndexToRender)(leaves, this.region);
                        for (let i = startIndex; i < leaves.length; i++) {
                            const leaf = leaves[i];
                            const content = leaf.getContent();
                            this.renderedMaxZIndex ??= content.getZIndex();
                            this.renderedMaxZIndex = Math.max(this.renderedMaxZIndex, content.getZIndex());
                            leaf.render(thisRenderer, this.region);
                        }
                        if (this.cacheState.debugMode) {
                            // Red for full rerender
                            screenRenderer.drawRect(this.region, 3 * viewport.getSizeOfPixelOnCanvas(), {
                                fill: _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Color4.red,
                            });
                        }
                    }
                    this.renderedIds = leafIds;
                }
                else {
                    this.cachedRenderer?.dealloc();
                    // Slightly increase the clip region to prevent seams.
                    // Divide by two because grownBy expands the rectangle on all sides.
                    const pixelSize = viewport.getSizeOfPixelOnCanvas();
                    const expandedRegion = new _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Rect2(this.region.x, this.region.y, this.region.w + pixelSize, this.region.h + pixelSize);
                    const clip = true;
                    screenRenderer.startObject(expandedRegion, clip);
                    for (const leaf of leaves) {
                        leaf.render(screenRenderer, this.region.intersection(viewport.visibleRect));
                    }
                    screenRenderer.endObject();
                    if (this.cacheState.debugMode) {
                        // Green for no cache needed render
                        screenRenderer.drawRect(this.region, 2 * viewport.getSizeOfPixelOnCanvas(), {
                            fill: _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Color4.green,
                        });
                    }
                }
            }
            else {
                thisRenderer = this.cachedRenderer.startRender();
            }
            if (thisRenderer) {
                const transformMat = this.cachedRenderer.getTransform(this.region).inverse();
                screenRenderer.renderFromOtherOfSameType(transformMat, thisRenderer);
            }
            // Can we clean up this' children? (Are they unused?)
            if (this.instantiatedChildren.every((child) => child.isEmpty())) {
                this.instantiatedChildren = [];
            }
        }
        this.checkRep();
    }
    // Returns true iff this/its children have no cached state.
    isEmpty() {
        if (this.cachedRenderer !== null) {
            return false;
        }
        return this.instantiatedChildren.every((child) => child.isEmpty());
    }
    onRegionDealloc() {
        this.cachedRenderer = null;
        if (this.isEmpty()) {
            this.instantiatedChildren = [];
        }
    }
    checkRep() {
        if (this.instantiatedChildren.length !== cacheDivisionSize * cacheDivisionSize &&
            this.instantiatedChildren.length !== 0) {
            throw new Error(`Repcheck: Wrong number of children. Got ${this.instantiatedChildren.length}`);
        }
        if (this.renderedIds[1] !== undefined && this.renderedIds[0] >= this.renderedIds[1]) {
            console.error(this.renderedIds);
            throw new Error('Repcheck: First two ids are not in ascending order!');
        }
        for (const child of this.instantiatedChildren) {
            if (child.parent !== this) {
                throw new Error('Children should be linked to their parents!');
            }
        }
        if (this.cachedRenderer && !this.cachedRenderer.isAllocd()) {
            throw new Error("this' cachedRenderer != null, but is dealloc'd");
        }
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/rendering/lib.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/rendering/lib.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractRenderer: () => (/* reexport safe */ _renderers_AbstractRenderer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   CanvasRenderer: () => (/* reexport safe */ _renderers_CanvasRenderer_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   Display: () => (/* reexport safe */ _Display_mjs__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   DummyRenderer: () => (/* reexport safe */ _renderers_DummyRenderer_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   RenderingMode: () => (/* reexport safe */ _Display_mjs__WEBPACK_IMPORTED_MODULE_4__.RenderingMode),
/* harmony export */   SVGRenderer: () => (/* reexport safe */ _renderers_SVGRenderer_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   pathFromRenderable: () => (/* reexport safe */ _RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_5__.pathFromRenderable),
/* harmony export */   pathToRenderable: () => (/* reexport safe */ _RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_5__.pathToRenderable),
/* harmony export */   pathVisualEquivalent: () => (/* reexport safe */ _RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_5__.visualEquivalent)
/* harmony export */ });
/* harmony import */ var _renderers_AbstractRenderer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./renderers/AbstractRenderer.mjs */ "./node_modules/js-draw/dist/mjs/rendering/renderers/AbstractRenderer.mjs");
/* harmony import */ var _renderers_DummyRenderer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./renderers/DummyRenderer.mjs */ "./node_modules/js-draw/dist/mjs/rendering/renderers/DummyRenderer.mjs");
/* harmony import */ var _renderers_SVGRenderer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./renderers/SVGRenderer.mjs */ "./node_modules/js-draw/dist/mjs/rendering/renderers/SVGRenderer.mjs");
/* harmony import */ var _renderers_CanvasRenderer_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./renderers/CanvasRenderer.mjs */ "./node_modules/js-draw/dist/mjs/rendering/renderers/CanvasRenderer.mjs");
/* harmony import */ var _Display_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Display.mjs */ "./node_modules/js-draw/dist/mjs/rendering/Display.mjs");
/* harmony import */ var _RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RenderablePathSpec.mjs */ "./node_modules/js-draw/dist/mjs/rendering/RenderablePathSpec.mjs");








/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/rendering/localization.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/rendering/localization.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultTextRendererLocalization: () => (/* binding */ defaultTextRendererLocalization)
/* harmony export */ });
const defaultTextRendererLocalization = {
    pathNodeCount: (count) => `There are ${count} visible path objects.`,
    textNodeCount: (count) => `There are ${count} visible text nodes.`,
    imageNodeCount: (nodeCount) => `There are ${nodeCount} visible image nodes.`,
    textNode: (content) => `Text: ${content}`,
    imageNode: (label) => `Image: ${label}`,
    unlabeledImageNode: 'Unlabeled image',
    rerenderAsText: 'Re-render as text',
};


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/rendering/renderers/AbstractRenderer.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/rendering/renderers/AbstractRenderer.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AbstractRenderer)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _RenderingStyle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../RenderingStyle.mjs */ "./node_modules/js-draw/dist/mjs/rendering/RenderingStyle.mjs");
/* harmony import */ var _RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../RenderablePathSpec.mjs */ "./node_modules/js-draw/dist/mjs/rendering/RenderablePathSpec.mjs");



/**
 * Abstract base class for renderers.
 *
 * @see {@link EditorImage.render}
 */
class AbstractRenderer {
    constructor(viewport) {
        this.viewport = viewport;
        // If null, this' transformation is linked to the Viewport
        this.selfTransform = null;
        this.transformStack = [];
        this.objectLevel = 0;
        this.currentPaths = null;
    }
    /**
     * this.canvasToScreen, etc. should be used instead of the corresponding
     * methods on `Viewport`, because the viewport may not accurately reflect
     * what is rendered.
     */
    getViewport() {
        return this.viewport;
    }
    setDraftMode(_draftMode) { }
    flushPath() {
        if (!this.currentPaths) {
            return;
        }
        let lastStyle = null;
        for (const path of this.currentPaths) {
            const { startPoint, commands, style } = path;
            if (!lastStyle || !(0,_RenderingStyle_mjs__WEBPACK_IMPORTED_MODULE_1__.stylesEqual)(lastStyle, style)) {
                if (lastStyle) {
                    this.endPath(lastStyle);
                }
                this.beginPath(startPoint);
                lastStyle = style;
            }
            else {
                this.moveTo(startPoint);
            }
            for (const command of commands) {
                if (command.kind === _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo) {
                    this.lineTo(command.point);
                }
                else if (command.kind === _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.MoveTo) {
                    this.moveTo(command.point);
                }
                else if (command.kind === _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.CubicBezierTo) {
                    this.traceCubicBezierCurve(command.controlPoint1, command.controlPoint2, command.endPoint);
                }
                else if (command.kind === _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.QuadraticBezierTo) {
                    this.traceQuadraticBezierCurve(command.controlPoint, command.endPoint);
                }
            }
        }
        if (lastStyle) {
            this.endPath(lastStyle);
        }
        this.currentPaths = [];
    }
    /**
     * Draws a styled path. If within an object started by {@link startObject},
     * the resultant path may not be visible until {@link endObject} is called.
     */
    drawPath(path) {
        // If we're being called outside of an object,
        // we can't delay rendering
        if (this.objectLevel === 0 || this.currentPaths === null) {
            this.currentPaths = [path];
            this.flushPath();
            this.currentPaths = null;
        }
        else {
            // Otherwise, don't render paths all at once. This prevents faint lines between
            // segments of the same stroke from being visible.
            this.currentPaths.push(path);
        }
    }
    // Strokes a rectangle. Boundary lines have width [lineWidth] and are filled with [lineFill].
    // This is equivalent to `drawPath(Path.fromRect(...).toRenderable(...))`.
    drawRect(rect, lineWidth, lineFill) {
        const path = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Path.fromRect(rect, lineWidth);
        this.drawPath((0,_RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_2__.pathToRenderable)(path, lineFill));
    }
    /** Draws a filled rectangle. */
    fillRect(rect, fill) {
        const path = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Path.fromRect(rect);
        this.drawPath((0,_RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_2__.pathToRenderable)(path, { fill }));
    }
    /**
     * This should be called whenever a new object is being drawn.
     *
     * @param _boundingBox The bounding box of the object to be drawn.
     * @param _clip Whether content outside `_boundingBox` should be drawn. Renderers
     *              that override this method are not required to support `_clip`.
     */
    startObject(_boundingBox, _clip) {
        if (this.objectLevel > 0) {
            this.flushPath();
        }
        this.currentPaths = [];
        this.objectLevel++;
    }
    /**
     * Notes the end of an object.
     * @param _loaderData - a map from strings to JSON-ifyable objects
     * and contains properties attached to the object by whatever loader loaded the image. This
     * is used to preserve attributes not supported by js-draw when loading/saving an image.
     * Renderers may ignore this.
     *
     * @param _objectTags - a list of labels (e.g. `className`s) to be attached to the object.
     * Renderers may ignore this.
     */
    endObject(_loaderData, _objectTags) {
        // Render the paths all at once
        this.flushPath();
        this.currentPaths = null;
        this.objectLevel--;
        if (this.objectLevel < 0) {
            throw new Error('More objects have ended than have been started (negative object nesting level)!');
        }
    }
    getNestingLevel() {
        return this.objectLevel;
    }
    // Returns true iff other can be rendered onto this without data loss.
    canRenderFromWithoutDataLoss(_other) {
        return false;
    }
    // MUST throw if other and this are not of the same base class.
    renderFromOtherOfSameType(_renderTo, other) {
        throw new Error(`Unable to render from ${other}: Not implemented`);
    }
    // Set a transformation to apply to things before rendering,
    // replacing the viewport's transform.
    setTransform(transform) {
        this.selfTransform = transform;
    }
    pushTransform(transform) {
        this.transformStack.push(this.selfTransform);
        this.setTransform(this.getCanvasToScreenTransform().rightMul(transform));
    }
    popTransform() {
        if (this.transformStack.length === 0) {
            throw new Error('Unable to pop more transforms than have been pushed!');
        }
        this.setTransform(this.transformStack.pop() ?? null);
    }
    // Get the matrix that transforms a vector on the canvas to a vector on this'
    // rendering target.
    getCanvasToScreenTransform() {
        if (this.selfTransform) {
            return this.selfTransform;
        }
        return this.viewport.canvasToScreenTransform;
    }
    canvasToScreen(vec) {
        return this.getCanvasToScreenTransform().transformVec2(vec);
    }
    getSizeOfCanvasPixelOnScreen() {
        return this.getCanvasToScreenTransform().transformVec3(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.unitX).length();
    }
    /**
     * @internal
     */
    overrideVisibleRect(rect) {
        this.visibleRectOverride = rect;
    }
    // Returns the region in canvas space that is visible within the viewport this
    // canvas is rendering to.
    //
    // Note that in some cases this might not be the same as the `visibleRect` given
    // to components in their `render` method.
    getVisibleRect() {
        return this.visibleRectOverride ?? this.viewport.visibleRect;
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/rendering/renderers/CanvasRenderer.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/rendering/renderers/CanvasRenderer.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CanvasRenderer)
/* harmony export */ });
/* harmony import */ var _components_TextComponent_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../components/TextComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/TextComponent.mjs");
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _AbstractRenderer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbstractRenderer.mjs */ "./node_modules/js-draw/dist/mjs/rendering/renderers/AbstractRenderer.mjs");
/* harmony import */ var _RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../RenderablePathSpec.mjs */ "./node_modules/js-draw/dist/mjs/rendering/RenderablePathSpec.mjs");




/**
 * Renders onto a `CanvasRenderingContext2D`.
 *
 * **Example**:
 * [[include:doc-pages/inline-examples/canvas-renderer.md]]
 */
class CanvasRenderer extends _AbstractRenderer_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /**
     * Creates a new `CanvasRenderer` that renders to the given rendering context.
     * The `viewport` is used to determine the translation/rotation/scaling of the content
     * to draw.
     */
    constructor(ctx, viewport) {
        super(viewport);
        this.ctx = ctx;
        this.ignoreObjectsAboveLevel = null;
        this.ignoringObject = false;
        this.currentObjectBBox = null;
        this.clipLevels = [];
        this.setDraftMode(false);
    }
    transformBy(transformBy) {
        // From MDN, transform(a,b,c,d,e,f)
        // takes input such that
        // ⎡ a c e ⎤
        // ⎢ b d f ⎥ transforms content drawn to [ctx].
        // ⎣ 0 0 1 ⎦
        this.ctx.transform(transformBy.a1, transformBy.b1, // a, b
        transformBy.a2, transformBy.b2, // c, d
        transformBy.a3, transformBy.b3);
    }
    canRenderFromWithoutDataLoss(other) {
        return other instanceof CanvasRenderer;
    }
    renderFromOtherOfSameType(transformBy, other) {
        if (!(other instanceof CanvasRenderer)) {
            throw new Error(`${other} cannot be rendered onto ${this}`);
        }
        transformBy = this.getCanvasToScreenTransform().rightMul(transformBy);
        this.ctx.save();
        this.transformBy(transformBy);
        this.ctx.drawImage(other.ctx.canvas, 0, 0);
        this.ctx.restore();
    }
    // Set parameters for lower/higher quality rendering
    setDraftMode(draftMode) {
        if (draftMode) {
            this.minSquareCurveApproxDist = 9;
            this.minRenderSizeBothDimens = 1;
            this.minRenderSizeAnyDimen = 0.1;
        }
        else {
            this.minSquareCurveApproxDist = 0.5;
            this.minRenderSizeBothDimens = 0.1;
            this.minRenderSizeAnyDimen = 1e-6;
        }
    }
    displaySize() {
        return _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(this.ctx.canvas.clientWidth, this.ctx.canvas.clientHeight);
    }
    clear() {
        this.ctx.save();
        this.ctx.resetTransform();
        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
        this.ctx.restore();
    }
    beginPath(startPoint) {
        startPoint = this.canvasToScreen(startPoint);
        this.ctx.beginPath();
        this.ctx.moveTo(startPoint.x, startPoint.y);
    }
    endPath(style) {
        // Saving and restoring can be slow in some browsers
        // (e.g. 0.50ms). Avoid.
        //this.ctx.save();
        // If not a transparent fill
        if (style.fill.a > 0) {
            this.ctx.fillStyle = style.fill.toHexString();
            this.ctx.fill();
        }
        if (style.stroke) {
            this.ctx.strokeStyle = style.stroke.color.toHexString();
            this.ctx.lineWidth = this.getSizeOfCanvasPixelOnScreen() * style.stroke.width;
            this.ctx.lineCap = 'round';
            this.ctx.lineJoin = 'round';
            this.ctx.stroke();
            this.ctx.lineWidth = 1;
        }
        this.ctx.closePath();
        //this.ctx.restore();
    }
    lineTo(point) {
        point = this.canvasToScreen(point);
        this.ctx.lineTo(point.x, point.y);
    }
    moveTo(point) {
        point = this.canvasToScreen(point);
        this.ctx.moveTo(point.x, point.y);
    }
    traceCubicBezierCurve(p1, p2, p3) {
        p1 = this.canvasToScreen(p1);
        p2 = this.canvasToScreen(p2);
        p3 = this.canvasToScreen(p3);
        // Approximate the curve if small enough.
        const delta1 = p2.minus(p1);
        const delta2 = p3.minus(p2);
        if (delta1.magnitudeSquared() < this.minSquareCurveApproxDist &&
            delta2.magnitudeSquared() < this.minSquareCurveApproxDist) {
            this.ctx.lineTo(p3.x, p3.y);
        }
        else {
            this.ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
        }
    }
    traceQuadraticBezierCurve(controlPoint, endPoint) {
        controlPoint = this.canvasToScreen(controlPoint);
        endPoint = this.canvasToScreen(endPoint);
        // Approximate the curve with a line if small enough
        const delta = controlPoint.minus(endPoint);
        if (delta.magnitudeSquared() < this.minSquareCurveApproxDist) {
            this.ctx.lineTo(endPoint.x, endPoint.y);
        }
        else {
            this.ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, endPoint.x, endPoint.y);
        }
    }
    drawPath(path) {
        if (this.ignoringObject) {
            return;
        }
        // If part of a huge object, it might be worth trimming the path
        const visibleRect = this.getVisibleRect();
        if (this.currentObjectBBox?.containsRect(visibleRect)) {
            // Try to trim/remove parts of the path outside of the bounding box.
            path = (0,_RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_3__.visualEquivalent)(path, visibleRect);
        }
        super.drawPath(path);
    }
    drawText(text, transform, style) {
        this.ctx.save();
        transform = this.getCanvasToScreenTransform().rightMul(transform);
        this.transformBy(transform);
        _components_TextComponent_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].applyTextStyles(this.ctx, style);
        if (style.renderingStyle.fill.a !== 0) {
            this.ctx.fillStyle = style.renderingStyle.fill.toHexString();
            this.ctx.fillText(text, 0, 0);
        }
        if (style.renderingStyle.stroke) {
            this.ctx.strokeStyle = style.renderingStyle.stroke.color.toHexString();
            this.ctx.lineWidth = style.renderingStyle.stroke.width;
            this.ctx.strokeText(text, 0, 0);
        }
        this.ctx.restore();
    }
    drawImage(image) {
        // .drawImage can fail for zero-size images.
        if (image.image.width === 0 || image.image.height === 0) {
            return;
        }
        this.ctx.save();
        const transform = this.getCanvasToScreenTransform().rightMul(image.transform);
        this.transformBy(transform);
        this.ctx.drawImage(image.image, 0, 0);
        this.ctx.restore();
    }
    startObject(boundingBox, clip) {
        if (this.isTooSmallToRender(boundingBox)) {
            this.ignoreObjectsAboveLevel = this.getNestingLevel();
            this.ignoringObject = true;
        }
        super.startObject(boundingBox);
        this.currentObjectBBox = boundingBox;
        if (!this.ignoringObject && clip) {
            // Don't clip if it would only remove content already trimmed by
            // the edge of the screen.
            const clippedIsOutsideScreen = boundingBox.containsRect(this.getVisibleRect());
            if (!clippedIsOutsideScreen) {
                this.clipLevels.push(this.objectLevel);
                this.ctx.save();
                this.ctx.beginPath();
                for (const corner of boundingBox.corners) {
                    const screenCorner = this.canvasToScreen(corner);
                    this.ctx.lineTo(screenCorner.x, screenCorner.y);
                }
                this.ctx.clip();
            }
        }
    }
    endObject() {
        // Cache this.objectLevel — it may be decremented by super.endObject.
        const objectLevel = this.objectLevel;
        this.currentObjectBBox = null;
        super.endObject();
        if (!this.ignoringObject && this.clipLevels.length > 0) {
            if (this.clipLevels[this.clipLevels.length - 1] === objectLevel) {
                this.ctx.restore();
                this.clipLevels.pop();
            }
        }
        // If exiting an object with a too-small-to-draw bounding box,
        if (this.ignoreObjectsAboveLevel !== null &&
            this.getNestingLevel() <= this.ignoreObjectsAboveLevel) {
            this.ignoreObjectsAboveLevel = null;
            this.ignoringObject = false;
        }
    }
    // @internal
    drawPoints(...points) {
        const pointRadius = 10;
        for (let i = 0; i < points.length; i++) {
            const point = this.canvasToScreen(points[i]);
            this.ctx.beginPath();
            this.ctx.arc(point.x, point.y, pointRadius, 0, Math.PI * 2);
            this.ctx.fillStyle = _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Color4.ofRGBA(0.5 + Math.sin(i) / 2, 1.0, 0.5 + Math.cos(i * 0.2) / 4, 0.5).toHexString();
            this.ctx.lineWidth = 2;
            this.ctx.fill();
            this.ctx.stroke();
            this.ctx.closePath();
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.fillStyle = 'black';
            this.ctx.fillText(`${i}`, point.x, point.y, pointRadius * 2);
        }
    }
    // @internal
    isTooSmallToRender(rect) {
        // Should we ignore all objects within this object's bbox?
        const diagonal = rect.size.times(this.getSizeOfCanvasPixelOnScreen());
        const bothDimenMinSize = this.minRenderSizeBothDimens;
        const bothTooSmall = Math.abs(diagonal.x) < bothDimenMinSize && Math.abs(diagonal.y) < bothDimenMinSize;
        const anyDimenMinSize = this.minRenderSizeAnyDimen;
        const anyTooSmall = Math.abs(diagonal.x) < anyDimenMinSize || Math.abs(diagonal.y) < anyDimenMinSize;
        return bothTooSmall || anyTooSmall;
    }
    // @internal
    static fromViewport(exportViewport, options = {}) {
        const canvas = document.createElement('canvas');
        const exportRectSize = exportViewport.getScreenRectSize();
        let canvasSize = options.canvasSize ?? exportRectSize;
        if (options.maxCanvasDimen && canvasSize.maximumEntryMagnitude() > options.maxCanvasDimen) {
            canvasSize = canvasSize.times(options.maxCanvasDimen / canvasSize.maximumEntryMagnitude());
        }
        canvas.width = canvasSize.x;
        canvas.height = canvasSize.y;
        const ctx = canvas.getContext('2d');
        // Scale to ensure that the entire output is visible.
        const scaleFactor = Math.min(canvasSize.x / exportRectSize.x, canvasSize.y / exportRectSize.y);
        ctx.scale(scaleFactor, scaleFactor);
        return { renderer: new CanvasRenderer(ctx, exportViewport), element: canvas };
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/rendering/renderers/DummyRenderer.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/rendering/renderers/DummyRenderer.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DummyRenderer)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _AbstractRenderer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AbstractRenderer.mjs */ "./node_modules/js-draw/dist/mjs/rendering/renderers/AbstractRenderer.mjs");


// Renderer that outputs almost nothing. Useful for automated tests.
class DummyRenderer extends _AbstractRenderer_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(viewport) {
        super(viewport);
        // Variables that track the state of what's been rendered
        this.clearedCount = 0;
        this.renderedPathCount = 0;
        this.lastFillStyle = null;
        this.lastPoint = null;
        this.objectNestingLevel = 0;
        this.lastText = null;
        this.lastImage = null;
        // List of points drawn since the last clear.
        this.pointBuffer = [];
    }
    displaySize() {
        // Do we have a stored viewport size?
        const viewportSize = this.getViewport().getScreenRectSize();
        // Don't use a 0x0 viewport — DummyRenderer is often used
        // for tests that run without a display, so pretend we have a
        // reasonable-sized display.
        if (viewportSize.x === 0 || viewportSize.y === 0) {
            return _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(640, 480);
        }
        return viewportSize;
    }
    clear() {
        this.clearedCount++;
        this.renderedPathCount = 0;
        this.pointBuffer = [];
        this.lastText = null;
        this.lastImage = null;
        // Ensure all objects finished rendering
        if (this.objectNestingLevel > 0) {
            throw new Error(`Within an object while clearing! Nesting level: ${this.objectNestingLevel}`);
        }
    }
    beginPath(startPoint) {
        this.lastPoint = startPoint;
        this.pointBuffer.push(startPoint);
    }
    endPath(style) {
        this.renderedPathCount++;
        this.lastFillStyle = style;
    }
    lineTo(point) {
        point = this.canvasToScreen(point);
        this.lastPoint = point;
        this.pointBuffer.push(point);
    }
    moveTo(point) {
        point = this.canvasToScreen(point);
        this.lastPoint = point;
        this.pointBuffer.push(point);
    }
    traceCubicBezierCurve(p1, p2, p3) {
        p1 = this.canvasToScreen(p1);
        p2 = this.canvasToScreen(p2);
        p3 = this.canvasToScreen(p3);
        this.lastPoint = p3;
        this.pointBuffer.push(p1, p2, p3);
    }
    traceQuadraticBezierCurve(controlPoint, endPoint) {
        controlPoint = this.canvasToScreen(controlPoint);
        endPoint = this.canvasToScreen(endPoint);
        this.lastPoint = endPoint;
        this.pointBuffer.push(controlPoint, endPoint);
    }
    drawPoints(..._points) {
        // drawPoints is intended for debugging.
        // As such, it is unlikely to be the target of automated tests.
    }
    drawText(text, _transform, _style) {
        this.lastText = text;
    }
    drawImage(image) {
        this.lastImage = image;
    }
    startObject(boundingBox, _clip) {
        super.startObject(boundingBox);
        this.objectNestingLevel += 1;
    }
    endObject() {
        super.endObject();
        this.objectNestingLevel -= 1;
    }
    isTooSmallToRender(_rect) {
        return false;
    }
    canRenderFromWithoutDataLoss(other) {
        return other instanceof DummyRenderer;
    }
    renderFromOtherOfSameType(transform, other) {
        if (!(other instanceof DummyRenderer)) {
            throw new Error(`${other} cannot be rendered onto ${this}`);
        }
        this.renderedPathCount += other.renderedPathCount;
        this.lastFillStyle = other.lastFillStyle;
        this.lastPoint = other.lastPoint;
        this.pointBuffer.push(...other.pointBuffer.map((point) => {
            return transform.transformVec2(point);
        }));
    }
    toString() {
        return '[DummyRenderer]';
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/rendering/renderers/SVGRenderer.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/rendering/renderers/SVGRenderer.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SVGRenderer),
/* harmony export */   renderedStylesheetId: () => (/* binding */ renderedStylesheetId)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _SVGLoader_SVGLoader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../SVGLoader/SVGLoader.mjs */ "./node_modules/js-draw/dist/mjs/SVGLoader/SVGLoader.mjs");
/* harmony import */ var _RenderingStyle_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../RenderingStyle.mjs */ "./node_modules/js-draw/dist/mjs/rendering/RenderingStyle.mjs");
/* harmony import */ var _AbstractRenderer_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AbstractRenderer.mjs */ "./node_modules/js-draw/dist/mjs/rendering/renderers/AbstractRenderer.mjs");
/* harmony import */ var _RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../RenderablePathSpec.mjs */ "./node_modules/js-draw/dist/mjs/rendering/RenderablePathSpec.mjs");
/* harmony import */ var _util_listPrefixMatch_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/listPrefixMatch.mjs */ "./node_modules/js-draw/dist/mjs/util/listPrefixMatch.mjs");






const renderedStylesheetId = 'js-draw-style-sheet';
const svgNameSpace = 'http://www.w3.org/2000/svg';
const defaultTextStyle = {
    fontWeight: '400',
    fontStyle: 'normal',
};
/**
 * Renders onto an `SVGElement`.
 *
 * @see {@link Editor.toSVG}
 */
class SVGRenderer extends _AbstractRenderer_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    /**
     * Creates a renderer that renders onto `elem`. If `sanitize`, don't render potentially untrusted data.
     *
     * `viewport` is used to determine the translation/rotation/scaling/output size of the rendered
     * data.
     */
    constructor(elem, viewport, sanitize = false) {
        super(viewport);
        this.elem = elem;
        this.sanitize = sanitize;
        this.lastPathStyle = null;
        this.lastPathString = [];
        this.lastContainerIDList = [];
        // Elements that make up the current object (as created by startObject)
        // if any.
        this.objectElems = null;
        this.overwrittenAttrs = {};
        this.textContainer = null;
        this.textContainerTransform = null;
        this.textParentStyle = defaultTextStyle;
        this.clear();
        this.addStyleSheet();
    }
    addStyleSheet() {
        if (!this.elem.querySelector(`#${renderedStylesheetId}`)) {
            // Default to rounded strokes.
            const styleSheet = document.createElementNS('http://www.w3.org/2000/svg', 'style');
            styleSheet.appendChild(document.createTextNode(`
				path {
					stroke-linecap: round;
					stroke-linejoin: round;
				}

				text {
					white-space: pre;
				}
			`.replace(/\s+/g, '')));
            styleSheet.setAttribute('id', renderedStylesheetId);
            this.elem.appendChild(styleSheet);
        }
    }
    // Sets an attribute on the root SVG element.
    setRootSVGAttribute(name, value) {
        if (this.sanitize) {
            return;
        }
        // Make the original value of the attribute restorable on clear
        if (!(name in this.overwrittenAttrs)) {
            this.overwrittenAttrs[name] = this.elem.getAttribute(name);
        }
        if (value !== null) {
            this.elem.setAttribute(name, value);
        }
        else {
            this.elem.removeAttribute(name);
        }
    }
    displaySize() {
        return _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(this.elem.clientWidth, this.elem.clientHeight);
    }
    clear() {
        this.lastPathString = [];
        this.lastContainerIDList = [];
        if (!this.sanitize) {
            // Restore all all attributes
            for (const attrName in this.overwrittenAttrs) {
                const value = this.overwrittenAttrs[attrName];
                if (value) {
                    this.elem.setAttribute(attrName, value);
                }
                else {
                    this.elem.removeAttribute(attrName);
                }
            }
            this.overwrittenAttrs = {};
        }
    }
    // Push `this.fullPath` to the SVG. Returns the path added to the SVG, if any.
    // @internal
    addPathToSVG() {
        if (!this.lastPathStyle || this.lastPathString.length === 0) {
            return null;
        }
        const pathElem = document.createElementNS(svgNameSpace, 'path');
        pathElem.setAttribute('d', this.lastPathString.join(' '));
        const style = this.lastPathStyle;
        if (style.fill.a > 0) {
            pathElem.setAttribute('fill', style.fill.toHexString());
        }
        else {
            pathElem.setAttribute('fill', 'none');
        }
        if (style.stroke) {
            pathElem.setAttribute('stroke', style.stroke.color.toHexString());
            pathElem.setAttribute('stroke-width', (0,_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.toRoundedString)(style.stroke.width * this.getSizeOfCanvasPixelOnScreen()));
        }
        this.elem.appendChild(pathElem);
        this.objectElems?.push(pathElem);
        return pathElem;
    }
    drawPath(pathSpec) {
        const style = pathSpec.style;
        const path = (0,_RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_4__.pathFromRenderable)(pathSpec).transformedBy(this.getCanvasToScreenTransform());
        // Try to extend the previous path, if possible
        if (this.lastPathString.length === 0 ||
            !this.lastPathStyle ||
            !(0,_RenderingStyle_mjs__WEBPACK_IMPORTED_MODULE_2__.stylesEqual)(this.lastPathStyle, style)) {
            this.addPathToSVG();
            this.lastPathStyle = style;
            this.lastPathString = [];
        }
        this.lastPathString.push(path.toString());
    }
    // Apply [elemTransform] to [elem]. Uses both a `matrix` and `.x`, `.y` properties if `setXY` is true.
    // Otherwise, just uses a `matrix`.
    transformFrom(elemTransform, elem, inCanvasSpace = false) {
        const transform = !inCanvasSpace
            ? this.getCanvasToScreenTransform().rightMul(elemTransform)
            : elemTransform;
        if (!transform.eq(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.identity)) {
            const matrixString = transform.toCSSMatrix();
            elem.style.transform = matrixString;
            // Most browsers round the components of CSS transforms.
            // Include a higher precision copy of the element's transform.
            elem.setAttribute('data-highp-transform', matrixString);
        }
        else {
            elem.style.transform = '';
        }
    }
    drawText(text, transform, style) {
        const applyTextStyles = (elem, style) => {
            if (style.fontFamily !== this.textParentStyle?.fontFamily) {
                elem.style.fontFamily = style.fontFamily;
            }
            if (style.fontVariant !== this.textParentStyle?.fontVariant) {
                elem.style.fontVariant = style.fontVariant ?? '';
            }
            if (style.fontWeight !== this.textParentStyle?.fontWeight) {
                elem.style.fontWeight = style.fontWeight ?? '';
            }
            if (style.fontStyle !== this.textParentStyle?.fontStyle) {
                elem.style.fontStyle = style.fontStyle ?? '';
            }
            if (style.size !== this.textParentStyle?.size) {
                elem.style.fontSize = style.size + 'px';
            }
            const fillString = style.renderingStyle.fill.toHexString();
            // TODO: Uncomment at some future major version release --- currently causes incompatibility due
            //       to an SVG parsing bug in older versions.
            //const parentFillString = this.textParentStyle?.renderingStyle?.fill?.toHexString();
            //if (fillString !== parentFillString) {
            elem.style.fill = fillString;
            //}
            if (style.renderingStyle.stroke) {
                const strokeStyle = style.renderingStyle.stroke;
                elem.style.stroke = strokeStyle.color.toHexString();
                elem.style.strokeWidth = strokeStyle.width + 'px';
            }
        };
        transform = this.getCanvasToScreenTransform().rightMul(transform);
        if (!this.textContainer) {
            const container = document.createElementNS(svgNameSpace, 'text');
            container.appendChild(document.createTextNode(text));
            this.transformFrom(transform, container, true);
            applyTextStyles(container, style);
            this.elem.appendChild(container);
            this.objectElems?.push(container);
            if (this.objectLevel > 0) {
                this.textContainer = container;
                this.textContainerTransform = transform;
                this.textParentStyle = { ...defaultTextStyle, ...style };
            }
        }
        else {
            const elem = document.createElementNS(svgNameSpace, 'tspan');
            elem.appendChild(document.createTextNode(text));
            this.textContainer.appendChild(elem);
            // Make .x/.y relative to the parent.
            transform = this.textContainerTransform.inverse().rightMul(transform);
            // .style.transform does nothing to tspan elements. As such, we need to set x/y:
            const translation = transform.transformVec2(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.zero);
            elem.setAttribute('x', `${(0,_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.toRoundedString)(translation.x)}`);
            elem.setAttribute('y', `${(0,_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.toRoundedString)(translation.y)}`);
            applyTextStyles(elem, style);
        }
    }
    drawImage(image) {
        let label = image.label ?? image.image.getAttribute('aria-label') ?? '';
        if (label === '') {
            label = image.image.getAttribute('alt') ?? '';
        }
        const svgImgElem = document.createElementNS(svgNameSpace, 'image');
        svgImgElem.setAttribute('href', image.base64Url);
        svgImgElem.setAttribute('width', image.image.getAttribute('width') ?? '');
        svgImgElem.setAttribute('height', image.image.getAttribute('height') ?? '');
        svgImgElem.setAttribute('aria-label', label);
        this.transformFrom(image.transform, svgImgElem);
        this.elem.appendChild(svgImgElem);
        this.objectElems?.push(svgImgElem);
    }
    startObject(boundingBox) {
        super.startObject(boundingBox);
        // Only accumulate a path within an object
        this.lastPathString = [];
        this.lastPathStyle = null;
        this.textContainer = null;
        this.textParentStyle = defaultTextStyle;
        this.objectElems = [];
    }
    endObject(loaderData, elemClassNames) {
        super.endObject(loaderData);
        // Don't extend paths across objects
        this.addPathToSVG();
        // If empty/not an object, stop.
        if (!this.objectElems) {
            return;
        }
        if (loaderData && !this.sanitize) {
            // Restore any attributes unsupported by the app.
            for (const elem of this.objectElems) {
                const attrs = loaderData[_SVGLoader_SVGLoader_mjs__WEBPACK_IMPORTED_MODULE_1__.svgAttributesDataKey];
                const styleAttrs = loaderData[_SVGLoader_SVGLoader_mjs__WEBPACK_IMPORTED_MODULE_1__.svgStyleAttributesDataKey];
                if (attrs) {
                    for (const [attr, value] of attrs) {
                        elem.setAttribute(attr, value);
                    }
                }
                if (styleAttrs) {
                    for (const attr of styleAttrs) {
                        elem.style.setProperty(attr.key, attr.value, attr.priority);
                    }
                }
            }
            // Update the parent
            const containerIDData = loaderData[_SVGLoader_SVGLoader_mjs__WEBPACK_IMPORTED_MODULE_1__.svgLoaderAttributeContainerID];
            let containerIDList = [];
            if (containerIDData && containerIDData[0]) {
                // If a string list,
                if (containerIDData[0].length) {
                    containerIDList = containerIDData[0];
                }
            }
            if (containerIDList.length > 0 &&
                // containerIDList must share a prefix with the last ID list
                // otherwise, the z order of elements may have been changed from
                // the original image.
                // In the case that the z order has been changed, keep the current
                // element as a child of the root to preserve z order.
                (0,_util_listPrefixMatch_mjs__WEBPACK_IMPORTED_MODULE_5__["default"])(this.lastContainerIDList, containerIDList) &&
                // The component can add at most one more parent than the previous item.
                this.lastContainerIDList.length >= containerIDList.length - 1) {
                // Select the last
                const containerID = containerIDList[containerIDList.length - 1];
                const containerCandidates = this.elem.querySelectorAll(`g#${containerID}`);
                if (containerCandidates.length >= 1) {
                    const container = containerCandidates[0];
                    // If this is the first time we're entering the group, the
                    // group should be empty.
                    // Otherwise, this may be a case that would break z-ordering.
                    if (container.children.length === 0 ||
                        this.lastContainerIDList.length >= containerIDList.length) {
                        // Move all objectElems to the found container
                        for (const elem of this.objectElems) {
                            elem.remove();
                            container.appendChild(elem);
                        }
                    }
                    else {
                        containerIDList = [];
                    }
                }
            }
            else {
                containerIDList = [];
            }
            this.lastContainerIDList = containerIDList;
        }
        // Add class names to the object, if given.
        if (elemClassNames && this.objectElems) {
            if (this.objectElems.length === 1) {
                this.objectElems[0].classList.add(...elemClassNames);
            }
            else {
                const wrapper = document.createElementNS(svgNameSpace, 'g');
                wrapper.classList.add(...elemClassNames);
                for (const elem of this.objectElems) {
                    elem.remove();
                    wrapper.appendChild(elem);
                }
                this.elem.appendChild(wrapper);
            }
        }
    }
    // Not implemented -- use drawPath instead.
    unimplementedMessage() {
        throw new Error('Not implemenented!');
    }
    beginPath(_startPoint) {
        this.unimplementedMessage();
    }
    endPath(_style) {
        this.unimplementedMessage();
    }
    lineTo(_point) {
        this.unimplementedMessage();
    }
    moveTo(_point) {
        this.unimplementedMessage();
    }
    traceCubicBezierCurve(_controlPoint1, _controlPoint2, _endPoint) {
        this.unimplementedMessage();
    }
    traceQuadraticBezierCurve(_controlPoint, _endPoint) {
        this.unimplementedMessage();
    }
    drawPoints(...points) {
        points.map((point) => {
            const elem = document.createElementNS(svgNameSpace, 'circle');
            elem.setAttribute('cx', `${point.x}`);
            elem.setAttribute('cy', `${point.y}`);
            elem.setAttribute('r', '15');
            this.elem.appendChild(elem);
        });
    }
    // Renders a **copy** of the given element.
    drawSVGElem(elem) {
        if (this.sanitize) {
            return;
        }
        // Don't add multiple copies of the default stylesheet.
        if (elem.tagName.toLowerCase() === 'style' &&
            elem.getAttribute('id') === renderedStylesheetId) {
            return;
        }
        const elemToDraw = elem.cloneNode(true);
        this.elem.appendChild(elemToDraw);
        this.objectElems?.push(elemToDraw);
    }
    isTooSmallToRender(_rect) {
        return false;
    }
    /**
     * Creates a new SVG element and `SVGRenerer` with `width`, `height`, `viewBox`,
     * and other metadata attributes set for the given `Viewport`.
     *
     * If `options` is a `boolean`, it is interpreted as whether to sanitize (not add unknown
     * SVG entities to) the output.
     */
    static fromViewport(viewport, options = true) {
        let sanitize;
        let useViewBoxForPositioning;
        if (typeof options === 'boolean') {
            sanitize = options;
            useViewBoxForPositioning = false;
        }
        else {
            sanitize = options.sanitize ?? true;
            useViewBoxForPositioning = options.useViewBoxForPositioning ?? false;
        }
        const svgNameSpace = 'http://www.w3.org/2000/svg';
        const result = document.createElementNS(svgNameSpace, 'svg');
        const screenRectSize = viewport.getScreenRectSize();
        const visibleRect = viewport.visibleRect;
        let viewBoxComponents;
        if (useViewBoxForPositioning) {
            const exportRect = viewport.visibleRect;
            viewBoxComponents = [exportRect.x, exportRect.y, exportRect.w, exportRect.h];
            // Replace the viewport with a copy that has a modified transform.
            // (Avoids modifying the original viewport).
            viewport = viewport.getTemporaryClone();
            // TODO: This currently discards any rotation information.
            // Render with (0,0) at (0,0) -- the translation is handled by the viewBox.
            viewport.resetTransform(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.identity);
        }
        else {
            viewBoxComponents = [0, 0, screenRectSize.x, screenRectSize.y];
        }
        // rect.x -> size of rect in x direction, rect.y -> size of rect in y direction.
        result.setAttribute('viewBox', viewBoxComponents.map((part) => (0,_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.toRoundedString)(part)).join(' '));
        result.setAttribute('width', (0,_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.toRoundedString)(screenRectSize.x));
        result.setAttribute('height', (0,_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.toRoundedString)(screenRectSize.y));
        // Ensure the image can be identified as an SVG if downloaded.
        // See https://jwatt.org/svg/authoring/
        result.setAttribute('version', '1.1');
        result.setAttribute('baseProfile', 'full');
        result.setAttribute('xmlns', svgNameSpace);
        const renderer = new SVGRenderer(result, viewport, sanitize);
        if (!visibleRect.eq(viewport.visibleRect)) {
            renderer.overrideVisibleRect(visibleRect);
        }
        return { element: result, renderer };
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/rendering/renderers/TextOnlyRenderer.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/rendering/renderers/TextOnlyRenderer.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextOnlyRenderer)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _AbstractRenderer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AbstractRenderer.mjs */ "./node_modules/js-draw/dist/mjs/rendering/renderers/AbstractRenderer.mjs");


// Outputs a description of what was rendered.
class TextOnlyRenderer extends _AbstractRenderer_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(viewport, localizationTable) {
        super(viewport);
        this.localizationTable = localizationTable;
        this.descriptionBuilder = [];
        this.pathCount = 0;
        this.textNodeCount = 0;
        this.imageNodeCount = 0;
    }
    displaySize() {
        // We don't have a graphical display, export a reasonable size.
        return _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(500, 500);
    }
    clear() {
        this.descriptionBuilder = [];
        this.pathCount = 0;
        this.textNodeCount = 0;
        this.imageNodeCount = 0;
    }
    getDescription() {
        return [
            this.localizationTable.pathNodeCount(this.pathCount),
            ...(this.textNodeCount > 0 ? [this.localizationTable.textNodeCount(this.textNodeCount)] : []),
            ...(this.imageNodeCount > 0
                ? [this.localizationTable.imageNodeCount(this.imageNodeCount)]
                : []),
            ...this.descriptionBuilder,
        ].join('\n');
    }
    beginPath(_startPoint) { }
    endPath(_style) {
        this.pathCount++;
    }
    lineTo(_point) { }
    moveTo(_point) { }
    traceCubicBezierCurve(_p1, _p2, _p3) { }
    traceQuadraticBezierCurve(_controlPoint, _endPoint) { }
    drawText(text, _transform, _style) {
        this.descriptionBuilder.push(this.localizationTable.textNode(text));
        this.textNodeCount++;
    }
    drawImage(image) {
        const label = image.label
            ? this.localizationTable.imageNode(image.label)
            : this.localizationTable.unlabeledImageNode;
        this.descriptionBuilder.push(label);
        this.imageNodeCount++;
    }
    isTooSmallToRender(rect) {
        return rect.maxDimension < 15 / this.getSizeOfCanvasPixelOnScreen();
    }
    drawPoints(..._points) { }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/shortcuts/KeyBinding.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/shortcuts/KeyBinding.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ KeyBinding)
/* harmony export */ });
const isUppercaseLetter = (text) => {
    return text.toUpperCase() === text && text.toLowerCase() !== text && text.length === 1;
};
const isLowercaseLetter = (text) => {
    return text.toLowerCase() === text && text.toUpperCase() !== text && text.length === 1;
};
/** Represents a key combination that can trigger a keyboard shortcut. */
class KeyBinding {
    constructor(trigger) {
        this.key = trigger.key;
        this.shiftKey = trigger.shiftKey;
        this.ctrlKey = trigger.ctrlKey;
        this.altKey = trigger.altKey;
        this.metaKey = trigger.metaKey;
        this.controlOrMeta = trigger.controlOrMeta;
    }
    /** Returns true if and only if `keyEvent` should trigger this shortcut. */
    matchesEvent(keyEvent) {
        const lowercaseKey = keyEvent.key?.toLowerCase();
        // Determine whether the input is an upper case letter or not.
        const isUpperCaseKey = isUppercaseLetter(keyEvent.key ?? '');
        const isLowercaseKey = isLowercaseLetter(keyEvent.key ?? '');
        const ctrlKey = (keyEvent.ctrlKey ?? false) || lowercaseKey === 'control';
        const altKey = (keyEvent.altKey ?? false) || lowercaseKey === 'alt';
        const metaKey = (keyEvent.metaKey ?? false) || lowercaseKey === 'meta';
        const shiftKey = (keyEvent.shiftKey ?? isUpperCaseKey) || lowercaseKey === 'shift';
        const keyEventHasCtrlOrMeta = keyEvent.controlOrMeta || keyEvent.ctrlKey || keyEvent.metaKey || false;
        // If we're not working with key codes,
        if (this.key !== keyEvent.code) {
            // Different keys entirely? They don't match.
            if (this.key.toLowerCase() !== lowercaseKey) {
                return false;
            }
            // If a case where the ASCII case of the given key might matter,
            // compare.
            if ((isUpperCaseKey || isLowercaseKey) && this.key !== keyEvent.key) {
                // this.shiftKey may be interpreted as allowing this shortcut to be uppercased.
                // If so, try making this.key uppercase and matching the shortcut.
                const uppercaseKeyMatches = this.shiftKey === true && this.key.toUpperCase() === keyEvent.key;
                if (!uppercaseKeyMatches) {
                    return false;
                }
            }
        }
        const shortcutControlOrMeta = this.controlOrMeta;
        // Match ctrl/meta if the shortcut doesn't have controlOrMeta specified
        // (controlOrMeta should match either).
        const ctrlAndMetaMatches = ctrlKey === this.ctrlKey && metaKey === this.metaKey && !shortcutControlOrMeta;
        const matches = (ctrlAndMetaMatches || (shortcutControlOrMeta && keyEventHasCtrlOrMeta)) &&
            altKey === this.altKey &&
            (shiftKey === this.shiftKey || this.shiftKey === undefined);
        return matches;
    }
    /**
     * Returns a string representation of this shortcut in the same format accepted by
     * {@link fromString}.
     */
    toString() {
        const result = [];
        if (this.ctrlKey && this.key !== 'control') {
            result.push('Ctrl');
        }
        if (this.controlOrMeta) {
            result.push('CtrlOrMeta');
        }
        if (this.altKey && this.key !== 'alt') {
            result.push('Alt');
        }
        if (this.metaKey && this.key !== 'meta') {
            result.push('Meta');
        }
        if (this.shiftKey && this.key !== 'shift') {
            result.push('Shift');
        }
        result.push(this.key);
        return result.join('+');
    }
    /**
     * Accepts a string in the form `modifier1+modifier2+...+key` (e.g. `Ctrl+Shift+a`)
     * and returns the corresponding `KeyboardShortcut`.
     */
    static fromString(shortcutStr) {
        const getDefaultModifiers = (key) => {
            // Unless a letter, as long as the given key matches, it shouldn't matter whether
            // the shift key is pressed.
            let shiftKey = undefined;
            if (isUppercaseLetter(key)) {
                shiftKey = true;
            }
            else if (isLowercaseLetter(key)) {
                shiftKey = false;
            }
            // If not just a single character (e.g. a key code like KeyA), shift must
            // be specified manually.
            else if (key.length > 1) {
                shiftKey = false;
            }
            const lowercaseKey = key.toLowerCase();
            // shiftKey should always be true if the key is 'shift'
            if (lowercaseKey === 'shift') {
                shiftKey = true;
            }
            return {
                shiftKey,
                ctrlKey: lowercaseKey === 'control' || lowercaseKey === 'ctrl',
                altKey: lowercaseKey === 'alt',
                metaKey: lowercaseKey === 'meta',
                controlOrMeta: lowercaseKey === 'control or meta' || lowercaseKey === 'ctrlormeta',
            };
        };
        const hasNoModifiers = shortcutStr.search(/[-+]/) === -1 || shortcutStr.length === 1;
        if (hasNoModifiers) {
            const modifiers = getDefaultModifiers(shortcutStr);
            return new KeyBinding({
                key: shortcutStr,
                ...modifiers,
            });
        }
        const keyModifiersExp = /^(.*[-+])?(.+)$/g;
        const match = keyModifiersExp.exec(shortcutStr);
        if (!match) {
            throw new Error(`Invalid shortcut expression, ${shortcutStr}!`);
        }
        const key = match[2];
        const defaultModifiers = getDefaultModifiers(key);
        const modifierStrings = (match[1] ?? '').split(/[-+]/);
        let shiftKey = defaultModifiers.shiftKey;
        let ctrlKey = defaultModifiers.ctrlKey;
        let altKey = defaultModifiers.altKey;
        let metaKey = defaultModifiers.metaKey;
        let controlOrMeta = defaultModifiers.controlOrMeta;
        for (const modifier of modifierStrings) {
            if (modifier === '') {
                continue;
            }
            switch (modifier.toLowerCase()) {
                case 'shift':
                    shiftKey = true;
                    break;
                case 'anyshift':
                    shiftKey = undefined;
                    break;
                case 'ctrl':
                case 'control':
                    ctrlKey = true;
                    break;
                case 'meta':
                    metaKey = true;
                    break;
                case 'ctrlormeta':
                case 'ctrl or meta':
                case 'controlormeta':
                    controlOrMeta = true;
                    break;
                case 'alt':
                    altKey = true;
                    break;
                default:
                    throw new Error(`Unknown modifier: "${modifier}" in shortcut ${shortcutStr}.`);
            }
        }
        const shortcut = new KeyBinding({
            key,
            shiftKey,
            ctrlKey,
            altKey,
            metaKey,
            controlOrMeta,
        });
        return shortcut;
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/shortcuts/KeyboardShortcutManager.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/shortcuts/KeyboardShortcutManager.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _localizations_getLocalizationTable_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../localizations/getLocalizationTable.mjs */ "./node_modules/js-draw/dist/mjs/localizations/getLocalizationTable.mjs");
/* harmony import */ var _KeyBinding_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./KeyBinding.mjs */ "./node_modules/js-draw/dist/mjs/shortcuts/KeyBinding.mjs");


/**
 * Allows adding/changing keyboard shortcuts. This class provides static methods for registering
 * default shortcuts. An instance of this class must be used to access or change keyboard shortcuts.
 */
class KeyboardShortcutManager {
    /**
     * Creates a new `ShortcutManager` with an initial set of shortcut overrides.
     *
     * @internal
     */
    constructor(initialOverrides) {
        this.shortcutOverrides = Object.create(null);
        for (const id in initialOverrides) {
            this.overrideShortcut(id, initialOverrides[id]);
        }
    }
    /**
     * Override an existing shortcut with a custom set of triggers.
     * @internal
     */
    overrideShortcut(shortcutId, overrideWith) {
        this.shortcutOverrides[shortcutId] = [...overrideWith];
    }
    /** Returns true if `keyEvent` matches the shortcut with `shortcutId`. @internal */
    matchesShortcut(shortcutId, keyEvent) {
        // Get all shortcucts associated with `shortcutId`.
        let shortcutList = this.shortcutOverrides[shortcutId];
        if (!shortcutList) {
            if (shortcutId in KeyboardShortcutManager.shortcuts) {
                shortcutList = KeyboardShortcutManager.shortcuts[shortcutId];
            }
            else {
                throw new Error(`No shortcut with ID ${shortcutId} exists!`);
            }
        }
        // return true if keyEvent matches *any* shortcuts in shortcutList
        for (const shortcut of shortcutList) {
            if (shortcut.matchesEvent(keyEvent)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Registers a default keyboard shortcut that can be overridden by individual instances
     * of `ShortcutManager`. Note that `id` should be a globally unique identifier.
     *
     * Only the first call to this method for a given `id` has an effect.
     *
     * @example
     * ```ts
     * const shortcutId = 'io.github.personalizedrefrigerator.js-draw.select-all';
     *
     * // Associate two shortcuts with the same ID
     * const shortcut1 = KeyBinding.fromString('ctrlOrMeta+a');
     * const shortcut2 = KeyBinding.fromString('ctrlOrMeta+shift+a');
     * KeyboardShortcutManager.registerDefaultKeyboardShortcut(
     * 	shortcutId,
     * 	[ shortcut1, shortcut2 ],
     * 	"Select All",
     * );
     *
     * // Provide a localized description
     * KeyboardShortcutManager.provideShortcutDescription(
     * 	shotcutId,
     * 	'es',
     * 	'Seleccionar todo',
     * );
     * ```
     *
     * @internal
     */
    static registerDefaultKeyboardShortcut(id, shortcuts, defaultDescription) {
        if (id in KeyboardShortcutManager.shortcuts) {
            return false;
        }
        // Convert the strings to shortcut maps.
        const shortcutsAsShortcuts = shortcuts.map((shortcut) => {
            if (typeof shortcut === 'string') {
                return _KeyBinding_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].fromString(shortcut);
            }
            return shortcut;
        });
        KeyboardShortcutManager.shortcuts[id] = [...shortcutsAsShortcuts];
        KeyboardShortcutManager.shortcutDefaultDescriptions[id] = defaultDescription;
        return true;
    }
    /** Provides a localized description of a keyboard shortcut. @internal */
    static provideShortcutDescription(id, locale, description) {
        if (!(locale in KeyboardShortcutManager.shortcutLocalizedDescriptions)) {
            KeyboardShortcutManager.shortcutLocalizedDescriptions[locale] = Object.create(null);
        }
        KeyboardShortcutManager.shortcutLocalizedDescriptions[locale][id] = description;
    }
    /**
     * Gets all registered keyboard shortcut IDs.
     *
     * @see {@link getShortcutDescription}
     */
    static getAllShortcutIds() {
        const ids = [];
        for (const id in this.shortcuts) {
            ids.push(id);
        }
        return ids;
    }
    /**
     * Get the default keybindings associated with a keyboard shortcut.
     *
     * Any keybinding in the resultant list, by default, can trigger the function associated
     * with the shortcut.
     */
    static getShortcutDefaultKeybindings(shortcutId) {
        if (!(shortcutId in KeyboardShortcutManager.shortcuts)) {
            throw new Error(`No shortcut with ID ${shortcutId} exists!`);
        }
        return KeyboardShortcutManager.shortcuts[shortcutId];
    }
    /**
     * Get a description of a keyboard shortcut.
     *
     * `localeList`, if given, attempts to
     */
    static getShortcutDescription(id, localeList) {
        const localizationTable = (0,_localizations_getLocalizationTable_mjs__WEBPACK_IMPORTED_MODULE_0__.matchingLocalizationTable)(localeList ?? [], this.shortcutLocalizedDescriptions, this.shortcutDefaultDescriptions);
        return localizationTable[id] ?? this.shortcutDefaultDescriptions[id] ?? null;
    }
}
KeyboardShortcutManager.shortcuts = Object.create(null);
KeyboardShortcutManager.shortcutDefaultDescriptions = Object.create(null);
KeyboardShortcutManager.shortcutLocalizedDescriptions = Object.create(null);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (KeyboardShortcutManager);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/shortcuts/lib.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/shortcuts/lib.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KeyBinding: () => (/* reexport safe */ _KeyBinding_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   KeyboardShortcutManager: () => (/* reexport safe */ _KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./KeyboardShortcutManager.mjs */ "./node_modules/js-draw/dist/mjs/shortcuts/KeyboardShortcutManager.mjs");
/* harmony import */ var _KeyBinding_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./KeyBinding.mjs */ "./node_modules/js-draw/dist/mjs/shortcuts/KeyBinding.mjs");




/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/testing/getUniquePointerId.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/testing/getUniquePointerId.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Returns the smallest ID not used by the pointers in the given list. */
const getUniquePointerId = (pointers) => {
    let ptrId = 0;
    const pointerIds = pointers.map((ptr) => ptr.id);
    pointerIds.sort();
    for (const pointerId of pointerIds) {
        if (ptrId === pointerId) {
            ptrId = pointerId + 1;
        }
    }
    return ptrId;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getUniquePointerId);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/testing/lib.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/testing/lib.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sendPenEvent: () => (/* reexport safe */ _sendPenEvent_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   sendTouchEvent: () => (/* reexport safe */ _sendTouchEvent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _sendPenEvent_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sendPenEvent.mjs */ "./node_modules/js-draw/dist/mjs/testing/sendPenEvent.mjs");
/* harmony import */ var _sendTouchEvent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sendTouchEvent.mjs */ "./node_modules/js-draw/dist/mjs/testing/sendTouchEvent.mjs");




/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/testing/sendPenEvent.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/testing/sendPenEvent.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Pointer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Pointer.mjs */ "./node_modules/js-draw/dist/mjs/Pointer.mjs");
/* harmony import */ var _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../inputEvents.mjs */ "./node_modules/js-draw/dist/mjs/inputEvents.mjs");
/* harmony import */ var _getUniquePointerId_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getUniquePointerId.mjs */ "./node_modules/js-draw/dist/mjs/testing/getUniquePointerId.mjs");



/**
 * Dispatch a pen event to the currently selected tool.
 * Intended for unit tests.
 *
 * @see {@link sendTouchEvent}
 */
const sendPenEvent = (editor, eventType, point, allPointers, deviceType = _Pointer_mjs__WEBPACK_IMPORTED_MODULE_0__.PointerDevice.Pen) => {
    const id = (0,_getUniquePointerId_mjs__WEBPACK_IMPORTED_MODULE_2__["default"])(allPointers ?? []);
    const mainPointer = _Pointer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].ofCanvasPoint(point, eventType !== _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_1__.InputEvtType.PointerUpEvt, editor.viewport, id, deviceType);
    editor.toolController.dispatchInputEvent({
        kind: eventType,
        allPointers: allPointers ?? [mainPointer],
        current: mainPointer,
    });
    return mainPointer;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sendPenEvent);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/testing/sendTouchEvent.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/testing/sendTouchEvent.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Pointer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Pointer.mjs */ "./node_modules/js-draw/dist/mjs/Pointer.mjs");
/* harmony import */ var _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../inputEvents.mjs */ "./node_modules/js-draw/dist/mjs/inputEvents.mjs");
/* harmony import */ var _getUniquePointerId_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getUniquePointerId.mjs */ "./node_modules/js-draw/dist/mjs/testing/getUniquePointerId.mjs");



/**
 * Dispatch a touch event to the currently selected tool. Intended for unit tests.
 *
 * @see {@link sendPenEvent}
 *
 * @example
 * **Simulating a horizontal swipe gesture:**
 * ```ts
 * sendTouchEvent(editor, InputEvtType.PointerDownEvt, Vec2.of(0, 0));
 * for (let i = 1; i <= 10; i++) {
 *   jest.advanceTimersByTime(10);
 *   sendTouchEvent(editor, InputEvtType.PointerMoveEvt, Vec2.of(i * 10, 0));
 * }
 * ```
 *
 * @example
 * **Simulating a pinch gesture.** This example assumes that you're using [Jest with timer mocks enabled](https://jestjs.io/docs/timer-mocks).
 * ```ts
 * let firstPointer = sendTouchEvent(editor, InputEvtType.PointerDownEvt, Vec2.of(0, 0));
 * let secondPointer = sendTouchEvent(editor, InputEvtType.PointerDownEvt, Vec2.of(100, 0), [ firstPointer ]);
 *
 * // Simulate a pinch
 * const maxIterations = 10;
 * for (let i = 0; i < maxIterations; i++) {
 *   // Use the unit testing framework's tool for increasing the current time
 *   // returned by (new Date()).getTime(), etc.
 *   jest.advanceTimersByTime(100);
 *
 *   const point1 = Vec2.of(-i * 5, 0);
 *   const point2 = Vec2.of(i * 5 + 100, 0);
 *
 *   firstPointer = sendTouchEvent(editor, InputEvtType.PointerMoveEvt, point1, [ secondPointer ]);
 *   secondPointer = sendTouchEvent(editor, InputEvtType.PointerMoveEvt, point2, [ firstPointer ]);
 * }
 * ```
 */
const sendTouchEvent = (editor, eventType, screenPos, allOtherPointers) => {
    const canvasPos = editor.viewport.screenToCanvas(screenPos);
    // Get a unique ID for the main pointer
    // (try to use id=0, but don't use it if it's already in use).
    const ptrId = (0,_getUniquePointerId_mjs__WEBPACK_IMPORTED_MODULE_2__["default"])(allOtherPointers ?? []);
    const mainPointer = _Pointer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].ofCanvasPoint(canvasPos, eventType !== _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_1__.InputEvtType.PointerUpEvt, editor.viewport, ptrId, _Pointer_mjs__WEBPACK_IMPORTED_MODULE_0__.PointerDevice.Touch);
    editor.toolController.dispatchInputEvent({
        kind: eventType,
        allPointers: [...(allOtherPointers ?? []), mainPointer],
        current: mainPointer,
    });
    return mainPointer;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sendTouchEvent);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/AbstractToolbar.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/AbstractToolbar.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types.mjs */ "./node_modules/js-draw/dist/mjs/types.mjs");
/* harmony import */ var _melloware_coloris__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @melloware/coloris */ "./node_modules/@melloware/coloris/dist/esm/coloris.js");
/* harmony import */ var _localization_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./localization.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/localization.mjs");
/* harmony import */ var _tools_SelectionTool_SelectionTool_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tools/SelectionTool/SelectionTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionTool.mjs");
/* harmony import */ var _tools_PanZoom_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tools/PanZoom.mjs */ "./node_modules/js-draw/dist/mjs/tools/PanZoom.mjs");
/* harmony import */ var _tools_TextTool_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tools/TextTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/TextTool.mjs");
/* harmony import */ var _tools_Eraser_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../tools/Eraser.mjs */ "./node_modules/js-draw/dist/mjs/tools/Eraser.mjs");
/* harmony import */ var _tools_Pen_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tools/Pen.mjs */ "./node_modules/js-draw/dist/mjs/tools/Pen.mjs");
/* harmony import */ var _widgets_PenToolWidget_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./widgets/PenToolWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/PenToolWidget.mjs");
/* harmony import */ var _widgets_EraserToolWidget_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./widgets/EraserToolWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/EraserToolWidget.mjs");
/* harmony import */ var _widgets_SelectionToolWidget_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./widgets/SelectionToolWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/SelectionToolWidget.mjs");
/* harmony import */ var _widgets_TextToolWidget_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./widgets/TextToolWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/TextToolWidget.mjs");
/* harmony import */ var _widgets_HandToolWidget_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./widgets/HandToolWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/HandToolWidget.mjs");
/* harmony import */ var _widgets_BaseWidget_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./widgets/BaseWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/BaseWidget.mjs");
/* harmony import */ var _widgets_ActionButtonWidget_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./widgets/ActionButtonWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/ActionButtonWidget.mjs");
/* harmony import */ var _widgets_InsertImageWidget_InsertImageWidget_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./widgets/InsertImageWidget/InsertImageWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/InsertImageWidget/InsertImageWidget.mjs");
/* harmony import */ var _widgets_DocumentPropertiesWidget_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./widgets/DocumentPropertiesWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/DocumentPropertiesWidget.mjs");
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./constants.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/constants.mjs");
/* harmony import */ var _widgets_SaveActionWidget_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./widgets/SaveActionWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/SaveActionWidget.mjs");
/* harmony import */ var _widgets_ExitActionWidget_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./widgets/ExitActionWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/ExitActionWidget.mjs");
/* harmony import */ var _util_assertions_mjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../util/assertions.mjs */ "./node_modules/js-draw/dist/mjs/util/assertions.mjs");
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _AbstractToolbar_listeners, _AbstractToolbar_widgetsById, _AbstractToolbar_widgetList, _AbstractToolbar_updateColoris;






















/**
 * Abstract base class for js-draw editor toolbars.
 *
 * See {@link Editor.addToolbar}, {@link makeDropdownToolbar}, and {@link makeEdgeToolbar}.
 */
class AbstractToolbar {
    /** @internal */
    constructor(editor, localizationTable = _localization_mjs__WEBPACK_IMPORTED_MODULE_2__.defaultToolbarLocalization) {
        this.editor = editor;
        this.localizationTable = localizationTable;
        _AbstractToolbar_listeners.set(this, []);
        _AbstractToolbar_widgetsById.set(this, {});
        _AbstractToolbar_widgetList.set(this, []);
        _AbstractToolbar_updateColoris.set(this, null);
        this.closeColorPickerOverlay = null;
        if (!AbstractToolbar.colorisStarted) {
            (0,_melloware_coloris__WEBPACK_IMPORTED_MODULE_1__.init)();
            AbstractToolbar.colorisStarted = true;
        }
        this.setupColorPickers();
    }
    setupCloseColorPickerOverlay() {
        if (this.closeColorPickerOverlay)
            return;
        this.closeColorPickerOverlay = document.createElement('div');
        this.closeColorPickerOverlay.className = `${_constants_mjs__WEBPACK_IMPORTED_MODULE_18__.toolbarCSSPrefix}closeColorPickerOverlay`;
        this.editor.createHTMLOverlay(this.closeColorPickerOverlay);
        // Hide the color picker when attempting to draw on the overlay.
        __classPrivateFieldGet(this, _AbstractToolbar_listeners, "f").push(this.editor.handlePointerEventsExceptClicksFrom(this.closeColorPickerOverlay, (eventName) => {
            if (eventName === 'pointerdown') {
                (0,_melloware_coloris__WEBPACK_IMPORTED_MODULE_1__.close)();
            }
            // Transfer focus to the editor to allow keyboard events to be handled.
            if (eventName === 'pointerup') {
                this.editor.focus();
            }
            // Send the event to the editor
            return true;
        }));
    }
    // @internal
    setupColorPickers() {
        // Much of the setup only needs to be done once.
        if (__classPrivateFieldGet(this, _AbstractToolbar_updateColoris, "f")) {
            __classPrivateFieldGet(this, _AbstractToolbar_updateColoris, "f").call(this);
            return;
        }
        this.setupCloseColorPickerOverlay();
        const maxSwatchLen = 12;
        const swatches = [
            _js_draw_math__WEBPACK_IMPORTED_MODULE_17__.Color4.red.toHexString(),
            _js_draw_math__WEBPACK_IMPORTED_MODULE_17__.Color4.purple.toHexString(),
            _js_draw_math__WEBPACK_IMPORTED_MODULE_17__.Color4.blue.toHexString(),
            _js_draw_math__WEBPACK_IMPORTED_MODULE_17__.Color4.clay.toHexString(),
            _js_draw_math__WEBPACK_IMPORTED_MODULE_17__.Color4.black.toHexString(),
            _js_draw_math__WEBPACK_IMPORTED_MODULE_17__.Color4.white.toHexString(),
        ];
        const presetColorEnd = swatches.length;
        // Keeps track of whether a Coloris initialization is scheduled.
        let colorisInitScheduled = false;
        // (Re)init Coloris -- update the swatches list.
        const initColoris = () => {
            try {
                (0,_melloware_coloris__WEBPACK_IMPORTED_MODULE_1__.coloris)({
                    el: '.coloris_input',
                    format: 'hex',
                    selectInput: false,
                    focusInput: false,
                    themeMode: 'auto',
                    swatches,
                });
            }
            catch (err) {
                console.warn('Failed to initialize Coloris. Error: ', err);
                // Try again --- a known issue is that Coloris fails to load if the document
                // isn't ready.
                if (!colorisInitScheduled) {
                    colorisInitScheduled = true;
                    // Wait to initialize after the document has loaded
                    document.addEventListener('load', () => {
                        initColoris();
                    }, { once: true });
                }
            }
        };
        initColoris();
        __classPrivateFieldSet(this, _AbstractToolbar_updateColoris, initColoris, "f");
        const addColorToSwatch = (newColor) => {
            let alreadyPresent = false;
            for (const color of swatches) {
                if (color === newColor) {
                    alreadyPresent = true;
                }
            }
            if (!alreadyPresent) {
                swatches.push(newColor);
                if (swatches.length > maxSwatchLen) {
                    swatches.splice(presetColorEnd, 1);
                }
                initColoris();
            }
        };
        __classPrivateFieldGet(this, _AbstractToolbar_listeners, "f").push(this.editor.notifier.on(_types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ColorPickerToggled, (event) => {
            if (event.kind !== _types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ColorPickerToggled) {
                return;
            }
            // Show/hide the overlay. Making the overlay visible gives users a surface to click
            // on that shows/hides the color picker.
            if (this.closeColorPickerOverlay) {
                this.closeColorPickerOverlay.style.display = event.open ? 'block' : 'none';
            }
        }));
        // Add newly-selected colors to the swatch.
        __classPrivateFieldGet(this, _AbstractToolbar_listeners, "f").push(this.editor.notifier.on(_types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ColorPickerColorSelected, (event) => {
            if (event.kind === _types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ColorPickerColorSelected) {
                addColorToSwatch(event.color.toHexString());
            }
        }));
    }
    closeColorPickers() {
        (0,_melloware_coloris__WEBPACK_IMPORTED_MODULE_1__.close)?.();
    }
    getWidgetUniqueId(widget) {
        return widget.getUniqueIdIn(__classPrivateFieldGet(this, _AbstractToolbar_widgetsById, "f"));
    }
    getWidgetFromId(id) {
        return __classPrivateFieldGet(this, _AbstractToolbar_widgetsById, "f")[id];
    }
    /** Do **not** modify the return value. */
    getAllWidgets() {
        return __classPrivateFieldGet(this, _AbstractToolbar_widgetList, "f");
    }
    /**
     * Adds an `ActionButtonWidget` or `BaseToolWidget`. The widget should not have already have a parent
     * (i.e. its `addTo` method should not have been called).
     *
     * @example
     * ```ts
     * const toolbar = editor.addToolbar();
     * const insertImageWidget = new InsertImageWidget(editor);
     * toolbar.addWidget(insertImageWidget);
     * ```
     */
    addWidget(widget) {
        // Prevent name collisions
        const id = widget.getUniqueIdIn(__classPrivateFieldGet(this, _AbstractToolbar_widgetsById, "f"));
        // Add the widget
        __classPrivateFieldGet(this, _AbstractToolbar_widgetsById, "f")[id] = widget;
        __classPrivateFieldGet(this, _AbstractToolbar_widgetList, "f").push(widget);
        this.addWidgetInternal(widget);
        this.setupColorPickers();
    }
    /** Removes the given `widget` from this toolbar. */
    removeWidget(widget) {
        const id = widget.getUniqueIdIn(__classPrivateFieldGet(this, _AbstractToolbar_widgetsById, "f"));
        this.removeWidgetInternal(widget);
        delete __classPrivateFieldGet(this, _AbstractToolbar_widgetsById, "f")[id];
        __classPrivateFieldSet(this, _AbstractToolbar_widgetList, __classPrivateFieldGet(this, _AbstractToolbar_widgetList, "f").filter((otherWidget) => otherWidget !== widget), "f");
    }
    /** Returns a snapshot of the state of widgets in the toolbar. */
    serializeState() {
        const result = {};
        for (const widgetId in __classPrivateFieldGet(this, _AbstractToolbar_widgetsById, "f")) {
            result[widgetId] = __classPrivateFieldGet(this, _AbstractToolbar_widgetsById, "f")[widgetId].serializeState();
        }
        result[AbstractToolbar.rootToolbarId] = this.serializeInternal();
        return JSON.stringify(result);
    }
    /**
     * Deserialize toolbar widgets from the given state.
     * Assumes that toolbar widgets are in the same order as when state was serialized.
     */
    deserializeState(state) {
        const data = JSON.parse(state);
        (0,_util_assertions_mjs__WEBPACK_IMPORTED_MODULE_21__.assertIsObject)(data);
        (0,_util_assertions_mjs__WEBPACK_IMPORTED_MODULE_21__.assertTruthy)(data);
        const rootId = AbstractToolbar.rootToolbarId;
        if (rootId in data && typeof data[rootId] !== 'undefined') {
            this.deserializeInternal(data[rootId]);
        }
        for (const widgetId in data) {
            if (widgetId === rootId) {
                continue;
            }
            if (!(widgetId in __classPrivateFieldGet(this, _AbstractToolbar_widgetsById, "f"))) {
                console.warn(`Unable to deserialize widget ${widgetId} ­— no such widget.`);
                continue;
            }
            if (typeof data[widgetId] === 'object' && data[widgetId]) {
                __classPrivateFieldGet(this, _AbstractToolbar_widgetsById, "f")[widgetId].deserializeFrom(data[widgetId]);
            }
        }
    }
    /**
     * Called by `serializeState` to attach any additional JSONifyable data
     * to the serialized result.
     *
     * @returns an object that can be converted to JSON with `JSON.stringify`.
     */
    serializeInternal() { }
    /**
     * Called by `deserializeState` with a version of the JSON outputted
     * previously by `serializeInternal`.
     */
    deserializeInternal(_json) { }
    /**
     * Creates, but does not add, an action button to this container.
     *
     * @see
     * {@link addActionButton}
     */
    makeActionButton(title, command, options = true) {
        // Parse options
        if (typeof options === 'boolean') {
            options = {
                mustBeToplevel: options,
            };
        }
        const mustBeToplevel = options.mustBeToplevel ?? true;
        const autoDisableInReadOnlyEditors = options.autoDisableInReadOnlyEditors ?? true;
        const titleString = typeof title === 'string' ? title : title.label;
        const widgetId = 'action-button';
        const makeIcon = () => {
            if (typeof title === 'string') {
                return null;
            }
            return title.icon;
        };
        const widget = new _widgets_ActionButtonWidget_mjs__WEBPACK_IMPORTED_MODULE_14__["default"](this.editor, widgetId, makeIcon, titleString, command, this.editor.localization, mustBeToplevel, autoDisableInReadOnlyEditors);
        return widget;
    }
    /**
     * Adds an action button with `title` to this toolbar (or to the given `parent` element).
     *
     * `options` can either be an object with properties `mustBeToplevel` and/or
     * `autoDisableInReadOnlyEditors` or a boolean value. If a boolean, it is interpreted
     * as being the value of `mustBeToplevel`.
     *
     * @return The added button.
     *
     * **Example**:
     * ```ts,runnable
     * import { Editor } from 'js-draw';
     * const editor = new Editor(document.body);
     * const toolbar = editor.addToolbar();
     *
     * function makeTrashIcon() {
     *   const container = document.createElement('div');
     *   container.textContent = '🗑️';
     *   return container;
     * }
     *
     * toolbar.addActionButton({
     *   icon: makeTrashIcon(), // can be any Element not in the DOM
     *   label: 'Delete all',
     * }, () => {
     *   alert('to-do!');
     * });
     */
    addActionButton(title, command, options = true) {
        const widget = this.makeActionButton(title, command, options);
        this.addWidget(widget);
        return widget;
    }
    /**
     * Like {@link addActionButton}, except associates `tags` with the button that allow
     * different toolbar styles to give the button tag-dependent styles.
     */
    addTaggedActionButton(tags, title, command, options = true) {
        const widget = this.makeActionButton(title, command, options);
        widget.setTags(tags);
        this.addWidget(widget);
        return widget;
    }
    /**
     * Adds a save button that, when clicked, calls `saveCallback`.
     *
     * @example
     * ```ts,runnable
     * import { Editor, makeDropdownToolbar } from 'js-draw';
     *
     * const editor = new Editor(document.body);
     * const toolbar = makeDropdownToolbar(editor);
     *
     * toolbar.addDefaults();
     * toolbar.addSaveButton(() => alert('save clicked!'));
     * ```
     *
     * `labelOverride` can optionally be used to change the `label` or `icon` of the button.
     */
    addSaveButton(saveCallback, labelOverride = {}) {
        const widget = new _widgets_SaveActionWidget_mjs__WEBPACK_IMPORTED_MODULE_19__["default"](this.editor, this.localizationTable, saveCallback, labelOverride);
        this.addWidget(widget);
        return widget;
    }
    /**
     * Adds an "Exit" button that, when clicked, calls `exitCallback`.
     *
     * **Note**: This is *roughly* equivalent to
     * ```ts
     * toolbar.addTaggedActionButton([ ToolbarWidgetTag.Exit ], {
     *   label: this.editor.localization.exit,
     *   icon: this.editor.icons.makeCloseIcon(),
     *
     *   // labelOverride can be used to override label or icon.
     *   ...labelOverride,
     * }, () => {
     *   exitCallback();
     * });
     * ```
     * with some additional configuration.
     *
     * @final
     */
    addExitButton(exitCallback, labelOverride = {}) {
        const widget = new _widgets_ExitActionWidget_mjs__WEBPACK_IMPORTED_MODULE_20__["default"](this.editor, this.localizationTable, exitCallback, labelOverride);
        this.addWidget(widget);
        return widget;
    }
    /**
     * Adds undo and redo buttons that trigger the editor's built-in undo and redo
     * functionality.
     */
    addUndoRedoButtons(undoFirst = true) {
        const makeUndo = () => {
            return this.addTaggedActionButton([_widgets_BaseWidget_mjs__WEBPACK_IMPORTED_MODULE_13__.ToolbarWidgetTag.Undo], {
                label: this.localizationTable.undo,
                icon: this.editor.icons.makeUndoIcon(),
            }, () => {
                this.editor.history.undo();
            });
        };
        const makeRedo = () => {
            return this.addTaggedActionButton([_widgets_BaseWidget_mjs__WEBPACK_IMPORTED_MODULE_13__.ToolbarWidgetTag.Redo], {
                label: this.localizationTable.redo,
                icon: this.editor.icons.makeRedoIcon(),
            }, () => {
                this.editor.history.redo();
            });
        };
        let undoButton;
        let redoButton;
        if (undoFirst) {
            undoButton = makeUndo();
            redoButton = makeRedo();
        }
        else {
            redoButton = makeRedo();
            undoButton = makeUndo();
        }
        undoButton.setDisabled(true);
        redoButton.setDisabled(true);
        this.editor.notifier.on(_types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.UndoRedoStackUpdated, (event) => {
            if (event.kind !== _types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.UndoRedoStackUpdated) {
                throw new Error('Wrong event type!');
            }
            undoButton.setDisabled(event.undoStackSize === 0);
            redoButton.setDisabled(event.redoStackSize === 0);
        });
    }
    /**
     * Adds widgets for pen/eraser/selection/text/pan-zoom primary tools.
     *
     * If `filter` returns `false` for a tool, no widget is added for that tool.
     * See {@link addDefaultToolWidgets}
     */
    addWidgetsForPrimaryTools(filter) {
        for (const tool of this.editor.toolController.getPrimaryTools()) {
            if (filter && !filter?.(tool)) {
                continue;
            }
            if (tool instanceof _tools_Pen_mjs__WEBPACK_IMPORTED_MODULE_7__["default"]) {
                const widget = new _widgets_PenToolWidget_mjs__WEBPACK_IMPORTED_MODULE_8__["default"](this.editor, tool, this.localizationTable);
                this.addWidget(widget);
            }
            else if (tool instanceof _tools_Eraser_mjs__WEBPACK_IMPORTED_MODULE_6__["default"]) {
                this.addWidget(new _widgets_EraserToolWidget_mjs__WEBPACK_IMPORTED_MODULE_9__["default"](this.editor, tool, this.localizationTable));
            }
            else if (tool instanceof _tools_SelectionTool_SelectionTool_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]) {
                this.addWidget(new _widgets_SelectionToolWidget_mjs__WEBPACK_IMPORTED_MODULE_10__["default"](this.editor, tool, this.localizationTable));
            }
            else if (tool instanceof _tools_TextTool_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]) {
                this.addWidget(new _widgets_TextToolWidget_mjs__WEBPACK_IMPORTED_MODULE_11__["default"](this.editor, tool, this.localizationTable));
            }
            else if (tool instanceof _tools_PanZoom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"]) {
                this.addWidget(new _widgets_HandToolWidget_mjs__WEBPACK_IMPORTED_MODULE_12__["default"](this.editor, tool, this.localizationTable));
            }
        }
    }
    /**
     * Adds toolbar widgets based on the enabled tools, and additional tool-like
     * buttons (e.g. {@link DocumentPropertiesWidget} and {@link InsertImageWidget}).
     */
    addDefaultToolWidgets() {
        this.addWidgetsForPrimaryTools();
        this.addDefaultEditorControlWidgets();
    }
    /**
     * Adds widgets that don't correspond to tools, but do allow the user to control
     * the editor in some way.
     *
     * By default, this includes {@link DocumentPropertiesWidget} and {@link InsertImageWidget}.
     */
    addDefaultEditorControlWidgets() {
        this.addWidget(new _widgets_DocumentPropertiesWidget_mjs__WEBPACK_IMPORTED_MODULE_16__["default"](this.editor, this.localizationTable));
        this.addWidget(new _widgets_InsertImageWidget_InsertImageWidget_mjs__WEBPACK_IMPORTED_MODULE_15__["default"](this.editor, this.localizationTable));
    }
    addDefaultActionButtons() {
        this.addUndoRedoButtons();
    }
    /**
     * Remove this toolbar from its container and clean up listeners.
     * This should only be called **once** for a given toolbar.
     */
    remove() {
        this.closeColorPickerOverlay?.remove();
        for (const listener of __classPrivateFieldGet(this, _AbstractToolbar_listeners, "f")) {
            listener.remove();
        }
        __classPrivateFieldSet(this, _AbstractToolbar_listeners, [], "f");
        this.onRemove();
        for (const widget of __classPrivateFieldGet(this, _AbstractToolbar_widgetList, "f")) {
            widget.remove();
        }
    }
    /**
     * Removes `listener` when {@link remove} is called.
     */
    manageListener(listener) {
        __classPrivateFieldGet(this, _AbstractToolbar_listeners, "f").push(listener);
    }
}
_AbstractToolbar_listeners = new WeakMap(), _AbstractToolbar_widgetsById = new WeakMap(), _AbstractToolbar_widgetList = new WeakMap(), _AbstractToolbar_updateColoris = new WeakMap();
AbstractToolbar.colorisStarted = false;
AbstractToolbar.rootToolbarId = 'root-toolbar--';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AbstractToolbar);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/DropdownToolbar.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/DropdownToolbar.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DropdownToolbar),
/* harmony export */   makeDropdownToolbar: () => (/* binding */ makeDropdownToolbar)
/* harmony export */ });
/* harmony import */ var _localization_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./localization.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/localization.mjs");
/* harmony import */ var _widgets_OverflowWidget_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./widgets/OverflowWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/OverflowWidget.mjs");
/* harmony import */ var _AbstractToolbar_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbstractToolbar.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/AbstractToolbar.mjs");
/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/constants.mjs");




/**
 * @example
 *
 * ```ts,runnable
 * import { makeDropdownToolbar, Editor } from 'js-draw';
 *
 * const editor = new Editor(document.body);
 * const toolbar = makeDropdownToolbar(editor);
 * toolbar.addDefaults();
 *
 * toolbar.addExitButton(editor => {
 *   // TODO
 * });
 *
 * toolbar.addSaveButton(editor => {
 *   // TODO
 * });
 * ```
 *
 * Returns a subclass of {@link AbstractToolbar}.
 *
 * @see
 * - {@link makeEdgeToolbar}
 * - {@link AbstractToolbar.addSaveButton}
 * - {@link AbstractToolbar.addExitButton}
 */
const makeDropdownToolbar = (editor) => {
    return new DropdownToolbar(editor, editor.getRootElement());
};
class DropdownToolbar extends _AbstractToolbar_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /** @internal */
    constructor(editor, parent, localizationTable = _localization_mjs__WEBPACK_IMPORTED_MODULE_0__.defaultToolbarLocalization) {
        super(editor, localizationTable);
        // Flex-order of the next widget to be added.
        this.widgetOrderCounter = 0;
        // Widget to toggle overflow menu.
        this.overflowWidget = null;
        this.reLayoutQueued = false;
        this.container = document.createElement('div');
        this.container.classList.add(`${_constants_mjs__WEBPACK_IMPORTED_MODULE_3__.toolbarCSSPrefix}root`);
        this.container.classList.add(`${_constants_mjs__WEBPACK_IMPORTED_MODULE_3__.toolbarCSSPrefix}element`);
        this.container.classList.add(`${_constants_mjs__WEBPACK_IMPORTED_MODULE_3__.toolbarCSSPrefix}dropdown-toolbar`);
        this.container.setAttribute('role', 'toolbar');
        parent.appendChild(this.container);
        if ('ResizeObserver' in window) {
            this.resizeObserver = new ResizeObserver((_entries) => {
                this.reLayout();
            });
            this.resizeObserver.observe(this.container);
        }
        else {
            console.warn('ResizeObserver not supported. Toolbar will not resize.');
        }
    }
    queueReLayout() {
        if (!this.reLayoutQueued) {
            this.reLayoutQueued = true;
            requestAnimationFrame(() => this.reLayout());
        }
    }
    reLayout() {
        this.reLayoutQueued = false;
        if (!this.overflowWidget) {
            return;
        }
        const getTotalWidth = (widgetList) => {
            let totalWidth = 0;
            for (const widget of widgetList) {
                if (!widget.isHidden()) {
                    totalWidth += widget.getButtonWidth();
                }
            }
            return totalWidth;
        };
        // Returns true if there is enough empty space to move the first child
        // from the overflow menu to the main menu.
        const canRemoveFirstChildFromOverflow = (freeSpaceInMainMenu) => {
            const overflowChildren = this.overflowWidget?.getChildWidgets() ?? [];
            if (overflowChildren.length === 0) {
                return false;
            }
            return overflowChildren[0].getButtonWidth() <= freeSpaceInMainMenu;
        };
        const allWidgets = this.getAllWidgets();
        let overflowWidgetsWidth = getTotalWidth(this.overflowWidget.getChildWidgets());
        let shownWidgetWidth = getTotalWidth(allWidgets) - overflowWidgetsWidth;
        let availableWidth = this.container.clientWidth * 0.87;
        // If on a device that has enough vertical space, allow
        // showing two rows of buttons.
        // TODO: Fix magic numbers
        if (window.innerHeight > availableWidth * 1.75) {
            availableWidth *= 1.75;
        }
        let updatedChildren = false;
        // If we can remove at least one child from the overflow menu,
        if (canRemoveFirstChildFromOverflow(availableWidth - shownWidgetWidth)) {
            // Move widgets to the main menu.
            const overflowChildren = this.overflowWidget.clearChildren();
            for (const child of overflowChildren) {
                child.addTo(this.container);
                child.setIsToplevel(true);
                if (!child.isHidden()) {
                    shownWidgetWidth += child.getButtonWidth();
                }
            }
            overflowWidgetsWidth = 0;
            updatedChildren = true;
        }
        if (shownWidgetWidth >= availableWidth) {
            // Move widgets to the overflow menu.
            // Start with the rightmost widget, move to the leftmost
            for (let i = allWidgets.length - 1; i >= 0 && shownWidgetWidth >= availableWidth; i--) {
                const child = allWidgets[i];
                if (this.overflowWidget.hasAsChild(child)) {
                    continue;
                }
                if (child.canBeInOverflowMenu()) {
                    shownWidgetWidth -= child.getButtonWidth();
                    this.overflowWidget.addToOverflow(child);
                }
            }
            updatedChildren = true;
        }
        // Hide/show the overflow widget.
        this.overflowWidget.setHidden(this.overflowWidget.getChildWidgets().length === 0);
        if (updatedChildren) {
            this.setupColorPickers();
        }
    }
    addWidgetInternal(widget) {
        const container = widget.addTo(this.container);
        // Ensure that the widget gets displayed in the correct
        // place in the toolbar, even if it's removed and re-added.
        container.style.order = `${this.widgetOrderCounter++}`;
        this.queueReLayout();
    }
    removeWidgetInternal(widget) {
        widget.remove();
        this.queueReLayout();
    }
    addSpacer(options = {}) {
        const spacer = document.createElement('div');
        spacer.classList.add(`${_constants_mjs__WEBPACK_IMPORTED_MODULE_3__.toolbarCSSPrefix}spacer`);
        if (options.grow) {
            spacer.style.flexGrow = `${options.grow}`;
        }
        if (options.minSize) {
            spacer.style.minWidth = options.minSize;
        }
        if (options.maxSize) {
            spacer.style.maxWidth = options.maxSize;
        }
        spacer.style.order = `${this.widgetOrderCounter++}`;
        this.container.appendChild(spacer);
    }
    /**
     * Adds a widget that toggles the overflow menu. Call `addOverflowWidget` to ensure
     * that this widget is in the correct space (if shown).
     *
     * @example
     * ```ts
     * toolbar.addDefaultToolWidgets();
     * toolbar.addOverflowWidget();
     * toolbar.addDefaultActionButtons();
     * ```
     * shows the overflow widget between the default tool widgets and the default action buttons,
     * if shown.
     */
    addOverflowWidget() {
        this.overflowWidget = new _widgets_OverflowWidget_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](this.editor, this.localizationTable);
        this.addWidget(this.overflowWidget);
    }
    /**
     * Adds both the default tool widgets and action buttons. Equivalent to
     * ```ts
     * toolbar.addDefaultToolWidgets();
     * toolbar.addOverflowWidget();
     * toolbar.addDefaultActionButtons();
     * ```
     */
    addDefaults() {
        this.addDefaultToolWidgets();
        this.addOverflowWidget();
        this.addDefaultActionButtons();
    }
    onRemove() {
        this.container.remove();
        this.resizeObserver.disconnect();
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/EdgeToolbar.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/EdgeToolbar.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EdgeToolbar),
/* harmony export */   makeEdgeToolbar: () => (/* binding */ makeEdgeToolbar)
/* harmony export */ });
/* harmony import */ var _widgets_BaseWidget_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./widgets/BaseWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/BaseWidget.mjs");
/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/constants.mjs");
/* harmony import */ var _widgets_layout_EdgeToolbarLayoutManager_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./widgets/layout/EdgeToolbarLayoutManager.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/layout/EdgeToolbarLayoutManager.mjs");
/* harmony import */ var _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/ReactiveValue.mjs */ "./node_modules/js-draw/dist/mjs/util/ReactiveValue.mjs");
/* harmony import */ var _AbstractToolbar_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AbstractToolbar.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/AbstractToolbar.mjs");
/* harmony import */ var _util_stopPropagationOfScrollingWheelEvents_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/stopPropagationOfScrollingWheelEvents.mjs */ "./node_modules/js-draw/dist/mjs/util/stopPropagationOfScrollingWheelEvents.mjs");
/* harmony import */ var _utils_makeDraggable_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/makeDraggable.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/utils/makeDraggable.mjs");







/**
 * Creates an `EdgeToolbar`.
 *
 * [Credit for the original design of this UI](https://www.figma.com/file/NA5F2AMWO3wUuaoDfUaAb8/Material-3-wireframes?type=design&node-id=54490%3A1103&mode=design&t=Ee0UwnPnQ2bNC2uM-1).
 *
 * @example
 *
 * ```ts,runnable
 * import { makeEdgeToolbar, Editor } from 'js-draw';
 *
 * const editor = new Editor(document.body);
 * const toolbar = makeEdgeToolbar(editor);
 * toolbar.addDefaults();
 *
 * toolbar.addSaveButton(editor => {
 *   // TODO
 * });
 *
 * toolbar.addExitButton(editor => {
 *   // TODO
 * });
 * ```
 *
 * @see
 * - {@link makeDropdownToolbar}
 * - {@link AbstractToolbar.addSaveButton}
 * - {@link AbstractToolbar.addExitButton}
 */
const makeEdgeToolbar = (editor) => {
    return new EdgeToolbar(editor, editor.getRootElement(), editor.localization);
};
class EdgeToolbar extends _AbstractToolbar_mjs__WEBPACK_IMPORTED_MODULE_4__["default"] {
    /** @internal */
    constructor(editor, parent, localizationTable) {
        super(editor, localizationTable);
        this.clearDragListeners = null;
        this.toolbarContainer = document.createElement('div');
        this.toolbarContainer.classList.add(`${_constants_mjs__WEBPACK_IMPORTED_MODULE_1__.toolbarCSSPrefix}root`);
        this.toolbarContainer.classList.add(`${_constants_mjs__WEBPACK_IMPORTED_MODULE_1__.toolbarCSSPrefix}element`);
        this.toolbarContainer.classList.add(`${_constants_mjs__WEBPACK_IMPORTED_MODULE_1__.toolbarCSSPrefix}edge-toolbar`);
        this.toolbarContainer.setAttribute('role', 'toolbar');
        this.toolbarActionRow = document.createElement('div');
        this.toolbarActionRow.classList.add('toolbar-element', 'toolbar-action-row');
        this.toolbarToolRow = document.createElement('div');
        this.toolbarToolRow.classList.add('toolbar-element', 'toolbar-tool-row');
        (0,_util_stopPropagationOfScrollingWheelEvents_mjs__WEBPACK_IMPORTED_MODULE_5__["default"])(this.toolbarToolRow);
        if ('ResizeObserver' in window) {
            this.toolRowResizeObserver = new ResizeObserver((_entries) => {
                this.onToolbarRowResize();
            });
            this.toolRowResizeObserver.observe(this.toolbarToolRow);
        }
        else {
            console.warn('ResizeObserver not supported. Toolbar will not resize.');
        }
        this.toolbarContainer.replaceChildren(this.toolbarActionRow, this.toolbarToolRow);
        parent.appendChild(this.toolbarContainer);
        this.sidebarVisible = _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_3__.ReactiveValue.fromInitialValue(false);
        this.sidebarY = _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_3__.ReactiveValue.fromInitialValue(0);
        // Create the container elements
        this.menuContainer = document.createElement('div');
        this.menuContainer.classList.add(`${_constants_mjs__WEBPACK_IMPORTED_MODULE_1__.toolbarCSSPrefix}edgemenu-container`);
        this.sidebarContainer = document.createElement('div');
        this.sidebarContainer.classList.add(`${_constants_mjs__WEBPACK_IMPORTED_MODULE_1__.toolbarCSSPrefix}edgemenu`, `${_constants_mjs__WEBPACK_IMPORTED_MODULE_1__.toolbarCSSPrefix}element`);
        this.sidebarContainer.classList.add(`${_constants_mjs__WEBPACK_IMPORTED_MODULE_1__.toolbarCSSPrefix}tool-properties`);
        this.sidebarContent = document.createElement('div');
        // Setup resizing/dragging
        this.sidebarY.onUpdateAndNow((y) => {
            const belowEdgeClassName = 'dropdown-below-edge';
            if (y > 0) {
                this.sidebarContainer.style.transform = `translate(0, ${y}px)`;
                this.sidebarContainer.style.paddingBottom = '';
                this.menuContainer.classList.add(belowEdgeClassName);
            }
            else {
                this.sidebarContainer.style.transform = '';
                this.sidebarContainer.style.paddingBottom = `${-y}px`;
                this.menuContainer.classList.remove(belowEdgeClassName);
            }
        });
        this.closeButton = document.createElement('button');
        this.closeButton.classList.add('drag-elem');
        // The close button has default focus -- forward its events to the main editor so that keyboard
        // shortcuts still work.
        this.editor.handleKeyEventsFrom(this.closeButton, (event) => {
            // Don't send
            return event.code !== 'Space' && event.code !== 'Enter' && event.code !== 'Tab';
        });
        // Close the sidebar when pressing escape
        this.sidebarContainer.addEventListener('keyup', (event) => {
            if (!event.defaultPrevented && event.code === 'Escape') {
                this.sidebarVisible.set(false);
                event.preventDefault();
            }
        });
        this.initDragListeners();
        // Initialize the layout manager
        const setSidebarContent = (...content) => {
            this.sidebarContent.replaceChildren(...content);
            this.setupColorPickers();
        };
        this.sidebarTitle = _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_3__.MutableReactiveValue.fromInitialValue('');
        this.layoutManager = new _widgets_layout_EdgeToolbarLayoutManager_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](setSidebarContent, this.sidebarTitle, this.sidebarVisible, editor.announceForAccessibility.bind(editor), localizationTable);
        this.sidebarTitle.onUpdateAndNow((title) => {
            this.closeButton.setAttribute('aria-label', localizationTable.closeSidebar(title));
        });
        // Make things visible/keep hidden.
        this.listenForVisibilityChanges();
        this.sidebarContainer.replaceChildren(this.closeButton, this.sidebarContent);
        this.menuContainer.replaceChildren(this.sidebarContainer);
        parent.appendChild(this.menuContainer);
    }
    listenForVisibilityChanges() {
        let animationTimeout = null;
        const animationDuration = 170;
        if (!this.sidebarVisible.get()) {
            this.menuContainer.style.display = 'none';
            // Set the initial opacity to 0 to allow the `transition` property
            // to animate it to 1.
            this.menuContainer.style.opacity = '0';
        }
        const prefersReduceMotion = window.matchMedia?.('(prefers-reduced-motion: reduce)') ?? '';
        this.sidebarVisible.onUpdate((visible) => {
            const animationProperties = `${animationDuration}ms ease`;
            // We need to use different animations when reducing motion.
            const reduceMotion = prefersReduceMotion.matches ? '-reduce-motion' : '';
            if (visible) {
                this.sidebarY.set(this.snappedSidebarY());
                if (animationTimeout) {
                    clearTimeout(animationTimeout);
                    animationTimeout = null;
                }
                this.menuContainer.style.display = '';
                this.sidebarContainer.style.animation = `${animationProperties} ${_constants_mjs__WEBPACK_IMPORTED_MODULE_1__.toolbarCSSPrefix}-edgemenu-transition-in${reduceMotion}`;
                this.menuContainer.style.animation = `${animationProperties} ${_constants_mjs__WEBPACK_IMPORTED_MODULE_1__.toolbarCSSPrefix}-edgemenu-container-transition-in${reduceMotion}`;
                this.menuContainer.style.opacity = '1';
                // Focus the close button when first shown, but prevent scroll because the button
                // is likely at the bottom of the screen (and we want the full sidebar to remain
                // visible).
                this.closeButton.focus({ preventScroll: true });
            }
            else {
                this.closeColorPickers();
                if (animationTimeout === null) {
                    this.sidebarContainer.style.animation = `${animationProperties} ${_constants_mjs__WEBPACK_IMPORTED_MODULE_1__.toolbarCSSPrefix}-edgemenu-transition-out${reduceMotion}`;
                    this.menuContainer.style.animation = `${animationProperties} ${_constants_mjs__WEBPACK_IMPORTED_MODULE_1__.toolbarCSSPrefix}-edgemenu-container-transition-out${reduceMotion}`;
                    // Manually set the container's opacity to prevent flickering when closing
                    // the toolbar.
                    this.menuContainer.style.opacity = '0';
                    // Hide overflow -- don't show the part of the edge toolbar that's outside of
                    // the editor.
                    //this.menuContainer.style.overflowY = 'hidden';
                    this.editor.announceForAccessibility(this.localizationTable.dropdownHidden(this.sidebarTitle.get()));
                    animationTimeout = setTimeout(() => {
                        this.menuContainer.style.display = 'none';
                        this.menuContainer.style.overflowY = '';
                        animationTimeout = null;
                    }, animationDuration);
                }
            }
        });
    }
    onToolbarRowResize() {
        const setExtraPadding = () => {
            const visibleWidth = this.toolbarToolRow.clientWidth;
            // Determine whether extra spacing needs to be added so that one button is cut
            // in half. Ideally, when there is scroll, one button will be cut in half to show
            // that scrolling is possible.
            let currentWidth = 0;
            let extraPadding = 0;
            let numVisibleButtons = 0;
            for (const child of this.toolbarToolRow.children) {
                // Use the first child -- padding is applied around that child. Assumes
                // that the button's width is its height plus some padding.
                const buttonBaseSize = child.clientHeight;
                currentWidth += buttonBaseSize;
                numVisibleButtons++;
                if (currentWidth > visibleWidth) {
                    // We want extraPadding + (currentWidth - buttonWidth / 2) = visibleWidth.
                    // Thus, extraPadding = visibleWidth - currentWidth + buttonWidth / 2;
                    extraPadding = visibleWidth - currentWidth + buttonBaseSize / 2;
                    // Ensure that the padding is positive
                    if (extraPadding < 0) {
                        extraPadding += buttonBaseSize;
                    }
                    break;
                }
            }
            const perButtonPadding = Math.round((extraPadding / numVisibleButtons) * 10) / 10;
            this.toolbarToolRow.style.setProperty('--extra-left-right-padding', `${perButtonPadding}px`);
        };
        const actionRowBBox = this.toolbarActionRow.getBoundingClientRect();
        const toolbarRowBBox = this.toolbarToolRow.getBoundingClientRect();
        const onDifferentRows = actionRowBBox.y + actionRowBBox.height <= toolbarRowBBox.y;
        if (onDifferentRows) {
            this.toolbarContainer.classList.remove('one-row');
        }
        else {
            this.toolbarContainer.classList.add('one-row');
        }
        if (this.toolbarToolRow.clientWidth < this.toolbarToolRow.scrollWidth) {
            this.toolbarToolRow.classList.add('has-scroll');
            // Note: This can potentially change the size of the tool row.
            // Because this is run inside of a ResizeObserver callback, special
            // care must be taken to ensure that this change doesn't re-trigger
            // the resize observer.
            setExtraPadding();
        }
        else {
            this.toolbarToolRow.classList.remove('has-scroll', 'extra-padding');
        }
    }
    addSpacer(_options) {
        //throw new Error('Method not implemented.');
        // Unused for this toolbar.
    }
    addUndoRedoButtons() {
        super.addUndoRedoButtons(false);
    }
    addDefaults() {
        this.addDefaultActionButtons();
        this.addDefaultToolWidgets();
    }
    updateWidgetCSSClasses(widget) {
        const tags = widget.getTags();
        widget.removeCSSClassFromContainer('label-inline');
        widget.removeCSSClassFromContainer('label-left');
        widget.removeCSSClassFromContainer('label-right');
        if (tags.includes(_widgets_BaseWidget_mjs__WEBPACK_IMPORTED_MODULE_0__.ToolbarWidgetTag.Save)) {
            widget.addCSSClassToContainer('label-inline');
            widget.addCSSClassToContainer('label-left');
        }
        if (tags.includes(_widgets_BaseWidget_mjs__WEBPACK_IMPORTED_MODULE_0__.ToolbarWidgetTag.Exit)) {
            widget.addCSSClassToContainer('label-inline');
            widget.addCSSClassToContainer('label-right');
        }
    }
    addWidgetInternal(widget) {
        this.updateWidgetCSSClasses(widget);
        widget.setLayoutManager(this.layoutManager);
        if (widget.mustBeInToplevelMenu()) {
            widget.addTo(this.toolbarActionRow);
        }
        else {
            widget.addTo(this.toolbarToolRow);
        }
    }
    removeWidgetInternal(widget) {
        widget.remove();
    }
    onRemove() {
        this.toolbarContainer.remove();
        this.menuContainer.remove();
        this.toolRowResizeObserver.disconnect();
        this.clearDragListeners?.();
    }
    initDragListeners() {
        const dragElements = [this.closeButton, this.sidebarContainer, this.sidebarContent];
        // Forward longer touch events from the menu background to the
        // editor (and close the sidebar).
        this.manageListener(this.editor.handlePointerEventsExceptClicksFrom(this.menuContainer, (eventName, event) => {
            if (event.target === this.menuContainer) {
                if (eventName === 'pointerdown') {
                    this.sidebarVisible.set(false);
                    // A delay seems necessary for the editor
                    setTimeout(() => this.editor.focus(), 0);
                }
                return true;
            }
            if (!this.sidebarVisible.get()) {
                return true;
            }
            // Don't send pointer events that don't directly target mainContainer
            // to the editor
            return false;
        }, (_eventName, event) => {
            return event.target === this.menuContainer;
        }));
        // Set lastGestureWasRoughlyClick to `true` initially because on page load
        // performance.now() is zero.
        let lastGestureWasRoughlyClick = true;
        let gestureEndTimestamp = 0;
        const dragController = (0,_utils_makeDraggable_mjs__WEBPACK_IMPORTED_MODULE_6__["default"])(this.sidebarContainer, {
            draggableChildElements: dragElements,
            onDrag: (deltaX, deltaY) => this.handleDrag(deltaX, deltaY),
            onDragEnd: (dragStatistics) => {
                gestureEndTimestamp = dragStatistics.endTimestamp;
                lastGestureWasRoughlyClick = dragStatistics.roughlyClick;
                this.finalizeDrag();
            },
        });
        this.clearDragListeners = () => dragController.removeListeners();
        this.closeButton.onclick = () => {
            const wasJustDragging = performance.now() - gestureEndTimestamp < 100;
            // Ignore the click event if it was caused by dragging the button.
            if ((wasJustDragging && lastGestureWasRoughlyClick) || !wasJustDragging) {
                this.sidebarVisible.set(false);
            }
        };
    }
    /**
     * Updates the position of this menu **during** a drag. After a drag ends,
     * {@link finalizeDrag} should be called.
     */
    handleDrag(_deltaX, deltaY) {
        this.sidebarContainer.style.transition = 'none';
        this.sidebarY.set(this.sidebarY.get() + deltaY);
    }
    /** Returns `this.sidebarY` rounded to a valid value. */
    snappedSidebarY(sidebarY) {
        const y = sidebarY ?? this.sidebarY.get();
        const snapYs = [-100, 0];
        // Allow some amount of scrolling if the sidebar is too tall to fit entirely
        // in the window.
        if (this.sidebarContainer.clientHeight > window.innerHeight) {
            snapYs.push(100);
        }
        let closestSnap = snapYs[0];
        for (const snapY of snapYs) {
            if (Math.abs(snapY - y) < Math.abs(closestSnap - y)) {
                closestSnap = snapY;
            }
        }
        return closestSnap;
    }
    /**
     * Moves the menu to a valid location or closes it, depending on
     * the position set by the drag.
     */
    finalizeDrag() {
        this.sidebarContainer.style.transition = '';
        if (this.sidebarY.get() > this.sidebarContainer.clientHeight / 2) {
            this.sidebarVisible.set(false);
        }
        else {
            // Snap to the closest valid Y.
            this.sidebarY.set(this.snappedSidebarY());
        }
    }
    serializeInternal() {
        return {
            menuSizeY: this.snappedSidebarY(),
        };
    }
    deserializeInternal(json) {
        if (typeof json === 'object' && typeof json['menuSizeY'] === 'number') {
            // Load the y-position of the sidebar  -- call snappedSidebarY to ensure validity.
            this.sidebarY.set(this.snappedSidebarY(json['menuSizeY']));
        }
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/IconProvider.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/IconProvider.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _rendering_renderers_SVGRenderer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rendering/renderers/SVGRenderer.mjs */ "./node_modules/js-draw/dist/mjs/rendering/renderers/SVGRenderer.mjs");
/* harmony import */ var _Viewport_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Viewport.mjs */ "./node_modules/js-draw/dist/mjs/Viewport.mjs");
/* harmony import */ var _components_builders_FreehandLineBuilder_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/builders/FreehandLineBuilder.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/FreehandLineBuilder.mjs");
/* harmony import */ var _components_builders_PolylineBuilder_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/builders/PolylineBuilder.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/PolylineBuilder.mjs");
/* harmony import */ var _tools_Eraser_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tools/Eraser.mjs */ "./node_modules/js-draw/dist/mjs/tools/Eraser.mjs");
/* harmony import */ var _util_createElement_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/createElement.mjs */ "./node_modules/js-draw/dist/mjs/util/createElement.mjs");
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _IconProvider_instances, _IconProvider_makeXIcon;







const svgNamespace = 'http://www.w3.org/2000/svg';
let checkerboardIdCounter = 0;
const makeCheckerboardPattern = () => {
    const id = `checkerboard-${checkerboardIdCounter++}`;
    const patternElement = (0,_util_createElement_mjs__WEBPACK_IMPORTED_MODULE_6__.createSvgElement)('pattern', {
        id: id,
        viewBox: '0,0,10,10',
        width: '20%',
        height: '20%',
        patternUnits: 'userSpaceOnUse',
        children: (0,_util_createElement_mjs__WEBPACK_IMPORTED_MODULE_6__.createSvgElements)('rect', [
            { x: 0, y: 0, width: 10, height: 10, fill: 'white' },
            { x: 0, y: 0, width: 5, height: 5, fill: 'gray' },
            { x: 5, y: 5, width: 5, height: 5, fill: 'gray' },
        ]),
    });
    const patternRef = `url(#${id})`;
    return {
        patternDefElement: patternElement,
        // @deprecated use patternDefElement
        get patternDef() {
            return patternElement.innerHTML;
        },
        patternRef,
    };
};
const makeRedoIcon = (mirror) => {
    const icon = document.createElementNS(svgNamespace, 'svg');
    icon.innerHTML = `
		<style>
			.toolbar-svg-undo-redo-icon {
				stroke: var(--icon-color);
				stroke-width: 12;
				stroke-linejoin: round;
				stroke-linecap: round;
				fill: none;

				transform-origin: center;
			}
		</style>
	`;
    const path = document.createElementNS(svgNamespace, 'path');
    path.setAttribute('d', 'M20,20 A15,15 0 0 1 70,80 L80,90 L60,70 L65,90 L87,90 L65,80');
    path.classList.add('toolbar-svg-undo-redo-icon');
    if (mirror) {
        path.style.transform = 'scale(-1, 1)';
    }
    icon.appendChild(path);
    icon.setAttribute('viewBox', '0 0 100 100');
    return icon;
};
/**
 * Provides icons that can be used in the toolbar and other locations.
 *
 * To customize the icons used by the editor, extend this class and override methods.
 *
 * @example
 * ```ts,runnable
 * import * as jsdraw from 'js-draw';
 *
 * class CustomIconProvider extends jsdraw.IconProvider {
 *     // Use '☺' instead of the default dropdown symbol.
 *     public override makeDropdownIcon() {
 *         const icon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
 *         icon.innerHTML = `
 *             <text x='5' y='55' style='fill: var(--icon-color); font-size: 50pt;'>☺</text>
 *         `;
 *         icon.setAttribute('viewBox', '0 0 100 100');
 *         return icon;
 *     }
 * }
 *
 * const icons = new CustomIconProvider();
 * const editor = new jsdraw.Editor(document.body, {
 *     // The icon pack to use is specified through the editor's initial
 *     // configuration object:
 *     iconProvider: icons,
 * });
 *
 * // Add a toolbar that uses these icons
 * jsdraw.makeDropdownToolbar(editor).addDefaults();
 * ```
 */
class IconProvider {
    constructor() {
        _IconProvider_instances.add(this);
    }
    makeUndoIcon() {
        return makeRedoIcon(true);
    }
    // @returns a redo icon.
    makeRedoIcon() {
        return makeRedoIcon(false);
    }
    makeDropdownIcon() {
        const icon = this.makeIconFromPath('M5,10 L50,90 L95,10 Z');
        icon.setAttribute('viewBox', '-10 -10 110 110');
        return icon;
    }
    makeEraserIcon(eraserSize, mode) {
        eraserSize ??= 10;
        const scaledSize = eraserSize / 4;
        const eraserColor = '#ff70af';
        // Draw an eraser-like shape. Created with Inkscape
        const icon = (0,_util_createElement_mjs__WEBPACK_IMPORTED_MODULE_6__.createSvgElement)('svg', {
            viewBox: '0 0 120 120',
            children: [
                (0,_util_createElement_mjs__WEBPACK_IMPORTED_MODULE_6__.createSvgElement)('defs', {
                    children: [
                        (0,_util_createElement_mjs__WEBPACK_IMPORTED_MODULE_6__.createSvgElement)('linearGradient', {
                            id: 'dash-pattern',
                            children: (0,_util_createElement_mjs__WEBPACK_IMPORTED_MODULE_6__.createSvgElements)('stop', [
                                { offset: '80%', 'stop-color': eraserColor },
                                { offset: '85%', 'stop-color': 'white' },
                                { offset: '90%', 'stop-color': eraserColor },
                            ]),
                        }),
                    ],
                }),
                (0,_util_createElement_mjs__WEBPACK_IMPORTED_MODULE_6__.createSvgElement)('path', {
                    fill: mode === _tools_Eraser_mjs__WEBPACK_IMPORTED_MODULE_5__.EraserMode.PartialStroke ? 'url(#dash-pattern)' : eraserColor,
                    stroke: 'black',
                    transform: 'rotate(41.35)',
                    d: `
						M 52.5 27
						C 50 28.9 48.9 31.7 48.9 34.8
						L 48.9 39.8
						C 48.9 45.3 53.4 49.8 58.9 49.8
						L 103.9 49.8
						C 105.8 49.8 107.6 49.2 109.1 48.3
						L 110.2 ${scaledSize + 49.5} L 159.7 ${scaledSize + 5}
						L 157.7 ${-scaledSize + 5.2} L 112.4 ${49.5 - scaledSize}
						C 113.4 43.5 113.9 41.7 113.9 39.8
						L 113.9 34.8
						C 113.9 29.3 109.4 24.8 103.9 24.8
						L 58.9 24.8
						C 56.5 24.8 54.3 25.7 52.5 27
						z
					`,
                }),
                (0,_util_createElement_mjs__WEBPACK_IMPORTED_MODULE_6__.createSvgElement)('rect', {
                    stroke: '#cc8077',
                    fill: 'var(--icon-color)',
                    width: 65,
                    height: 75,
                    x: 48.9,
                    y: -38.7,
                    transform: 'rotate(41.35)',
                }),
            ],
        });
        return icon;
    }
    makeSelectionIcon() {
        const icon = document.createElementNS(svgNamespace, 'svg');
        // Draw a cursor-like shape
        icon.innerHTML = `
		<g>
			<rect x="10" y="10" width="70" height="70" fill="pink" stroke="black"/>
			<rect x="75" y="75" width="10" height="10" fill="white" stroke="black"/>
		</g>
		`;
        icon.setAttribute('viewBox', '0 0 100 100');
        return icon;
    }
    makeRotateIcon() {
        const icon = document.createElementNS(svgNamespace, 'svg');
        icon.innerHTML = `
			<defs>
				<marker
					id="arrow-marker"
					viewBox="0 0 10 10"
					refX="3" refY="5"
					markerWidth="3" markerHeight="3"
					orient="auto-start-reverse"
				>
					<path
						d="M0,0 L8,5 L0,10z"
						fill="var(--icon-color)"
					/>
				</marker>
			</defs>

			<path
				marker-start="url(#arrow-marker)"
				d="
					M20,20
					A30,30 0 1 1 80 80
				"
				fill="none"
				stroke="var(--icon-color)"
				stroke-width="12"
			/>
			<path
				d="
					M80,80
					A30,30 0 1 1 20 20
				"
				fill="none"
				stroke="var(--icon-color)"
				stroke-width="12"
				stroke-dasharray="30 10 20 10 20 10 10"
				style="stroke-linecap: butt;"
			/>
		`;
        icon.setAttribute('viewBox', '-5 -5 110 110');
        return icon;
    }
    makeHandToolIcon() {
        const fill = 'none';
        const strokeColor = 'var(--icon-color)';
        const strokeWidth = '3';
        // Draw a cursor-like shape
        return this.makeIconFromPath(`
			m 10,60
				5,30
			H 90
			V 30
			C 90,20 75,20 75,30
			V 60
				20
			C 75,10 60,10 60,20
			V 60
				15
			C 60,5 45,5 45,15
			V 60
				25
			C 45,15 30,15 30,25
			V 60
				75
			L 25,60
			C 20,45 10,50 10,60
			Z
		`, fill, strokeColor, strokeWidth);
    }
    makeTouchPanningIcon() {
        const fill = 'none';
        const strokeColor = 'var(--icon-color)';
        const strokeWidth = '3';
        return this.makeIconFromPath(`
			M 5,5.5
			V 17.2
			L 16.25,5.46
			Z
	
			m 33.75,0
			L 50,17
			V 5.5
			Z
	
			M 5,40.7
			v 11.7
			h 11.25
			z
	
			M 26,19
			C 19.8,19.4 17.65,30.4 21.9,34.8
			L 50,70
			H 27.5
			c -11.25,0 -11.25,17.6 0,17.6
			H 61.25
			C 94.9,87.8 95,87.6 95,40.7 78.125,23 67,29 55.6,46.5
			L 33.1,23
			C 30.3125,20.128192 27.9,19 25.830078,19.119756
			Z
		`, fill, strokeColor, strokeWidth);
    }
    /** Unused by js-draw. @deprecated */
    makeAllDevicePanningIcon() {
        const fill = 'none';
        const strokeColor = 'var(--icon-color)';
        const strokeWidth = '3';
        return this.makeIconFromPath(`
			M 5 5
			L 5 17.5
				17.5 5
				5 5
			z
	
			M 42.5 5
			L 55 17.5
				55 5
				42.5 5
			z
	
			M 70 10
			L 70 21
				61 15
				55.5 23
				66 30
				56 37
				61 45
				70 39
				70 50
				80 50
				80 39
				89 45
				95 36
				84 30
				95 23
				89 15
				80 21
				80 10
				70 10
			z
	
			M 27.5 26.25
			L 27.5 91.25
			L 43.75 83.125
			L 52 99
			L 68 91
			L 60 75
			L 76.25 66.875
			L 27.5 26.25
			z
	
			M 5 42.5
			L 5 55
			L 17.5 55
			L 5 42.5
			z
		`, fill, strokeColor, strokeWidth);
    }
    makeZoomIcon() {
        const icon = document.createElementNS(svgNamespace, 'svg');
        icon.setAttribute('viewBox', '0 0 100 100');
        const addTextNode = (text, x, y) => {
            const textNode = document.createElementNS(svgNamespace, 'text');
            textNode.appendChild(document.createTextNode(text));
            textNode.setAttribute('x', x.toString());
            textNode.setAttribute('y', y.toString());
            textNode.style.textAlign = 'center';
            textNode.style.textAnchor = 'middle';
            textNode.style.fontSize = '55px';
            textNode.style.fill = 'var(--icon-color)';
            textNode.style.fontFamily = 'monospace';
            icon.appendChild(textNode);
        };
        addTextNode('+', 40, 45);
        addTextNode('-', 70, 75);
        return icon;
    }
    makeRotationLockIcon() {
        const icon = this.makeIconFromPath(`
			M 40.1 25.1 
			C 32.5 25 27.9 34.1 27.9 34.1 
			L 25.7 30 
			L 28 44.7 
			L 36.6 40.3 
			L 32.3 38.3 
			C 33.6 28 38.1 25.2 45.1 31.8 
			L 49.4 29.6 
			C 45.9 26.3 42.8 25.1 40.1 25.1 
			z

			M 51.7 34.2 
			L 43.5 39.1 
			L 48 40.8 
			C 47.4 51.1 43.1 54.3 35.7 48.2 
			L 31.6 50.7 
			C 45.5 62.1 52.6 44.6 52.6 44.6 
			L 55.1 48.6 
			L 51.7 34.2 
			z

			M 56.9 49.9 
			C 49.8 49.9 49.2 57.3 49.3 60.9 
			L 47.6 60.9 
			L 47.6 73.7 
			L 66.1 73.7 
			L 66.1 60.9 
			L 64.4 60.9 
			C 64.5 57.3 63.9 49.9 56.9 49.9 
			z

			M 56.9 53.5 
			C 60.8 53.5 61 58.2 60.8 60.9 
			L 52.9 60.9 
			C 52.7 58.2 52.9 53.5 56.9 53.5 
			z
		`);
        icon.setAttribute('viewBox', '10 10 70 70');
        return icon;
    }
    makeInsertImageIcon() {
        return this.makeIconFromPath(`
			M 5 10 L 5 90 L 95 90 L 95 10 L 5 10 z
			M 10 15 L 90 15 L 90 50 L 70 75 L 40 50 L 10 75 L 10 15 z
			M 22.5 25 A 7.5 7.5 0 0 0 15 32.5 A 7.5 7.5 0 0 0 22.5 40 A 7.5 7.5 0 0 0 30 32.5 A 7.5 7.5 0 0 0 22.5 25 z 
		`);
    }
    makeUploadFileIcon() {
        return this.makeIconFromPath(`
			M 48,10 32,34 43,33 42,68
			H 54
			L 53,33 64,34 Z
	
			M 8,66 V 86 H 88 V 66 H 78 V 76 H 18 V 66 Z
		`);
    }
    makeTextIcon(textStyle) {
        const icon = document.createElementNS(svgNamespace, 'svg');
        icon.setAttribute('viewBox', '0 0 100 100');
        const textNode = document.createElementNS(svgNamespace, 'text');
        textNode.appendChild(document.createTextNode('T'));
        textNode.style.fontFamily = textStyle.fontFamily;
        textNode.style.fontWeight = textStyle.fontWeight ?? '';
        textNode.style.fontVariant = textStyle.fontVariant ?? '';
        textNode.style.fill = textStyle.renderingStyle.fill.toHexString();
        textNode.style.textAnchor = 'middle';
        textNode.setAttribute('x', '50');
        textNode.setAttribute('y', '75');
        textNode.style.fontSize = '65px';
        textNode.style.filter = 'drop-shadow(0px 0px 10px var(--shadow-color))';
        icon.appendChild(textNode);
        return icon;
    }
    makePenIcon(penStyle) {
        // Use a square-root scale to prevent the pen's tip from overflowing.
        const strokeSize = Math.round(Math.sqrt(penStyle.thickness) * 4);
        const color = penStyle.color;
        const rounded = this.isRoundedTipPen(penStyle);
        const tipThickness = strokeSize / 2;
        const inkTipPath = `
			M ${15 - tipThickness},${80 - tipThickness}
			  ${15 - tipThickness},${80 + tipThickness}
			  30,83
			  15,65
			Z
		`;
        const trailStartEndY = 80 + tipThickness;
        const inkTrailPath = `
			m ${15 - tipThickness * 1.1},${trailStartEndY}
			c 35,10 55,15 60,30
			l ${35 + tipThickness * 1.2},${-10 - tipThickness}
			C 80.47,98.32 50.5,${90 + tipThickness} 20,${trailStartEndY} Z
		`;
        const colorBubblePath = `
			M 72.45,35.67
			A 10,15 41.8 0 1 55,40.2 10,15 41.8 0 1 57.55,22.3 10,15 41.8 0 1 75,17.8 10,15 41.8 0 1 72.5,35.67
			Z
		`;
        let gripMainPath = 'M 85,-25 25,35 h 10 v 10 h 10 v 10 h 10 v 10 h 10 l -5,10 60,-60 z';
        let gripShadow1Path = 'M 25,35 H 35 L 90,-15 85,-25 Z';
        let gripShadow2Path = 'M 60,75 65,65 H 55 l 55,-55 10,5 z';
        if (rounded) {
            gripMainPath = 'M 85,-25 25,35 c 15,0 40,30 35,40 l 60,-60 z';
            gripShadow1Path = 'm 25,35 c 3.92361,0.384473 7.644275,0.980572 10,3 l 55,-53 -5,-10 z';
            gripShadow2Path = 'M 60,75 C 61,66 59,65 56,59 l 54,-54 10,10 z';
        }
        const penTipPath = `M 25,35 ${10 - tipThickness / 4},${70 - tipThickness / 2} 20,75 25,85 60,75 70,55 45,25 Z`;
        const pencilTipColor = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.fromHex('#f4d7d7');
        const tipColor = pencilTipColor.mix(color, tipThickness / 40 - 0.1).toHexString();
        const checkerboardPattern = makeCheckerboardPattern();
        const colorString = color.toHexString();
        const ink = (0,_util_createElement_mjs__WEBPACK_IMPORTED_MODULE_6__.createSvgPaths)({
            fill: checkerboardPattern.patternRef,
            d: inkTipPath,
        }, {
            fill: checkerboardPattern.patternRef,
            d: inkTrailPath,
        }, {
            fill: colorString,
            d: inkTipPath,
        }, {
            fill: colorString,
            d: inkTrailPath,
        });
        const penTip = (0,_util_createElement_mjs__WEBPACK_IMPORTED_MODULE_6__.createSvgPaths)({ fill: checkerboardPattern.patternRef, d: penTipPath }, { fill: tipColor, stroke: colorString, d: penTipPath });
        const grip = (0,_util_createElement_mjs__WEBPACK_IMPORTED_MODULE_6__.createSvgPaths)({ fill: 'var(--icon-color)', stroke: 'var(--icon-color)', d: gripMainPath }, 
        // Shadows
        { fill: 'rgba(150, 150, 150, 0.3)', d: gripShadow1Path }, { fill: 'rgba(100, 100, 100, 0.2)', d: gripShadow2Path }, 
        // Color bubble
        { fill: checkerboardPattern.patternRef, d: colorBubblePath }, { fill: colorString, d: colorBubblePath });
        const icon = document.createElementNS(svgNamespace, 'svg');
        icon.setAttribute('viewBox', '0 0 100 100');
        const iconMainContent = (0,_util_createElement_mjs__WEBPACK_IMPORTED_MODULE_6__.createSvgElement)('g', {
            children: [ink, penTip, grip].flat(),
        });
        const defs = (0,_util_createElement_mjs__WEBPACK_IMPORTED_MODULE_6__.createSvgElement)('defs', {
            children: [checkerboardPattern.patternDefElement],
        });
        icon.replaceChildren(defs, iconMainContent);
        return icon;
    }
    makeIconFromFactory(penStyle) {
        // Increase the thickness we use to generate the icon less with larger actual thicknesses.
        // We want the icon to be recognisable with a large range of thicknesses.
        const thickness = Math.sqrt(penStyle.thickness) * 3;
        const nowTime = performance.now();
        const startPoint = {
            pos: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(10, 10),
            width: thickness,
            color: penStyle.color,
            time: nowTime - 100,
        };
        const endPoint = {
            pos: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(90, 90),
            width: thickness,
            color: penStyle.color,
            time: nowTime,
        };
        const viewport = new _Viewport_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](() => { });
        const builder = penStyle.factory(startPoint, viewport);
        builder.addPoint(endPoint);
        const icon = document.createElementNS(svgNamespace, 'svg');
        icon.setAttribute('viewBox', '0 0 100 100');
        viewport.updateScreenSize(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(100, 100));
        let renderer;
        // Any transparency? Include a checkerboard grid.
        const includeTransparencyGrid = penStyle.color.a < 1;
        if (includeTransparencyGrid) {
            const checkerboardPattern = makeCheckerboardPattern();
            const defs = document.createElementNS(svgNamespace, 'defs');
            defs.appendChild(checkerboardPattern.patternDefElement);
            icon.appendChild(defs);
            const background = document.createElementNS(svgNamespace, 'g');
            icon.appendChild(background);
            renderer = new (class extends _rendering_renderers_SVGRenderer_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
                constructor() {
                    super(icon, viewport);
                }
                addPathToSVG() {
                    const addedPath = super.addPathToSVG();
                    if (addedPath) {
                        // Add a copy of the path on the background
                        const copy = addedPath.cloneNode(true);
                        copy.style.zIndex = '-1';
                        if (copy.hasAttribute('stroke')) {
                            copy.setAttribute('stroke', checkerboardPattern.patternRef);
                        }
                        // Note: Assumes that the component wouldn't normally be both stroked
                        // and filled.
                        else if (copy.hasAttribute('fill')) {
                            copy.setAttribute('fill', checkerboardPattern.patternRef);
                        }
                        background.appendChild(copy);
                    }
                    return addedPath;
                }
            })();
        }
        else {
            renderer = new _rendering_renderers_SVGRenderer_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](icon, viewport);
        }
        builder.preview(renderer);
        // If only a single path was rendered, try to give it a checkerboard background to
        // emphasize transparency. TODO: This is very fragile
        const bbox = builder.getBBox();
        icon.setAttribute('viewBox', `${bbox.x} ${bbox.y} ${bbox.w} ${bbox.h}`);
        return icon;
    }
    makePipetteIcon(color) {
        const icon = document.createElementNS(svgNamespace, 'svg');
        const mainGroup = document.createElementNS(svgNamespace, 'g');
        mainGroup.style.rotate = '45deg';
        mainGroup.style.transformOrigin = 'center';
        const pipette = document.createElementNS(svgNamespace, 'g');
        pipette.innerHTML = `
		<path
			style="fill: var(--icon-color); stroke-linecap:round; stroke-linejoin:round;"
			d="
				m 32,12 v 68
				c 0,1 0.5,2 1.33,2.5 1.67,1.15 3.67,2.1 5.17,3.2 1.4,1.1 2.3,2.1 2.5,3.1 0.6,2.1 1,4.6 1,6.2 0,3.7 5.45,4.1 6,0.4 l 0.9,-6.8
				c 0.3,-0.9 1.1,-1.9 2.6,-2.9 1.5,-1.1 3.4,-2 5.1,-3.2
				C 57.5,82 58,81 58,80
				V 12 Z m 20,25 v 41.3
				c 0,1.7 -2.5,1.6 -4,2.7 -1,0.76 -2.1,1.5 -3,2.6
				C 44,82.5 43.02,81.75 42,81 40.51,79.92 38,80 38,78.34
				V 51 Z
			"
		/>
		<rect
			style="fill: var(--icon-color);"
			width="32"
			height="9"
			x="29"
			y="2"
			ry="4.5"
		/>
		<path
			style="fill: var(--icon-color);"
			d="m 45,-25 c -5.54,0 -11,4.26 -11,9 V 0 h 22 v -16 c 0,-4.74 -5.46,-9 -11,-9 z"
		/>
		`;
        if (color) {
            const checkerboardPattern = makeCheckerboardPattern();
            const defs = document.createElementNS(svgNamespace, 'defs');
            defs.appendChild(checkerboardPattern.patternDefElement);
            icon.appendChild(defs);
            const fluidBackground = document.createElementNS(svgNamespace, 'path');
            const fluid = document.createElementNS(svgNamespace, 'path');
            const fluidPathData = `
				M 35,36 H 55 V 78.678012 83 L 45,87 35,83 Z
			`;
            fluid.setAttribute('d', fluidPathData);
            fluidBackground.setAttribute('d', fluidPathData);
            fluid.style.fill = color.toHexString();
            fluidBackground.style.fill = checkerboardPattern.patternRef;
            mainGroup.appendChild(fluidBackground);
            mainGroup.appendChild(fluid);
        }
        mainGroup.appendChild(pipette);
        icon.appendChild(mainGroup);
        icon.setAttribute('viewBox', '5 -40 140 140');
        return icon;
    }
    makeShapeAutocorrectIcon() {
        const fill = 'none';
        const strokeColor = 'var(--icon-color)';
        return this.makeIconFromPath(`
			m 79.129476,33.847107 9.967823,-0.03218 v 55 h -55 l 0.03218,-9.96782
			M 71.1,40.8 a 30,30 0 0 1 -30,30 30,30 0 0 1 -30,-30 30,30 0 0 1 30,-30 30,30 0 0 1 30,30 L 71.1,40.8
			M 34.1,58.8 v -25 h 25 v 0
		`, fill, strokeColor, '7px');
    }
    makeStrokeSmoothingIcon() {
        const fill = 'none';
        const strokeColor = 'var(--icon-color)';
        return this.makeIconFromPath(`
			m 31,83.2 c -50,0 30,-65 -20,-65
			M 75,17.3 40,59.7 38.2,77.6 55.5,72.4 90.5,30 Z
		`, fill, strokeColor, '7px');
    }
    /** Unused. @deprecated */
    makeFormatSelectionIcon() {
        return this.makeIconFromPath(`
			M 5 10
			L 5 20 L 10 20 L 10 15 L 20 15 L 20 40 L 15 40 L 15 45 L 35 45 L 35 40 L 30 40 L 30 15 L 40 15 L 40 20 L 45 20 L 45 15 L 45 10 L 5 10 z
			M 90 10 C 90 10 86.5 13.8 86 14 C 86 14 76.2 24.8 76 25 L 60 25 L 60 65 C 75 70 85 70 90 65 L 90 25 L 80 25 L 76.7 25 L 90 10 z
			M 60 25 L 55 25 L 50 30 L 60 25 z
			M 10 55 L 10 90 L 41 90 L 41 86 L 45 86 L 45 55 L 10 55 z
			M 42 87 L 42 93 L 48 93 L 48 87 L 42 87 z 
		`);
    }
    makeResizeImageToSelectionIcon() {
        return this.makeIconFromPath(`
			M 75 5 75 10 90 10 90 25 95 25 95 5 75 5 z
			M 15 15 15 30 20 30 20 20 30 20 30 15 15 15 z
			M 84 15 82 17 81 16 81 20 85 20 84 19 86 17 84 15 z
			M 26 24 24 26 26 28 25 29 29 29 29 25 28 26 26 24 z
			M 25 71 26 72 24 74 26 76 28 74 29 75 29 71 25 71 z
			M 15 75 15 85 25 85 25 80 20 80 20 75 15 75 z
			M 90 75 90 90 75 90 75 95 95 95 95 75 90 75 z
			M 81 81 81 85 82 84 84 86 86 84 84 82 85 81 81 81 z
		`);
    }
    /** Renamed to {@link makeResizeImageToSelectionIcon} @deprecated */
    makeResizeViewportIcon() {
        return this.makeResizeImageToSelectionIcon();
    }
    makeDuplicateSelectionIcon() {
        return this.makeIconFromPath(`
			M 45,10 45,55 90,55 90,10 45,10 z
			M 10,25 10,90 70,90 70,60 40,60 40,25 10,25 z 
		`);
    }
    makeCopyIcon() {
        return this.makeIconFromPath(`
			M 45,10 45,55 90,55 90,10 45,10 z
			M 10,25 10,90 70,90 70,60 40,60 40,25 10,25 z 
		`);
    }
    makePasteIcon() {
        const icon = this.makeIconFromPath(`
			M 50 0 L 50 5 L 35 5 L 40 24.75 L 20 25 L 20 100 L 85 100 L 100 90 L 100 24 L 75.1 24.3 L 80 5 L 65 5 L 65 0 L 50 0 z
			M 10 15 L 10 115 L 110 115 L 110 15 L 85 15 L 83 20 L 105 20 L 105 110 L 15 110 L 15 20 L 32 20 L 30 15 L 10 15 z
			M 25 35 L 90 35 L 90 40 L 25 40 L 25 35 z
			M 25 45 L 90 45 L 90 50 L 25 50 L 25 45 z
			M 25 55 L 85 55 L 85 60 L 25 60 L 25 55 z
			M 25 65 L 90 65 L 90 70 L 25 70 L 25 65 z 
		`);
        icon.setAttribute('viewBox', '0 0 120 120');
        return icon;
    }
    makeDeleteSelectionIcon() {
        return __classPrivateFieldGet(this, _IconProvider_instances, "m", _IconProvider_makeXIcon).call(this);
    }
    makeCloseIcon() {
        return __classPrivateFieldGet(this, _IconProvider_instances, "m", _IconProvider_makeXIcon).call(this);
    }
    makeSaveIcon() {
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.innerHTML = `
			<style>
				.toolbar-save-icon {
					stroke: var(--icon-color);
					stroke-width: 6;
					stroke-linejoin: round;
					stroke-linecap: round;
					fill: none;
				}
			</style>
			<path
				d='
					M 15,55 30,70 85,20
				'
				class='toolbar-save-icon'
			/>
		`;
        svg.setAttribute('viewBox', '0 0 100 100');
        return svg;
    }
    makeConfigureDocumentIcon() {
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.innerHTML = `
			<path
				d='
					M 5,5 V 95 H 95 V 5 Z m 5,5 H 90 V 90 H 10 Z
					m 5,10 V 30 H 50 V 25 H 20 v -5 z
					m 40,0 V 50 H 85 V 20 Z
					m 2,2 H 83 V 39 L 77,28 70,42 64,35 57,45 Z
					m 8.5,5 C 64.67,27 64,27.67 64,28.5 64,29.33 64.67,30 65.5,30 66.33,30 67,29.33 67,28.5 67,27.67 66.33,27 65.5,27 Z
					M 15,40 v 5 h 35 v -5 z
					m 0,15 v 5 h 70 v -5 z
					m 0,15 v 5 h 70 v -5 z
				'
				style='fill: var(--icon-color);'
			/>
		`;
        svg.setAttribute('viewBox', '0 0 100 100');
        return svg;
    }
    makeOverflowIcon() {
        return this.makeIconFromPath(`
			M 15 40
			A 12.5 12.5 0 0 0 2.5 52.5
			A 12.5 12.5 0 0 0 15 65
			A 12.5 12.5 0 0 0 27.5 52.5
			A 12.5 12.5 0 0 0 15 40
			z
	
			M 50 40
			A 12.5 12.5 0 0 0 37.5 52.5
			A 12.5 12.5 0 0 0 50 65
			A 12.5 12.5 0 0 0 62.5 52.5
			A 12.5 12.5 0 0 0 50 40
			z
			
			M 85 40
			A 12.5 12.5 0 0 0 72.5 52.5
			A 12.5 12.5 0 0 0 85 65
			A 12.5 12.5 0 0 0 97.5 52.5
			A 12.5 12.5 0 0 0 85 40
			z
		`);
    }
    makeHelpIcon() {
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.innerHTML = `
			<circle
				style="stroke-width:1.587; stroke: var(--icon-color);"
				fill="none"
				cx="13.23"
				cy="13.23"
				r="11.9"
			/>
			<path
				style="stroke-width: 3; stroke-linecap: butt; stroke: var(--icon-color);"
				fill="none"
				d="M 9.26,6.61 C 18.7,3.25 19.95,10.4 14.3,13.4 c -1.15,0.61 -1.32,1.32 -1.32,2.65 v 2.12"
			/>
			<circle
				style="fill: var(--icon-color);"
				cx="13"
				cy="21.32"
				r="1.9"
			/>
		`;
        svg.setAttribute('viewBox', '0 0 26.46 26.46');
        svg.setAttribute('width', '100');
        svg.setAttribute('height', '100');
        return svg;
    }
    /**
     * @param pathData - SVG path data (e.g. `m10,10l30,30z`)
     * @param fill - A valid CSS color (e.g. `var(--icon-color)` or `#f0f`). This can be `none`.
     */
    makeIconFromPath(pathData, fill = 'var(--icon-color)', strokeColor = 'none', strokeWidth = '0px') {
        const icon = document.createElementNS(svgNamespace, 'svg');
        const path = document.createElementNS(svgNamespace, 'path');
        path.setAttribute('d', pathData);
        path.style.fill = fill;
        path.style.stroke = strokeColor;
        path.style.strokeWidth = strokeWidth;
        icon.appendChild(path);
        icon.setAttribute('viewBox', '0 0 100 100');
        return icon;
    }
    /**
     * @returns An object with both the definition of a checkerboard pattern and the syntax to
     * reference that pattern. The defs provided by this function should be wrapped within a
     * `<defs></defs>` element.
     *
     * **Note**: This function's return value includes both `patternDefElement` (which returns
     * an Element) and a (deprecated) `patternDef` string. Avoid using the `patternDef` result.
     */
    makeCheckerboardPattern() {
        return makeCheckerboardPattern();
    }
    /**
     * @returns true if the given `penStyle` is known to match a rounded tip type of pen.
     */
    isRoundedTipPen(penStyle) {
        return penStyle.factory === _components_builders_FreehandLineBuilder_mjs__WEBPACK_IMPORTED_MODULE_3__.makeFreehandLineBuilder || penStyle.factory === _components_builders_PolylineBuilder_mjs__WEBPACK_IMPORTED_MODULE_4__.makePolylineBuilder;
    }
    isPolylinePen(penStyle) {
        return penStyle.factory === _components_builders_PolylineBuilder_mjs__WEBPACK_IMPORTED_MODULE_4__.makePolylineBuilder;
    }
    /** Must be overridden by icon packs that need attribution. */
    licenseInfo() {
        return null;
    }
}
_IconProvider_instances = new WeakSet(), _IconProvider_makeXIcon = function _IconProvider_makeXIcon() {
    const strokeWidth = '6px';
    const strokeColor = 'var(--icon-color)';
    const fillColor = 'none';
    return this.makeIconFromPath(`
			M 15,15 85,85
			M 15,85 85,15
		`, fillColor, strokeColor, strokeWidth);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconProvider);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/constants.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/constants.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   toolbarCSSPrefix: () => (/* binding */ toolbarCSSPrefix)
/* harmony export */ });
const toolbarCSSPrefix = 'toolbar-';


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/lib.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/lib.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ActionButtonWidget: () => (/* reexport safe */ _widgets_lib_mjs__WEBPACK_IMPORTED_MODULE_0__.ActionButtonWidget),
/* harmony export */   BaseToolWidget: () => (/* reexport safe */ _widgets_lib_mjs__WEBPACK_IMPORTED_MODULE_0__.BaseToolWidget),
/* harmony export */   BaseWidget: () => (/* reexport safe */ _widgets_lib_mjs__WEBPACK_IMPORTED_MODULE_0__.BaseWidget),
/* harmony export */   DocumentPropertiesWidget: () => (/* reexport safe */ _widgets_lib_mjs__WEBPACK_IMPORTED_MODULE_0__.DocumentPropertiesWidget),
/* harmony export */   EraserToolWidget: () => (/* reexport safe */ _widgets_lib_mjs__WEBPACK_IMPORTED_MODULE_0__.EraserToolWidget),
/* harmony export */   HandToolWidget: () => (/* reexport safe */ _widgets_lib_mjs__WEBPACK_IMPORTED_MODULE_0__.HandToolWidget),
/* harmony export */   IconProvider: () => (/* reexport safe */ _IconProvider_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   InsertImageWidget: () => (/* reexport safe */ _widgets_lib_mjs__WEBPACK_IMPORTED_MODULE_0__.InsertImageWidget),
/* harmony export */   PenToolWidget: () => (/* reexport safe */ _widgets_lib_mjs__WEBPACK_IMPORTED_MODULE_0__.PenToolWidget),
/* harmony export */   SelectionToolWidget: () => (/* reexport safe */ _widgets_lib_mjs__WEBPACK_IMPORTED_MODULE_0__.SelectionToolWidget),
/* harmony export */   TextToolWidget: () => (/* reexport safe */ _widgets_lib_mjs__WEBPACK_IMPORTED_MODULE_0__.TextToolWidget),
/* harmony export */   ToolbarWidgetTag: () => (/* reexport safe */ _widgets_lib_mjs__WEBPACK_IMPORTED_MODULE_0__.ToolbarWidgetTag),
/* harmony export */   makeColorInput: () => (/* reexport safe */ _widgets_components_makeColorInput_mjs__WEBPACK_IMPORTED_MODULE_1__.makeColorInput),
/* harmony export */   makeDropdownToolbar: () => (/* reexport safe */ _DropdownToolbar_mjs__WEBPACK_IMPORTED_MODULE_3__.makeDropdownToolbar),
/* harmony export */   makeEdgeToolbar: () => (/* reexport safe */ _EdgeToolbar_mjs__WEBPACK_IMPORTED_MODULE_4__.makeEdgeToolbar)
/* harmony export */ });
/* harmony import */ var _widgets_lib_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./widgets/lib.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/lib.mjs");
/* harmony import */ var _widgets_components_makeColorInput_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./widgets/components/makeColorInput.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeColorInput.mjs");
/* harmony import */ var _IconProvider_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IconProvider.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/IconProvider.mjs");
/* harmony import */ var _DropdownToolbar_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DropdownToolbar.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/DropdownToolbar.mjs");
/* harmony import */ var _EdgeToolbar_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EdgeToolbar.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/EdgeToolbar.mjs");







/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/localization.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/localization.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultToolbarLocalization: () => (/* binding */ defaultToolbarLocalization)
/* harmony export */ });
/* harmony import */ var _utils_localization_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/localization.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/utils/localization.mjs");

const defaultToolbarLocalization = {
    ..._utils_localization_mjs__WEBPACK_IMPORTED_MODULE_0__.defaultToolbarUtilsLocalization,
    pen: 'Pen',
    eraser: 'Eraser',
    select: 'Select',
    handTool: 'Pan',
    zoom: 'Zoom',
    image: 'Image',
    reformatSelection: 'Format selection',
    inputAltText: 'Alt text',
    decreaseImageSize: 'Decrease size',
    resetImage: 'Reset',
    chooseFile: 'Choose file',
    dragAndDropHereOrBrowse: 'Drag and drop here\nor\n{{browse}}',
    submit: 'Submit',
    addAll: 'Add all',
    cancel: 'Cancel',
    resetView: 'Reset view',
    thicknessLabel: 'Thickness',
    colorLabel: 'Color',
    fontLabel: 'Font',
    textSize: 'Size',
    resizeImageToSelection: 'Resize image to selection',
    deleteSelection: 'Delete selection',
    duplicateSelection: 'Duplicate selection',
    exit: 'Exit',
    save: 'Save',
    undo: 'Undo',
    redo: 'Redo',
    fullStrokeEraser: 'Full stroke eraser',
    selectPenType: 'Pen type',
    selectShape: 'Shape',
    pickColorFromScreen: 'Pick color from screen',
    clickToPickColorAnnouncement: 'Click on the screen to pick a color',
    colorSelectionCanceledAnnouncement: 'Color selection canceled',
    selectionToolKeyboardShortcuts: 'Selection tool: Use arrow keys to move selected items, lowercase/uppercase ‘i’ and ‘o’ to resize.',
    documentProperties: 'Page',
    backgroundColor: 'Background color',
    imageWidthOption: 'Width',
    imageHeightOption: 'Height',
    useGridOption: 'Grid',
    enableAutoresizeOption: 'Auto-resize',
    toggleOverflow: 'More',
    about: 'About',
    inputStabilization: 'Stabilization',
    strokeAutocorrect: 'Autocorrect',
    touchPanning: 'Scroll with touch',
    roundedTipPen: 'Round',
    roundedTipPen2: 'Polyline',
    flatTipPen: 'Flat',
    arrowPen: 'Arrow',
    linePen: 'Line',
    outlinedRectanglePen: 'Outlined rectangle',
    filledRectanglePen: 'Filled rectangle',
    outlinedCirclePen: 'Outlined circle',
    lockRotation: 'Lock rotation',
    paste: 'Paste',
    errorImageHasZeroSize: 'Error: Image has zero size',
    describeTheImage: 'Image description',
    fileInput__loading: 'Loading...',
    fileInput__andNMoreFiles: (n) => `(...${n} more)`,
    // Help text
    penDropdown__baseHelpText: 'This tool draws shapes or freehand lines.',
    penDropdown__colorHelpText: "Changes the pen's color",
    penDropdown__thicknessHelpText: 'Changes the thickness of strokes drawn by the pen.',
    penDropdown__penTypeHelpText: 'Changes the pen style.\n\nEither a “pen” style or “shape” can be chosen. Choosing a “pen” style draws freehand lines. Choosing a “shape” draws shapes.',
    penDropdown__autocorrectHelpText: 'Converts approximate freehand lines and rectangles to perfect ones.\n\nThe pen must be held stationary at the end of a stroke to trigger a correction.',
    penDropdown__stabilizationHelpText: 'Draws smoother strokes.\n\nThis also adds a short delay between the mouse/stylus and the stroke.',
    handDropdown__baseHelpText: 'This tool is responsible for scrolling, rotating, and zooming the editor.',
    handDropdown__zoomInHelpText: 'Zooms in.',
    handDropdown__zoomOutHelpText: 'Zooms out.',
    handDropdown__resetViewHelpText: 'Resets the zoom level to 100% and resets scroll.',
    handDropdown__zoomDisplayHelpText: 'Shows the current zoom level. 100% shows the image at its actual size.',
    handDropdown__touchPanningHelpText: 'When enabled, touchscreen gestures move the image rather than select or draw.',
    handDropdown__lockRotationHelpText: 'When enabled, prevents touch gestures from rotating the screen.',
    eraserDropdown__baseHelpText: 'This tool removes strokes, images, and text under the cursor.',
    eraserDropdown__thicknessHelpText: 'Changes the size of the eraser.',
    eraserDropdown__fullStrokeEraserHelpText: 'When in full-stroke mode, entire shapes are erased.\n\nWhen not in full-stroke mode, shapes can be partially erased.',
    selectionDropdown__baseHelpText: 'Selects content and manipulates the selection',
    selectionDropdown__resizeToHelpText: "Crops the drawing to the size of what's currently selected.\n\nIf auto-resize is enabled, it will be disabled.",
    selectionDropdown__deleteHelpText: 'Erases selected items.',
    selectionDropdown__duplicateHelpText: 'Makes a copy of selected items.',
    selectionDropdown__changeColorHelpText: 'Changes the color of selected items.',
    pageDropdown__baseHelpText: "Controls the drawing canvas' background color, pattern, and size.",
    pageDropdown__backgroundColorHelpText: 'Changes the background color of the drawing canvas.',
    pageDropdown__gridCheckboxHelpText: 'Enables/disables a background grid pattern.',
    pageDropdown__autoresizeCheckboxHelpText: 'When checked, the page grows to fit the drawing.\n\nWhen unchecked, the page is visible and its size can be set manually.',
    pageDropdown__aboutButtonHelpText: 'Shows version, debug, and other information.',
    colorPickerPipetteHelpText: 'Picks a color from the screen.',
    colorPickerToggleHelpText: 'Opens/closes the color picker.',
    closeSidebar: (toolName) => `Close sidebar for ${toolName}`,
    dropdownShown: (toolName) => `Menu for ${toolName} shown`,
    dropdownHidden: (toolName) => `Menu for ${toolName} hidden`,
    zoomLevel: (zoomPercent) => `Zoom: ${zoomPercent}%`,
    colorChangedAnnouncement: (color) => `Color changed to ${color}`,
    imageSize: (size, units) => `Image size: ${size} ${units}`,
    imageLoadError: (message) => `Error loading image: ${message}`,
};


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/utils/HelpDisplay.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/utils/HelpDisplay.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _makeDraggable_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./makeDraggable.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/utils/makeDraggable.mjs");
/* harmony import */ var _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/ReactiveValue.mjs */ "./node_modules/js-draw/dist/mjs/util/ReactiveValue.mjs");
/* harmony import */ var _util_cloneElementWithStyles_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/cloneElementWithStyles.mjs */ "./node_modules/js-draw/dist/mjs/util/cloneElementWithStyles.mjs");
/* harmony import */ var _util_addLongPressOrHoverCssClasses_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/addLongPressOrHoverCssClasses.mjs */ "./node_modules/js-draw/dist/mjs/util/addLongPressOrHoverCssClasses.mjs");
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _HelpDisplay_helpData;





/**
 * Creates the main content of the help overlay.
 *
 * Shows the label for a `HelpRecord` and a highlighted copy
 * of that label's `targetElements`.
 */
const createHelpPage = (helpItems, onItemClick, onBackgroundClick, context) => {
    const container = document.createElement('div');
    container.classList.add('help-page-container');
    const textLabel = document.createElement('div');
    textLabel.classList.add('label', '-space-above');
    textLabel.setAttribute('aria-live', 'polite');
    // The current active item in helpItems.
    // (Only one item is active at a time, but each item can have multiple HTMLElements).
    let currentItemIndex = 0;
    let currentItem = helpItems[0] ?? null;
    // Each help item can have multiple associated elements. We store clones of each
    // of these elements in their own container.
    //
    // clonedElementContainers maps from help item indicies to **arrays** of containers.
    //
    // For example, clonedElementContainers would be
    //   [ [ Container1, Container2 ], [ Container3 ], [ Container4 ]]
    //       ↑                            ↑              ↑
    //       HelpItem 1                   HelpItem 2     HelpItem 3
    // if the first help item had two elements (and thus two cloned element containers).
    //
    // We also store the original bounding box -- the bounding box of the clones can change
    // while dragging to switch pages.
    let clonedElementContainers = [];
    // Clicking on the background of the help area should send an event (e.g. to allow the
    // help container to be closed).
    container.addEventListener('click', (event) => {
        // If clicking directly on the container (and not on a child)
        if (event.target === container) {
            onBackgroundClick();
        }
    });
    // Returns the combined bounding box of all elements associated with the currentItem
    // (all active help items).
    const getCombinedBBox = () => {
        if (!currentItem) {
            return _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2.empty;
        }
        const itemBoundingBoxes = currentItem.targetElements.map((element) => _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2.of(element.getBoundingClientRect()));
        return _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2.union(...itemBoundingBoxes);
    };
    // Updates each cloned element's click listener and CSS classes based on whether
    // that element is the current focused element.
    const updateClonedElementStates = () => {
        const currentItemBBox = getCombinedBBox();
        for (let index = 0; index < clonedElementContainers.length; index++) {
            for (const { container, bbox: containerBBox } of clonedElementContainers[index]) {
                if (index === currentItemIndex) {
                    container.classList.add('-active');
                    container.classList.remove('-clickable', '-background');
                    container.onclick = () => { };
                }
                // Otherwise, if not containing the current element
                else {
                    if (!containerBBox.containsRect(currentItemBBox)) {
                        container.classList.add('-clickable');
                        container.classList.remove('-active', '-background');
                    }
                    else {
                        container.classList.add('-background');
                        container.classList.remove('-active', '-clickable');
                    }
                    const containerIndex = index;
                    container.onclick = () => {
                        onItemClick(containerIndex);
                    };
                }
            }
        }
    };
    // Ensures that the item label doesn't overlap the current help item's cloned element.
    const updateLabelPosition = () => {
        const labelBBox = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2.of(textLabel.getBoundingClientRect());
        const combinedBBox = getCombinedBBox();
        if (labelBBox.intersects(combinedBBox)) {
            const containerBBox = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2.of(container.getBoundingClientRect());
            const spaceAboveCombined = combinedBBox.topLeft.y;
            const spaceBelowCombined = containerBBox.bottomLeft.y - combinedBBox.bottomLeft.y;
            if (spaceAboveCombined > spaceBelowCombined && spaceAboveCombined > labelBBox.height / 3) {
                // Push to the very top
                textLabel.classList.remove('-small-space-above', '-large-space-above');
                textLabel.classList.add('-large-space-below');
            }
            if (spaceAboveCombined < spaceBelowCombined && spaceBelowCombined > labelBBox.height) {
                // Push to the very bottom
                textLabel.classList.add('-large-space-above');
                textLabel.classList.remove('-large-space-below');
            }
        }
    };
    const refreshContent = () => {
        container.replaceChildren();
        // Add the text label first so that screen readers will visit it first.
        textLabel.classList.remove('-large-space-above');
        textLabel.classList.add('-small-space-above', '-large-space-below');
        container.appendChild(textLabel);
        const screenBBox = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2(0, 0, window.innerWidth, window.innerHeight);
        clonedElementContainers = [];
        for (let itemIndex = 0; itemIndex < helpItems.length; itemIndex++) {
            const item = helpItems[itemIndex];
            const itemCloneContainers = [];
            for (const targetElement of item.targetElements) {
                let targetBBox = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2.of(targetElement.getBoundingClientRect());
                // Move the element onto the screen if not visible
                if (!screenBBox.intersects(targetBBox)) {
                    const screenBottomCenter = screenBBox.bottomLeft.lerp(screenBBox.bottomRight, 0.5);
                    const targetBottomCenter = targetBBox.bottomLeft.lerp(targetBBox.bottomRight, 0.5);
                    const delta = screenBottomCenter.minus(targetBottomCenter);
                    targetBBox = targetBBox.translatedBy(delta);
                }
                const clonedElement = (0,_util_cloneElementWithStyles_mjs__WEBPACK_IMPORTED_MODULE_3__["default"])(targetElement);
                // Interacting with the clone won't trigger event listeners, so disable
                // all inputs.
                for (const input of clonedElement.querySelectorAll('input')) {
                    input.disabled = true;
                }
                clonedElement.style.margin = '0';
                const clonedElementContainer = document.createElement('div');
                clonedElementContainer.classList.add('cloned-element-container');
                clonedElementContainer.style.position = 'absolute';
                clonedElementContainer.style.left = `${targetBBox.topLeft.x}px`;
                clonedElementContainer.style.top = `${targetBBox.topLeft.y}px`;
                clonedElementContainer.replaceChildren(clonedElement);
                (0,_util_addLongPressOrHoverCssClasses_mjs__WEBPACK_IMPORTED_MODULE_4__["default"])(clonedElementContainer, { timeout: 0 });
                itemCloneContainers.push({ container: clonedElementContainer, bbox: targetBBox });
                container.appendChild(clonedElementContainer);
            }
            clonedElementContainers.push(itemCloneContainers);
        }
        updateClonedElementStates();
    };
    const refresh = () => {
        refreshContent();
        updateLabelPosition();
    };
    const onItemChange = () => {
        const helpTextElement = document.createElement('div');
        helpTextElement.innerText = currentItem?.helpText ?? '';
        // For tests
        helpTextElement.classList.add('current-item-help');
        const navigationHelpElement = document.createElement('div');
        navigationHelpElement.innerText = context.localization.helpScreenNavigationHelp;
        navigationHelpElement.classList.add('navigation-help');
        textLabel.replaceChildren(helpTextElement, ...(currentItemIndex === 0 ? [navigationHelpElement] : []));
        updateClonedElementStates();
    };
    onItemChange();
    return {
        addToParent: (parent) => {
            refreshContent();
            parent.appendChild(container);
            updateLabelPosition();
        },
        refresh,
        setPageIndex: (pageIndex) => {
            currentItemIndex = pageIndex;
            currentItem = helpItems[pageIndex];
            onItemChange();
        },
    };
};
/**
 * Creates and manages an overlay that shows help text for a set of
 * `HTMLElement`s.
 *
 * @see {@link BaseWidget.fillDropdown}.
 */
class HelpDisplay {
    /** Constructed internally by BaseWidget. @internal */
    constructor(createOverlay, context) {
        this.createOverlay = createOverlay;
        this.context = context;
        _HelpDisplay_helpData.set(this, []);
    }
    /** @internal */
    showHelpOverlay() {
        const overlay = document.createElement('dialog');
        overlay.setAttribute('autofocus', 'true');
        overlay.classList.add('toolbar-help-overlay');
        // Closes the overlay with a closing animation
        const closing = false;
        const closeOverlay = () => {
            if (closing)
                return;
            // If changing animationDelay, be sure to also update the CSS.
            const animationDelay = 250; // ms
            overlay.classList.add('-hiding');
            setTimeout(() => overlay.close(), animationDelay);
        };
        let lastDragTimestamp = 0;
        const onBackgroundClick = () => {
            const wasJustDragging = performance.now() - lastDragTimestamp < 100;
            if (!wasJustDragging) {
                closeOverlay();
            }
        };
        const makeCloseButton = () => {
            const closeButton = document.createElement('button');
            closeButton.classList.add('close-button');
            closeButton.appendChild(this.context.icons.makeCloseIcon());
            const label = this.context.localization.close;
            closeButton.setAttribute('aria-label', label);
            closeButton.setAttribute('title', label);
            closeButton.onclick = () => {
                closeOverlay();
            };
            return closeButton;
        };
        // Wraps the label and clickable help elements
        const makeNavigationContent = () => {
            const currentPage = _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_2__.MutableReactiveValue.fromInitialValue(0);
            const content = document.createElement('div');
            content.classList.add('navigation-content');
            const helpPage = createHelpPage(__classPrivateFieldGet(this, _HelpDisplay_helpData, "f"), (newPageIndex) => currentPage.set(newPageIndex), onBackgroundClick, this.context);
            helpPage.addToParent(content);
            const showPage = (pageIndex) => {
                if (pageIndex >= __classPrivateFieldGet(this, _HelpDisplay_helpData, "f").length || pageIndex < 0) {
                    // Hide if out of bounds
                    console.warn('Help screen: Navigated to out-of-bounds page', pageIndex);
                    content.style.display = 'none';
                }
                else {
                    content.style.display = '';
                    helpPage.setPageIndex(pageIndex);
                }
            };
            currentPage.onUpdateAndNow(showPage);
            const navigationControl = {
                content,
                currentPage,
                toNext: () => {
                    if (navigationControl.hasNext()) {
                        currentPage.set(currentPage.get() + 1);
                    }
                },
                toPrevious: () => {
                    if (navigationControl.hasPrevious()) {
                        currentPage.set(currentPage.get() - 1);
                    }
                },
                hasNext: () => {
                    return currentPage.get() + 1 < __classPrivateFieldGet(this, _HelpDisplay_helpData, "f").length;
                },
                hasPrevious: () => {
                    return currentPage.get() > 0;
                },
                refreshCurrent: () => {
                    helpPage.refresh();
                },
            };
            return navigationControl;
        };
        // Creates next/previous buttons.
        const makeNavigationButtons = (navigation) => {
            const navigationButtonContainer = document.createElement('div');
            navigationButtonContainer.classList.add('navigation-buttons');
            const nextButton = document.createElement('button');
            const previousButton = document.createElement('button');
            nextButton.innerText = this.context.localization.next;
            previousButton.innerText = this.context.localization.previous;
            nextButton.classList.add('next');
            previousButton.classList.add('previous');
            const updateButtonVisibility = () => {
                navigationButtonContainer.classList.remove('-has-next', '-has-previous');
                if (navigation.hasNext()) {
                    navigationButtonContainer.classList.add('-has-next');
                    nextButton.disabled = false;
                }
                else {
                    navigationButtonContainer.classList.remove('-has-next');
                    nextButton.disabled = true;
                }
                if (navigation.hasPrevious()) {
                    navigationButtonContainer.classList.add('-has-previous');
                    previousButton.disabled = false;
                }
                else {
                    navigationButtonContainer.classList.remove('-has-previous');
                    previousButton.disabled = true;
                }
            };
            navigation.currentPage.onUpdateAndNow(updateButtonVisibility);
            nextButton.onclick = () => {
                navigation.toNext();
            };
            previousButton.onclick = () => {
                navigation.toPrevious();
            };
            navigationButtonContainer.replaceChildren(previousButton, nextButton);
            return navigationButtonContainer;
        };
        const navigation = makeNavigationContent();
        const navigationButtons = makeNavigationButtons(navigation);
        overlay.replaceChildren(makeCloseButton(), navigationButtons, navigation.content);
        this.createOverlay(overlay);
        overlay.showModal();
        const minDragOffsetToTransition = 30;
        const setDragOffset = (offset) => {
            if (offset > 0 && !navigation.hasPrevious()) {
                offset = 0;
            }
            if (offset < 0 && !navigation.hasNext()) {
                offset = 0;
            }
            // Clamp offset
            if (offset > minDragOffsetToTransition || offset < -minDragOffsetToTransition) {
                offset = minDragOffsetToTransition * Math.sign(offset);
            }
            overlay.style.transform = `translate(${offset}px, 0px)`;
            if (offset >= minDragOffsetToTransition) {
                navigationButtons.classList.add('-highlight-previous');
            }
            else {
                navigationButtons.classList.remove('-highlight-previous');
            }
            if (offset <= -minDragOffsetToTransition) {
                navigationButtons.classList.add('-highlight-next');
            }
            else {
                navigationButtons.classList.remove('-highlight-next');
            }
        };
        // Listeners
        const dragListener = (0,_makeDraggable_mjs__WEBPACK_IMPORTED_MODULE_1__["default"])(overlay, {
            draggableChildElements: [navigation.content],
            onDrag: (_deltaX, _deltaY, totalDisplacement) => {
                overlay.classList.add('-dragging');
                setDragOffset(totalDisplacement.x);
            },
            onDragEnd: (dragStatistics) => {
                overlay.classList.remove('-dragging');
                setDragOffset(0);
                if (!dragStatistics.roughlyClick) {
                    const xDisplacement = dragStatistics.displacement.x;
                    if (xDisplacement > minDragOffsetToTransition) {
                        navigation.toPrevious();
                    }
                    else if (xDisplacement < -minDragOffsetToTransition) {
                        navigation.toNext();
                    }
                    lastDragTimestamp = dragStatistics.endTimestamp;
                }
            },
        });
        let resizeObserver;
        if (window.ResizeObserver) {
            resizeObserver = new ResizeObserver(() => {
                navigation.refreshCurrent();
            });
            resizeObserver.observe(overlay);
        }
        const onMediaChangeListener = () => {
            // Refresh the cloned elements and their styles after a delay.
            // This is necessary because styles are cloned, in addition to elements.
            requestAnimationFrame(() => navigation.refreshCurrent());
        };
        // matchMedia is unsupported by jsdom
        const mediaQueryList = window.matchMedia?.('(prefers-color-scheme: dark)');
        mediaQueryList?.addEventListener('change', onMediaChangeListener);
        // Close the overlay when clicking on the background (*directly* on any of the
        // elements in closeOverlayTriggers).
        const closeOverlayTriggers = [navigation.content, navigationButtons, overlay];
        overlay.onclick = (event) => {
            if (closeOverlayTriggers.includes(event.target)) {
                onBackgroundClick();
            }
        };
        overlay.onkeyup = (event) => {
            if (event.code === 'Escape') {
                closeOverlay();
                event.preventDefault();
            }
            else if (event.code === 'ArrowRight') {
                navigation.toNext();
                event.preventDefault();
            }
            else if (event.code === 'ArrowLeft') {
                navigation.toPrevious();
                event.preventDefault();
            }
        };
        overlay.addEventListener('close', () => {
            this.context.announceForAccessibility(this.context.localization.helpHidden);
            mediaQueryList?.removeEventListener('change', onMediaChangeListener);
            dragListener.removeListeners();
            resizeObserver?.disconnect();
            overlay.remove();
        });
    }
    /** Marks `helpText` as associated with a single `targetElement`. */
    registerTextHelpForElement(targetElement, helpText) {
        this.registerTextHelpForElements([targetElement], helpText);
    }
    /** Marks `helpText` as associated with all elements in `targetElements`. */
    registerTextHelpForElements(targetElements, helpText) {
        __classPrivateFieldGet(this, _HelpDisplay_helpData, "f").push({ targetElements: [...targetElements], helpText });
    }
    /** Returns true if any help text has been registered. */
    hasHelpText() {
        return __classPrivateFieldGet(this, _HelpDisplay_helpData, "f").length > 0;
    }
    /**
     * Creates and returns a button that toggles the help display.
     */
    createToggleButton() {
        const buttonContainer = document.createElement('div');
        buttonContainer.classList.add('toolbar-help-overlay-button');
        const helpButton = document.createElement('button');
        helpButton.classList.add('button');
        const icon = this.context.icons.makeHelpIcon();
        icon.classList.add('icon');
        helpButton.appendChild(icon);
        helpButton.setAttribute('aria-label', this.context.localization.help);
        helpButton.onclick = () => {
            this.showHelpOverlay();
        };
        buttonContainer.appendChild(helpButton);
        return buttonContainer;
    }
}
_HelpDisplay_helpData = new WeakMap();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HelpDisplay);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/utils/localization.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/utils/localization.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultToolbarUtilsLocalization: () => (/* binding */ defaultToolbarUtilsLocalization)
/* harmony export */ });
const defaultToolbarUtilsLocalization = {
    help: 'Help',
    helpHidden: 'Help hidden',
    next: 'Next',
    previous: 'Previous',
    close: 'Close',
    helpScreenNavigationHelp: 'Click on a control for more information.',
};


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/utils/makeDraggable.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/utils/makeDraggable.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");

const makeDraggable = (dragElement, options) => {
    const dragElements = [...options.draggableChildElements, dragElement];
    let lastX = 0;
    let lastY = 0;
    let startX = 0;
    let startY = 0;
    let pointerDown = false;
    let capturedPointerId = null;
    const isDraggableElement = (element) => {
        if (!element) {
            return false;
        }
        if (dragElements.includes(element)) {
            return true;
        }
        // Some inputs handle dragging themselves. Don't also interpret such gestures
        // as dragging the dropdown.
        const undraggableElementTypes = ['INPUT', 'SELECT', 'IMG'];
        let hasSuitableAncestors = false;
        let ancestor = element.parentElement;
        while (ancestor) {
            if (undraggableElementTypes.includes(ancestor.tagName)) {
                break;
            }
            if (dragElements.includes(ancestor)) {
                hasSuitableAncestors = true;
                break;
            }
            ancestor = ancestor.parentElement;
        }
        return !undraggableElementTypes.includes(element.tagName) && hasSuitableAncestors;
    };
    const removeEventListenerCallbacks = [];
    const addEventListener = (listenerType, listener, options) => {
        dragElement.addEventListener(listenerType, listener, options);
        removeEventListenerCallbacks.push(() => {
            dragElement.removeEventListener(listenerType, listener);
        });
    };
    const clickThreshold = 5;
    // Returns whether the current (or if no current, **the last**) gesture is roughly a click.
    // Because this can be called **after** a gesture has just ended, it should not require
    // the gesture to be in progress.
    const isRoughlyClick = () => {
        return Math.hypot(lastX - startX, lastY - startY) < clickThreshold;
    };
    let startedDragging = false;
    addEventListener('pointerdown', (event) => {
        if (event.defaultPrevented || !isDraggableElement(event.target)) {
            return;
        }
        if (event.isPrimary) {
            startedDragging = false;
            lastX = event.clientX;
            lastY = event.clientY;
            startX = event.clientX;
            startY = event.clientY;
            capturedPointerId = null;
            pointerDown = true;
        }
    }, { passive: true });
    const onGestureEnd = (_event) => {
        // If the pointerup/pointercancel event was for a pointer not being tracked,
        if (!pointerDown) {
            return;
        }
        if (capturedPointerId !== null) {
            dragElement.releasePointerCapture(capturedPointerId);
            capturedPointerId = null;
        }
        options.onDragEnd({
            roughlyClick: isRoughlyClick(),
            endTimestamp: performance.now(),
            displacement: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(lastX - startX, lastY - startY),
        });
        pointerDown = false;
        startedDragging = false;
    };
    addEventListener('pointermove', (event) => {
        if (!event.isPrimary || !pointerDown) {
            return undefined;
        }
        // Mouse event and no buttons pressed? Cancel the event.
        // This can happen if the event was canceled by a focus change (e.g. by opening a
        // right-click menu).
        if (event.pointerType === 'mouse' && event.buttons === 0) {
            onGestureEnd(event);
            return undefined;
        }
        // Only capture after motion -- capturing early prevents click events in Chrome.
        if (capturedPointerId === null && !isRoughlyClick()) {
            dragElement.setPointerCapture(event.pointerId);
            capturedPointerId = event.pointerId;
        }
        const x = event.clientX;
        const y = event.clientY;
        const dx = x - lastX;
        const dy = y - lastY;
        const isClick = Math.abs(x - startX) <= clickThreshold && Math.abs(y - startY) <= clickThreshold;
        if (!isClick || startedDragging) {
            options.onDrag(dx, dy, _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(x - startX, y - startY));
            lastX = x;
            lastY = y;
            startedDragging = true;
        }
    });
    addEventListener('pointerleave', (event) => {
        // Capture the pointer if it exits the container while dragging.
        if (capturedPointerId === null && pointerDown && event.isPrimary) {
            dragElement.setPointerCapture(event.pointerId);
            capturedPointerId = event.pointerId;
        }
    });
    addEventListener('pointerup', onGestureEnd);
    addEventListener('pointercancel', onGestureEnd);
    return {
        removeListeners: () => {
            for (const removeListenerCallback of removeEventListenerCallbacks) {
                removeListenerCallback();
            }
        },
    };
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (makeDraggable);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/widgets/ActionButtonWidget.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/widgets/ActionButtonWidget.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _BaseWidget_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/BaseWidget.mjs");
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ActionButtonWidget_autoDisableInReadOnlyEditors, _ActionButtonWidget_helpText;

class ActionButtonWidget extends _BaseWidget_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(editor, id, makeIcon, title, clickAction, localizationTable, mustBeToplevel = false, autoDisableInReadOnlyEditors = true) {
        super(editor, id, localizationTable);
        this.makeIcon = makeIcon;
        this.title = title;
        this.clickAction = clickAction;
        this.mustBeToplevel = mustBeToplevel;
        _ActionButtonWidget_autoDisableInReadOnlyEditors.set(this, void 0);
        _ActionButtonWidget_helpText.set(this, undefined);
        __classPrivateFieldSet(this, _ActionButtonWidget_autoDisableInReadOnlyEditors, autoDisableInReadOnlyEditors, "f");
    }
    /**
     * Sets the text shown in a help overlay for this button.
     *
     * See {@link getHelpText}.
     */
    setHelpText(helpText) {
        __classPrivateFieldSet(this, _ActionButtonWidget_helpText, helpText, "f");
    }
    getHelpText() {
        return __classPrivateFieldGet(this, _ActionButtonWidget_helpText, "f");
    }
    shouldAutoDisableInReadOnlyEditor() {
        return __classPrivateFieldGet(this, _ActionButtonWidget_autoDisableInReadOnlyEditors, "f");
    }
    handleClick() {
        this.clickAction();
    }
    getTitle() {
        return this.title;
    }
    createIcon() {
        return this.makeIcon();
    }
    fillDropdown(_dropdown) {
        return false;
    }
    mustBeInToplevelMenu() {
        return this.mustBeToplevel;
    }
}
_ActionButtonWidget_autoDisableInReadOnlyEditors = new WeakMap(), _ActionButtonWidget_helpText = new WeakMap();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ActionButtonWidget);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/widgets/BaseToolWidget.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/widgets/BaseToolWidget.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BaseToolWidget)
/* harmony export */ });
/* harmony import */ var _BaseWidget_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/BaseWidget.mjs");
/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/constants.mjs");


const isToolWidgetFocused = () => {
    const currentFocus = [...document.querySelectorAll('*:focus')];
    return (currentFocus.length &&
        currentFocus.some((elem) => elem.classList.contains(`${_constants_mjs__WEBPACK_IMPORTED_MODULE_1__.toolbarCSSPrefix}button`)));
};
class BaseToolWidget extends _BaseWidget_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(editor, targetTool, id, localizationTable) {
        super(editor, id, localizationTable);
        this.targetTool = targetTool;
        this.targetTool.enabledValue().onUpdateAndNow((enabled) => {
            if (enabled) {
                this.setSelected(true);
                // Transfer focus to the current button, only if another toolbar button is
                // focused.
                // This prevents pressing "space" from triggering a different action when
                // the current is selected.
                if (isToolWidgetFocused()) {
                    this.focus();
                }
            }
            else {
                this.setSelected(false);
                this.setDropdownVisible(false);
            }
        });
    }
    shouldAutoDisableInReadOnlyEditor() {
        return !this.targetTool.canReceiveInputInReadOnlyEditor();
    }
    handleClick() {
        if (this.hasDropdown) {
            if (!this.targetTool.isEnabled()) {
                this.targetTool.setEnabled(true);
                this.activateDropdown();
            }
            else {
                this.setDropdownVisible(!this.isDropdownVisible());
            }
        }
        else {
            this.targetTool.setEnabled(!this.targetTool.isEnabled());
        }
    }
    onKeyPress(event) {
        if (this.isSelected() && event.code === 'Space' && this.hasDropdown) {
            this.handleClick();
            return true;
        }
        return false;
    }
    addTo(parent) {
        const result = super.addTo(parent);
        this.setSelected(this.targetTool.isEnabled());
        return result;
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/widgets/BaseWidget.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/widgets/BaseWidget.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ToolbarWidgetTag: () => (/* binding */ ToolbarWidgetTag),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tools_ToolbarShortcutHandler_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/ToolbarShortcutHandler.mjs */ "./node_modules/js-draw/dist/mjs/tools/ToolbarShortcutHandler.mjs");
/* harmony import */ var _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../inputEvents.mjs */ "./node_modules/js-draw/dist/mjs/inputEvents.mjs");
/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/constants.mjs");
/* harmony import */ var _layout_DropdownLayoutManager_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./layout/DropdownLayoutManager.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/layout/DropdownLayoutManager.mjs");
/* harmony import */ var _util_addLongPressOrHoverCssClasses_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/addLongPressOrHoverCssClasses.mjs */ "./node_modules/js-draw/dist/mjs/util/addLongPressOrHoverCssClasses.mjs");
/* harmony import */ var _utils_HelpDisplay_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/HelpDisplay.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/utils/HelpDisplay.mjs");
/* harmony import */ var _util_assertions_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/assertions.mjs */ "./node_modules/js-draw/dist/mjs/util/assertions.mjs");
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BaseWidget_instances, _a, _BaseWidget_hasDropdown, _BaseWidget_disabledDueToReadOnlyEditor, _BaseWidget_tags, _BaseWidget_removeEditorListeners, _BaseWidget_addEditorListeners;







/**
 * A set of labels that allow toolbar themes to treat buttons differently.
 */
var ToolbarWidgetTag;
(function (ToolbarWidgetTag) {
    ToolbarWidgetTag["Save"] = "save";
    ToolbarWidgetTag["Exit"] = "exit";
    ToolbarWidgetTag["Undo"] = "undo";
    ToolbarWidgetTag["Redo"] = "redo";
})(ToolbarWidgetTag || (ToolbarWidgetTag = {}));
/**
 * The `abstract` base class for items that can be shown in a `js-draw` toolbar. See also {@link AbstractToolbar.addWidget}.
 *
 * See [the custom tool example](https://github.com/personalizedrefrigerator/js-draw/blob/main/docs/examples/example-custom-tools/example.ts)
 * for how to create a custom toolbar widget for a tool.
 *
 * For custom action buttons, {@link AbstractToolbar.addActionButton} may be sufficient for most use cases.
 */
class BaseWidget {
    constructor(editor, id, localizationTable) {
        _BaseWidget_instances.add(this);
        this.editor = editor;
        this.id = id;
        this.dropdown = null;
        _BaseWidget_hasDropdown.set(this, void 0);
        // True iff this widget is disabled.
        this.disabled = false;
        // True iff this widget is currently disabled because the editor is read only
        _BaseWidget_disabledDueToReadOnlyEditor.set(this, false);
        _BaseWidget_tags.set(this, []);
        // Maps subWidget IDs to subWidgets.
        this.subWidgets = {};
        this.toplevel = true;
        _BaseWidget_removeEditorListeners.set(this, null);
        this.localizationTable = localizationTable ?? editor.localization;
        // Default layout manager
        const defaultLayoutManager = new _layout_DropdownLayoutManager_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]((text) => this.editor.announceForAccessibility(text), this.localizationTable);
        defaultLayoutManager.connectToEditorNotifier(editor.notifier);
        this.layoutManager = defaultLayoutManager;
        this.icon = null;
        this.container = document.createElement('div');
        this.container.classList.add(`${_constants_mjs__WEBPACK_IMPORTED_MODULE_2__.toolbarCSSPrefix}toolContainer`, `${_constants_mjs__WEBPACK_IMPORTED_MODULE_2__.toolbarCSSPrefix}toolButtonContainer`, `${_constants_mjs__WEBPACK_IMPORTED_MODULE_2__.toolbarCSSPrefix}internalWidgetId--${id.replace(/[^a-zA-Z0-9_]/g, '-')}`);
        this.dropdownContent = document.createElement('div');
        __classPrivateFieldSet(this, _BaseWidget_hasDropdown, false, "f");
        this.button = document.createElement('div');
        this.button.classList.add(`${_constants_mjs__WEBPACK_IMPORTED_MODULE_2__.toolbarCSSPrefix}button`);
        this.label = document.createElement('label');
        this.button.setAttribute('role', 'button');
        this.button.tabIndex = 0;
        // Disable the context menu. This allows long-press gestures to trigger the button's
        // tooltip instead.
        this.button.oncontextmenu = (event) => {
            event.preventDefault();
        };
        (0,_util_addLongPressOrHoverCssClasses_mjs__WEBPACK_IMPORTED_MODULE_4__["default"])(this.button);
    }
    /**
     * Should return a constant true or false value. If true (the default),
     * this widget must be automatically disabled when its editor is read-only.
     */
    shouldAutoDisableInReadOnlyEditor() {
        return true;
    }
    getId() {
        return this.id;
    }
    /**
     * Note: Tags should be set *before* a tool widget is added to a toolbar.
     *
     *
     * Associates tags with this widget that can be used by toolbar themes
     * to customize the layout/appearance of this button. Prefer tags in
     * the `ToolbarWidgetTag` enum, where possible.
     *
     * In addition to being readable from the {@link getTags} method, tags are
     * added to a button's main container as CSS classes with the `toolwidget-tag--` prefix.
     *
     * For example, the `undo` tag would result in `toolwidget-tag--undo`
     * being added to the button's container's class list.
     *
     */
    setTags(tags) {
        const toClassName = (tag) => {
            return `toolwidget-tag--${tag}`;
        };
        // Remove CSS classes associated with old tags
        for (const tag of __classPrivateFieldGet(this, _BaseWidget_tags, "f")) {
            this.container.classList.remove(toClassName(tag));
        }
        __classPrivateFieldSet(this, _BaseWidget_tags, [...tags], "f");
        // Add new CSS classes
        for (const tag of __classPrivateFieldGet(this, _BaseWidget_tags, "f")) {
            this.container.classList.add(toClassName(tag));
        }
    }
    getTags() {
        return [...__classPrivateFieldGet(this, _BaseWidget_tags, "f")];
    }
    /**
     * Returns the ID of this widget in `container`. Adds a suffix to this' ID
     * if an item in `container` already has this' ID.
     *
     * For example, if `this` has ID `foo` and if
     * `container = { 'foo': somethingNotThis, 'foo-1': somethingElseNotThis }`, this method
     * returns `foo-2` because elements with IDs `foo` and `foo-1` are already present in
     * `container`.
     *
     * If `this` is already in `container`, returns the id given to `this` in the container.
     */
    getUniqueIdIn(container) {
        let id = this.getId();
        let idCounter = 0;
        while (id in container && container[id] !== this) {
            id = this.getId() + '-' + idCounter.toString();
            idCounter++;
        }
        return id;
    }
    // Add content to the widget's associated dropdown menu.
    // Returns true if such a menu should be created, false otherwise.
    fillDropdown(dropdown, helpDisplay) {
        if (Object.keys(this.subWidgets).length === 0) {
            return false;
        }
        for (const widgetId in this.subWidgets) {
            const widget = this.subWidgets[widgetId];
            const widgetElement = widget.addTo(dropdown);
            widget.setIsToplevel(false);
            // Add help information
            const helpText = widget.getHelpText();
            if (helpText) {
                helpDisplay?.registerTextHelpForElement(widgetElement, helpText);
            }
        }
        return true;
    }
    /**
     * Should return a 1-2 sentence description of the widget.
     *
     * At present, this is only used if this widget has an associated dropdown.
     */
    getHelpText() {
        return undefined;
    }
    /** @deprecated Renamed to `setUpButtonEventListeners`. */
    setupActionBtnClickListener(button) {
        return this.setUpButtonEventListeners(button);
    }
    setUpButtonEventListeners(button) {
        const clickTriggers = { Enter: true, ' ': true };
        button.onkeydown = (evt) => {
            let handled = false;
            if (evt.key in clickTriggers) {
                if (!this.disabled) {
                    this.handleClick();
                    handled = true;
                }
            }
            // If we didn't do anything with the event, send it to the editor.
            if (!handled) {
                const editorEvent = (0,_inputEvents_mjs__WEBPACK_IMPORTED_MODULE_1__.keyPressEventFromHTMLEvent)(evt);
                handled = this.editor.toolController.dispatchInputEvent(editorEvent);
            }
            if (handled) {
                evt.preventDefault();
            }
        };
        button.onkeyup = (htmlEvent) => {
            if (htmlEvent.key in clickTriggers) {
                return;
            }
            const event = (0,_inputEvents_mjs__WEBPACK_IMPORTED_MODULE_1__.keyUpEventFromHTMLEvent)(htmlEvent);
            const handled = this.editor.toolController.dispatchInputEvent(event);
            if (handled) {
                htmlEvent.preventDefault();
            }
        };
        button.onclick = () => {
            if (!this.disabled) {
                this.handleClick();
            }
        };
        // Prevent double-click zoom on some devices.
        button.ondblclick = (event) => {
            event.preventDefault();
        };
    }
    // Add a listener that is triggered when a key is pressed.
    // Listeners will fire regardless of whether this widget is selected and require that
    // {@link Editor.toolController} to have an enabled {@link ToolbarShortcutHandler} tool.
    onKeyPress(_event) {
        return false;
    }
    get hasDropdown() {
        return __classPrivateFieldGet(this, _BaseWidget_hasDropdown, "f");
    }
    // Add a widget to this' dropdown. Must be called before this.addTo.
    addSubWidget(widget) {
        // Generate a unique ID for the widget.
        const id = widget.getUniqueIdIn(this.subWidgets);
        this.subWidgets[id] = widget;
    }
    setLayoutManager(manager) {
        if (manager === this.layoutManager) {
            return;
        }
        this.layoutManager = manager;
        if (this.container.parentElement) {
            // Trigger a re-creation of this' content
            this.addTo(this.container.parentElement);
        }
    }
    /**
     * Adds this to `parent`.
     * Returns the element that was just added to `parent`.
     * @internal
     */
    addTo(parent) {
        // Update title and icon
        this.icon = null;
        this.updateIcon();
        this.label.innerText = this.getTitle();
        const longLabelCSSClass = 'long-label';
        if (this.label.innerText.length > 7) {
            this.label.classList.add(longLabelCSSClass);
        }
        else {
            this.label.classList.remove(longLabelCSSClass);
        }
        // Click functionality
        this.setUpButtonEventListeners(this.button);
        // Clear anything already in this.container.
        this.container.replaceChildren();
        this.button.replaceChildren(this.icon, this.label);
        this.container.appendChild(this.button);
        const helpDisplay = new _utils_HelpDisplay_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]((content) => this.editor.createHTMLOverlay(content), this.editor);
        const helpText = this.getHelpText();
        if (helpText) {
            helpDisplay.registerTextHelpForElement(this.dropdownContent, [this.getTitle(), helpText].join('\n\n'));
        }
        // Clear the dropdownContainer in case this element is being moved to another
        // parent.
        this.dropdownContent.replaceChildren();
        __classPrivateFieldSet(this, _BaseWidget_hasDropdown, this.fillDropdown(this.dropdownContent, helpDisplay), "f");
        if (__classPrivateFieldGet(this, _BaseWidget_hasDropdown, "f")) {
            this.button.classList.add('has-dropdown');
            // We're re-creating the dropdown.
            this.dropdown?.destroy();
            this.dropdownIcon = this.createDropdownIcon();
            this.button.appendChild(this.dropdownIcon);
            this.dropdown = this.layoutManager.createToolMenu({
                target: this.button,
                getTitle: () => this.getTitle(),
                isToplevel: () => this.toplevel,
            });
            this.dropdown.visible.onUpdate((visible) => {
                if (visible) {
                    this.container.classList.add('dropdownVisible');
                }
                else {
                    this.container.classList.remove('dropdownVisible');
                }
                // Auto-focus this component's button when the dropdown hides --
                // this ensures that keyboard focus goes to a reasonable location when
                // the user closes a menu.
                if (!visible) {
                    this.focus();
                }
            });
            if (helpDisplay.hasHelpText()) {
                this.dropdown.appendChild(helpDisplay.createToggleButton());
            }
            this.dropdown.appendChild(this.dropdownContent);
        }
        this.setDropdownVisible(false);
        if (this.container.parentElement) {
            this.container.remove();
        }
        __classPrivateFieldGet(this, _BaseWidget_instances, "m", _BaseWidget_addEditorListeners).call(this);
        parent.appendChild(this.container);
        return this.container;
    }
    /**
     * Remove this. This allows the widget to be added to a toolbar again
     * in the future using `addTo`.
     */
    remove() {
        this.container.remove();
        __classPrivateFieldGet(this, _BaseWidget_removeEditorListeners, "f")?.call(this);
    }
    focus() {
        this.button.focus();
    }
    /**
     * @internal
     */
    addCSSClassToContainer(className) {
        this.container.classList.add(className);
    }
    removeCSSClassFromContainer(className) {
        this.container.classList.remove(className);
    }
    updateIcon() {
        let newIcon = this.createIcon();
        if (!newIcon) {
            newIcon = document.createElement('div');
            this.container.classList.add('no-icon');
        }
        else {
            this.container.classList.remove('no-icon');
        }
        this.icon?.replaceWith(newIcon);
        this.icon = newIcon;
        this.icon.classList.add(`${_constants_mjs__WEBPACK_IMPORTED_MODULE_2__.toolbarCSSPrefix}icon`);
    }
    setDisabled(disabled) {
        this.disabled = disabled;
        __classPrivateFieldSet(this, _BaseWidget_disabledDueToReadOnlyEditor, false, "f");
        if (this.disabled) {
            this.button.classList.add('disabled');
            this.button.setAttribute('aria-disabled', 'true');
        }
        else {
            this.button.classList.remove('disabled');
            this.button.removeAttribute('aria-disabled');
        }
    }
    setSelected(selected) {
        const currentlySelected = this.isSelected();
        if (currentlySelected === selected) {
            return;
        }
        // Ensure that accessibility tools check and read the value of
        // aria-checked.
        // TODO: Ensure that 'role' is set to 'switch' by default for selectable
        //       buttons.
        this.button.setAttribute('role', 'switch');
        if (selected) {
            this.container.classList.add('selected');
            this.button.setAttribute('aria-checked', 'true');
        }
        else {
            this.container.classList.remove('selected');
            this.button.setAttribute('aria-checked', 'false');
        }
    }
    setDropdownVisible(visible) {
        if (visible) {
            this.dropdown?.requestShow();
        }
        else {
            this.dropdown?.requestHide();
        }
    }
    /**
     * Only used by some layout managers.
     * In those layout managers, makes this dropdown visible.
     */
    activateDropdown() {
        this.dropdown?.onActivated();
    }
    /**
     * Returns `true` if this widget must always be in a toplevel menu and not
     * in a scrolling/overflow menu.
     *
     * This method can be overidden to override the default of `true`.
     */
    mustBeInToplevelMenu() {
        return false;
    }
    /**
     * Returns true iff this widget can be in a nontoplevel menu.
     *
     * @deprecated Use `!mustBeInToplevelMenu()` instead.
     */
    canBeInOverflowMenu() {
        return !this.mustBeInToplevelMenu();
    }
    getButtonWidth() {
        return this.button.clientWidth;
    }
    isHidden() {
        return this.container.style.display === 'none';
    }
    setHidden(hidden) {
        this.container.style.display = hidden ? 'none' : '';
    }
    /** Set whether the widget is contained within another. @internal */
    setIsToplevel(toplevel) {
        this.toplevel = toplevel;
    }
    /** Returns true if the menu for this widget is open. */
    isDropdownVisible() {
        return this.dropdown?.visible?.get() ?? false;
    }
    isSelected() {
        return this.container.classList.contains('selected');
    }
    createDropdownIcon() {
        const icon = this.editor.icons.makeDropdownIcon();
        icon.classList.add(`${_constants_mjs__WEBPACK_IMPORTED_MODULE_2__.toolbarCSSPrefix}showHideDropdownIcon`);
        return icon;
    }
    /**
     * Serialize state associated with this widget.
     * Override this method to allow saving/restoring from state on application load.
     *
     * Overriders should call `super` and include the output of `super.serializeState` in
     * the output dictionary.
     *
     * Clients should not rely on the output from `saveState` being in any particular
     * format.
     */
    serializeState() {
        const subwidgetState = {};
        // Save all subwidget state.
        for (const subwidgetId in this.subWidgets) {
            subwidgetState[subwidgetId] = this.subWidgets[subwidgetId].serializeState();
        }
        return {
            subwidgetState,
        };
    }
    /**
     * Restore widget state from serialized data. See also `saveState`.
     *
     * Overriders must call `super`.
     */
    deserializeFrom(state) {
        if (state.subwidgetState) {
            (0,_util_assertions_mjs__WEBPACK_IMPORTED_MODULE_6__.assertIsObject)(state.subwidgetState);
            // Deserialize all subwidgets.
            for (const subwidgetId in state.subwidgetState) {
                if (subwidgetId in this.subWidgets) {
                    const serializedSubwidgetState = state.subwidgetState[subwidgetId];
                    if (serializedSubwidgetState) {
                        this.subWidgets[subwidgetId].deserializeFrom(serializedSubwidgetState);
                    }
                }
            }
        }
    }
}
_a = BaseWidget, _BaseWidget_hasDropdown = new WeakMap(), _BaseWidget_disabledDueToReadOnlyEditor = new WeakMap(), _BaseWidget_tags = new WeakMap(), _BaseWidget_removeEditorListeners = new WeakMap(), _BaseWidget_instances = new WeakSet(), _BaseWidget_addEditorListeners = function _BaseWidget_addEditorListeners() {
    __classPrivateFieldGet(this, _BaseWidget_removeEditorListeners, "f")?.call(this);
    const toolbarShortcutHandlers = this.editor.toolController.getMatchingTools(_tools_ToolbarShortcutHandler_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]);
    let removeKeyPressListener = null;
    // If the onKeyPress function has been extended and the editor is configured to send keypress events to
    // toolbar widgets,
    if (toolbarShortcutHandlers.length > 0 && this.onKeyPress !== _a.prototype.onKeyPress) {
        const keyPressListener = (event) => this.onKeyPress(event);
        const handler = toolbarShortcutHandlers[0];
        handler.registerListener(keyPressListener);
        removeKeyPressListener = () => {
            handler.removeListener(keyPressListener);
        };
    }
    const readOnlyListener = this.editor.isReadOnlyReactiveValue().onUpdateAndNow((readOnly) => {
        if (readOnly && this.shouldAutoDisableInReadOnlyEditor() && !this.disabled) {
            this.setDisabled(true);
            __classPrivateFieldSet(this, _BaseWidget_disabledDueToReadOnlyEditor, true, "f");
            if (__classPrivateFieldGet(this, _BaseWidget_hasDropdown, "f")) {
                this.dropdown?.requestHide();
            }
        }
        else if (!readOnly && __classPrivateFieldGet(this, _BaseWidget_disabledDueToReadOnlyEditor, "f")) {
            __classPrivateFieldSet(this, _BaseWidget_disabledDueToReadOnlyEditor, false, "f");
            this.setDisabled(false);
        }
    });
    __classPrivateFieldSet(this, _BaseWidget_removeEditorListeners, () => {
        readOnlyListener.remove();
        removeKeyPressListener?.();
        __classPrivateFieldSet(this, _BaseWidget_removeEditorListeners, null, "f");
    }, "f");
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseWidget);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/widgets/DocumentPropertiesWidget.mjs":
/*!************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/widgets/DocumentPropertiesWidget.mjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _commands_Erase_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../commands/Erase.mjs */ "./node_modules/js-draw/dist/mjs/commands/Erase.mjs");
/* harmony import */ var _commands_uniteCommands_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../commands/uniteCommands.mjs */ "./node_modules/js-draw/dist/mjs/commands/uniteCommands.mjs");
/* harmony import */ var _components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/BackgroundComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/BackgroundComponent.mjs");
/* harmony import */ var _image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../image/EditorImage.mjs */ "./node_modules/js-draw/dist/mjs/image/EditorImage.mjs");
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../types.mjs */ "./node_modules/js-draw/dist/mjs/types.mjs");
/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../constants.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/constants.mjs");
/* harmony import */ var _components_makeColorInput_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/makeColorInput.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeColorInput.mjs");
/* harmony import */ var _BaseWidget_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./BaseWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/BaseWidget.mjs");









class DocumentPropertiesWidget extends _BaseWidget_mjs__WEBPACK_IMPORTED_MODULE_8__["default"] {
    constructor(editor, localizationTable) {
        super(editor, 'document-properties-widget', localizationTable);
        this.updateDropdownContent = () => { };
        this.dropdownUpdateQueued = false;
        // Make it possible to open the dropdown, even if this widget isn't selected.
        this.container.classList.add('dropdownShowable');
        this.editor.notifier.on(_types_mjs__WEBPACK_IMPORTED_MODULE_5__.EditorEventType.UndoRedoStackUpdated, () => {
            this.queueDropdownUpdate();
        });
        this.editor.image.notifier.on(_image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_3__.EditorImageEventType.ExportViewportChanged, () => {
            this.queueDropdownUpdate();
        });
    }
    getTitle() {
        return this.localizationTable.documentProperties;
    }
    createIcon() {
        return this.editor.icons.makeConfigureDocumentIcon();
    }
    handleClick() {
        this.setDropdownVisible(!this.isDropdownVisible());
        this.queueDropdownUpdate();
    }
    queueDropdownUpdate() {
        if (!this.dropdownUpdateQueued) {
            requestAnimationFrame(() => this.updateDropdown());
            this.dropdownUpdateQueued = true;
        }
    }
    updateDropdown() {
        this.dropdownUpdateQueued = false;
        if (this.isDropdownVisible()) {
            this.updateDropdownContent();
        }
    }
    setBackgroundColor(color) {
        this.editor.dispatch(this.editor.setBackgroundColor(color));
    }
    getBackgroundColor() {
        return this.editor.estimateBackgroundColor();
    }
    removeBackgroundComponents() {
        const previousBackgrounds = [];
        for (const component of this.editor.image.getBackgroundComponents()) {
            if (component instanceof _components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]) {
                previousBackgrounds.push(component);
            }
        }
        return new _commands_Erase_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](previousBackgrounds);
    }
    /** Replace existing background components with a background of the given type. */
    setBackgroundType(backgroundType) {
        const prevBackgroundColor = this.editor.estimateBackgroundColor();
        const newBackground = new _components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](backgroundType, prevBackgroundColor);
        const addBackgroundCommand = this.editor.image.addElement(newBackground);
        return (0,_commands_uniteCommands_mjs__WEBPACK_IMPORTED_MODULE_1__["default"])([this.removeBackgroundComponents(), addBackgroundCommand]);
    }
    /** Returns the type of the topmost background component */
    getBackgroundType() {
        const backgroundComponents = this.editor.image.getBackgroundComponents();
        for (let i = backgroundComponents.length - 1; i >= 0; i--) {
            const component = backgroundComponents[i];
            if (component instanceof _components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]) {
                return component.getBackgroundType();
            }
        }
        return _components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_2__.BackgroundType.None;
    }
    updateImportExportRectSize(size) {
        const filterDimension = (dim) => {
            if (dim !== undefined && (!isFinite(dim) || dim <= 0)) {
                dim = 100;
            }
            return dim;
        };
        const width = filterDimension(size.width);
        const height = filterDimension(size.height);
        const currentRect = this.editor.getImportExportRect();
        const newRect = new _js_draw_math__WEBPACK_IMPORTED_MODULE_4__.Rect2(currentRect.x, currentRect.y, width ?? currentRect.w, height ?? currentRect.h);
        this.editor.dispatch(this.editor.image.setImportExportRect(newRect));
        this.editor.queueRerender();
    }
    getHelpText() {
        return this.localizationTable.pageDropdown__baseHelpText;
    }
    fillDropdown(dropdown, helpDisplay) {
        const container = document.createElement('div');
        container.classList.add(`${_constants_mjs__WEBPACK_IMPORTED_MODULE_6__.toolbarCSSPrefix}spacedList`, `${_constants_mjs__WEBPACK_IMPORTED_MODULE_6__.toolbarCSSPrefix}nonbutton-controls-main-list`, `${_constants_mjs__WEBPACK_IMPORTED_MODULE_6__.toolbarCSSPrefix}document-properties-widget`);
        // Background color input
        const makeBackgroundColorInput = () => {
            const backgroundColorRow = document.createElement('div');
            const backgroundColorLabel = document.createElement('label');
            backgroundColorLabel.innerText = this.localizationTable.backgroundColor;
            const { input: colorInput, container: backgroundColorInputContainer, setValue: setBgColorInputValue, registerWithHelpTextDisplay: registerHelpForInputs, } = (0,_components_makeColorInput_mjs__WEBPACK_IMPORTED_MODULE_7__["default"])(this.editor, (color) => {
                if (!color.eq(this.getBackgroundColor())) {
                    this.setBackgroundColor(color);
                }
            });
            colorInput.id = `${_constants_mjs__WEBPACK_IMPORTED_MODULE_6__.toolbarCSSPrefix}docPropertiesColorInput-${DocumentPropertiesWidget.idCounter++}`;
            backgroundColorLabel.htmlFor = colorInput.id;
            backgroundColorRow.replaceChildren(backgroundColorLabel, backgroundColorInputContainer);
            const registerWithHelp = (helpDisplay) => {
                if (!helpDisplay) {
                    return;
                }
                helpDisplay?.registerTextHelpForElement(backgroundColorRow, this.localizationTable.pageDropdown__backgroundColorHelpText);
                registerHelpForInputs(helpDisplay);
            };
            return { setBgColorInputValue, backgroundColorRow, registerWithHelp };
        };
        const { backgroundColorRow, setBgColorInputValue, registerWithHelp: registerBackgroundRowWithHelp, } = makeBackgroundColorInput();
        const makeCheckboxRow = (labelText, onChange) => {
            const rowContainer = document.createElement('div');
            const labelElement = document.createElement('label');
            const checkboxElement = document.createElement('input');
            checkboxElement.id = `${_constants_mjs__WEBPACK_IMPORTED_MODULE_6__.toolbarCSSPrefix}docPropertiesCheckbox-${DocumentPropertiesWidget.idCounter++}`;
            labelElement.htmlFor = checkboxElement.id;
            checkboxElement.type = 'checkbox';
            labelElement.innerText = labelText;
            checkboxElement.oninput = () => {
                onChange(checkboxElement.checked);
            };
            rowContainer.replaceChildren(labelElement, checkboxElement);
            return { container: rowContainer, checkbox: checkboxElement };
        };
        // Background style selector
        const { container: useGridRow, checkbox: useGridCheckbox } = makeCheckboxRow(this.localizationTable.useGridOption, (checked) => {
            const prevBackgroundType = this.getBackgroundType();
            const wasGrid = prevBackgroundType === _components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_2__.BackgroundType.Grid;
            if (wasGrid === checked) {
                // Already the requested background type.
                return;
            }
            let newBackgroundType = _components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_2__.BackgroundType.SolidColor;
            if (checked) {
                newBackgroundType = _components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_2__.BackgroundType.Grid;
            }
            this.editor.dispatch(this.setBackgroundType(newBackgroundType));
        });
        // Adds a width/height input
        const addDimensionRow = (labelContent, onChange) => {
            const row = document.createElement('div');
            const label = document.createElement('label');
            const input = document.createElement('input');
            label.innerText = labelContent;
            input.type = 'number';
            input.min = '0';
            input.id = `${_constants_mjs__WEBPACK_IMPORTED_MODULE_6__.toolbarCSSPrefix}docPropertiesDimensionRow-${DocumentPropertiesWidget.idCounter++}`;
            label.htmlFor = input.id;
            input.style.flexGrow = '2';
            input.style.width = '25px';
            input.oninput = () => {
                onChange(parseFloat(input.value));
            };
            row.classList.add('js-draw-size-input-row');
            row.replaceChildren(label, input);
            return {
                setValue: (value) => {
                    // Slightly improve the case where the user tries to change the
                    // first digit of a dimension like 600.
                    //
                    // As changing the value also gives the image zero size (which is unsupported,
                    // .setValue is called immediately). We work around this by trying to select
                    // the added/changed digits.
                    //
                    // See https://github.com/personalizedrefrigerator/js-draw/issues/58.
                    if (document.activeElement === input && input.value.match(/^0*$/)) {
                        // We need to switch to type="text" and back to type="number" because
                        // number inputs don't support selection.
                        //
                        // See https://stackoverflow.com/q/22381837
                        const originalValue = input.value;
                        input.type = 'text';
                        input.value = value.toString();
                        // Select the added digits
                        const lengthToSelect = Math.max(1, input.value.length - originalValue.length);
                        input.setSelectionRange(0, lengthToSelect);
                        input.type = 'number';
                    }
                    else {
                        input.value = value.toString();
                    }
                },
                setIsAutomaticSize: (automatic) => {
                    input.disabled = automatic;
                    const automaticSizeClass = 'size-input-row--automatic-size';
                    if (automatic) {
                        row.classList.add(automaticSizeClass);
                    }
                    else {
                        row.classList.remove(automaticSizeClass);
                    }
                },
                element: row,
            };
        };
        const imageWidthRow = addDimensionRow(this.localizationTable.imageWidthOption, (value) => {
            this.updateImportExportRectSize({ width: value });
        });
        const imageHeightRow = addDimensionRow(this.localizationTable.imageHeightOption, (value) => {
            this.updateImportExportRectSize({ height: value });
        });
        // The autoresize checkbox
        const { container: auroresizeRow, checkbox: autoresizeCheckbox } = makeCheckboxRow(this.localizationTable.enableAutoresizeOption, (checked) => {
            const image = this.editor.image;
            this.editor.dispatch(image.setAutoresizeEnabled(checked));
        });
        // The "About..." button
        const aboutButton = document.createElement('button');
        aboutButton.classList.add('about-button');
        aboutButton.innerText = this.localizationTable.about;
        aboutButton.onclick = () => {
            this.editor.showAboutDialog();
        };
        // Add help text
        registerBackgroundRowWithHelp(helpDisplay);
        helpDisplay?.registerTextHelpForElement(useGridRow, this.localizationTable.pageDropdown__gridCheckboxHelpText);
        helpDisplay?.registerTextHelpForElement(auroresizeRow, this.localizationTable.pageDropdown__autoresizeCheckboxHelpText);
        helpDisplay?.registerTextHelpForElement(aboutButton, this.localizationTable.pageDropdown__aboutButtonHelpText);
        this.updateDropdownContent = () => {
            setBgColorInputValue(this.getBackgroundColor());
            const autoresize = this.editor.image.getAutoresizeEnabled();
            const importExportRect = this.editor.getImportExportRect();
            imageWidthRow.setValue(importExportRect.width);
            imageHeightRow.setValue(importExportRect.height);
            autoresizeCheckbox.checked = autoresize;
            imageWidthRow.setIsAutomaticSize(autoresize);
            imageHeightRow.setIsAutomaticSize(autoresize);
            useGridCheckbox.checked = this.getBackgroundType() === _components_BackgroundComponent_mjs__WEBPACK_IMPORTED_MODULE_2__.BackgroundType.Grid;
        };
        this.updateDropdownContent();
        container.replaceChildren(backgroundColorRow, useGridRow, imageWidthRow.element, imageHeightRow.element, auroresizeRow, aboutButton);
        dropdown.replaceChildren(container);
        return true;
    }
}
DocumentPropertiesWidget.idCounter = 0;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DocumentPropertiesWidget);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/widgets/EraserToolWidget.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/widgets/EraserToolWidget.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tools_Eraser_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/Eraser.mjs */ "./node_modules/js-draw/dist/mjs/tools/Eraser.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../types.mjs */ "./node_modules/js-draw/dist/mjs/types.mjs");
/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/constants.mjs");
/* harmony import */ var _BaseToolWidget_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BaseToolWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/BaseToolWidget.mjs");
/* harmony import */ var _components_makeThicknessSlider_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/makeThicknessSlider.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeThicknessSlider.mjs");





class EraserToolWidget extends _BaseToolWidget_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(editor, tool, localizationTable) {
        super(editor, tool, 'eraser-tool-widget', localizationTable);
        this.tool = tool;
        this.updateInputs = () => { };
        this.editor.notifier.on(_types_mjs__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.ToolUpdated, (toolEvt) => {
            if (toolEvt.kind === _types_mjs__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.ToolUpdated && toolEvt.tool === this.tool) {
                this.updateInputs();
                this.updateIcon();
            }
        });
    }
    getHelpText() {
        return this.localizationTable.eraserDropdown__baseHelpText;
    }
    getTitle() {
        return this.localizationTable.eraser;
    }
    makeIconForType(mode) {
        return this.editor.icons.makeEraserIcon(this.tool.getThickness(), mode);
    }
    createIcon() {
        return this.makeIconForType(this.tool.getModeValue().get());
    }
    makeEraserTypeSelector(helpDisplay) {
        const container = document.createElement('div');
        const labelElement = document.createElement('label');
        const checkboxElement = document.createElement('input');
        checkboxElement.id = `${_constants_mjs__WEBPACK_IMPORTED_MODULE_2__.toolbarCSSPrefix}eraserToolWidget-${EraserToolWidget.idCounter++}`;
        labelElement.htmlFor = checkboxElement.id;
        labelElement.innerText = this.localizationTable.fullStrokeEraser;
        checkboxElement.type = 'checkbox';
        checkboxElement.oninput = () => {
            this.tool
                .getModeValue()
                .set(checkboxElement.checked ? _tools_Eraser_mjs__WEBPACK_IMPORTED_MODULE_0__.EraserMode.FullStroke : _tools_Eraser_mjs__WEBPACK_IMPORTED_MODULE_0__.EraserMode.PartialStroke);
        };
        const updateValue = () => {
            checkboxElement.checked = this.tool.getModeValue().get() === _tools_Eraser_mjs__WEBPACK_IMPORTED_MODULE_0__.EraserMode.FullStroke;
        };
        container.replaceChildren(labelElement, checkboxElement);
        helpDisplay?.registerTextHelpForElement(container, this.localizationTable.eraserDropdown__fullStrokeEraserHelpText);
        return {
            addTo: (parent) => {
                parent.appendChild(container);
            },
            updateValue,
        };
    }
    fillDropdown(dropdown, helpDisplay) {
        const container = document.createElement('div');
        container.classList.add(`${_constants_mjs__WEBPACK_IMPORTED_MODULE_2__.toolbarCSSPrefix}spacedList`, `${_constants_mjs__WEBPACK_IMPORTED_MODULE_2__.toolbarCSSPrefix}nonbutton-controls-main-list`);
        const thicknessSlider = (0,_components_makeThicknessSlider_mjs__WEBPACK_IMPORTED_MODULE_4__["default"])(this.editor, (thickness) => {
            this.tool.setThickness(thickness);
        });
        thicknessSlider.setBounds(10, 55);
        helpDisplay?.registerTextHelpForElement(thicknessSlider.container, this.localizationTable.eraserDropdown__thicknessHelpText);
        const modeSelector = this.makeEraserTypeSelector(helpDisplay);
        this.updateInputs = () => {
            thicknessSlider.setValue(this.tool.getThickness());
            modeSelector.updateValue();
        };
        this.updateInputs();
        container.replaceChildren(thicknessSlider.container);
        modeSelector.addTo(container);
        dropdown.replaceChildren(container);
        return true;
    }
    serializeState() {
        return {
            ...super.serializeState(),
            thickness: this.tool.getThickness(),
            mode: this.tool.getModeValue().get(),
        };
    }
    deserializeFrom(state) {
        super.deserializeFrom(state);
        if (state.thickness) {
            const parsedThickness = parseFloat(state.thickness);
            if (typeof parsedThickness !== 'number' || !isFinite(parsedThickness)) {
                throw new Error(`Deserializing property ${parsedThickness} is not a number or is not finite.`);
            }
            this.tool.setThickness(parsedThickness);
        }
        if (state.mode) {
            const mode = state.mode;
            if (Object.values(_tools_Eraser_mjs__WEBPACK_IMPORTED_MODULE_0__.EraserMode).includes(mode)) {
                this.tool.getModeValue().set(mode);
            }
        }
    }
}
EraserToolWidget.idCounter = 0;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EraserToolWidget);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/widgets/ExitActionWidget.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/widgets/ExitActionWidget.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ActionButtonWidget_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ActionButtonWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/ActionButtonWidget.mjs");
/* harmony import */ var _BaseWidget_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/BaseWidget.mjs");
/* harmony import */ var _keybindings_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keybindings.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/keybindings.mjs");



class ExitActionWidget extends _ActionButtonWidget_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(editor, localization, saveCallback, labelOverride = {}) {
        super(editor, 'exit-button', 
        // Creates an icon
        () => {
            return labelOverride.icon ?? editor.icons.makeCloseIcon();
        }, labelOverride.label ?? localization.exit, saveCallback);
        this.setTags([_BaseWidget_mjs__WEBPACK_IMPORTED_MODULE_1__.ToolbarWidgetTag.Exit]);
    }
    shouldAutoDisableInReadOnlyEditor() {
        return false;
    }
    onKeyPress(event) {
        if (this.editor.shortcuts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_2__.exitKeyboardShortcut, event)) {
            this.clickAction();
            return true;
        }
        return super.onKeyPress(event);
    }
    mustBeInToplevelMenu() {
        return true;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExitActionWidget);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/widgets/HandToolWidget.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/widgets/HandToolWidget.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ HandToolWidget)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _tools_PanZoom_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/PanZoom.mjs */ "./node_modules/js-draw/dist/mjs/tools/PanZoom.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../types.mjs */ "./node_modules/js-draw/dist/mjs/types.mjs");
/* harmony import */ var _Viewport_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Viewport.mjs */ "./node_modules/js-draw/dist/mjs/Viewport.mjs");
/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/constants.mjs");
/* harmony import */ var _BaseToolWidget_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./BaseToolWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/BaseToolWidget.mjs");
/* harmony import */ var _BaseWidget_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./BaseWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/BaseWidget.mjs");
/* harmony import */ var _components_makeSeparator_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/makeSeparator.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeSeparator.mjs");








const makeZoomControl = (localizationTable, editor, helpDisplay) => {
    const zoomLevelRow = document.createElement('div');
    const increaseButton = document.createElement('button');
    const decreaseButton = document.createElement('button');
    const resetViewButton = document.createElement('button');
    const zoomLevelDisplay = document.createElement('span');
    increaseButton.innerText = '+';
    decreaseButton.innerText = '-';
    resetViewButton.innerText = localizationTable.resetView;
    zoomLevelRow.replaceChildren(zoomLevelDisplay, increaseButton, decreaseButton, resetViewButton);
    zoomLevelRow.classList.add(`${_constants_mjs__WEBPACK_IMPORTED_MODULE_4__.toolbarCSSPrefix}zoomLevelEditor`);
    zoomLevelDisplay.classList.add('zoomDisplay');
    let lastZoom;
    const updateZoomDisplay = () => {
        let zoomLevel = editor.viewport.getScaleFactor() * 100;
        if (zoomLevel > 0.1) {
            zoomLevel = Math.round(zoomLevel * 10) / 10;
        }
        else {
            zoomLevel = Math.round(zoomLevel * 1000) / 1000;
        }
        if (zoomLevel !== lastZoom) {
            zoomLevelDisplay.textContent = localizationTable.zoomLevel(zoomLevel);
            lastZoom = zoomLevel;
        }
    };
    updateZoomDisplay();
    editor.notifier.on(_types_mjs__WEBPACK_IMPORTED_MODULE_2__.EditorEventType.ViewportChanged, (event) => {
        if (event.kind === _types_mjs__WEBPACK_IMPORTED_MODULE_2__.EditorEventType.ViewportChanged) {
            updateZoomDisplay();
            // Can't reset if already reset.
            resetViewButton.disabled = event.newTransform.eq(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.identity);
        }
    });
    const zoomBy = (factor) => {
        const screenCenter = editor.viewport.visibleRect.center;
        const transformUpdate = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.scaling2D(factor, screenCenter);
        editor.dispatch(_Viewport_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].transformBy(transformUpdate), false);
    };
    increaseButton.onclick = () => {
        zoomBy(5.0 / 4);
    };
    decreaseButton.onclick = () => {
        zoomBy(4.0 / 5);
    };
    resetViewButton.onclick = () => {
        const addToHistory = false;
        editor.dispatch(_Viewport_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].transformBy(editor.viewport.canvasToScreenTransform.inverse()), addToHistory);
    };
    helpDisplay?.registerTextHelpForElement(increaseButton, localizationTable.handDropdown__zoomInHelpText);
    helpDisplay?.registerTextHelpForElement(decreaseButton, localizationTable.handDropdown__zoomOutHelpText);
    helpDisplay?.registerTextHelpForElement(resetViewButton, localizationTable.handDropdown__resetViewHelpText);
    helpDisplay?.registerTextHelpForElement(zoomLevelDisplay, localizationTable.handDropdown__zoomDisplayHelpText);
    return zoomLevelRow;
};
class HandModeWidget extends _BaseWidget_mjs__WEBPACK_IMPORTED_MODULE_6__["default"] {
    constructor(editor, tool, flag, makeIcon, title, helpText, localizationTable) {
        super(editor, `pan-mode-${flag}`, localizationTable);
        this.tool = tool;
        this.flag = flag;
        this.makeIcon = makeIcon;
        this.title = title;
        this.helpText = helpText;
        editor.notifier.on(_types_mjs__WEBPACK_IMPORTED_MODULE_2__.EditorEventType.ToolUpdated, (toolEvt) => {
            if (toolEvt.kind === _types_mjs__WEBPACK_IMPORTED_MODULE_2__.EditorEventType.ToolUpdated && toolEvt.tool === tool) {
                const allEnabled = !!(tool.getMode() & _tools_PanZoom_mjs__WEBPACK_IMPORTED_MODULE_1__.PanZoomMode.SinglePointerGestures);
                this.setSelected(!!(tool.getMode() & flag) || allEnabled);
                // Unless this widget toggles all single pointer gestures, toggling while
                // single pointer gestures are enabled should have no effect
                this.setDisabled(allEnabled && flag !== _tools_PanZoom_mjs__WEBPACK_IMPORTED_MODULE_1__.PanZoomMode.SinglePointerGestures);
            }
        });
        this.setSelected(false);
    }
    shouldAutoDisableInReadOnlyEditor() {
        return false;
    }
    setModeFlag(enabled) {
        this.tool.setModeEnabled(this.flag, enabled);
    }
    handleClick() {
        this.setModeFlag(!this.isSelected());
    }
    getTitle() {
        return this.title;
    }
    createIcon() {
        return this.makeIcon();
    }
    fillDropdown(_dropdown) {
        return false;
    }
    getHelpText() {
        return this.helpText;
    }
}
/** This toolbar widget allows controlling the editor's {@link PanZoom} tool(s). */
class HandToolWidget extends _BaseToolWidget_mjs__WEBPACK_IMPORTED_MODULE_5__["default"] {
    constructor(editor, 
    // Can either be the primary pan/zoom tool (in the primary tools list) or
    // the override pan/zoom tool.
    // If the override pan/zoom tool, the primary will be gotten from the editor's
    // tool controller.
    // If the primary, the override will be gotten from the editor's tool controller.
    tool, localizationTable) {
        const isGivenToolPrimary = editor.toolController.getPrimaryTools().includes(tool);
        const primaryTool = (isGivenToolPrimary ? tool : HandToolWidget.getPrimaryHandTool(editor.toolController)) ??
            tool;
        super(editor, primaryTool, 'hand-tool-widget', localizationTable);
        this.overridePanZoomTool =
            (isGivenToolPrimary ? HandToolWidget.getOverrideHandTool(editor.toolController) : tool) ??
                tool;
        // Only allow toggling a hand tool if we're using the primary hand tool and not the override
        // hand tool for this button.
        this.allowTogglingBaseTool = primaryTool !== null;
        // Allow showing/hiding the dropdown, even if `overridePanZoomTool` isn't enabled.
        if (!this.allowTogglingBaseTool) {
            this.container.classList.add('dropdownShowable');
        }
        // Controls for the overriding hand tool.
        const touchPanningWidget = new HandModeWidget(editor, this.overridePanZoomTool, _tools_PanZoom_mjs__WEBPACK_IMPORTED_MODULE_1__.PanZoomMode.OneFingerTouchGestures, () => this.editor.icons.makeTouchPanningIcon(), localizationTable.touchPanning, localizationTable.handDropdown__touchPanningHelpText, localizationTable);
        const rotationLockWidget = new HandModeWidget(editor, this.overridePanZoomTool, _tools_PanZoom_mjs__WEBPACK_IMPORTED_MODULE_1__.PanZoomMode.RotationLocked, () => this.editor.icons.makeRotationLockIcon(), localizationTable.lockRotation, localizationTable.handDropdown__lockRotationHelpText, localizationTable);
        this.addSubWidget(touchPanningWidget);
        this.addSubWidget(rotationLockWidget);
    }
    static getPrimaryHandTool(toolController) {
        const primaryPanZoomToolList = toolController
            .getPrimaryTools()
            .filter((tool) => tool instanceof _tools_PanZoom_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]);
        const primaryPanZoomTool = primaryPanZoomToolList[0];
        return primaryPanZoomTool;
    }
    static getOverrideHandTool(toolController) {
        const panZoomToolList = toolController.getMatchingTools(_tools_PanZoom_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]);
        const panZoomTool = panZoomToolList[0];
        return panZoomTool;
    }
    shouldAutoDisableInReadOnlyEditor() {
        return false;
    }
    getTitle() {
        return this.localizationTable.handTool;
    }
    createIcon() {
        return this.editor.icons.makeHandToolIcon();
    }
    handleClick() {
        if (this.allowTogglingBaseTool) {
            super.handleClick();
        }
        else {
            this.setDropdownVisible(!this.isDropdownVisible());
        }
    }
    getHelpText() {
        return this.localizationTable.handDropdown__baseHelpText;
    }
    fillDropdown(dropdown, helpDisplay) {
        super.fillDropdown(dropdown, helpDisplay);
        // The container for all actions that come after the toolbar buttons.
        const nonbuttonActionContainer = document.createElement('div');
        nonbuttonActionContainer.classList.add(`${_constants_mjs__WEBPACK_IMPORTED_MODULE_4__.toolbarCSSPrefix}nonbutton-controls-main-list`);
        (0,_components_makeSeparator_mjs__WEBPACK_IMPORTED_MODULE_7__["default"])().addTo(nonbuttonActionContainer);
        const zoomControl = makeZoomControl(this.localizationTable, this.editor, helpDisplay);
        nonbuttonActionContainer.appendChild(zoomControl);
        dropdown.appendChild(nonbuttonActionContainer);
        return true;
    }
    setSelected(selected) {
        if (this.allowTogglingBaseTool) {
            super.setSelected(selected);
        }
    }
    serializeState() {
        const toolMode = this.overridePanZoomTool.getMode();
        return {
            ...super.serializeState(),
            touchPanning: toolMode & _tools_PanZoom_mjs__WEBPACK_IMPORTED_MODULE_1__.PanZoomMode.OneFingerTouchGestures,
            rotationLocked: toolMode & _tools_PanZoom_mjs__WEBPACK_IMPORTED_MODULE_1__.PanZoomMode.RotationLocked,
        };
    }
    deserializeFrom(state) {
        if (state.touchPanning !== undefined) {
            this.overridePanZoomTool.setModeEnabled(_tools_PanZoom_mjs__WEBPACK_IMPORTED_MODULE_1__.PanZoomMode.OneFingerTouchGestures, !!state.touchPanning);
        }
        if (state.rotationLocked !== undefined) {
            this.overridePanZoomTool.setModeEnabled(_tools_PanZoom_mjs__WEBPACK_IMPORTED_MODULE_1__.PanZoomMode.RotationLocked, !!state.rotationLocked);
        }
        super.deserializeFrom(state);
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/widgets/InsertImageWidget/ImageWrapper.mjs":
/*!******************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/widgets/InsertImageWidget/ImageWrapper.mjs ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ImageWrapper: () => (/* binding */ ImageWrapper)
/* harmony export */ });
/** Handles filtering and other operations on an image. */
class ImageWrapper {
    constructor(imageBase64Url, preview, onUrlUpdate) {
        this.imageBase64Url = imageBase64Url;
        this.preview = preview;
        this.onUrlUpdate = onUrlUpdate;
        this.originalSrc = imageBase64Url;
        preview.src = imageBase64Url;
    }
    updateImageData(base64DataUrl) {
        this.preview.src = base64DataUrl;
        this.imageBase64Url = base64DataUrl;
        this.onUrlUpdate();
    }
    decreaseSize(resizeFactor = 3 / 4) {
        const canvas = document.createElement('canvas');
        canvas.width = this.preview.naturalWidth * resizeFactor;
        canvas.height = this.preview.naturalHeight * resizeFactor;
        const ctx = canvas.getContext('2d');
        ctx?.drawImage(this.preview, 0, 0, canvas.width, canvas.height);
        // JPEG can be much smaller than PNG for the same image size. Prefer it if
        // the image is already a JPEG.
        const format = this.originalSrc?.startsWith('data:image/jpeg;') ? 'image/jpeg' : 'image/png';
        this.updateImageData(canvas.toDataURL(format));
    }
    reset() {
        this.updateImageData(this.originalSrc);
    }
    isChanged() {
        return this.imageBase64Url !== this.originalSrc;
    }
    // Returns true if the current image is large enough to display a "decrease size"
    // option.
    isLarge() {
        const largeImageThreshold = 0.12 * 1024 * 1024; // 0.12 MiB
        return this.getBase64Url().length > largeImageThreshold;
    }
    getBase64Url() {
        return this.imageBase64Url;
    }
    getAltText() {
        return this.altText;
    }
    setAltText(text) {
        this.altText = text;
        this.preview.alt = text;
    }
    static fromSrcAndPreview(initialBase64Src, preview, onUrlUpdate) {
        return new ImageWrapper(initialBase64Src, preview, onUrlUpdate);
    }
    static fromRenderable(renderable, onUrlUpdate) {
        const preview = new Image();
        preview.src = renderable.base64Url;
        const result = new ImageWrapper(renderable.base64Url, preview, onUrlUpdate);
        const altText = renderable.label ?? renderable.image.getAttribute('alt');
        if (altText) {
            result.setAltText(altText);
        }
        return { wrapper: result, preview };
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/widgets/InsertImageWidget/InsertImageWidget.mjs":
/*!***********************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/widgets/InsertImageWidget/InsertImageWidget.mjs ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _components_ImageComponent_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../components/ImageComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/ImageComponent.mjs");
/* harmony import */ var _commands_Erase_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../commands/Erase.mjs */ "./node_modules/js-draw/dist/mjs/commands/Erase.mjs");
/* harmony import */ var _image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../image/EditorImage.mjs */ "./node_modules/js-draw/dist/mjs/image/EditorImage.mjs");
/* harmony import */ var _commands_uniteCommands_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../commands/uniteCommands.mjs */ "./node_modules/js-draw/dist/mjs/commands/uniteCommands.mjs");
/* harmony import */ var _tools_SelectionTool_SelectionTool_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../tools/SelectionTool/SelectionTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionTool.mjs");
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _BaseWidget_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../BaseWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/BaseWidget.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../types.mjs */ "./node_modules/js-draw/dist/mjs/types.mjs");
/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../constants.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/constants.mjs");
/* harmony import */ var _components_makeFileInput_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../components/makeFileInput.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeFileInput.mjs");
/* harmony import */ var _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../util/ReactiveValue.mjs */ "./node_modules/js-draw/dist/mjs/util/ReactiveValue.mjs");
/* harmony import */ var _util_bytesToSizeString_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../util/bytesToSizeString.mjs */ "./node_modules/js-draw/dist/mjs/util/bytesToSizeString.mjs");
/* harmony import */ var _ImageWrapper_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ImageWrapper.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/InsertImageWidget/ImageWrapper.mjs");
/* harmony import */ var _components_makeSnappedList_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../components/makeSnappedList.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeSnappedList.mjs");
/* harmony import */ var _fileToImages_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./fileToImages.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/InsertImageWidget/fileToImages.mjs");















/**
 * Provides a widget that allows inserting or modifying raster images.
 *
 * It's possible to customize the file picker used by this widget through {@link EditorSettings.image}.
 *
 * @example
 * ```ts,runnable
 * import { Editor, makeEdgeToolbar, InsertImageWidget } from 'js-draw';
 *
 * const editor = new Editor(document.body);
 * const toolbar = makeEdgeToolbar(editor);
 *
 * toolbar.addWidget(new InsertImageWidget(editor));
 * ```
 */
class InsertImageWidget extends _BaseWidget_mjs__WEBPACK_IMPORTED_MODULE_6__["default"] {
    constructor(editor, localization) {
        localization ??= editor.localization;
        super(editor, 'insert-image-widget', localization);
        // Make the dropdown showable
        this.container.classList.add('dropdownShowable');
        editor.notifier.on(_types_mjs__WEBPACK_IMPORTED_MODULE_7__.EditorEventType.SelectionUpdated, (event) => {
            if (event.kind === _types_mjs__WEBPACK_IMPORTED_MODULE_7__.EditorEventType.SelectionUpdated && this.isDropdownVisible()) {
                this.updateInputs();
            }
        });
        this.images = _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_10__.MutableReactiveValue.fromInitialValue([]);
        this.images.onUpdateAndNow(() => {
            this.onImageDataUpdate();
        });
    }
    getTitle() {
        return this.localizationTable.image;
    }
    createIcon() {
        return this.editor.icons.makeInsertImageIcon();
    }
    setDropdownVisible(visible) {
        super.setDropdownVisible(visible);
        // Update the dropdown just before showing.
        if (this.isDropdownVisible()) {
            this.updateInputs();
        }
        else {
            // Allow any previously-selected files to be freed.
            this.selectedFiles?.set([]);
        }
    }
    handleClick() {
        this.setDropdownVisible(!this.isDropdownVisible());
    }
    fillDropdown(dropdown) {
        const container = document.createElement('div');
        container.classList.add('insert-image-widget-dropdown-content', `${_constants_mjs__WEBPACK_IMPORTED_MODULE_8__.toolbarCSSPrefix}spacedList`, `${_constants_mjs__WEBPACK_IMPORTED_MODULE_8__.toolbarCSSPrefix}nonbutton-controls-main-list`);
        const { container: chooseImageRow, selectedFiles } = (0,_components_makeFileInput_mjs__WEBPACK_IMPORTED_MODULE_9__["default"])(this.localizationTable.chooseFile, this.editor, {
            accepts: 'image/*',
            allowMultiSelect: true,
            customPickerAction: this.editor.getCurrentSettings().image?.showImagePicker,
        });
        const altTextRow = document.createElement('div');
        this.imagesPreview = (0,_components_makeSnappedList_mjs__WEBPACK_IMPORTED_MODULE_13__["default"])(this.images);
        this.statusView = document.createElement('div');
        const actionButtonRow = document.createElement('div');
        actionButtonRow.classList.add('action-button-row');
        this.statusView.classList.add('insert-image-image-status-view');
        this.submitButton = document.createElement('button');
        this.selectedFiles = selectedFiles;
        this.imageAltTextInput = document.createElement('input');
        // Label the alt text input
        const imageAltTextLabel = document.createElement('label');
        const altTextInputId = `insert-image-alt-text-input-${InsertImageWidget.nextInputId++}`;
        this.imageAltTextInput.setAttribute('id', altTextInputId);
        imageAltTextLabel.htmlFor = altTextInputId;
        imageAltTextLabel.innerText = this.localizationTable.inputAltText;
        this.imageAltTextInput.type = 'text';
        this.imageAltTextInput.placeholder = this.localizationTable.describeTheImage;
        this.statusView.setAttribute('aria-live', 'polite');
        this.submitButton.innerText = this.localizationTable.submit;
        this.imagesPreview.visibleItem.onUpdateAndNow(() => this.onImageDataUpdate());
        this.imageAltTextInput.oninput = () => {
            const currentImage = this.imagesPreview.visibleItem.get();
            if (currentImage) {
                currentImage.setAltText(this.imageAltTextInput.value);
                this.submitButton.style.display = '';
            }
        };
        this.selectedFiles.onUpdateAndNow(async (files) => {
            if (files.length === 0) {
                this.images.set([]);
                return;
            }
            const previews = (await Promise.all(files.map(async (imageFile) => {
                let renderableImages;
                try {
                    renderableImages = await (0,_fileToImages_mjs__WEBPACK_IMPORTED_MODULE_14__["default"])(imageFile);
                }
                catch (error) {
                    console.error('Image load error', error);
                    const errorMessage = this.localizationTable.imageLoadError(error);
                    this.statusView.innerText = errorMessage;
                    return [];
                }
                return renderableImages.map((image) => {
                    const { wrapper, preview } = _ImageWrapper_mjs__WEBPACK_IMPORTED_MODULE_12__.ImageWrapper.fromRenderable(image, () => this.onImageDataUpdate());
                    return {
                        data: wrapper,
                        element: preview,
                    };
                });
            }))).flat();
            this.images.set(previews);
        });
        altTextRow.replaceChildren(imageAltTextLabel, this.imageAltTextInput);
        actionButtonRow.replaceChildren(this.submitButton);
        container.replaceChildren(chooseImageRow, altTextRow, this.imagesPreview.container, this.statusView, actionButtonRow);
        dropdown.replaceChildren(container);
        return true;
    }
    onImageDataUpdate() {
        if (!this.imagesPreview)
            return;
        const currentImage = this.imagesPreview.visibleItem.get();
        const base64Data = currentImage?.getBase64Url();
        this.imageAltTextInput.value = currentImage?.getAltText() ?? '';
        if (base64Data) {
            this.submitButton.disabled = false;
            this.submitButton.style.display = '';
            this.updateImageSizeDisplay();
        }
        else {
            this.submitButton.disabled = true;
            this.submitButton.style.display = 'none';
            this.statusView.innerText = '';
            this.submitButton.disabled = true;
        }
        if (this.images.get().length <= 1) {
            this.submitButton.innerText = this.localizationTable.submit;
        }
        else {
            this.submitButton.innerText = this.localizationTable.addAll;
        }
    }
    hideDialog() {
        this.setDropdownVisible(false);
    }
    updateImageSizeDisplay() {
        const currentImage = this.imagesPreview.visibleItem.get();
        const imageData = currentImage?.getBase64Url() ?? '';
        const { size, units } = (0,_util_bytesToSizeString_mjs__WEBPACK_IMPORTED_MODULE_11__["default"])(imageData.length);
        const sizeText = document.createElement('span');
        sizeText.innerText = this.localizationTable.imageSize(Math.round(size), units);
        // Add a button to allow decreasing the size of large images.
        const decreaseSizeButton = document.createElement('button');
        decreaseSizeButton.innerText = this.localizationTable.decreaseImageSize;
        decreaseSizeButton.onclick = () => {
            currentImage?.decreaseSize();
        };
        const resetSizeButton = document.createElement('button');
        resetSizeButton.innerText = this.localizationTable.resetImage;
        resetSizeButton.onclick = () => {
            currentImage?.reset();
        };
        this.statusView.replaceChildren(sizeText);
        if (currentImage?.isLarge()) {
            this.statusView.appendChild(decreaseSizeButton);
        }
        else if (currentImage?.isChanged()) {
            this.statusView.appendChild(resetSizeButton);
        }
        else {
            const hasLargeOrChangedImages = this.images
                .get()
                .some((image) => image.data?.isChanged() || image.data?.isLarge());
            if (hasLargeOrChangedImages) {
                // Still show the button -- prevents the layout from readjusting while
                // scrolling through the image list
                decreaseSizeButton.disabled = true;
                this.statusView.appendChild(decreaseSizeButton);
            }
        }
    }
    updateInputs() {
        const resetInputs = () => {
            this.selectedFiles?.set([]);
            this.imageAltTextInput.value = '';
            this.submitButton.disabled = true;
            this.statusView.innerText = '';
            this.submitButton.style.display = '';
        };
        resetInputs();
        const selectionTools = this.editor.toolController.getMatchingTools(_tools_SelectionTool_SelectionTool_mjs__WEBPACK_IMPORTED_MODULE_4__["default"]);
        const selectedObjects = selectionTools.map((tool) => tool.getSelectedObjects()).flat();
        // Check: Is there a selected image that can be edited?
        let editingImage = null;
        if (selectedObjects.length === 1 && selectedObjects[0] instanceof _components_ImageComponent_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]) {
            editingImage = selectedObjects[0];
            const image = new Image();
            const imageWrapper = _ImageWrapper_mjs__WEBPACK_IMPORTED_MODULE_12__.ImageWrapper.fromSrcAndPreview(editingImage.getURL(), image, () => this.onImageDataUpdate());
            imageWrapper.setAltText(editingImage.getAltText() ?? '');
            this.images.set([{ data: imageWrapper, element: image }]);
        }
        else if (selectedObjects.length > 0) {
            // If not, clear the selection.
            selectionTools.forEach((tool) => tool.clearSelection());
        }
        // Show the submit button only when there is data to submit.
        this.submitButton.style.display = 'none';
        this.submitButton.onclick = async () => {
            const newComponents = [];
            let transform = _js_draw_math__WEBPACK_IMPORTED_MODULE_5__.Mat33.identity;
            let fullBBox = null;
            for (const { data: imageWrapper } of this.images.get()) {
                if (!imageWrapper) {
                    continue;
                }
                const image = new Image();
                image.src = imageWrapper.getBase64Url();
                const altText = imageWrapper.getAltText();
                if (altText) {
                    image.setAttribute('alt', altText);
                }
                let component;
                try {
                    component = await _components_ImageComponent_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].fromImage(image, transform);
                }
                catch (error) {
                    console.error('Error loading image', error);
                    this.statusView.innerText = this.localizationTable.imageLoadError(error);
                    return;
                }
                const componentBBox = component.getBBox();
                if (componentBBox.area === 0) {
                    this.statusView.innerText = this.localizationTable.errorImageHasZeroSize;
                    return;
                }
                newComponents.push(component);
                fullBBox ??= componentBBox;
                fullBBox.union(componentBBox);
                // Update the transform for the next item.
                const shift = _js_draw_math__WEBPACK_IMPORTED_MODULE_5__.Vec2.of(0, componentBBox.height);
                transform = transform.rightMul(_js_draw_math__WEBPACK_IMPORTED_MODULE_5__.Mat33.translation(shift));
            }
            if (newComponents.length) {
                if (!fullBBox) {
                    throw new Error('Logic error: Full bounding box must be calculated when components are to be added.');
                }
                this.hideDialog();
                if (editingImage) {
                    const eraseCommand = new _commands_Erase_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]([editingImage]);
                    // Try to preserve the original width
                    const originalTransform = editingImage.getTransformation();
                    // || 1: Prevent division by zero
                    const originalWidth = editingImage.getBBox().width || 1;
                    const newWidth = fullBBox.transformedBoundingBox(originalTransform).width || 1;
                    const widthAdjustTransform = _js_draw_math__WEBPACK_IMPORTED_MODULE_5__.Mat33.scaling2D(originalWidth / newWidth);
                    const commands = [];
                    for (const component of newComponents) {
                        commands.push(_image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].addElement(component), component.transformBy(originalTransform.rightMul(widthAdjustTransform)), component.setZIndex(editingImage.getZIndex()));
                    }
                    this.editor.dispatch((0,_commands_uniteCommands_mjs__WEBPACK_IMPORTED_MODULE_3__["default"])([...commands, eraseCommand]));
                    selectionTools[0]?.setSelection(newComponents);
                }
                else {
                    await this.editor.addAndCenterComponents(newComponents);
                }
            }
        };
    }
}
InsertImageWidget.nextInputId = 0;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InsertImageWidget);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/widgets/InsertImageWidget/fileToImages.mjs":
/*!******************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/widgets/InsertImageWidget/fileToImages.mjs ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_fileToBase64Url_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/fileToBase64Url.mjs */ "./node_modules/js-draw/dist/mjs/util/fileToBase64Url.mjs");
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");


const fileToImages = async (imageFile) => {
    const result = [];
    const imageElement = new Image();
    const base64Url = await (0,_util_fileToBase64Url_mjs__WEBPACK_IMPORTED_MODULE_0__["default"])(imageFile);
    if (base64Url) {
        result.push({
            image: imageElement,
            base64Url: base64Url,
            transform: _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Mat33.identity,
        });
    }
    return result;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (fileToImages);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/widgets/OverflowWidget.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/widgets/OverflowWidget.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ OverflowWidget)
/* harmony export */ });
/* harmony import */ var _BaseWidget_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/BaseWidget.mjs");

class OverflowWidget extends _BaseWidget_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(editor, localizationTable) {
        super(editor, 'overflow-widget', localizationTable);
        this.overflowChildren = [];
        this.container.classList.add('toolbar-overflow-widget');
        // Make the dropdown openable
        this.container.classList.add('dropdownShowable');
        this.overflowContainer ??= document.createElement('div');
    }
    shouldAutoDisableInReadOnlyEditor() {
        return false;
    }
    getTitle() {
        return this.localizationTable.toggleOverflow;
    }
    createIcon() {
        return this.editor.icons.makeOverflowIcon();
    }
    handleClick() {
        this.setDropdownVisible(!this.isDropdownVisible());
    }
    fillDropdown(dropdown) {
        this.overflowContainer ??= document.createElement('div');
        if (this.overflowContainer.parentElement) {
            this.overflowContainer.remove();
        }
        this.overflowContainer.classList.add('toolbar-overflow-widget-overflow-list');
        dropdown.appendChild(this.overflowContainer);
        return true;
    }
    /**
     * Removes all `BaseWidget`s from this and returns them.
     */
    clearChildren() {
        this.overflowContainer.replaceChildren();
        this.container.classList.remove('horizontal');
        const overflowChildren = this.overflowChildren;
        this.overflowChildren = [];
        return overflowChildren;
    }
    getChildWidgets() {
        return [...this.overflowChildren];
    }
    hasAsChild(widget) {
        for (const otherWidget of this.overflowChildren) {
            if (widget === otherWidget) {
                return true;
            }
        }
        return false;
    }
    /**
     * Adds `widget` to this.
     * `widget`'s previous parent is still responsible
     * for serializing/deserializing its state.
     */
    addToOverflow(widget) {
        this.overflowChildren.push(widget);
        widget.addTo(this.overflowContainer);
        widget.setIsToplevel(false);
        // Switch to a horizontal layout if enough children
        if (this.overflowChildren.length > 2) {
            this.container.classList.add('horizontal');
        }
    }
    // This always returns false.
    // Don't try to move the overflow menu to itself.
    canBeInOverflowMenu() {
        return false;
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/widgets/PenToolWidget.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/widgets/PenToolWidget.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _components_builders_ArrowBuilder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../components/builders/ArrowBuilder.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/ArrowBuilder.mjs");
/* harmony import */ var _components_builders_FreehandLineBuilder_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/builders/FreehandLineBuilder.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/FreehandLineBuilder.mjs");
/* harmony import */ var _components_builders_PressureSensitiveFreehandLineBuilder_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/builders/PressureSensitiveFreehandLineBuilder.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/PressureSensitiveFreehandLineBuilder.mjs");
/* harmony import */ var _components_builders_LineBuilder_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../components/builders/LineBuilder.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/LineBuilder.mjs");
/* harmony import */ var _components_builders_RectangleBuilder_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../components/builders/RectangleBuilder.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/RectangleBuilder.mjs");
/* harmony import */ var _components_builders_CircleBuilder_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../components/builders/CircleBuilder.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/CircleBuilder.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../types.mjs */ "./node_modules/js-draw/dist/mjs/types.mjs");
/* harmony import */ var _components_makeColorInput_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/makeColorInput.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeColorInput.mjs");
/* harmony import */ var _BaseToolWidget_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./BaseToolWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/BaseToolWidget.mjs");
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _keybindings_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./keybindings.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/keybindings.mjs");
/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../constants.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/constants.mjs");
/* harmony import */ var _components_makeThicknessSlider_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./components/makeThicknessSlider.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeThicknessSlider.mjs");
/* harmony import */ var _components_makeGridSelector_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./components/makeGridSelector.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeGridSelector.mjs");
/* harmony import */ var _components_builders_PolylineBuilder_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../components/builders/PolylineBuilder.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/PolylineBuilder.mjs");















/**
 * This toolbar widget allows a user to control a single {@link Pen} tool.
 *
 * See also {@link AbstractToolbar.addDefaultToolWidgets}.
 */
class PenToolWidget extends _BaseToolWidget_mjs__WEBPACK_IMPORTED_MODULE_8__["default"] {
    constructor(editor, tool, localization) {
        super(editor, tool, 'pen', localization);
        this.tool = tool;
        this.updateInputs = () => { };
        // Pen types that correspond to
        this.shapelikeIDs = ['pressure-sensitive-pen', 'freehand-pen'];
        // Additional client-specified pens.
        const additionalPens = editor.getCurrentSettings().pens?.additionalPenTypes ?? [];
        const filterPens = editor.getCurrentSettings().pens?.filterPenTypes ?? (() => true);
        // Default pen types
        this.penTypes = [
            // Non-shape pens
            {
                name: this.localizationTable.flatTipPen,
                id: 'pressure-sensitive-pen',
                factory: _components_builders_PressureSensitiveFreehandLineBuilder_mjs__WEBPACK_IMPORTED_MODULE_2__.makePressureSensitiveFreehandLineBuilder,
            },
            {
                name: this.localizationTable.roundedTipPen,
                id: 'freehand-pen',
                factory: _components_builders_FreehandLineBuilder_mjs__WEBPACK_IMPORTED_MODULE_1__.makeFreehandLineBuilder,
            },
            {
                name: this.localizationTable.roundedTipPen2,
                id: 'polyline-pen',
                factory: _components_builders_PolylineBuilder_mjs__WEBPACK_IMPORTED_MODULE_14__.makePolylineBuilder,
            },
            ...additionalPens.filter((pen) => !pen.isShapeBuilder),
            // Shape pens
            {
                name: this.localizationTable.arrowPen,
                id: 'arrow',
                isShapeBuilder: true,
                factory: _components_builders_ArrowBuilder_mjs__WEBPACK_IMPORTED_MODULE_0__.makeArrowBuilder,
            },
            {
                name: this.localizationTable.linePen,
                id: 'line',
                isShapeBuilder: true,
                factory: _components_builders_LineBuilder_mjs__WEBPACK_IMPORTED_MODULE_3__.makeLineBuilder,
            },
            {
                name: this.localizationTable.filledRectanglePen,
                id: 'filled-rectangle',
                isShapeBuilder: true,
                factory: _components_builders_RectangleBuilder_mjs__WEBPACK_IMPORTED_MODULE_4__.makeFilledRectangleBuilder,
            },
            {
                name: this.localizationTable.outlinedRectanglePen,
                id: 'outlined-rectangle',
                isShapeBuilder: true,
                factory: _components_builders_RectangleBuilder_mjs__WEBPACK_IMPORTED_MODULE_4__.makeOutlinedRectangleBuilder,
            },
            {
                name: this.localizationTable.outlinedCirclePen,
                id: 'outlined-circle',
                isShapeBuilder: true,
                factory: _components_builders_CircleBuilder_mjs__WEBPACK_IMPORTED_MODULE_5__.makeOutlinedCircleBuilder,
            },
            ...additionalPens.filter((pen) => pen.isShapeBuilder),
        ].filter(filterPens);
        this.editor.notifier.on(_types_mjs__WEBPACK_IMPORTED_MODULE_6__.EditorEventType.ToolUpdated, (toolEvt) => {
            if (toolEvt.kind !== _types_mjs__WEBPACK_IMPORTED_MODULE_6__.EditorEventType.ToolUpdated) {
                throw new Error('Invalid event type!');
            }
            // The button icon may depend on tool properties.
            if (toolEvt.tool === this.tool) {
                this.updateIcon();
                this.updateInputs();
            }
        });
    }
    getTitle() {
        return this.targetTool.description;
    }
    // Return the index of this tool's stroke factory in the list of
    // all stroke factories.
    //
    // Returns -1 if the stroke factory is not in the list of all stroke factories.
    getCurrentPenTypeIdx() {
        const currentFactory = this.tool.getStrokeFactory();
        for (let i = 0; i < this.penTypes.length; i++) {
            if (this.penTypes[i].factory === currentFactory) {
                return i;
            }
        }
        return -1;
    }
    getCurrentPenType() {
        for (const penType of this.penTypes) {
            if (penType.factory === this.tool.getStrokeFactory()) {
                return penType;
            }
        }
        return null;
    }
    createIconForRecord(record) {
        const style = {
            ...this.tool.getStyleValue().get(),
        };
        if (record?.factory) {
            style.factory = record.factory;
        }
        const strokeFactory = record?.factory;
        if (!strokeFactory ||
            strokeFactory === _components_builders_FreehandLineBuilder_mjs__WEBPACK_IMPORTED_MODULE_1__.makeFreehandLineBuilder ||
            strokeFactory === _components_builders_PressureSensitiveFreehandLineBuilder_mjs__WEBPACK_IMPORTED_MODULE_2__.makePressureSensitiveFreehandLineBuilder ||
            strokeFactory === _components_builders_PolylineBuilder_mjs__WEBPACK_IMPORTED_MODULE_14__.makePolylineBuilder) {
            return this.editor.icons.makePenIcon(style);
        }
        else {
            return this.editor.icons.makeIconFromFactory(style);
        }
    }
    createIcon() {
        return this.createIconForRecord(this.getCurrentPenType());
    }
    // Creates a widget that allows selecting different pen types
    createPenTypeSelector(helpOverlay) {
        const allChoices = this.penTypes.map((penType, index) => {
            return {
                id: index,
                makeIcon: () => this.createIconForRecord(penType),
                title: penType.name,
                isShapeBuilder: penType.isShapeBuilder ?? false,
            };
        });
        const penItems = allChoices.filter((choice) => !choice.isShapeBuilder);
        const penSelector = (0,_components_makeGridSelector_mjs__WEBPACK_IMPORTED_MODULE_13__["default"])(this.localizationTable.selectPenType, this.getCurrentPenTypeIdx(), penItems);
        const shapeItems = allChoices.filter((choice) => choice.isShapeBuilder);
        const shapeSelector = (0,_components_makeGridSelector_mjs__WEBPACK_IMPORTED_MODULE_13__["default"])(this.localizationTable.selectShape, this.getCurrentPenTypeIdx(), shapeItems);
        const onSelectorUpdate = (newPenTypeIndex) => {
            this.tool.setStrokeFactory(this.penTypes[newPenTypeIndex].factory);
        };
        penSelector.value.onUpdate(onSelectorUpdate);
        shapeSelector.value.onUpdate(onSelectorUpdate);
        helpOverlay?.registerTextHelpForElements([penSelector.getRootElement(), shapeSelector.getRootElement()], this.localizationTable.penDropdown__penTypeHelpText);
        return {
            setValue: (penTypeIndex) => {
                penSelector.value.set(penTypeIndex);
                shapeSelector.value.set(penTypeIndex);
            },
            updateIcons: () => {
                penSelector.updateIcons();
                shapeSelector.updateIcons();
            },
            addTo: (parent) => {
                if (penItems.length) {
                    penSelector.addTo(parent);
                }
                if (shapeItems.length) {
                    shapeSelector.addTo(parent);
                }
            },
        };
    }
    createStrokeCorrectionOptions(helpOverlay) {
        const container = document.createElement('div');
        container.classList.add('action-button-row', `${_constants_mjs__WEBPACK_IMPORTED_MODULE_11__.toolbarCSSPrefix}-pen-tool-toggle-buttons`);
        const addToggleButton = (labelText, icon) => {
            const button = document.createElement('button');
            button.classList.add(`${_constants_mjs__WEBPACK_IMPORTED_MODULE_11__.toolbarCSSPrefix}-toggle-button`);
            const iconElement = icon.cloneNode(true);
            iconElement.classList.add('icon');
            const label = document.createElement('span');
            label.innerText = labelText;
            button.replaceChildren(iconElement, label);
            button.setAttribute('role', 'switch');
            container.appendChild(button);
            let checked = false;
            let onChangeListener = (_checked) => { };
            const result = {
                setChecked(newChecked) {
                    checked = newChecked;
                    button.setAttribute('aria-checked', `${checked}`);
                    onChangeListener(checked);
                },
                setOnInputListener(listener) {
                    onChangeListener = listener;
                },
                addHelpText(text) {
                    helpOverlay?.registerTextHelpForElement(button, text);
                },
            };
            button.onclick = () => {
                result.setChecked(!checked);
            };
            return result;
        };
        const stabilizationOption = addToggleButton(this.localizationTable.inputStabilization, this.editor.icons.makeStrokeSmoothingIcon());
        stabilizationOption.setOnInputListener((enabled) => {
            this.tool.setHasStabilization(enabled);
        });
        const autocorrectOption = addToggleButton(this.localizationTable.strokeAutocorrect, this.editor.icons.makeShapeAutocorrectIcon());
        autocorrectOption.setOnInputListener((enabled) => {
            this.tool.setStrokeAutocorrectEnabled(enabled);
        });
        // Help text
        autocorrectOption.addHelpText(this.localizationTable.penDropdown__autocorrectHelpText);
        stabilizationOption.addHelpText(this.localizationTable.penDropdown__stabilizationHelpText);
        return {
            update: () => {
                stabilizationOption.setChecked(!!this.tool.getInputMapper());
                autocorrectOption.setChecked(this.tool.getStrokeAutocorrectionEnabled());
            },
            addTo: (parent) => {
                parent.appendChild(container);
            },
        };
    }
    getHelpText() {
        return this.localizationTable.penDropdown__baseHelpText;
    }
    fillDropdown(dropdown, helpDisplay) {
        const container = document.createElement('div');
        container.classList.add(`${_constants_mjs__WEBPACK_IMPORTED_MODULE_11__.toolbarCSSPrefix}spacedList`, `${_constants_mjs__WEBPACK_IMPORTED_MODULE_11__.toolbarCSSPrefix}nonbutton-controls-main-list`);
        // Thickness: Value of the input is squared to allow for finer control/larger values.
        const { container: thicknessRow, setValue: setThickness } = (0,_components_makeThicknessSlider_mjs__WEBPACK_IMPORTED_MODULE_12__["default"])(this.editor, (thickness) => {
            this.tool.setThickness(thickness);
        });
        const colorRow = document.createElement('div');
        const colorLabel = document.createElement('label');
        const colorInputControl = (0,_components_makeColorInput_mjs__WEBPACK_IMPORTED_MODULE_7__["default"])(this.editor, (color) => {
            this.tool.setColor(color);
        });
        const { input: colorInput, container: colorInputContainer } = colorInputControl;
        colorInput.id = `${_constants_mjs__WEBPACK_IMPORTED_MODULE_11__.toolbarCSSPrefix}colorInput${PenToolWidget.idCounter++}`;
        colorLabel.innerText = this.localizationTable.colorLabel;
        colorLabel.setAttribute('for', colorInput.id);
        colorRow.appendChild(colorLabel);
        colorRow.appendChild(colorInputContainer);
        // Autocorrect and stabilization options
        const toggleButtonRow = this.createStrokeCorrectionOptions(helpDisplay);
        const penTypeSelect = this.createPenTypeSelector(helpDisplay);
        // Add help text for color and thickness last, as these are likely to be
        // features users are least interested in.
        helpDisplay?.registerTextHelpForElement(colorRow, this.localizationTable.penDropdown__colorHelpText);
        if (helpDisplay) {
            colorInputControl.registerWithHelpTextDisplay(helpDisplay);
        }
        helpDisplay?.registerTextHelpForElement(thicknessRow, this.localizationTable.penDropdown__thicknessHelpText);
        this.updateInputs = () => {
            colorInputControl.setValue(this.tool.getColor());
            setThickness(this.tool.getThickness());
            penTypeSelect.updateIcons();
            // Update the selected stroke factory.
            penTypeSelect.setValue(this.getCurrentPenTypeIdx());
            toggleButtonRow.update();
        };
        this.updateInputs();
        container.replaceChildren(colorRow, thicknessRow);
        penTypeSelect.addTo(container);
        dropdown.replaceChildren(container);
        // Add the toggle button row *outside* of the main content (use different
        // spacing with respect to the sides of the container).
        toggleButtonRow.addTo(dropdown);
        return true;
    }
    onKeyPress(event) {
        if (!this.isSelected()) {
            return false;
        }
        for (let i = 0; i < _keybindings_mjs__WEBPACK_IMPORTED_MODULE_10__.selectStrokeTypeKeyboardShortcutIds.length; i++) {
            const shortcut = _keybindings_mjs__WEBPACK_IMPORTED_MODULE_10__.selectStrokeTypeKeyboardShortcutIds[i];
            if (this.editor.shortcuts.matchesShortcut(shortcut, event)) {
                const penTypeIdx = i;
                if (penTypeIdx < this.penTypes.length) {
                    this.tool.setStrokeFactory(this.penTypes[penTypeIdx].factory);
                    return true;
                }
            }
        }
        // Run any default actions registered by the parent class.
        if (super.onKeyPress(event)) {
            return true;
        }
        return false;
    }
    serializeState() {
        return {
            ...super.serializeState(),
            color: this.tool.getColor().toHexString(),
            thickness: this.tool.getThickness(),
            strokeFactoryId: this.getCurrentPenType()?.id,
            inputStabilization: !!this.tool.getInputMapper(),
            strokeAutocorrect: this.tool.getStrokeAutocorrectionEnabled(),
        };
    }
    deserializeFrom(state) {
        super.deserializeFrom(state);
        const verifyPropertyType = (propertyName, expectedType) => {
            const actualType = typeof state[propertyName];
            if (actualType !== expectedType) {
                throw new Error(`Deserializing property ${propertyName}: Invalid type. Expected ${expectedType},` +
                    ` was ${actualType}.`);
            }
        };
        if (state.color) {
            verifyPropertyType('color', 'string');
            this.tool.setColor(_js_draw_math__WEBPACK_IMPORTED_MODULE_9__.Color4.fromHex(state.color));
        }
        if (state.thickness) {
            verifyPropertyType('thickness', 'number');
            this.tool.setThickness(state.thickness);
        }
        if (state.strokeFactoryId) {
            verifyPropertyType('strokeFactoryId', 'string');
            const factoryId = state.strokeFactoryId;
            for (const penType of this.penTypes) {
                if (factoryId === penType.id) {
                    this.tool.setStrokeFactory(penType.factory);
                    break;
                }
            }
        }
        if (state.inputStabilization !== undefined) {
            this.tool.setHasStabilization(!!state.inputStabilization);
        }
        if (state.strokeAutocorrect !== undefined) {
            this.tool.setStrokeAutocorrectEnabled(!!state.strokeAutocorrect);
        }
    }
}
// A counter variable that ensures different HTML elements are given unique names/ids.
PenToolWidget.idCounter = 0;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PenToolWidget);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/widgets/SaveActionWidget.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/widgets/SaveActionWidget.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ActionButtonWidget_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ActionButtonWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/ActionButtonWidget.mjs");
/* harmony import */ var _BaseWidget_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/BaseWidget.mjs");
/* harmony import */ var _keybindings_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keybindings.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/keybindings.mjs");



class SaveActionWidget extends _ActionButtonWidget_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(editor, localization, saveCallback, labelOverride = {}) {
        super(editor, 'save-button', 
        // Creates an icon
        () => {
            return labelOverride.icon ?? editor.icons.makeSaveIcon();
        }, labelOverride.label ?? localization.save, saveCallback);
        this.setTags([_BaseWidget_mjs__WEBPACK_IMPORTED_MODULE_1__.ToolbarWidgetTag.Save]);
    }
    shouldAutoDisableInReadOnlyEditor() {
        return false;
    }
    onKeyPress(event) {
        if (this.editor.shortcuts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_2__.saveKeyboardShortcut, event)) {
            this.clickAction();
            return true;
        }
        // Run any default actions registered by the parent class.
        return super.onKeyPress(event);
    }
    mustBeInToplevelMenu() {
        return true;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SaveActionWidget);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/widgets/SelectionToolWidget.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/widgets/SelectionToolWidget.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SelectionToolWidget)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _components_RestylableComponent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/RestylableComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/RestylableComponent.mjs");
/* harmony import */ var _commands_uniteCommands_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../commands/uniteCommands.mjs */ "./node_modules/js-draw/dist/mjs/commands/uniteCommands.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../types.mjs */ "./node_modules/js-draw/dist/mjs/types.mjs");
/* harmony import */ var _components_makeColorInput_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/makeColorInput.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeColorInput.mjs");
/* harmony import */ var _ActionButtonWidget_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ActionButtonWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/ActionButtonWidget.mjs");
/* harmony import */ var _BaseToolWidget_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./BaseToolWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/BaseToolWidget.mjs");
/* harmony import */ var _keybindings_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./keybindings.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/keybindings.mjs");
/* harmony import */ var _components_makeSeparator_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/makeSeparator.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeSeparator.mjs");
/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../constants.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/constants.mjs");










const makeFormatMenu = (editor, selectionTool, localizationTable) => {
    const container = document.createElement('div');
    container.classList.add('selection-format-menu', `${_constants_mjs__WEBPACK_IMPORTED_MODULE_9__.toolbarCSSPrefix}spacedList`, `${_constants_mjs__WEBPACK_IMPORTED_MODULE_9__.toolbarCSSPrefix}indentedList`);
    const colorRow = document.createElement('div');
    const colorLabel = document.createElement('label');
    const colorInputControl = (0,_components_makeColorInput_mjs__WEBPACK_IMPORTED_MODULE_4__["default"])(editor, (color) => {
        const selection = selectionTool.getSelection();
        if (selection) {
            const updateStyleCommands = [];
            for (const elem of selection.getSelectedObjects()) {
                if ((0,_components_RestylableComponent_mjs__WEBPACK_IMPORTED_MODULE_1__.isRestylableComponent)(elem)) {
                    updateStyleCommands.push(elem.updateStyle({ color }));
                }
            }
            const unitedCommand = (0,_commands_uniteCommands_mjs__WEBPACK_IMPORTED_MODULE_2__["default"])(updateStyleCommands);
            editor.dispatch(unitedCommand);
        }
    });
    const { input: colorInput, container: colorInputContainer } = colorInputControl;
    colorLabel.innerText = localizationTable.colorLabel;
    const update = () => {
        const selection = selectionTool.getSelection();
        if (selection && selection.getSelectedItemCount() > 0) {
            colorInput.disabled = false;
            container.classList.remove('disabled');
            const colors = [];
            for (const elem of selection.getSelectedObjects()) {
                if ((0,_components_RestylableComponent_mjs__WEBPACK_IMPORTED_MODULE_1__.isRestylableComponent)(elem)) {
                    const color = elem.getStyle().color;
                    if (color) {
                        colors.push(color);
                    }
                }
            }
            colorInputControl.setValue(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.average(colors));
        }
        else {
            colorInput.disabled = true;
            container.classList.add('disabled');
            colorInputControl.setValue(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.transparent);
        }
    };
    colorRow.replaceChildren(colorLabel, colorInputContainer);
    container.replaceChildren(colorRow);
    return {
        addTo: (parent) => {
            parent.appendChild(container);
        },
        update,
        registerHelpText: (helpDisplay) => {
            helpDisplay.registerTextHelpForElement(colorRow, localizationTable.selectionDropdown__changeColorHelpText);
            colorInputControl.registerWithHelpTextDisplay(helpDisplay);
        },
    };
};
class SelectionToolWidget extends _BaseToolWidget_mjs__WEBPACK_IMPORTED_MODULE_6__["default"] {
    constructor(editor, tool, localization) {
        super(editor, tool, 'selection-tool-widget', localization);
        this.tool = tool;
        this.updateFormatMenu = () => { };
        const resizeButton = new _ActionButtonWidget_mjs__WEBPACK_IMPORTED_MODULE_5__["default"](editor, 'resize-btn', () => editor.icons.makeResizeImageToSelectionIcon(), this.localizationTable.resizeImageToSelection, () => {
            this.resizeImageToSelection();
        }, localization);
        resizeButton.setHelpText(this.localizationTable.selectionDropdown__resizeToHelpText);
        const deleteButton = new _ActionButtonWidget_mjs__WEBPACK_IMPORTED_MODULE_5__["default"](editor, 'delete-btn', () => editor.icons.makeDeleteSelectionIcon(), this.localizationTable.deleteSelection, () => {
            const selection = this.tool.getSelection();
            this.editor.dispatch(selection.deleteSelectedObjects());
            this.tool.clearSelection();
        }, localization);
        deleteButton.setHelpText(this.localizationTable.selectionDropdown__deleteHelpText);
        const duplicateButton = new _ActionButtonWidget_mjs__WEBPACK_IMPORTED_MODULE_5__["default"](editor, 'duplicate-btn', () => editor.icons.makeDuplicateSelectionIcon(), this.localizationTable.duplicateSelection, async () => {
            const selection = this.tool.getSelection();
            this.editor.dispatch(await selection.duplicateSelectedObjects());
            this.setDropdownVisible(false);
        }, localization);
        duplicateButton.setHelpText(this.localizationTable.selectionDropdown__duplicateHelpText);
        this.addSubWidget(resizeButton);
        this.addSubWidget(deleteButton);
        this.addSubWidget(duplicateButton);
        const updateDisabled = (disabled) => {
            resizeButton.setDisabled(disabled);
            deleteButton.setDisabled(disabled);
            duplicateButton.setDisabled(disabled);
        };
        updateDisabled(true);
        // Enable/disable actions based on whether items are selected
        this.editor.notifier.on(_types_mjs__WEBPACK_IMPORTED_MODULE_3__.EditorEventType.ToolUpdated, (toolEvt) => {
            if (toolEvt.kind !== _types_mjs__WEBPACK_IMPORTED_MODULE_3__.EditorEventType.ToolUpdated) {
                throw new Error('Invalid event type!');
            }
            if (toolEvt.tool === this.tool) {
                const selection = this.tool.getSelection();
                const hasSelection = selection && selection.getSelectedItemCount() > 0;
                updateDisabled(!hasSelection);
                this.updateFormatMenu();
            }
        });
    }
    resizeImageToSelection() {
        const selection = this.tool.getSelection();
        if (selection) {
            this.editor.dispatch(this.editor.setImportExportRect(selection.region));
        }
    }
    onKeyPress(event) {
        const shortcuts = this.editor.shortcuts;
        // Resize image to selection:
        // Other keys are handled directly by the selection tool.
        if (shortcuts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_7__.resizeImageToSelectionKeyboardShortcut, event)) {
            this.resizeImageToSelection();
            return true;
        }
        // If we didn't handle the event, allow the superclass to handle it.
        if (super.onKeyPress(event)) {
            return true;
        }
        return false;
    }
    getTitle() {
        return this.localizationTable.select;
    }
    createIcon() {
        return this.editor.icons.makeSelectionIcon();
    }
    getHelpText() {
        return this.localizationTable.selectionDropdown__baseHelpText;
    }
    fillDropdown(dropdown, helpDisplay) {
        super.fillDropdown(dropdown, helpDisplay);
        const controlsContainer = document.createElement('div');
        controlsContainer.classList.add(`${_constants_mjs__WEBPACK_IMPORTED_MODULE_9__.toolbarCSSPrefix}nonbutton-controls-main-list`);
        dropdown.appendChild(controlsContainer);
        (0,_components_makeSeparator_mjs__WEBPACK_IMPORTED_MODULE_8__["default"])(this.localizationTable.reformatSelection).addTo(controlsContainer);
        const formatMenu = makeFormatMenu(this.editor, this.tool, this.localizationTable);
        formatMenu.addTo(controlsContainer);
        this.updateFormatMenu = () => formatMenu.update();
        if (helpDisplay) {
            formatMenu.registerHelpText(helpDisplay);
        }
        formatMenu.update();
        return true;
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/widgets/TextToolWidget.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/widgets/TextToolWidget.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../types.mjs */ "./node_modules/js-draw/dist/mjs/types.mjs");
/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/constants.mjs");
/* harmony import */ var _components_makeColorInput_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/makeColorInput.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeColorInput.mjs");
/* harmony import */ var _BaseToolWidget_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BaseToolWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/BaseToolWidget.mjs");





class TextToolWidget extends _BaseToolWidget_mjs__WEBPACK_IMPORTED_MODULE_4__["default"] {
    constructor(editor, tool, localization) {
        super(editor, tool, 'text-tool-widget', localization);
        this.tool = tool;
        this.updateDropdownInputs = null;
        editor.notifier.on(_types_mjs__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.ToolUpdated, (evt) => {
            if (evt.kind === _types_mjs__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.ToolUpdated && evt.tool === tool) {
                this.updateIcon();
                this.updateDropdownInputs?.();
            }
        });
    }
    getTitle() {
        return this.targetTool.description;
    }
    createIcon() {
        const textStyle = this.tool.getTextStyle();
        return this.editor.icons.makeTextIcon(textStyle);
    }
    fillDropdown(dropdown) {
        const container = document.createElement('div');
        container.classList.add(`${_constants_mjs__WEBPACK_IMPORTED_MODULE_2__.toolbarCSSPrefix}spacedList`, `${_constants_mjs__WEBPACK_IMPORTED_MODULE_2__.toolbarCSSPrefix}nonbutton-controls-main-list`);
        const fontRow = document.createElement('div');
        const colorRow = document.createElement('div');
        const sizeRow = document.createElement('div');
        const fontInput = document.createElement('select');
        const fontLabel = document.createElement('label');
        const sizeInput = document.createElement('input');
        const sizeLabel = document.createElement('label');
        const { input: colorInput, container: colorInputContainer, setValue: setColorInputValue, } = (0,_components_makeColorInput_mjs__WEBPACK_IMPORTED_MODULE_3__["default"])(this.editor, (color) => {
            this.tool.setColor(color);
        });
        const colorLabel = document.createElement('label');
        const fontsInInput = new Set();
        const addFontToInput = (fontName) => {
            const option = document.createElement('option');
            option.value = fontName;
            option.textContent = fontName;
            fontInput.appendChild(option);
            fontsInInput.add(fontName);
        };
        sizeInput.setAttribute('type', 'number');
        sizeInput.min = '1';
        sizeInput.max = '128';
        fontLabel.innerText = this.localizationTable.fontLabel;
        colorLabel.innerText = this.localizationTable.colorLabel;
        sizeLabel.innerText = this.localizationTable.textSize;
        colorInput.id = `${_constants_mjs__WEBPACK_IMPORTED_MODULE_2__.toolbarCSSPrefix}-text-color-input-${TextToolWidget.idCounter++}`;
        colorLabel.setAttribute('for', colorInput.id);
        sizeInput.id = `${_constants_mjs__WEBPACK_IMPORTED_MODULE_2__.toolbarCSSPrefix}-text-size-input-${TextToolWidget.idCounter++}`;
        sizeLabel.setAttribute('for', sizeInput.id);
        const defaultFonts = this.editor.getCurrentSettings().text?.fonts ?? [];
        for (const font of defaultFonts) {
            addFontToInput(font);
        }
        fontInput.classList.add('font-selector');
        fontInput.id = `${_constants_mjs__WEBPACK_IMPORTED_MODULE_2__.toolbarCSSPrefix}-text-font-input-${TextToolWidget.idCounter++}`;
        fontLabel.setAttribute('for', fontInput.id);
        fontInput.onchange = () => {
            this.tool.setFontFamily(fontInput.value);
        };
        sizeInput.onchange = () => {
            const size = parseInt(sizeInput.value);
            if (!isNaN(size) && size > 0) {
                this.tool.setFontSize(size);
            }
        };
        colorRow.appendChild(colorLabel);
        colorRow.appendChild(colorInputContainer);
        fontRow.appendChild(fontLabel);
        fontRow.appendChild(fontInput);
        sizeRow.appendChild(sizeLabel);
        sizeRow.appendChild(sizeInput);
        this.updateDropdownInputs = () => {
            const style = this.tool.getTextStyle();
            setColorInputValue(style.renderingStyle.fill);
            if (!fontsInInput.has(style.fontFamily)) {
                addFontToInput(style.fontFamily);
            }
            fontInput.value = style.fontFamily;
            sizeInput.value = `${style.size}`;
        };
        this.updateDropdownInputs();
        container.replaceChildren(colorRow, sizeRow, fontRow);
        dropdown.appendChild(container);
        return true;
    }
    serializeState() {
        const textStyle = this.tool.getTextStyle();
        return {
            ...super.serializeState(),
            fontFamily: textStyle.fontFamily,
            textSize: textStyle.size,
            color: textStyle.renderingStyle.fill.toHexString(),
        };
    }
    deserializeFrom(state) {
        if (state.fontFamily && typeof state.fontFamily === 'string') {
            this.tool.setFontFamily(state.fontFamily);
        }
        if (state.color && typeof state.color === 'string') {
            this.tool.setColor(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.fromHex(state.color));
        }
        if (state.textSize && typeof state.textSize === 'number') {
            this.tool.setFontSize(state.textSize);
        }
        super.deserializeFrom(state);
    }
}
TextToolWidget.idCounter = 0;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TextToolWidget);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeColorInput.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeColorInput.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   makeColorInput: () => (/* binding */ makeColorInput)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _tools_PipetteTool_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/PipetteTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/PipetteTool.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../types.mjs */ "./node_modules/js-draw/dist/mjs/types.mjs");



// Returns [ color input, input container, callback to change the color value ].
const makeColorInput = (editor, onColorChange) => {
    const container = document.createElement('span');
    const inputWrapper = document.createElement('span');
    const colorInput = document.createElement('input');
    colorInput.type = 'button';
    colorInput.classList.add('coloris_input');
    container.classList.add('color-input-container');
    inputWrapper.classList.add('color-input-wrapper');
    inputWrapper.appendChild(colorInput);
    container.appendChild(inputWrapper);
    const pipetteController = addPipetteTool(editor, container, (color) => {
        colorInput.value = color.toHexString();
        onInputEnd();
        // Update the color preview, if it exists (may be managed by Coloris).
        const parentElem = colorInput.parentElement;
        if (parentElem && parentElem.classList.contains('clr-field')) {
            parentElem.style.color = colorInput.value;
        }
    });
    let currentColor;
    const handleColorInput = () => {
        currentColor = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.fromHex(colorInput.value);
    };
    // Only change the pen color when we finish sending input (this limits the number of
    // editor events triggered and accessibility announcements).
    const onInputEnd = () => {
        handleColorInput();
        if (currentColor) {
            editor.announceForAccessibility(editor.localization.colorChangedAnnouncement(currentColor.toHexString()));
            onColorChange(currentColor);
            editor.notifier.dispatch(_types_mjs__WEBPACK_IMPORTED_MODULE_2__.EditorEventType.ColorPickerColorSelected, {
                kind: _types_mjs__WEBPACK_IMPORTED_MODULE_2__.EditorEventType.ColorPickerColorSelected,
                color: currentColor,
            });
        }
    };
    colorInput.oninput = handleColorInput;
    let isOpen = false;
    colorInput.addEventListener('open', () => {
        isOpen = true;
        editor.notifier.dispatch(_types_mjs__WEBPACK_IMPORTED_MODULE_2__.EditorEventType.ColorPickerToggled, {
            kind: _types_mjs__WEBPACK_IMPORTED_MODULE_2__.EditorEventType.ColorPickerToggled,
            open: true,
        });
        pipetteController.cancel();
        container.classList.add('picker-open');
        // Focus the Coloris color picker, if it exists.
        // Don't focus the text input within the color picker, however,
        // as this displays a keyboard on mobile devices.
        const colorPickerElem = document.querySelector('#clr-picker #clr-hue-slider');
        colorPickerElem?.focus();
    });
    const onClose = () => {
        isOpen = false;
        editor.notifier.dispatch(_types_mjs__WEBPACK_IMPORTED_MODULE_2__.EditorEventType.ColorPickerToggled, {
            kind: _types_mjs__WEBPACK_IMPORTED_MODULE_2__.EditorEventType.ColorPickerToggled,
            open: false,
        });
        onInputEnd();
        // Restore focus to the input that opened the color picker
        colorInput.focus();
        container.classList.remove('picker-open');
    };
    colorInput.addEventListener('close', () => {
        onClose();
    });
    const setColorInputValue = (color) => {
        if (typeof color === 'object') {
            color = color.toHexString();
        }
        colorInput.value = color;
        // Fire all color event listeners. See
        // https://github.com/mdbassit/Coloris#manually-updating-the-thumbnail
        colorInput.dispatchEvent(new Event('input', { bubbles: true }));
    };
    return {
        input: colorInput,
        container,
        setValue: setColorInputValue,
        closePicker: () => {
            if (isOpen) {
                onInputEnd();
            }
        },
        registerWithHelpTextDisplay: (helpDisplay) => {
            helpDisplay.registerTextHelpForElement(inputWrapper, editor.localization.colorPickerToggleHelpText);
            pipetteController.registerWithHelpTextDisplay(helpDisplay);
        },
    };
};
const addPipetteTool = (editor, container, onColorChange) => {
    const pipetteButton = document.createElement('button');
    pipetteButton.classList.add('pipetteButton');
    pipetteButton.title = editor.localization.pickColorFromScreen;
    pipetteButton.setAttribute('alt', pipetteButton.title);
    const pickColorLabel = document.createElement('span');
    pickColorLabel.classList.add('pickColorInstructions');
    pickColorLabel.innerText = editor.localization.clickToPickColorAnnouncement;
    const updatePipetteButtonContent = (color) => {
        pipetteButton.replaceChildren(editor.icons.makePipetteIcon(color), pickColorLabel);
    };
    updatePipetteButtonContent();
    const pipetteTool = editor.toolController.getMatchingTools(_tools_PipetteTool_mjs__WEBPACK_IMPORTED_MODULE_1__["default"])[0];
    const endColorSelectMode = () => {
        pipetteTool?.clearColorListener();
        updatePipetteButtonContent();
        pipetteButton.classList.remove('active');
    };
    const pipetteColorSelect = (color) => {
        endColorSelectMode();
        if (color) {
            onColorChange(color);
        }
    };
    const pipetteColorPreview = (color) => {
        if (color) {
            updatePipetteButtonContent(color);
        }
        else {
            updatePipetteButtonContent();
        }
    };
    pipetteButton.onclick = () => {
        // If already picking, cancel it.
        if (pipetteButton.classList.contains('active')) {
            endColorSelectMode();
            editor.announceForAccessibility(editor.localization.colorSelectionCanceledAnnouncement);
            return;
        }
        pipetteTool?.setColorListener(pipetteColorPreview, pipetteColorSelect);
        if (pipetteTool) {
            pipetteButton.classList.add('active');
            editor.announceForAccessibility(editor.localization.clickToPickColorAnnouncement);
        }
    };
    container.appendChild(pipetteButton);
    return {
        // Cancel a pipette color selection if one is in progress.
        cancel: () => {
            endColorSelectMode();
        },
        registerWithHelpTextDisplay: (helpDisplay) => {
            helpDisplay.registerTextHelpForElement(pipetteButton, editor.localization.colorPickerPipetteHelpText);
        },
    };
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (makeColorInput);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeFileInput.mjs":
/*!************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeFileInput.mjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/ReactiveValue.mjs */ "./node_modules/js-draw/dist/mjs/util/ReactiveValue.mjs");

let idCounter = 0;
/**
 * Creates a stylized file input. This file input can either use the system file picker, or a custom
 * one specified by `customPickerAction`.
 */
const makeFileInput = (labelText, context, { accepts = '*', allowMultiSelect = false, customPickerAction } = {}) => {
    const container = document.createElement('div');
    const label = document.createElement('label');
    const input = document.createElement('input');
    const descriptionBox = document.createElement('div');
    descriptionBox.classList.add('toolbar--file-input-description');
    const descriptionText = document.createElement('span');
    container.classList.add('toolbar--file-input-container');
    label.appendChild(document.createTextNode(labelText));
    input.accept = accepts;
    input.type = customPickerAction ? 'button' : 'file';
    input.classList.add('file-input');
    input.multiple = allowMultiSelect;
    // Associate the label with the input
    const inputId = `js-draw-file-input-${idCounter++}`;
    input.setAttribute('id', inputId);
    label.htmlFor = inputId;
    const icon = context.icons.makeUploadFileIcon();
    icon.classList.add('icon');
    descriptionBox.replaceChildren(icon, descriptionText);
    label.appendChild(descriptionBox);
    container.replaceChildren(label, input);
    const selectedFiles = _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].fromInitialValue([]);
    let loading = false;
    let cancelLoading = null;
    const updateStatusText = () => {
        const files = selectedFiles.get();
        if (loading) {
            descriptionText.textContent = context.localization.fileInput__loading;
            if (cancelLoading) {
                const cancelText = document.createElement('b');
                cancelText.textContent = context.localization.cancel;
                cancelText.classList.add('cancel-button');
                descriptionText.appendChild(cancelText);
            }
            icon.style.display = 'none';
        }
        else if (files.length > 0) {
            const fileNames = files.map((file) => file.name);
            const maxNames = 5;
            if (fileNames.length <= maxNames) {
                descriptionText.textContent = fileNames.join('\n');
            }
            else {
                const fileNamesToShow = fileNames.slice(0, maxNames - 1);
                descriptionText.textContent = [
                    ...fileNamesToShow,
                    context.localization.fileInput__andNMoreFiles(fileNames.length - fileNamesToShow.length),
                ].join('\n');
            }
            // Only show the icon when there are files
            icon.style.display = 'none';
        }
        else {
            // Show the icon
            icon.style.display = '';
            const text = context.localization.dragAndDropHereOrBrowse;
            // Split into regions surrounded by {{curly braces}} and regions that are
            // not.
            // When given a regular expression, `.split` outputs an array. For example,
            //    "a test __of__ split".split(/__(.*)__/)
            // results in
            //    ['a test ', 'of', ' split'].
            const segments = text.split(/[{]{2}(.*)[}]{2}/g);
            descriptionText.replaceChildren();
            for (let i = 0; i < segments.length; i++) {
                // Inside a {{pair of curly braces}}?
                if (i % 2 === 1) {
                    const boldedText = document.createElement('b');
                    boldedText.textContent = segments[i];
                    descriptionText.appendChild(boldedText);
                }
                else {
                    descriptionText.appendChild(document.createTextNode(segments[i]));
                }
            }
        }
    };
    const addFileEventListeners = () => {
        // Support dropping files
        label.addEventListener('dragover', (event) => {
            event.preventDefault();
            label.classList.add('drag-target');
        });
        label.addEventListener('dragenter', (event) => {
            event.preventDefault();
            label.classList.add('drag-target');
        });
        label.addEventListener('dragleave', (event) => {
            event.preventDefault();
            // Ensure the event wasn't targeting a child.
            // See https://stackoverflow.com/a/54271161 and
            //     https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/relatedTarget
            const enteringElement = event.relatedTarget;
            if (!enteringElement || !label.contains(enteringElement)) {
                label.classList.remove('drag-target');
            }
        });
        // See https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/File_drag_and_drop#process_the_drop
        label.addEventListener('drop', (event) => {
            event.preventDefault();
            label.classList.remove('drag-target');
            const fileList = [];
            if (event.dataTransfer) {
                fileList.push(...event.dataTransfer.files);
            }
            selectedFiles.set(fileList);
        });
        input.addEventListener('change', () => {
            const fileList = input.files ?? [];
            selectedFiles.set([...fileList]);
        });
    };
    addFileEventListeners();
    // Support for custom file pickers
    if (customPickerAction) {
        const promptForFiles = async () => {
            if (loading) {
                cancelLoading?.();
                return;
            }
            container.classList.add('-loading');
            loading = true;
            updateStatusText();
            try {
                const data = await customPickerAction({
                    setOnCancelCallback: (onCancel) => {
                        if (!loading) {
                            throw new Error("Task already completed. Can't register cancel handler.");
                        }
                        cancelLoading = () => {
                            cancelLoading = null;
                            updateStatusText();
                            onCancel();
                        };
                        updateStatusText();
                    },
                });
                if (data) {
                    selectedFiles.set(data);
                }
            }
            finally {
                container.classList.remove('-loading');
                loading = false;
                updateStatusText();
            }
        };
        input.onclick = promptForFiles;
    }
    selectedFiles.onUpdate((files) => {
        if (files.length === 0 && input.files && input.files.length > 0) {
            input.value = '';
        }
        cancelLoading?.();
    });
    // Update the status text and hide/show the icon.
    selectedFiles.onUpdateAndNow(updateStatusText);
    return {
        container,
        input,
        selectedFiles,
        addTo: (parent) => {
            parent.appendChild(container);
        },
    };
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (makeFileInput);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeGridSelector.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeGridSelector.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/ReactiveValue.mjs */ "./node_modules/js-draw/dist/mjs/util/ReactiveValue.mjs");
/* harmony import */ var _util_stopPropagationOfScrollingWheelEvents_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/stopPropagationOfScrollingWheelEvents.mjs */ "./node_modules/js-draw/dist/mjs/util/stopPropagationOfScrollingWheelEvents.mjs");
/* harmony import */ var _util_addLongPressOrHoverCssClasses_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/addLongPressOrHoverCssClasses.mjs */ "./node_modules/js-draw/dist/mjs/util/addLongPressOrHoverCssClasses.mjs");
/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../constants.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/constants.mjs");




let idCounter = 0;
/**
 * Creates a widget that allows users to select one of serveral items from a list.
 *
 * `ChoiceIdType` should be `string`, a `number`, or an `enum` (or similar).
 *
 * If this input is set to an ID that is not in `choices`, no item is selected.
 */
const makeGridSelector = (
// Text before the grid selector used as a label
labelText, defaultId, choices) => {
    const outerContainer = document.createElement('div');
    outerContainer.classList.add(`${_constants_mjs__WEBPACK_IMPORTED_MODULE_3__.toolbarCSSPrefix}grid-selector`);
    const selectedValue = _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_0__.MutableReactiveValue.fromInitialValue(defaultId);
    const menuContainer = document.createElement('div');
    menuContainer.setAttribute('role', 'menu');
    menuContainer.id = `${_constants_mjs__WEBPACK_IMPORTED_MODULE_3__.toolbarCSSPrefix}-grid-select-id-${idCounter++}`;
    (0,_util_stopPropagationOfScrollingWheelEvents_mjs__WEBPACK_IMPORTED_MODULE_1__["default"])(menuContainer);
    const label = document.createElement('label');
    label.textContent = labelText;
    label.htmlFor = menuContainer.id;
    outerContainer.appendChild(label);
    // All buttons in a radiogroup need the same name attribute.
    let radiogroupName = `${_constants_mjs__WEBPACK_IMPORTED_MODULE_3__.toolbarCSSPrefix}-grid-selector-${idCounter++}`;
    const createChoiceButton = (record) => {
        const buttonContainer = document.createElement('div');
        buttonContainer.classList.add('choice-button');
        const button = document.createElement('input');
        button.type = 'radio';
        button.id = `${_constants_mjs__WEBPACK_IMPORTED_MODULE_3__.toolbarCSSPrefix}-grid-select-button-${idCounter++}`;
        // Some toolbars only show the label on hover. Having long press or hover
        // CSS classes are helpful here.
        (0,_util_addLongPressOrHoverCssClasses_mjs__WEBPACK_IMPORTED_MODULE_2__["default"])(buttonContainer);
        // Clicking any part of labelContainer triggers the radio button.
        const labelContainer = document.createElement('label');
        const rebuildLabel = () => {
            labelContainer.setAttribute('title', record.title);
            const labelText = document.createElement('span');
            labelText.classList.add('button-label-text');
            const icon = record.makeIcon();
            icon.classList.add('icon');
            // The title of the record
            labelText.innerText = record.title;
            labelContainer.htmlFor = button.id;
            labelContainer.replaceChildren(icon, labelText);
        };
        rebuildLabel();
        // Mark the button as belonging to the current group (causes
        // other buttons in the same group to automatically uncheck
        // when this button is checked).
        const updateButtonRadiogroupName = () => {
            button.name = radiogroupName;
        };
        updateButtonRadiogroupName();
        const updateButtonCSS = () => {
            if (button.checked) {
                buttonContainer.classList.add('checked');
            }
            else {
                buttonContainer.classList.remove('checked');
            }
        };
        button.oninput = () => {
            // Setting the selected value fires an event that causes the value
            // of this button to be set.
            if (button.checked) {
                selectedValue.set(record.id);
            }
            updateButtonCSS();
        };
        button.onfocus = () => {
            if (buttonContainer.querySelector(':focus-visible')) {
                buttonContainer.classList.add('focus-visible');
            }
        };
        button.onblur = () => {
            buttonContainer.classList.remove('focus-visible');
        };
        // Prevent the right-click menu from being shown on long-press
        // (important for some toolbars that use long-press gestures to
        // show grid selector labels).
        buttonContainer.oncontextmenu = (event) => {
            event.preventDefault();
        };
        buttonContainer.replaceChildren(button, labelContainer);
        menuContainer.appendChild(buttonContainer);
        // Set whether the current button is checked
        const setChecked = (checked) => {
            button.checked = checked;
            updateButtonCSS();
        };
        setChecked(false);
        // Updates the factory's icon based on the current style of the tool.
        const updateIcon = () => {
            rebuildLabel();
        };
        return {
            choiceRecord: record,
            setChecked,
            updateIcon,
            updateButtonRadiogroupName,
        };
    };
    const buttons = [];
    for (const choice of choices) {
        buttons.push(createChoiceButton(choice));
    }
    // invariant: buttons.length = choices.length
    // However, it is still possible that selectedValue does not correspond
    // to a choice in `choices`. This is acceptable.
    outerContainer.appendChild(menuContainer);
    selectedValue.onUpdateAndNow((choiceId) => {
        for (let i = 0; i < buttons.length; i++) {
            buttons[i].setChecked(buttons[i].choiceRecord.id === choiceId);
        }
    });
    const result = {
        value: selectedValue,
        _radiogroupName: radiogroupName,
        linkWith: (other) => {
            result._radiogroupName = other._radiogroupName;
            radiogroupName = other._radiogroupName;
            for (const button of buttons) {
                button.updateButtonRadiogroupName();
            }
        },
        updateIcons: () => {
            buttons.forEach((button) => button.updateIcon());
        },
        getRootElement() {
            return outerContainer;
        },
        addTo: (parent) => {
            parent.appendChild(outerContainer);
        },
    };
    return result;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (makeGridSelector);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeSeparator.mjs":
/*!************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeSeparator.mjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Creates a separator element that renders a line and, optionally, a header.
 */
const makeSeparator = (header = '') => {
    const container = document.createElement('div');
    container.classList.add('tool-dropdown-separator');
    container.innerText = header;
    return {
        addTo: (parent) => {
            parent.appendChild(container);
        },
    };
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (makeSeparator);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeSnappedList.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeSnappedList.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_stopPropagationOfScrollingWheelEvents_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/stopPropagationOfScrollingWheelEvents.mjs */ "./node_modules/js-draw/dist/mjs/util/stopPropagationOfScrollingWheelEvents.mjs");
/* harmony import */ var _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/ReactiveValue.mjs */ "./node_modules/js-draw/dist/mjs/util/ReactiveValue.mjs");


/**
 * Creates a list that snaps to each item and reports the selected item.
 */
const makeSnappedList = (itemsValue) => {
    const container = document.createElement('div');
    container.classList.add('toolbar-snapped-scroll-list');
    const scroller = document.createElement('div');
    scroller.classList.add('scroller');
    const visibleIndex = _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_1__.MutableReactiveValue.fromInitialValue(0);
    let observer = null;
    const makePageMarkers = () => {
        const markerContainer = document.createElement('div');
        markerContainer.classList.add('page-markers');
        // Keyboard focus should go to the main scrolling list.
        // TODO: Does it make sense for the page marker list to be focusable?
        markerContainer.setAttribute('tabindex', '-1');
        const markers = [];
        const pairedItems = _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_1__.ReactiveValue.union([
            visibleIndex,
            itemsValue,
        ]);
        pairedItems.onUpdateAndNow(([currentVisibleIndex, items]) => {
            let addedOrRemovedMarkers = false;
            // Items may have been removed from the list of pages. Make the markers reflect that.
            while (items.length < markers.length) {
                markers.pop();
                addedOrRemovedMarkers = true;
            }
            let activeMarker;
            for (let i = 0; i < items.length; i++) {
                let marker;
                if (i >= markers.length) {
                    marker = document.createElement('div');
                    // Use a separate content element to increase the clickable size of
                    // the marker.
                    const content = document.createElement('div');
                    content.classList.add('content');
                    marker.replaceChildren(content);
                    markers.push(marker);
                    addedOrRemovedMarkers = true;
                }
                else {
                    marker = markers[i];
                }
                marker.classList.add('marker');
                if (i === currentVisibleIndex) {
                    marker.classList.add('-active');
                    activeMarker = marker;
                }
                else {
                    marker.classList.remove('-active');
                }
                const markerIndex = i;
                marker.onclick = () => {
                    wrappedItems
                        .get()[markerIndex]?.element?.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                };
            }
            // Only call .replaceChildren when necessary -- doing so on every change would
            // break transitions.
            if (addedOrRemovedMarkers) {
                markerContainer.replaceChildren(...markers);
            }
            // Handles the case where there are many markers and the current is offscreen
            if (activeMarker && markerContainer.scrollHeight > container.clientHeight) {
                activeMarker.scrollIntoView({ block: 'nearest' });
            }
            if (markers.length === 1) {
                markerContainer.classList.add('-one-element');
            }
            else {
                markerContainer.classList.remove('-one-element');
            }
        });
        return markerContainer;
    };
    const createObserver = () => {
        observer = new IntersectionObserver((entries) => {
            for (const entry of entries) {
                if (entry.isIntersecting && entry.intersectionRatio > 0.7) {
                    const indexString = entry.target.getAttribute('data-item-index');
                    if (indexString === null)
                        throw new Error('Could not find attribute data-item-index');
                    const index = Number(indexString);
                    visibleIndex.set(index);
                    break;
                }
            }
        }, {
            // Element to use as the boudning box with which to intersect.
            // See https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
            root: scroller,
            // Fraction of an element that must be visible to trigger the callback:
            threshold: 0.9,
        });
    };
    const destroyObserver = () => {
        if (observer) {
            observer.disconnect();
            visibleIndex.set(0);
            observer = null;
        }
    };
    const wrappedItems = _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_1__.ReactiveValue.map(itemsValue, (items) => {
        return items.map((item, index) => {
            const wrapper = document.createElement('div');
            if (item.element.parentElement)
                item.element.remove();
            wrapper.appendChild(item.element);
            wrapper.classList.add('item');
            wrapper.setAttribute('data-item-index', `${index}`);
            return {
                element: wrapper,
                data: item.data,
            };
        });
    });
    const lastItems = [];
    wrappedItems.onUpdateAndNow((items) => {
        visibleIndex.set(-1);
        for (const item of lastItems) {
            observer?.unobserve(item.element);
        }
        scroller.replaceChildren();
        // An observer is only necessary if there are multiple items to scroll through.
        if (items.length > 1) {
            createObserver();
        }
        else {
            destroyObserver();
        }
        // Different styling is applied when empty
        if (items.length === 0) {
            container.classList.add('-empty');
        }
        else {
            container.classList.remove('-empty');
        }
        for (const item of items) {
            scroller.appendChild(item.element);
        }
        visibleIndex.set(0);
        if (observer) {
            for (const item of items) {
                observer.observe(item.element);
            }
        }
    });
    const visibleItem = _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_1__.ReactiveValue.map(visibleIndex, (index) => {
        const values = itemsValue.get();
        if (0 <= index && index < values.length) {
            return values[index].data;
        }
        return null;
    });
    // makeSnappedList is generally shown within the toolbar. This allows users to
    // scroll it with a touchpad.
    (0,_util_stopPropagationOfScrollingWheelEvents_mjs__WEBPACK_IMPORTED_MODULE_0__["default"])(scroller);
    container.replaceChildren(makePageMarkers(), scroller);
    return {
        container,
        visibleItem,
    };
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (makeSnappedList);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeThicknessSlider.mjs":
/*!******************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeThicknessSlider.mjs ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/constants.mjs");


let idCounter = 0;
const makeThicknessSlider = (context, onChange) => {
    const container = document.createElement('div');
    const thicknessLabel = document.createElement('label');
    const thicknessInput = document.createElement('input');
    container.classList.add(`${_constants_mjs__WEBPACK_IMPORTED_MODULE_1__.toolbarCSSPrefix}thicknessSliderContainer`);
    // Give inputs IDs so we can label them with a <label for=...>Label text</label>
    thicknessInput.id = `${_constants_mjs__WEBPACK_IMPORTED_MODULE_1__.toolbarCSSPrefix}thicknessInput${idCounter++}`;
    thicknessLabel.innerText = context.localization.thicknessLabel;
    thicknessLabel.setAttribute('for', thicknessInput.id);
    // Use a logarithmic scale for thicknessInput (finer control over thinner strokewidths.)
    const inverseThicknessInputFn = (t) => Math.log10(t);
    const thicknessInputFn = (t) => 10 ** t;
    thicknessInput.type = 'range';
    thicknessInput.oninput = () => {
        onChange(thicknessInputFn(parseFloat(thicknessInput.value)));
    };
    container.appendChild(thicknessLabel);
    container.appendChild(thicknessInput);
    const setBounds = (min, max) => {
        const round = (value, roundUp) => {
            const roundFn = roundUp ? Math.ceil : Math.floor;
            return roundFn(value * 100) / 100;
        };
        const sliderMin = round(inverseThicknessInputFn(min), false);
        const sliderMax = round(inverseThicknessInputFn(max), true);
        thicknessInput.min = `${sliderMin}`;
        thicknessInput.max = `${sliderMax}`;
        thicknessInput.step = `${(0,_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.toRoundedString)((sliderMax - sliderMin) / 20)}`;
    };
    setBounds(2, 262);
    return {
        container,
        addTo: (parent) => {
            parent.appendChild(container);
        },
        setBounds,
        setValue: (thickness) => {
            thicknessInput.value = inverseThicknessInputFn(thickness).toString();
        },
    };
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (makeThicknessSlider);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/widgets/keybindings.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/widgets/keybindings.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   exitKeyboardShortcut: () => (/* binding */ exitKeyboardShortcut),
/* harmony export */   resizeImageToSelectionKeyboardShortcut: () => (/* binding */ resizeImageToSelectionKeyboardShortcut),
/* harmony export */   saveKeyboardShortcut: () => (/* binding */ saveKeyboardShortcut),
/* harmony export */   selectStrokeTypeKeyboardShortcutIds: () => (/* binding */ selectStrokeTypeKeyboardShortcutIds)
/* harmony export */ });
/* harmony import */ var _shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shortcuts/KeyboardShortcutManager.mjs */ "./node_modules/js-draw/dist/mjs/shortcuts/KeyboardShortcutManager.mjs");

// Selection
const resizeImageToSelectionKeyboardShortcut = 'jsdraw.toolbar.SelectionTool.resizeImageToSelection';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(resizeImageToSelectionKeyboardShortcut, ['ctrlOrMeta+r'], 'Resize image to selection');
// Pen tool
const selectStrokeTypeKeyboardShortcutIds = [1, 2, 3, 4, 5, 6, 7, 8, 9].map((id) => `jsdraw.toolbar.PenTool.select-pen-${id}`);
for (let i = 0; i < selectStrokeTypeKeyboardShortcutIds.length; i++) {
    const id = selectStrokeTypeKeyboardShortcutIds[i];
    _shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(id, [`CtrlOrMeta+Digit${i + 1}`], 'Select pen style ' + (i + 1));
}
// Save
const saveKeyboardShortcut = 'jsdraw.toolbar.SaveActionWidget.save';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(saveKeyboardShortcut, ['ctrlOrMeta+KeyS'], 'Save');
// Exit
const exitKeyboardShortcut = 'jsdraw.toolbar.ExitActionWidget.exit';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(exitKeyboardShortcut, ['Alt+KeyQ'], 'Exit');


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/widgets/layout/DropdownLayoutManager.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/widgets/layout/DropdownLayoutManager.mjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DropdownLayoutManager)
/* harmony export */ });
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../types.mjs */ "./node_modules/js-draw/dist/mjs/types.mjs");
/* harmony import */ var _EventDispatcher_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../EventDispatcher.mjs */ "./node_modules/js-draw/dist/mjs/EventDispatcher.mjs");
/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../constants.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/constants.mjs");
/* harmony import */ var _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../util/ReactiveValue.mjs */ "./node_modules/js-draw/dist/mjs/util/ReactiveValue.mjs");




var DropdownEventType;
(function (DropdownEventType) {
    DropdownEventType[DropdownEventType["DropdownShown"] = 0] = "DropdownShown";
    DropdownEventType[DropdownEventType["DropdownHidden"] = 1] = "DropdownHidden";
})(DropdownEventType || (DropdownEventType = {}));
class Dropdown {
    constructor(parent, notifier, onDestroy) {
        this.parent = parent;
        this.notifier = notifier;
        this.onDestroy = onDestroy;
        this.dropdownToggleListener = null;
        this.hideDropdownTimeout = null;
        this.visible = _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_3__.ReactiveValue.fromInitialValue(false);
        this.dropdownContainer = document.createElement('div');
        this.dropdownContainer.classList.add(`${_constants_mjs__WEBPACK_IMPORTED_MODULE_2__.toolbarCSSPrefix}dropdown`);
        this.dropdownContainer.classList.add('hidden');
        parent.target.insertAdjacentElement('afterend', this.dropdownContainer);
        // When another dropdown is shown,
        this.dropdownToggleListener = this.notifier.on(DropdownEventType.DropdownShown, (evt) => {
            if (evt.dropdown !== this &&
                // Don't hide if a submenu was shown (it might be a submenu of
                // the current menu).
                evt.fromToplevelDropdown) {
                this.setVisible(false);
            }
        });
    }
    onActivated() {
        // Do nothing.
    }
    repositionDropdown() {
        const dropdownBBox = this.dropdownContainer.getBoundingClientRect();
        const screenWidth = document.scrollingElement?.clientWidth ?? document.body.clientHeight;
        const screenHeight = document.scrollingElement?.clientHeight ?? document.body.clientHeight;
        let translateX = undefined;
        let translateY = undefined;
        if (dropdownBBox.left > screenWidth / 2) {
            const targetElem = this.parent.target;
            translateX = `calc(${targetElem.clientWidth + 'px'} - 100%)`;
        }
        // Shift the dropdown if it's off the screen, but only if doing so moves it on to the screen
        // (prevents dropdowns from going almost completely offscreen on small screens).
        if (dropdownBBox.bottom > screenHeight && dropdownBBox.top - dropdownBBox.height > 0) {
            const targetElem = this.parent.target;
            translateY = `calc(-${targetElem.clientHeight}px - 100%)`;
        }
        // Use .translate so as not to conflict with CSS animating the
        // transform property.
        if (translateX || translateY) {
            this.dropdownContainer.style.translate = `${translateX ?? '0'} ${translateY ?? '0'}`;
        }
        else {
            this.dropdownContainer.style.translate = '';
        }
    }
    setVisible(visible) {
        const currentlyVisible = this.visible.get();
        if (currentlyVisible === visible) {
            return;
        }
        // If waiting to hide the dropdown, cancel it.
        if (this.hideDropdownTimeout) {
            clearTimeout(this.hideDropdownTimeout);
            this.hideDropdownTimeout = null;
            this.dropdownContainer.classList.remove('hiding');
            this.repositionDropdown();
        }
        const animationDuration = 150; // ms
        this.visible.set(visible);
        if (visible) {
            this.dropdownContainer.classList.remove('hidden');
            this.notifier.dispatch(DropdownEventType.DropdownShown, {
                dropdown: this,
                fromToplevelDropdown: this.parent.isToplevel(),
            });
            this.repositionDropdown();
        }
        else {
            this.notifier.dispatch(DropdownEventType.DropdownHidden, {
                dropdown: this,
                fromToplevelDropdown: this.parent.isToplevel(),
            });
            this.dropdownContainer.classList.add('hiding');
            // Hide the dropdown *slightly* before the animation finishes. This
            // prevents flickering in some browsers.
            const hideDelay = animationDuration * 0.95;
            this.hideDropdownTimeout = setTimeout(() => {
                this.dropdownContainer.classList.add('hidden');
                this.dropdownContainer.classList.remove('hiding');
                this.repositionDropdown();
            }, hideDelay);
        }
        // Animate
        const animationName = `var(--dropdown-${visible ? 'show' : 'hide'}-animation)`;
        this.dropdownContainer.style.animation = `${animationDuration}ms ease ${animationName}`;
    }
    requestShow() {
        this.setVisible(true);
    }
    requestHide() {
        this.setVisible(false);
    }
    appendChild(item) {
        this.dropdownContainer.appendChild(item);
    }
    clearChildren() {
        this.dropdownContainer.replaceChildren();
    }
    destroy() {
        this.setVisible(false);
        this.dropdownContainer.remove();
        this.dropdownToggleListener?.remove();
        // Allow children to be added to other parents
        this.clearChildren();
        this.onDestroy();
    }
}
class DropdownLayoutManager {
    constructor(announceForAccessibility, localization) {
        this.localization = localization;
        this.dropdowns = new Set();
        this.listeners = [];
        this.connectedNotifiers = [];
        this.notifier = new _EventDispatcher_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]();
        this.notifier.on(DropdownEventType.DropdownShown, ({ dropdown, fromToplevelDropdown }) => {
            if (!dropdown)
                return;
            announceForAccessibility(this.localization.dropdownShown(dropdown.parent.getTitle()));
            // Share the event with other connected notifiers
            this.connectedNotifiers.forEach((notifier) => {
                notifier.dispatch(_types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ToolbarDropdownShown, {
                    kind: _types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ToolbarDropdownShown,
                    fromToplevelDropdown,
                    layoutManager: this,
                });
            });
        });
        this.notifier.on(DropdownEventType.DropdownHidden, ({ dropdown }) => {
            if (!dropdown)
                return;
            announceForAccessibility(this.localization.dropdownHidden(dropdown.parent.getTitle()));
        });
    }
    connectToEditorNotifier(notifier) {
        this.connectedNotifiers.push(notifier);
        this.refreshListeners();
    }
    /** Creates a dropdown within `parent`. */
    createToolMenu(parent) {
        const dropdown = new Dropdown(parent, this.notifier, () => {
            this.dropdowns.delete(dropdown);
            this.refreshListeners();
        });
        this.dropdowns.add(dropdown);
        this.refreshListeners();
        return dropdown;
    }
    /**
     * Adds/removes listeners based on whether we have any managed dropdowns.
     *
     * We attempt to clean up all resources when `dropdowns.size == 0`, at which
     * point, an instance of this could be safely garbage collected.
     */
    refreshListeners() {
        const clearListeners = () => {
            // Remove all listeners & resources that won't be garbage collected.
            this.listeners.forEach((l) => l.remove());
            this.listeners = [];
        };
        if (this.dropdowns.size === 0) {
            clearListeners();
        }
        else if (this.listeners.length !== this.connectedNotifiers.length) {
            clearListeners();
            this.listeners = this.connectedNotifiers.map((notifier) => {
                return notifier.on(_types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ToolbarDropdownShown, (evt) => {
                    if (evt.kind !== _types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ToolbarDropdownShown ||
                        // Don't forward to ourselves events that we originally triggered.
                        evt.layoutManager === this) {
                        return;
                    }
                    this.notifier.dispatch(DropdownEventType.DropdownShown, {
                        fromToplevelDropdown: evt.fromToplevelDropdown,
                    });
                });
            });
        }
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/widgets/layout/EdgeToolbarLayoutManager.mjs":
/*!*******************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/widgets/layout/EdgeToolbarLayoutManager.mjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EdgeToolbarLayoutManager)
/* harmony export */ });
/* harmony import */ var _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/ReactiveValue.mjs */ "./node_modules/js-draw/dist/mjs/util/ReactiveValue.mjs");

class EdgeToolbarLayoutManager {
    // @internal
    constructor(setSidebarContent, sidebarTitle, sidebarVisibility, announceForAccessibility, localization) {
        this.setSidebarContent = setSidebarContent;
        this.sidebarTitle = sidebarTitle;
        this.sidebarVisibility = sidebarVisibility;
        this.announceForAccessibility = announceForAccessibility;
        this.localization = localization;
        this.visibleWidgetContent = _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_0__.ReactiveValue.fromInitialValue(null);
    }
    /** Creates a dropdown within `parent`. */
    createToolMenu(parent) {
        const contentElem = document.createElement('div');
        let result = null;
        const visible = _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_0__.ReactiveValue.fromCallback(() => {
            return this.visibleWidgetContent.get() === result && this.sidebarVisibility.get();
        }, [this.visibleWidgetContent, this.sidebarVisibility]);
        result = {
            visible,
            requestShow: () => {
                this.setSidebarContent(contentElem);
                this.sidebarTitle.set(parent.getTitle());
                // Set visibleWidgetContent first -- this causes the previously visible (if any)
                // item to not be sent a shown event.
                this.visibleWidgetContent.set(result);
                this.sidebarVisibility.set(true);
                this.announceForAccessibility(this.localization.dropdownShown(parent.getTitle()));
            },
            onActivated: () => {
                // TODO: Only request show when in sidebar mode
                //result?.requestShow();
            },
            requestHide: () => {
                if (visible.get()) {
                    this.sidebarVisibility.set(false);
                }
            },
            appendChild: (item) => {
                contentElem.appendChild(item);
            },
            clearChildren: () => {
                contentElem.replaceChildren();
            },
            destroy: () => {
                result?.requestHide();
                if (contentElem.parentElement) {
                    contentElem.remove();
                }
                if (this.visibleWidgetContent.get() === result) {
                    this.visibleWidgetContent.set(null);
                }
            },
        };
        return result;
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/toolbar/widgets/lib.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/toolbar/widgets/lib.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ActionButtonWidget: () => (/* reexport safe */ _ActionButtonWidget_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   BaseToolWidget: () => (/* reexport safe */ _BaseToolWidget_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   BaseWidget: () => (/* reexport safe */ _BaseWidget_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   DocumentPropertiesWidget: () => (/* reexport safe */ _DocumentPropertiesWidget_mjs__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   EraserToolWidget: () => (/* reexport safe */ _EraserToolWidget_mjs__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   HandToolWidget: () => (/* reexport safe */ _HandToolWidget_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   InsertImageWidget: () => (/* reexport safe */ _InsertImageWidget_InsertImageWidget_mjs__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   PenToolWidget: () => (/* reexport safe */ _PenToolWidget_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   SelectionToolWidget: () => (/* reexport safe */ _SelectionToolWidget_mjs__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   TextToolWidget: () => (/* reexport safe */ _TextToolWidget_mjs__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   ToolbarWidgetTag: () => (/* reexport safe */ _BaseWidget_mjs__WEBPACK_IMPORTED_MODULE_2__.ToolbarWidgetTag)
/* harmony export */ });
/* harmony import */ var _ActionButtonWidget_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ActionButtonWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/ActionButtonWidget.mjs");
/* harmony import */ var _BaseToolWidget_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseToolWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/BaseToolWidget.mjs");
/* harmony import */ var _BaseWidget_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/BaseWidget.mjs");
/* harmony import */ var _PenToolWidget_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PenToolWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/PenToolWidget.mjs");
/* harmony import */ var _TextToolWidget_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TextToolWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/TextToolWidget.mjs");
/* harmony import */ var _HandToolWidget_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./HandToolWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/HandToolWidget.mjs");
/* harmony import */ var _SelectionToolWidget_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./SelectionToolWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/SelectionToolWidget.mjs");
/* harmony import */ var _EraserToolWidget_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./EraserToolWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/EraserToolWidget.mjs");
/* harmony import */ var _InsertImageWidget_InsertImageWidget_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./InsertImageWidget/InsertImageWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/InsertImageWidget/InsertImageWidget.mjs");
/* harmony import */ var _DocumentPropertiesWidget_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./DocumentPropertiesWidget.mjs */ "./node_modules/js-draw/dist/mjs/toolbar/widgets/DocumentPropertiesWidget.mjs");












/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/BaseTool.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/BaseTool.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types.mjs */ "./node_modules/js-draw/dist/mjs/types.mjs");
/* harmony import */ var _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../inputEvents.mjs */ "./node_modules/js-draw/dist/mjs/inputEvents.mjs");
/* harmony import */ var _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/ReactiveValue.mjs */ "./node_modules/js-draw/dist/mjs/util/ReactiveValue.mjs");
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BaseTool_enabled, _BaseTool_group, _BaseTool_inputMapper, _BaseTool_readOnlyEditorChangeListener;



class BaseTool {
    constructor(notifier, description) {
        this.notifier = notifier;
        this.description = description;
        _BaseTool_enabled.set(this, void 0);
        _BaseTool_group.set(this, null);
        _BaseTool_inputMapper.set(this, null);
        _BaseTool_readOnlyEditorChangeListener.set(this, null);
        __classPrivateFieldSet(this, _BaseTool_enabled, _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_2__.ReactiveValue.fromInitialValue(true), "f");
        __classPrivateFieldGet(this, _BaseTool_enabled, "f").onUpdate((enabled) => {
            // Ensure that at most one tool in the group is enabled.
            if (enabled) {
                __classPrivateFieldGet(this, _BaseTool_group, "f")?.notifyEnabled(this);
                this.notifier.dispatch(_types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ToolEnabled, {
                    kind: _types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ToolEnabled,
                    tool: this,
                });
            }
            else {
                this.notifier.dispatch(_types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ToolDisabled, {
                    kind: _types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ToolDisabled,
                    tool: this,
                });
            }
        });
    }
    /** Override this to allow this tool to be enabled in a read-only editor */
    canReceiveInputInReadOnlyEditor() {
        return false;
    }
    setInputMapper(mapper) {
        __classPrivateFieldSet(this, _BaseTool_inputMapper, mapper, "f");
        if (mapper) {
            mapper.setEmitListener((event) => this.dispatchEventToCallback(event));
        }
    }
    getInputMapper() {
        return __classPrivateFieldGet(this, _BaseTool_inputMapper, "f");
    }
    dispatchEventToCallback(event) {
        let exhaustivenessCheck;
        switch (event.kind) {
            case _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_1__.InputEvtType.PointerDownEvt:
                return this.onPointerDown(event);
            case _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_1__.InputEvtType.PointerMoveEvt:
                this.onPointerMove(event);
                break;
            case _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_1__.InputEvtType.PointerUpEvt:
                return this.onPointerUp(event) ?? false;
            case _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_1__.InputEvtType.GestureCancelEvt:
                this.onGestureCancel(event);
                break;
            case _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_1__.InputEvtType.WheelEvt:
                return this.onWheel(event);
            case _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_1__.InputEvtType.KeyPressEvent:
                return this.onKeyPress(event);
            case _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_1__.InputEvtType.KeyUpEvent:
                return this.onKeyUp(event);
            case _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_1__.InputEvtType.CopyEvent:
                return this.onCopy(event);
            case _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_1__.InputEvtType.PasteEvent:
                return this.onPaste(event);
            case _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_1__.InputEvtType.ContextMenu:
                return this.onContextMenu(event);
            default:
                exhaustivenessCheck = event;
                return exhaustivenessCheck;
        }
        return true;
    }
    // @internal
    onEvent(event) {
        if (__classPrivateFieldGet(this, _BaseTool_inputMapper, "f")) {
            return __classPrivateFieldGet(this, _BaseTool_inputMapper, "f").onEvent(event);
        }
        return this.dispatchEventToCallback(event);
    }
    /**
     * Returns true iff the tool handled the event and thus should receive additional
     * events.
     */
    onPointerDown(_event) {
        return false;
    }
    onPointerMove(_event) { }
    /**
     * Returns true iff there are additional pointers down and the tool should
     * remain active to handle the additional events.
     *
     * For most purposes, this should return `false` or nothing.
     */
    onPointerUp(_event) { }
    onGestureCancel(_event) { }
    onWheel(_event) {
        return false;
    }
    onCopy(_event) {
        return false;
    }
    onPaste(_event) {
        return false;
    }
    onKeyPress(_event) {
        return false;
    }
    onKeyUp(_event) {
        return false;
    }
    onContextMenu(_event) {
        return false;
    }
    /**
     * Return true if, while this tool is active, `_event` can be delivered to
     * another tool that is higher priority than this.
     * @internal May be renamed
     */
    eventCanBeDeliveredToNonActiveTool(_event) {
        return true;
    }
    setEnabled(enabled) {
        __classPrivateFieldGet(this, _BaseTool_enabled, "f").set(enabled);
    }
    isEnabled() {
        return __classPrivateFieldGet(this, _BaseTool_enabled, "f").get();
    }
    /**
     * Returns a {@link ReactiveValue} that updates based on whether this tool is
     * enabled.
     *
     * @example
     * ```ts
     * const tool = new SomeTool();
     *
     * // Watch for changes in enabled status
     * tool.enabledValue().onUpdate(enabled => doSomething(enabled));
     * ```
     */
    enabledValue() {
        return __classPrivateFieldGet(this, _BaseTool_enabled, "f");
    }
    // Connect this tool to a set of other tools, ensuring that at most one
    // of the tools in the group is enabled.
    setToolGroup(group) {
        if (this.isEnabled()) {
            group.notifyEnabled(this);
        }
        __classPrivateFieldSet(this, _BaseTool_group, group, "f");
    }
    getToolGroup() {
        if (__classPrivateFieldGet(this, _BaseTool_group, "f")) {
            return __classPrivateFieldGet(this, _BaseTool_group, "f");
        }
        return null;
    }
    // Called when the tool is removed/when the editor is destroyed.
    // Subclasses that override this method **must call super.onDestroy()**.
    onDestroy() {
        __classPrivateFieldGet(this, _BaseTool_readOnlyEditorChangeListener, "f")?.remove();
        __classPrivateFieldSet(this, _BaseTool_readOnlyEditorChangeListener, null, "f");
        __classPrivateFieldSet(this, _BaseTool_group, null, "f");
    }
}
_BaseTool_enabled = new WeakMap(), _BaseTool_group = new WeakMap(), _BaseTool_inputMapper = new WeakMap(), _BaseTool_readOnlyEditorChangeListener = new WeakMap();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseTool);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/Eraser.mjs":
/*!********************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/Eraser.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EraserMode: () => (/* binding */ EraserMode),
/* harmony export */   "default": () => (/* binding */ Eraser)
/* harmony export */ });
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types.mjs */ "./node_modules/js-draw/dist/mjs/types.mjs");
/* harmony import */ var _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/BaseTool.mjs");
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _commands_Erase_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../commands/Erase.mjs */ "./node_modules/js-draw/dist/mjs/commands/Erase.mjs");
/* harmony import */ var _Pointer_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Pointer.mjs */ "./node_modules/js-draw/dist/mjs/Pointer.mjs");
/* harmony import */ var _keybindings_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./keybindings.mjs */ "./node_modules/js-draw/dist/mjs/tools/keybindings.mjs");
/* harmony import */ var _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/ReactiveValue.mjs */ "./node_modules/js-draw/dist/mjs/util/ReactiveValue.mjs");
/* harmony import */ var _image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../image/EditorImage.mjs */ "./node_modules/js-draw/dist/mjs/image/EditorImage.mjs");
/* harmony import */ var _commands_uniteCommands_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../commands/uniteCommands.mjs */ "./node_modules/js-draw/dist/mjs/commands/uniteCommands.mjs");
/* harmony import */ var _rendering_RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../rendering/RenderablePathSpec.mjs */ "./node_modules/js-draw/dist/mjs/rendering/RenderablePathSpec.mjs");










var EraserMode;
(function (EraserMode) {
    EraserMode["PartialStroke"] = "partial-stroke";
    EraserMode["FullStroke"] = "full-stroke";
})(EraserMode || (EraserMode = {}));
/** Handles switching from other primary tools to the eraser and back */
class EraserSwitcher extends _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(editor, eraser) {
        super(editor.notifier, editor.localization.changeTool);
        this.editor = editor;
        this.eraser = eraser;
    }
    onPointerDown(event) {
        if (event.allPointers.length === 1 && event.current.device === _Pointer_mjs__WEBPACK_IMPORTED_MODULE_4__.PointerDevice.Eraser) {
            const toolController = this.editor.toolController;
            const enabledPrimaryTools = toolController
                .getPrimaryTools()
                .filter((tool) => tool.isEnabled());
            if (enabledPrimaryTools.length) {
                this.previousEnabledTool = enabledPrimaryTools[0];
            }
            else {
                this.previousEnabledTool = null;
            }
            this.previousEraserEnabledState = this.eraser.isEnabled();
            this.eraser.setEnabled(true);
            if (this.eraser.onPointerDown(event)) {
                return true;
            }
            else {
                this.restoreOriginalTool();
            }
        }
        return false;
    }
    onPointerMove(event) {
        this.eraser.onPointerMove(event);
    }
    restoreOriginalTool() {
        this.eraser.setEnabled(this.previousEraserEnabledState);
        if (this.previousEnabledTool) {
            this.previousEnabledTool.setEnabled(true);
        }
    }
    onPointerUp(event) {
        this.eraser.onPointerUp(event);
        this.restoreOriginalTool();
    }
    onGestureCancel(event) {
        this.eraser.onGestureCancel(event);
        this.restoreOriginalTool();
    }
}
/**
 * A tool that allows a user to erase parts of an image.
 */
class Eraser extends _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(editor, description, options) {
        super(editor.notifier, description);
        this.editor = editor;
        this.lastPoint = null;
        this.isFirstEraseEvt = true;
        this.toAdd = new Set();
        // Commands that each remove one element
        this.eraseCommands = [];
        this.addCommands = [];
        this.thickness = options?.thickness ?? 10;
        this.thicknessValue = _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_6__.ReactiveValue.fromInitialValue(this.thickness);
        this.thicknessValue.onUpdate((value) => {
            this.thickness = value;
            this.editor.notifier.dispatch(_types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ToolUpdated, {
                kind: _types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ToolUpdated,
                tool: this,
            });
        });
        this.modeValue = _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_6__.ReactiveValue.fromInitialValue(options?.mode ?? EraserMode.FullStroke);
        this.modeValue.onUpdate((_value) => {
            this.editor.notifier.dispatch(_types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ToolUpdated, {
                kind: _types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ToolUpdated,
                tool: this,
            });
        });
    }
    /**
     * @returns a tool that briefly enables the eraser when a physical eraser is used.
     * This tool should be added to the tool list after the primary tools.
     */
    makeEraserSwitcherTool() {
        return new EraserSwitcher(this.editor, this);
    }
    clearPreview() {
        this.editor.clearWetInk();
    }
    getSizeOnCanvas() {
        return this.thickness / this.editor.viewport.getScaleFactor();
    }
    drawPreviewAt(point) {
        this.clearPreview();
        const size = this.getSizeOnCanvas();
        const renderer = this.editor.display.getWetInkRenderer();
        const rect = this.getEraserRect(point);
        const rect2 = this.getEraserRect(this.lastPoint ?? point);
        const fill = {
            fill: _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Color4.transparent,
            stroke: { width: size / 10, color: _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Color4.gray },
        };
        renderer.drawPath((0,_rendering_RenderablePathSpec_mjs__WEBPACK_IMPORTED_MODULE_9__.pathToRenderable)(_js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Path.fromConvexHullOf([...rect.corners, ...rect2.corners]), fill));
    }
    /**
     * @returns the eraser rectangle in canvas coordinates.
     *
     * For now, all erasers are rectangles or points.
     */
    getEraserRect(centerPoint) {
        const size = this.getSizeOnCanvas();
        const halfSize = _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Vec2.of(size / 2, size / 2);
        return _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Rect2.fromCorners(centerPoint.minus(halfSize), centerPoint.plus(halfSize));
    }
    /** Erases in a line from the last point to the current. */
    eraseTo(currentPoint) {
        if (!this.isFirstEraseEvt && currentPoint.distanceTo(this.lastPoint) === 0) {
            return;
        }
        this.isFirstEraseEvt = false;
        // Currently only objects within eraserRect or that intersect a straight line
        // from the center of the current rect to the previous are erased. TODO: Erase
        // all objects as if there were pointerMove events between the two points.
        const eraserRect = this.getEraserRect(currentPoint);
        const line = new _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.LineSegment2(this.lastPoint, currentPoint);
        const region = _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Rect2.union(line.bbox, eraserRect);
        const intersectingElems = this.editor.image
            .getElementsIntersectingRegion(region)
            .filter((component) => {
            return component.intersects(line) || component.intersectsRect(eraserRect);
        });
        // Only erase components that could be selected (and thus interacted with)
        // by the user.
        const eraseableElems = intersectingElems.filter((elem) => elem.isSelectable());
        if (this.modeValue.get() === EraserMode.FullStroke) {
            // Remove any intersecting elements.
            this.toRemove.push(...eraseableElems);
            // Create new Erase commands for the now-to-be-erased elements and apply them.
            const newPartialCommands = eraseableElems.map((elem) => new _commands_Erase_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]([elem]));
            newPartialCommands.forEach((cmd) => cmd.apply(this.editor));
            this.eraseCommands.push(...newPartialCommands);
        }
        else {
            const toErase = [];
            const toAdd = [];
            for (const targetElem of eraseableElems) {
                toErase.push(targetElem);
                // Completely delete items that can't be divided.
                if (!targetElem.withRegionErased) {
                    continue;
                }
                // Completely delete items that are completely or almost completely
                // contained within the eraser.
                const grownRect = eraserRect.grownBy(eraserRect.maxDimension / 3);
                if (grownRect.containsRect(targetElem.getExactBBox())) {
                    continue;
                }
                // Join the current and previous rectangles so that points between events are also
                // erased.
                const erasePath = _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Path.fromConvexHullOf([
                    ...eraserRect.corners,
                    ...this.getEraserRect(this.lastPoint ?? currentPoint).corners,
                ].map((p) => this.editor.viewport.roundPoint(p)));
                toAdd.push(...targetElem.withRegionErased(erasePath, this.editor.viewport));
            }
            const eraseCommand = new _commands_Erase_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](toErase);
            const newAddCommands = toAdd.map((elem) => _image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_7__["default"].addElement(elem));
            eraseCommand.apply(this.editor);
            newAddCommands.forEach((command) => command.apply(this.editor));
            const finalToErase = [];
            for (const item of toErase) {
                if (this.toAdd.has(item)) {
                    this.toAdd.delete(item);
                }
                else {
                    finalToErase.push(item);
                }
            }
            this.toRemove.push(...finalToErase);
            for (const item of toAdd) {
                this.toAdd.add(item);
            }
            this.eraseCommands.push(new _commands_Erase_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](finalToErase));
            this.addCommands.push(...newAddCommands);
        }
        this.drawPreviewAt(currentPoint);
        this.lastPoint = currentPoint;
    }
    onPointerDown(event) {
        if (event.allPointers.length === 1 || event.current.device === _Pointer_mjs__WEBPACK_IMPORTED_MODULE_4__.PointerDevice.Eraser) {
            this.lastPoint = event.current.canvasPos;
            this.toRemove = [];
            this.toAdd.clear();
            this.isFirstEraseEvt = true;
            this.drawPreviewAt(event.current.canvasPos);
            return true;
        }
        return false;
    }
    onPointerMove(event) {
        const currentPoint = event.current.canvasPos;
        this.eraseTo(currentPoint);
    }
    onPointerUp(event) {
        this.eraseTo(event.current.canvasPos);
        const commands = [];
        if (this.addCommands.length > 0) {
            this.addCommands.forEach((cmd) => cmd.unapply(this.editor));
            // Remove items from toAdd that are also present in toRemove -- adding, then
            // removing these does nothing, and can break undo/redo.
            for (const item of this.toAdd) {
                if (this.toRemove.includes(item)) {
                    this.toAdd.delete(item);
                    this.toRemove = this.toRemove.filter((other) => other !== item);
                }
            }
            for (const item of this.toRemove) {
                if (this.toAdd.has(item)) {
                    this.toAdd.delete(item);
                    this.toRemove = this.toRemove.filter((other) => other !== item);
                }
            }
            commands.push(...[...this.toAdd].map((a) => _image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_7__["default"].addElement(a)));
            this.addCommands = [];
        }
        if (this.eraseCommands.length > 0) {
            // Undo commands for each individual component and unite into a single command.
            this.eraseCommands.forEach((cmd) => cmd.unapply(this.editor));
            this.eraseCommands = [];
            const command = new _commands_Erase_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](this.toRemove);
            commands.push(command);
        }
        if (commands.length === 1) {
            this.editor.dispatch(commands[0]); // dispatch: Makes undo-able.
        }
        else {
            this.editor.dispatch((0,_commands_uniteCommands_mjs__WEBPACK_IMPORTED_MODULE_8__["default"])(commands));
        }
        this.clearPreview();
    }
    onGestureCancel(_event) {
        this.addCommands.forEach((cmd) => cmd.unapply(this.editor));
        this.eraseCommands.forEach((cmd) => cmd.unapply(this.editor));
        this.eraseCommands = [];
        this.addCommands = [];
        this.clearPreview();
    }
    onKeyPress(event) {
        const shortcuts = this.editor.shortcuts;
        let newThickness;
        if (shortcuts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_5__.decreaseSizeKeyboardShortcutId, event)) {
            newThickness = (this.getThickness() * 2) / 3;
        }
        else if (shortcuts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_5__.increaseSizeKeyboardShortcutId, event)) {
            newThickness = (this.getThickness() * 3) / 2;
        }
        if (newThickness !== undefined) {
            newThickness = Math.min(Math.max(1, newThickness), 200);
            this.setThickness(newThickness);
            return true;
        }
        return false;
    }
    /** Returns the side-length of the tip of this eraser. */
    getThickness() {
        return this.thickness;
    }
    /** Sets the side-length of this' tip. */
    setThickness(thickness) {
        this.thicknessValue.set(thickness);
    }
    /**
     * Returns a {@link MutableReactiveValue} that can be used to watch
     * this tool's thickness.
     */
    getThicknessValue() {
        return this.thicknessValue;
    }
    /** @returns An object that allows switching between a full stroke and a partial stroke eraser. */
    getModeValue() {
        return this.modeValue;
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/FindTool.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/FindTool.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FindTool)
/* harmony export */ });
/* harmony import */ var _components_TextComponent_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/TextComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/TextComponent.mjs");
/* harmony import */ var _components_ImageComponent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/ImageComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/ImageComponent.mjs");
/* harmony import */ var _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/BaseTool.mjs");
/* harmony import */ var _keybindings_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./keybindings.mjs */ "./node_modules/js-draw/dist/mjs/tools/keybindings.mjs");
// Displays a find dialog that allows the user to search for and focus text.
//
// @packageDocumentation




const cssPrefix = 'find-tool';
class FindTool extends _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(editor) {
        super(editor.notifier, editor.localization.findLabel);
        this.editor = editor;
        this.currentMatchIdx = 0;
        this.overlay = document.createElement('div');
        this.fillOverlay();
        editor.createHTMLOverlay(this.overlay);
        this.overlay.style.display = 'none';
        this.overlay.classList.add(`${cssPrefix}-overlay`);
    }
    canReceiveInputInReadOnlyEditor() {
        return true;
    }
    getMatches(searchFor) {
        const lowerSearchFor = searchFor.toLocaleLowerCase();
        const matchingComponents = this.editor.image.getAllElements().filter((component) => {
            let text = '';
            if (component instanceof _components_TextComponent_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]) {
                text = component.getText();
            }
            else if (component instanceof _components_ImageComponent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]) {
                text = component.getAltText() ?? '';
            }
            else {
                return false;
            }
            const hasLowercaseMatch = text.toLocaleLowerCase().indexOf(lowerSearchFor) !== -1;
            const hasSameCaseMatch = text.indexOf(searchFor) !== -1;
            return hasLowercaseMatch || hasSameCaseMatch;
        });
        return matchingComponents.map((match) => match.getBBox());
    }
    focusCurrentMatch() {
        const matches = this.getMatches(this.searchInput.value);
        let matchIdx = this.currentMatchIdx % matches.length;
        if (matchIdx < 0) {
            matchIdx = matches.length + matchIdx;
        }
        if (matchIdx < matches.length) {
            const undoable = false;
            void this.editor.dispatch(this.editor.viewport.zoomTo(matches[matchIdx], true, true), undoable);
            this.editor.announceForAccessibility(this.editor.localization.focusedFoundText(matchIdx + 1, matches.length));
        }
    }
    toNextMatch() {
        this.currentMatchIdx++;
        this.focusCurrentMatch();
    }
    toPrevMatch() {
        this.currentMatchIdx--;
        this.focusCurrentMatch();
    }
    fillOverlay() {
        const label = document.createElement('label');
        this.searchInput = document.createElement('input');
        const nextBtn = document.createElement('button');
        const closeBtn = document.createElement('button');
        // Math.random() ensures that the ID is unique (to allow us to refer to it
        // with an htmlFor).
        this.searchInput.setAttribute('id', `${cssPrefix}-searchInput-${Math.random()}`);
        label.htmlFor = this.searchInput.getAttribute('id');
        label.innerText = this.editor.localization.findLabel;
        nextBtn.innerText = this.editor.localization.toNextMatch;
        closeBtn.innerText = this.editor.localization.closeDialog;
        this.searchInput.onkeydown = (ev) => {
            if (ev.key === 'Enter') {
                if (ev.shiftKey) {
                    this.toPrevMatch();
                }
                else {
                    this.toNextMatch();
                }
            }
            else if (ev.key === 'Escape') {
                this.setVisible(false);
            }
            else if (this.editor.shortcuts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_3__.toggleFindVisibleShortcutId, ev)) {
                ev.preventDefault();
                this.toggleVisible();
            }
        };
        nextBtn.onclick = () => {
            this.toNextMatch();
        };
        closeBtn.onclick = () => {
            this.setVisible(false);
        };
        this.overlay.replaceChildren(label, this.searchInput, nextBtn, closeBtn);
    }
    isVisible() {
        return this.overlay.style.display !== 'none';
    }
    setVisible(visible) {
        if (visible !== this.isVisible()) {
            this.overlay.style.display = visible ? 'block' : 'none';
            if (visible) {
                this.searchInput.focus();
                this.editor.announceForAccessibility(this.editor.localization.findDialogShown);
            }
            else {
                this.editor.focus();
                this.editor.announceForAccessibility(this.editor.localization.findDialogHidden);
            }
        }
    }
    toggleVisible() {
        this.setVisible(!this.isVisible());
    }
    onKeyPress(event) {
        if (this.editor.shortcuts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_3__.toggleFindVisibleShortcutId, event)) {
            this.toggleVisible();
            return true;
        }
        return false;
    }
    setEnabled(enabled) {
        super.setEnabled(enabled);
        if (this.isEnabled()) {
            this.setVisible(false);
        }
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/InputFilter/ContextMenuRecognizer.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/InputFilter/ContextMenuRecognizer.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ContextMenuRecognizer)
/* harmony export */ });
/* harmony import */ var _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../inputEvents.mjs */ "./node_modules/js-draw/dist/mjs/inputEvents.mjs");
/* harmony import */ var _InputMapper_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./InputMapper.mjs */ "./node_modules/js-draw/dist/mjs/tools/InputFilter/InputMapper.mjs");
/* harmony import */ var _util_StationaryPenDetector_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/StationaryPenDetector.mjs */ "./node_modules/js-draw/dist/mjs/tools/util/StationaryPenDetector.mjs");
/* harmony import */ var _Pointer_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Pointer.mjs */ "./node_modules/js-draw/dist/mjs/Pointer.mjs");




class ContextMenuRecognizer extends _InputMapper_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super();
        this.canShowContextMenu = false;
        this.stationaryDetector = null;
        this.clickTolerance = 12;
    }
    /**
     * In general, only certain events (i.e. touchscreens) are expected to be able to
     * create long-press menus. This method checks whether `event` was generated by
     * one such device.
     */
    canMakeLongPressMenuEvent(event) {
        const allowedDevices = [_Pointer_mjs__WEBPACK_IMPORTED_MODULE_3__.PointerDevice.Touch];
        return event.allPointers.length === 1 && allowedDevices.includes(event.current.device);
    }
    onEvent(event) {
        const sendContextMenuEvent = () => {
            if (!(0,_inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__.isPointerEvt)(event))
                return false;
            if (this.canShowContextMenu) {
                const eventHandled = this.emit({
                    kind: _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.ContextMenu,
                    screenPos: event.current.screenPos,
                    canvasPos: event.current.canvasPos,
                });
                if (eventHandled) {
                    this.emit({
                        kind: _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.GestureCancelEvt,
                    });
                    return true;
                }
            }
            return false;
        };
        if (event.kind === _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.PointerDownEvt) {
            if (event.allPointers.length === 1) {
                this.canShowContextMenu = true;
                this.contextMenuTriggerPointer = event.current;
                this.contextMenuStartPoint = event.current.screenPos;
                if (this.canMakeLongPressMenuEvent(event)) {
                    this.stationaryDetector = new _util_StationaryPenDetector_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](event.current, _util_StationaryPenDetector_mjs__WEBPACK_IMPORTED_MODULE_2__.defaultStationaryDetectionConfig, sendContextMenuEvent);
                }
            }
            else {
                this.canShowContextMenu = false;
            }
        }
        else if (event.kind === _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.PointerMoveEvt) {
            if (this.canShowContextMenu) {
                this.stationaryDetector?.onPointerMove(event.current);
                // Only clicks/stationary long presses can create context menu events.
                const deltaPosition = event.current.screenPos.minus(this.contextMenuStartPoint);
                const threshold = this.clickTolerance;
                if (deltaPosition.length() > threshold) {
                    this.canShowContextMenu = false;
                }
            }
        }
        else if (event.kind === _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.PointerUpEvt) {
            this.stationaryDetector?.destroy();
            if (this.contextMenuTriggerPointer?.id === event.current.id &&
                this.contextMenuTriggerPointer.device === _Pointer_mjs__WEBPACK_IMPORTED_MODULE_3__.PointerDevice.RightButtonMouse &&
                sendContextMenuEvent()) {
                return true;
            }
        }
        return this.emit(event);
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/InputFilter/InputMapper.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/InputFilter/InputMapper.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _InputMapper_listener;
/**
 * Accepts input events and emits input events.
 */
class InputMapper {
    constructor() {
        _InputMapper_listener.set(this, null);
    }
    // @internal
    setEmitListener(listener) {
        if (listener && typeof listener === 'object') {
            __classPrivateFieldSet(this, _InputMapper_listener, (event) => {
                return listener.onEvent(event) ?? false;
            }, "f");
        }
        else {
            __classPrivateFieldSet(this, _InputMapper_listener, listener, "f");
        }
    }
    emit(event) {
        return __classPrivateFieldGet(this, _InputMapper_listener, "f")?.call(this, event) ?? false;
    }
}
_InputMapper_listener = new WeakMap();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InputMapper);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/InputFilter/InputPipeline.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/InputFilter/InputPipeline.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _InputMapper_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./InputMapper.mjs */ "./node_modules/js-draw/dist/mjs/tools/InputFilter/InputMapper.mjs");
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _InputPipeline_head, _InputPipeline_tail;

/**
 * The composition of multiple `InputMapper`s.
 */
class InputPipeline extends _InputMapper_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        _InputPipeline_head.set(this, null);
        _InputPipeline_tail.set(this, null);
    }
    onEvent(event) {
        if (__classPrivateFieldGet(this, _InputPipeline_head, "f") === null) {
            return this.emit(event);
        }
        else {
            return __classPrivateFieldGet(this, _InputPipeline_head, "f").onEvent(event);
        }
    }
    /**
     * Adds a new `InputMapper` to the *tail* of this pipeline.
     * Note that an instance of an `InputMapper` can only be used in a single
     * pipeline.
     */
    addToTail(mapper) {
        if (!__classPrivateFieldGet(this, _InputPipeline_tail, "f")) {
            __classPrivateFieldSet(this, _InputPipeline_head, mapper, "f");
            __classPrivateFieldSet(this, _InputPipeline_tail, __classPrivateFieldGet(this, _InputPipeline_head, "f"), "f");
        }
        else {
            __classPrivateFieldGet(this, _InputPipeline_tail, "f").setEmitListener(mapper);
            __classPrivateFieldSet(this, _InputPipeline_tail, mapper, "f");
        }
        __classPrivateFieldGet(this, _InputPipeline_tail, "f").setEmitListener((event) => this.emit(event));
    }
}
_InputPipeline_head = new WeakMap(), _InputPipeline_tail = new WeakMap();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InputPipeline);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/InputFilter/InputStabilizer.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/InputFilter/InputStabilizer.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ InputStabilizer)
/* harmony export */ });
/* harmony import */ var _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../inputEvents.mjs */ "./node_modules/js-draw/dist/mjs/inputEvents.mjs");
/* harmony import */ var _InputMapper_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./InputMapper.mjs */ "./node_modules/js-draw/dist/mjs/tools/InputFilter/InputMapper.mjs");
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _util_untilNextAnimationFrame_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/untilNextAnimationFrame.mjs */ "./node_modules/js-draw/dist/mjs/util/untilNextAnimationFrame.mjs");




var StabilizerType;
(function (StabilizerType) {
    StabilizerType[StabilizerType["IntertialStabilizer"] = 0] = "IntertialStabilizer";
})(StabilizerType || (StabilizerType = {}));
const defaultOptions = {
    kind: StabilizerType.IntertialStabilizer,
    mass: 0.4, // kg
    springConstant: 100.0, // N/m
    frictionCoefficient: 0.28,
    maxPointDist: 10, // screen units
    inertiaFraction: 0.75,
    minSimilarityToFinalize: 0.0,
    velocityDecayFactor: 0.1,
};
// Stabilizes input for a single cursor
class StylusInputStabilizer {
    constructor(
    // The initial starting point of the pointer.
    start, 
    // Emits a pointer motion event, returns true if the event was handled.
    updatePointer, options) {
        this.updatePointer = updatePointer;
        this.options = options;
        this.runLoop = true;
        this.lastUpdateTime = 0;
        this.velocity = _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Vec2.zero;
        this.strokePoint = start;
        this.targetPoint = start;
        this.targetInterval = 10; // ms
        void this.loop();
    }
    async loop() {
        this.lastUpdateTime = performance.now();
        while (this.runLoop) {
            this.update(false);
            await (0,_util_untilNextAnimationFrame_mjs__WEBPACK_IMPORTED_MODULE_3__["default"])();
        }
    }
    setTarget(point) {
        this.targetPoint = point;
    }
    getNextVelocity(deltaTimeMs) {
        const toTarget = this.targetPoint.minus(this.strokePoint);
        const springForce = toTarget.times(this.options.springConstant);
        const gravityAccel = 10;
        const normalForceMagnitude = this.options.mass * gravityAccel;
        const frictionForce = this.velocity
            .normalizedOrZero()
            .times(-this.options.frictionCoefficient * normalForceMagnitude);
        const acceleration = springForce.plus(frictionForce).times(1 / this.options.mass);
        const decayFactor = this.options.velocityDecayFactor;
        const springVelocity = this.velocity
            .times(1 - decayFactor)
            .plus(acceleration.times(deltaTimeMs / 1000));
        // An alternate velocity that goes directly towards the target.
        const toTargetVelocity = toTarget.normalizedOrZero().times(springVelocity.length());
        return toTargetVelocity.lerp(springVelocity, this.options.inertiaFraction);
    }
    update(force) {
        const nowTime = performance.now();
        const deltaTime = nowTime - this.lastUpdateTime;
        const reachedTarget = this.strokePoint.eq(this.targetPoint);
        if (deltaTime > this.targetInterval || force) {
            if (!reachedTarget) {
                let velocity;
                let deltaX;
                let parts = 1;
                do {
                    velocity = this.getNextVelocity(deltaTime / parts);
                    deltaX = velocity.times(deltaTime / 1000);
                    parts++;
                } while (deltaX.magnitude() > this.options.maxPointDist && parts < 10);
                for (let i = 0; i < parts; i++) {
                    this.velocity = this.getNextVelocity(deltaTime / parts);
                    deltaX = this.velocity.times(deltaTime / 1000);
                    this.strokePoint = this.strokePoint.plus(deltaX);
                    // Allows the last updatePointer to be returned.
                    if (i < parts - 1) {
                        this.updatePointer(this.strokePoint, nowTime);
                    }
                }
            }
            // Even if we have reached the target, ensure that lastUpdateTime is updated
            // (prevent large deltaTime).
            this.lastUpdateTime = nowTime;
            if (force || !reachedTarget) {
                return this.updatePointer(this.strokePoint, nowTime);
            }
        }
        return false;
    }
    /** Finalizes the current stroke. */
    finish() {
        this.runLoop = false;
        const toTarget = this.targetPoint.minus(this.strokePoint);
        if (this.velocity.dot(toTarget) > this.options.minSimilarityToFinalize) {
            // Connect the stroke to its end point
            this.updatePointer(this.targetPoint, performance.now());
        }
    }
    cancel() {
        this.runLoop = false;
    }
}
class InputStabilizer extends _InputMapper_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(viewport, options = defaultOptions) {
        super();
        this.viewport = viewport;
        this.options = options;
        this.stabilizer = null;
        this.lastPointerEvent = null;
    }
    mapPointerEvent(event) {
        // Don't store the last pointer event for use with pressure/button data --
        // this information can be very different for a pointerup event.
        if ((0,_inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__.isPointerEvt)(event) && event.kind !== _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.PointerUpEvt) {
            this.lastPointerEvent = event;
        }
        // Only apply smoothing if there is a single pointer.
        if (event.kind === _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.GestureCancelEvt ||
            event.allPointers.length > 1 ||
            this.stabilizer === null) {
            return this.emit(event);
        }
        this.stabilizer.setTarget(event.current.screenPos);
        if (event.kind === _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.PointerMoveEvt) {
            return this.stabilizer.update(true);
        }
        else if (event.kind === _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.PointerUpEvt) {
            this.stabilizer.finish();
            return this.emit(event);
        }
        else {
            return this.emit(event);
        }
    }
    // Assumes that there is exactly one pointer that is currently down.
    emitPointerMove(screenPoint, timeStamp) {
        if (!this.lastPointerEvent) {
            return false;
        }
        const pointer = this.lastPointerEvent.current
            .withScreenPosition(screenPoint, this.viewport)
            .withTimestamp(timeStamp);
        const event = {
            kind: _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.PointerMoveEvt,
            current: pointer,
            allPointers: [pointer],
        };
        const handled = this.emit(event);
        return handled;
    }
    onEvent(event) {
        if ((0,_inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__.isPointerEvt)(event) || event.kind === _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.GestureCancelEvt) {
            if (event.kind === _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.PointerDownEvt) {
                if (this.stabilizer === null) {
                    this.stabilizer = new StylusInputStabilizer(event.current.screenPos, (screenPoint, timeStamp) => this.emitPointerMove(screenPoint, timeStamp), this.options);
                }
                else if (event.allPointers.length > 1) {
                    // Do not attempt to stabilize multiple pointers.
                    this.stabilizer.cancel();
                    this.stabilizer = null;
                }
            }
            const handled = this.mapPointerEvent(event);
            if (event.kind === _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.PointerUpEvt ||
                event.kind === _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.GestureCancelEvt) {
                this.stabilizer?.cancel();
                this.stabilizer = null;
            }
            return handled;
        }
        return this.emit(event);
    }
    static fromEditor(editor) {
        return new InputStabilizer(editor.viewport);
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/InputFilter/StrokeKeyboardControl.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/InputFilter/StrokeKeyboardControl.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ StrokeKeyboardControl)
/* harmony export */ });
/* harmony import */ var _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../inputEvents.mjs */ "./node_modules/js-draw/dist/mjs/inputEvents.mjs");
/* harmony import */ var _InputMapper_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./InputMapper.mjs */ "./node_modules/js-draw/dist/mjs/tools/InputFilter/InputMapper.mjs");
/* harmony import */ var _keybindings_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../keybindings.mjs */ "./node_modules/js-draw/dist/mjs/tools/keybindings.mjs");



/**
 * Provides keyboard shortcuts that provide some amount of control over
 * drawing (e.g. snap to grid, plane lock).
 */
class StrokeKeyboardControl extends _InputMapper_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(shortcuts, viewport) {
        super();
        this.shortcuts = shortcuts;
        this.viewport = viewport;
        this.snapToGridEnabled = false;
        this.angleLockEnabled = false;
        // The point at which the last pointerDown event happened (or null if
        // no such event has occurred).
        this.startPointCanvas = null;
    }
    // Snap the given pointer to the nearer of the x/y axes.
    xyAxesSnap(pointer) {
        if (!this.startPointCanvas) {
            return pointer;
        }
        // Convert this.startPointCanvas here because the viewport might change
        // while drawing a stroke.
        const screenPos = this.viewport.canvasToScreen(this.startPointCanvas);
        return pointer.lockedToXYAxesScreen(screenPos, this.viewport);
    }
    mapPointerEvent(event) {
        const mapPointer = (pointer) => {
            // Only map if there's exactly one pointer.
            if (event.allPointers.length > 1) {
                return pointer;
            }
            if (this.snapToGridEnabled) {
                return pointer.snappedToGrid(this.viewport);
            }
            if (this.angleLockEnabled && this.startPointCanvas) {
                return this.xyAxesSnap(pointer);
            }
            return pointer;
        };
        return {
            kind: event.kind,
            current: mapPointer(event.current),
            allPointers: event.allPointers.map(mapPointer),
        };
    }
    onEvent(event) {
        const shortcuts = this.shortcuts;
        if (event.kind === _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.PointerDownEvt ||
            event.kind === _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.PointerMoveEvt ||
            event.kind === _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.PointerUpEvt) {
            if (event.kind === _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.PointerDownEvt) {
                this.startPointCanvas = event.current.canvasPos;
            }
            event = this.mapPointerEvent(event);
        }
        let handled = this.emit(event);
        if (
        // Always check keyUpEvents (in case we handled the corresponding keyDown event)
        event.kind === _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.KeyUpEvent ||
            // Only handle key press events if another tool isn't handling it. We don't want
            // snap to grid/angle lock to conflict with selection/another tool's shortcuts.
            (!handled && event.kind === _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.KeyPressEvent)) {
            const isKeyPress = event.kind === _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.KeyPressEvent;
            if (shortcuts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_2__.snapToGridKeyboardShortcutId, event)) {
                this.snapToGridEnabled = isKeyPress;
                handled = true;
            }
            if (shortcuts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_2__.lineLockKeyboardShortcutId, event)) {
                this.angleLockEnabled = isKeyPress;
                handled = true;
            }
        }
        return handled;
    }
    static fromEditor(editor) {
        return new StrokeKeyboardControl(editor.shortcuts, editor.viewport);
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/PanZoom.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/PanZoom.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PanZoomMode: () => (/* binding */ PanZoomMode),
/* harmony export */   "default": () => (/* binding */ PanZoom)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _Pointer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Pointer.mjs */ "./node_modules/js-draw/dist/mjs/Pointer.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../types.mjs */ "./node_modules/js-draw/dist/mjs/types.mjs");
/* harmony import */ var _util_untilNextAnimationFrame_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/untilNextAnimationFrame.mjs */ "./node_modules/js-draw/dist/mjs/util/untilNextAnimationFrame.mjs");
/* harmony import */ var _Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Viewport.mjs */ "./node_modules/js-draw/dist/mjs/Viewport.mjs");
/* harmony import */ var _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./BaseTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/BaseTool.mjs");
/* harmony import */ var _keybindings_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./keybindings.mjs */ "./node_modules/js-draw/dist/mjs/tools/keybindings.mjs");







var PanZoomMode;
(function (PanZoomMode) {
    /** Touch gestures with a single pointer. Ignores non-touch gestures. */
    PanZoomMode[PanZoomMode["OneFingerTouchGestures"] = 1] = "OneFingerTouchGestures";
    /** Touch gestures with exactly two pointers. Ignores non-touch gestures. */
    PanZoomMode[PanZoomMode["TwoFingerTouchGestures"] = 2] = "TwoFingerTouchGestures";
    PanZoomMode[PanZoomMode["RightClickDrags"] = 4] = "RightClickDrags";
    /** Single-pointer gestures of *any* type (including touch). */
    PanZoomMode[PanZoomMode["SinglePointerGestures"] = 8] = "SinglePointerGestures";
    /** Keyboard navigation (e.g. LeftArrow to move left). */
    PanZoomMode[PanZoomMode["Keyboard"] = 16] = "Keyboard";
    /** If provided, prevents **this** tool from rotating the viewport (other tools may still do so). */
    PanZoomMode[PanZoomMode["RotationLocked"] = 32] = "RotationLocked";
})(PanZoomMode || (PanZoomMode = {}));
class InertialScroller {
    constructor(initialVelocity, scrollBy, onComplete) {
        this.initialVelocity = initialVelocity;
        this.scrollBy = scrollBy;
        this.onComplete = onComplete;
        this.running = false;
        this.start();
    }
    async start() {
        if (this.running) {
            return;
        }
        this.currentVelocity = this.initialVelocity;
        let lastTime = performance.now();
        this.running = true;
        const maxSpeed = 5000; // units/s
        const minSpeed = 200; // units/s
        if (this.currentVelocity.magnitude() > maxSpeed) {
            this.currentVelocity = this.currentVelocity.normalized().times(maxSpeed);
        }
        while (this.running && this.currentVelocity.magnitude() > minSpeed) {
            const nowTime = performance.now();
            const dt = (nowTime - lastTime) / 1000;
            this.currentVelocity = this.currentVelocity.times(Math.pow(1 / 8, dt));
            this.scrollBy(this.currentVelocity.times(dt));
            await (0,_util_untilNextAnimationFrame_mjs__WEBPACK_IMPORTED_MODULE_3__["default"])();
            lastTime = nowTime;
        }
        if (this.running) {
            this.stop();
        }
    }
    getCurrentVelocity() {
        if (!this.running) {
            return null;
        }
        return this.currentVelocity;
    }
    stop() {
        if (this.running) {
            this.running = false;
            this.onComplete();
        }
    }
}
/**
 * This tool moves the viewport in response to touchpad, touchscreen, mouse, and keyboard events.
 *
 * Which events are handled, and which are skipped, are determined by the tool's `mode`. For example,
 * a `PanZoom` tool with `mode = PanZoomMode.TwoFingerTouchGestures|PanZoomMode.RightClickDrags` would
 * respond to right-click drag events and two-finger touch gestures.
 *
 * @see {@link setModeEnabled}
 */
class PanZoom extends _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_5__["default"] {
    constructor(editor, mode, description) {
        super(editor.notifier, description);
        this.editor = editor;
        this.mode = mode;
        this.transform = null;
        // Constants
        // initialRotationSnapAngle is larger than afterRotationStartSnapAngle to
        // make it more difficult to start rotating (and easier to continue rotating).
        this.initialRotationSnapAngle = 0.22; // radians
        this.afterRotationStartSnapAngle = 0.07; // radians
        this.pinchZoomStartThreshold = 1.08; // scale factor
        // Last timestamp at which a pointerdown event was received
        this.lastPointerDownTimestamp = 0;
        this.initialTouchAngle = 0;
        this.initialViewportRotation = 0;
        this.initialViewportScale = 0;
        // Set to `true` only when scaling has started (if two fingers are down and have moved
        // far enough).
        this.isScaling = false;
        this.isRotating = false;
        this.inertialScroller = null;
        this.velocity = null;
    }
    // The pan/zoom tool can be used in a read-only editor.
    canReceiveInputInReadOnlyEditor() {
        return true;
    }
    // Returns information about the pointers in a gesture
    computePinchData(p1, p2) {
        // Swap the pointers to ensure consistent ordering.
        if (p1.id < p2.id) {
            const tmp = p1;
            p1 = p2;
            p2 = tmp;
        }
        const screenBetween = p2.screenPos.minus(p1.screenPos);
        const angle = screenBetween.angle();
        const dist = screenBetween.magnitude();
        const canvasCenter = p2.canvasPos.plus(p1.canvasPos).times(0.5);
        const screenCenter = p2.screenPos.plus(p1.screenPos).times(0.5);
        return { canvasCenter, screenCenter, angle, dist };
    }
    allPointersAreOfType(pointers, kind) {
        return pointers.every((pointer) => pointer.device === kind);
    }
    onPointerDown({ allPointers: pointers, current: currentPointer, }) {
        let handlingGesture = false;
        const inertialScrollerVelocity = this.inertialScroller?.getCurrentVelocity() ?? _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.zero;
        this.inertialScroller?.stop();
        this.velocity = inertialScrollerVelocity;
        this.lastPointerDownTimestamp = currentPointer.timeStamp;
        const allAreTouch = this.allPointersAreOfType(pointers, _Pointer_mjs__WEBPACK_IMPORTED_MODULE_1__.PointerDevice.Touch);
        const isRightClick = this.allPointersAreOfType(pointers, _Pointer_mjs__WEBPACK_IMPORTED_MODULE_1__.PointerDevice.RightButtonMouse);
        if (allAreTouch && pointers.length === 2 && this.mode & PanZoomMode.TwoFingerTouchGestures) {
            const { screenCenter, angle, dist } = this.computePinchData(pointers[0], pointers[1]);
            this.lastTouchDist = dist;
            this.startTouchDist = dist;
            this.lastScreenCenter = screenCenter;
            this.initialTouchAngle = angle;
            this.initialViewportRotation = this.editor.viewport.getRotationAngle();
            this.initialViewportScale = this.editor.viewport.getScaleFactor();
            this.isScaling = false;
            // We're initially rotated if `initialViewportRotation` isn't near a multiple of pi/2.
            // In other words, if sin(2 initialViewportRotation) is near zero.
            this.isRotating = Math.abs(Math.sin(this.initialViewportRotation * 2)) > 1e-3;
            handlingGesture = true;
        }
        else if (pointers.length === 1 &&
            ((this.mode & PanZoomMode.OneFingerTouchGestures && allAreTouch) ||
                (isRightClick && this.mode & PanZoomMode.RightClickDrags) ||
                this.mode & PanZoomMode.SinglePointerGestures)) {
            this.lastScreenCenter = pointers[0].screenPos;
            this.isScaling = false;
            handlingGesture = true;
        }
        if (handlingGesture) {
            this.lastTimestamp = performance.now();
            this.transform ??= _Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__.Viewport.transformBy(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.identity);
            this.editor.display.setDraftMode(true);
        }
        return handlingGesture;
    }
    updateVelocity(currentCenter) {
        const deltaPos = currentCenter.minus(this.lastScreenCenter);
        let deltaTime = (performance.now() - this.lastTimestamp) / 1000;
        // Ignore duplicate events, unless there has been enough time between them.
        if (deltaPos.magnitude() === 0 && deltaTime < 0.1) {
            return;
        }
        // We divide by deltaTime. Don't divide by zero.
        if (deltaTime === 0) {
            return;
        }
        // Don't divide by almost zero, either
        deltaTime = Math.max(deltaTime, 0.01);
        const currentVelocity = deltaPos.times(1 / deltaTime);
        let smoothedVelocity = currentVelocity;
        if (this.velocity) {
            smoothedVelocity = this.velocity.lerp(currentVelocity, 0.5);
        }
        this.velocity = smoothedVelocity;
    }
    // Returns the change in position of the center of the given group of pointers.
    // Assumes this.lastScreenCenter has been set appropriately.
    getCenterDelta(screenCenter) {
        // Use transformVec3 to avoid translating the delta
        const delta = this.editor.viewport.screenToCanvasTransform.transformVec3(screenCenter.minus(this.lastScreenCenter));
        return delta;
    }
    //  Snaps `angle` to common desired rotations. For example, if `touchAngle` corresponds
    // to a viewport rotation of 90.1 degrees, this function returns a rotation delta that,
    // when applied to the viewport, rotates the viewport to 90.0 degrees.
    //
    // Returns a snapped rotation delta that, when applied to the viewport, rotates the viewport,
    // from its position on the last touchDown event, by `touchAngle - initialTouchAngle`.
    toSnappedRotationDelta(touchAngle) {
        const deltaAngle = touchAngle - this.initialTouchAngle;
        let fullRotation = deltaAngle + this.initialViewportRotation;
        const snapToMultipleOf = Math.PI / 2;
        const roundedFullRotation = Math.round(fullRotation / snapToMultipleOf) * snapToMultipleOf;
        // The maximum angle for which we snap the given angle to a multiple of
        // `snapToMultipleOf`.
        // Use a smaller snap angle if already rotated (to avoid pinch zoom gestures from
        // starting rotation).
        const maxSnapAngle = this.isRotating
            ? this.afterRotationStartSnapAngle
            : this.initialRotationSnapAngle;
        // Snap the rotation
        if (Math.abs(fullRotation - roundedFullRotation) < maxSnapAngle) {
            fullRotation = roundedFullRotation;
            // Work around a rotation/matrix multiply bug.
            // (See commit after 4abe27ff8e7913155828f98dee77b09c57c51d30).
            // TODO: Fix the underlying issue and remove this.
            if (fullRotation !== 0) {
                fullRotation += 0.0001;
            }
        }
        return fullRotation - this.editor.viewport.getRotationAngle();
    }
    /**
     * Given a scale update, `scaleFactor`, returns a new scale factor snapped
     * to a power of two (if within some tolerance of that scale).
     */
    toSnappedScaleFactor(touchDist) {
        // scaleFactor is applied to the current transformation of the viewport.
        const newScale = (this.initialViewportScale * touchDist) / this.startTouchDist;
        const currentScale = this.editor.viewport.getScaleFactor();
        const logNewScale = Math.log(newScale) / Math.log(10);
        const roundedLogNewScale = Math.round(logNewScale);
        const logTolerance = 0.04;
        if (Math.abs(roundedLogNewScale - logNewScale) < logTolerance) {
            return Math.pow(10, roundedLogNewScale) / currentScale;
        }
        return touchDist / this.lastTouchDist;
    }
    handleTwoFingerMove(allPointers) {
        const { screenCenter, canvasCenter, angle, dist } = this.computePinchData(allPointers[0], allPointers[1]);
        const delta = this.getCenterDelta(screenCenter);
        let deltaRotation;
        if (this.isRotationLocked()) {
            deltaRotation = 0;
        }
        else {
            deltaRotation = this.toSnappedRotationDelta(angle);
        }
        // If any rotation, make a note of this (affects rotation snap
        // angles).
        if (Math.abs(deltaRotation) > 1e-8) {
            this.isRotating = true;
        }
        this.updateVelocity(screenCenter);
        if (!this.isScaling) {
            const initialScaleFactor = dist / this.startTouchDist;
            // Only start scaling if scaling done so far exceeds some threshold.
            const upperBound = this.pinchZoomStartThreshold;
            const lowerBound = 1 / this.pinchZoomStartThreshold;
            if (initialScaleFactor > upperBound || initialScaleFactor < lowerBound) {
                this.isScaling = true;
            }
        }
        let scaleFactor = 1;
        if (this.isScaling) {
            scaleFactor = this.toSnappedScaleFactor(dist);
            // Don't set lastDist until we start scaling --
            this.lastTouchDist = dist;
        }
        const transformUpdate = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.translation(delta)
            .rightMul(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.scaling2D(scaleFactor, canvasCenter))
            .rightMul(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.zRotation(deltaRotation, canvasCenter));
        this.lastScreenCenter = screenCenter;
        this.transform = _Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__.Viewport.transformBy(this.transform.transform.rightMul(transformUpdate));
        return transformUpdate;
    }
    handleOneFingerMove(pointer) {
        const delta = this.getCenterDelta(pointer.screenPos);
        const transformUpdate = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.translation(delta);
        this.transform = _Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__.Viewport.transformBy(this.transform.transform.rightMul(transformUpdate));
        this.updateVelocity(pointer.screenPos);
        this.lastScreenCenter = pointer.screenPos;
        return transformUpdate;
    }
    onPointerMove({ allPointers }) {
        this.transform ??= _Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__.Viewport.transformBy(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.identity);
        let transformUpdate = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.identity;
        if (allPointers.length === 2) {
            transformUpdate = this.handleTwoFingerMove(allPointers);
        }
        else if (allPointers.length === 1) {
            transformUpdate = this.handleOneFingerMove(allPointers[0]);
        }
        _Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__.Viewport.transformBy(transformUpdate).apply(this.editor);
        this.lastTimestamp = performance.now();
    }
    onPointerUp(event) {
        const onComplete = () => {
            if (this.transform) {
                this.transform.unapply(this.editor);
                this.editor.dispatch(this.transform, false);
            }
            this.editor.display.setDraftMode(false);
            this.transform = null;
            this.velocity = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.zero;
        };
        const minInertialScrollDt = 30;
        const shouldInertialScroll = event.current.device === _Pointer_mjs__WEBPACK_IMPORTED_MODULE_1__.PointerDevice.Touch &&
            event.allPointers.length === 1 &&
            this.velocity !== null &&
            event.current.timeStamp - this.lastPointerDownTimestamp > minInertialScrollDt;
        if (shouldInertialScroll && this.velocity !== null) {
            const oldVelocity = this.velocity;
            // If the user drags the screen, then stops, then lifts the pointer,
            // we want the final velocity to reflect the stop at the end (so the velocity
            // should be near zero). Handle this:
            this.updateVelocity(event.current.screenPos);
            // Work around an input issue. Some devices that disable the touchscreen when a stylus
            // comes near the screen fire a touch-end event at the position of the stylus when a
            // touch gesture is canceled. Because the stylus is often far away from the last touch,
            // this causes a great displacement between the second-to-last (from the touchscreen) and
            // last (from the pen that is now near the screen) events. Only allow velocity to decrease
            // to work around this:
            if (oldVelocity.magnitude() < this.velocity.magnitude()) {
                this.velocity = oldVelocity;
            }
            // Cancel any ongoing inertial scrolling.
            this.inertialScroller?.stop();
            this.inertialScroller = new InertialScroller(this.velocity, (scrollDelta) => {
                if (!this.transform) {
                    return;
                }
                const canvasDelta = this.editor.viewport.screenToCanvasTransform.transformVec3(scrollDelta);
                // Scroll by scrollDelta
                this.transform.unapply(this.editor);
                this.transform = _Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__.Viewport.transformBy(this.transform.transform.rightMul(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.translation(canvasDelta)));
                this.transform.apply(this.editor);
            }, onComplete);
        }
        else {
            onComplete();
        }
    }
    onGestureCancel() {
        this.inertialScroller?.stop();
        this.velocity = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.zero;
        this.transform?.unapply(this.editor);
        this.editor.display.setDraftMode(false);
        this.transform = null;
    }
    // Applies [transformUpdate] to the editor. This stacks on top of the
    // current transformation, if it exists.
    updateTransform(transformUpdate, announce = false) {
        let newTransform = transformUpdate;
        if (this.transform) {
            newTransform = this.transform.transform.rightMul(transformUpdate);
        }
        this.transform?.unapply(this.editor);
        this.transform = _Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__.Viewport.transformBy(newTransform);
        this.transform.apply(this.editor);
        if (announce) {
            this.editor.announceForAccessibility(this.transform.description(this.editor, this.editor.localization));
        }
    }
    /**
     * Updates the current transform and clears it. Use this method for events that are not part of
     * a larger gesture (i.e. have no start and end event). For example, this would be used for `onwheel`
     * events, but not for `onpointer` events.
     */
    applyAndFinalizeTransform(transformUpdate) {
        this.updateTransform(transformUpdate, true);
        this.transform = null;
    }
    onWheel({ delta, screenPos }) {
        this.inertialScroller?.stop();
        // Reset the transformation -- wheel events are individual events, so we don't
        // need to unapply/reapply.
        this.transform = _Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__.Viewport.transformBy(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.identity);
        const canvasPos = this.editor.viewport.screenToCanvas(screenPos);
        const toCanvas = this.editor.viewport.screenToCanvasTransform;
        // Transform without including translation
        const translation = toCanvas.transformVec3(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec3.of(-delta.x, -delta.y, 0));
        let pinchAmount = delta.z;
        // Clamp the magnitude of pinchAmount
        pinchAmount = Math.atan(pinchAmount / 2) * 2;
        const pinchZoomScaleFactor = 1.04;
        const transformUpdate = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.scaling2D(Math.max(0.4, Math.min(Math.pow(pinchZoomScaleFactor, -pinchAmount), 4)), canvasPos).rightMul(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.translation(translation));
        this.applyAndFinalizeTransform(transformUpdate);
        return true;
    }
    onKeyPress(event) {
        this.inertialScroller?.stop();
        if (!(this.mode & PanZoomMode.Keyboard)) {
            return false;
        }
        // No need to keep the same the transform for keyboard events.
        this.transform = _Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__.Viewport.transformBy(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.identity);
        let translation = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.zero;
        let scale = 1;
        let rotation = 0;
        // Keyboard shortcut handling
        const shortcucts = this.editor.shortcuts;
        if (shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_6__.moveLeftKeyboardShortcutId, event)) {
            translation = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(-1, 0);
        }
        else if (shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_6__.moveRightKeyboardShortcutId, event)) {
            translation = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(1, 0);
        }
        else if (shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_6__.moveUpKeyboardShortcutId, event)) {
            translation = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(0, -1);
        }
        else if (shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_6__.moveDownKeyboardShortcutId, event)) {
            translation = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(0, 1);
        }
        else if (shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_6__.zoomInKeyboardShortcutId, event)) {
            scale = 1 / 2;
        }
        else if (shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_6__.zoomOutKeyboardShortcutId, event)) {
            scale = 2;
        }
        else if (shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_6__.rotateClockwiseKeyboardShortcutId, event)) {
            rotation = 1;
        }
        else if (shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_6__.rotateCounterClockwiseKeyboardShortcutId, event)) {
            rotation = -1;
        }
        else {
            return false;
        }
        // For each keypress,
        translation = translation.times(30); // Move at most 30 units
        rotation *= Math.PI / 8; // Rotate at least a sixteenth of a rotation
        // Transform the canvas, not the viewport:
        translation = translation.times(-1);
        rotation = rotation * -1;
        scale = 1 / scale;
        // Work around an issue that seems to be related to rotation matrices losing precision on inversion.
        // TODO: Figure out why and implement a better solution.
        if (rotation !== 0) {
            rotation += 0.0001;
        }
        if (this.isRotationLocked()) {
            rotation = 0;
        }
        const toCanvas = this.editor.viewport.screenToCanvasTransform;
        // Transform without translating (treat toCanvas as a linear instead of
        // an affine transformation).
        translation = toCanvas.transformVec3(translation);
        // Rotate/scale about the center of the canvas
        const transformCenter = this.editor.viewport.visibleRect.center;
        const transformUpdate = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.scaling2D(scale, transformCenter)
            .rightMul(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.zRotation(rotation, transformCenter))
            .rightMul(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.translation(translation));
        this.applyAndFinalizeTransform(transformUpdate);
        return true;
    }
    isRotationLocked() {
        return !!(this.mode & PanZoomMode.RotationLocked);
    }
    /**
     * Changes the types of gestures used by this pan/zoom tool.
     *
     * @see {@link PanZoomMode} {@link setMode}
     *
     * @example
     * ```ts,runnable
     * import { Editor, PanZoomTool, PanZoomMode } from 'js-draw';
     *
     * const editor = new Editor(document.body);
     *
     * // By default, there are multiple PanZoom tools that handle different events.
     * // This gets all PanZoomTools.
     * const panZoomToolList = editor.toolController.getMatchingTools(PanZoomTool);
     *
     * // The first PanZoomTool is the highest priority -- by default,
     * // this tool is responsible for handling multi-finger touch gestures.
     * //
     * // Lower-priority PanZoomTools handle one-finger touch gestures and
     * // key-presses.
     * const panZoomTool = panZoomToolList[0];
     *
     * // Lock rotation for multi-finger touch gestures.
     * panZoomTool.setModeEnabled(PanZoomMode.RotationLocked, true);
     * ```
     */
    setModeEnabled(mode, enabled) {
        let newMode = this.mode;
        if (enabled) {
            newMode |= mode;
        }
        else {
            newMode &= ~mode;
        }
        this.setMode(newMode);
    }
    /**
     * Sets all modes for this tool using a bitmask.
     *
     * @see {@link setModeEnabled}
     *
     * @example
     * ```ts
     * tool.setMode(PanZoomMode.RotationLocked|PanZoomMode.TwoFingerTouchGestures);
     * ```
     */
    setMode(mode) {
        if (mode !== this.mode) {
            this.mode = mode;
            this.editor.notifier.dispatch(_types_mjs__WEBPACK_IMPORTED_MODULE_2__.EditorEventType.ToolUpdated, {
                kind: _types_mjs__WEBPACK_IMPORTED_MODULE_2__.EditorEventType.ToolUpdated,
                tool: this,
            });
        }
    }
    /**
     * Returns a bitmask indicating the currently-enabled modes.
     * @see {@link setModeEnabled}
     */
    getMode() {
        return this.mode;
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/PasteHandler.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/PasteHandler.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PasteHandler)
/* harmony export */ });
/* harmony import */ var _components_TextComponent_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/TextComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/TextComponent.mjs");
/* harmony import */ var _SVGLoader_SVGLoader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../SVGLoader/SVGLoader.mjs */ "./node_modules/js-draw/dist/mjs/SVGLoader/SVGLoader.mjs");
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BaseTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/BaseTool.mjs");
/* harmony import */ var _TextTool_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TextTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/TextTool.mjs");
/* harmony import */ var _components_ImageComponent_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/ImageComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/ImageComponent.mjs");






/**
 * A tool that handles paste events (e.g. as triggered by ctrl+V).
 *
 * @example
 * While `ToolController` has a `PasteHandler` in its default list of tools,
 * if a non-default set is being used, `PasteHandler` can be added as follows:
 * ```ts
 * const toolController = editor.toolController;
 * toolController.addTool(new PasteHandler(editor));
 * ```
 */
class PasteHandler extends _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(editor) {
        super(editor.notifier, editor.localization.pasteHandler);
        this.editor = editor;
    }
    // @internal
    onPaste(event, onComplete) {
        const mime = event.mime.toLowerCase();
        const svgData = (() => {
            if (mime === 'image/svg+xml') {
                return event.data;
            }
            // In some environments, it isn't possible to write non-text data to the
            // clipboard. To support these cases, auto-detect text/plain SVG data.
            if (mime === 'text/plain') {
                const trimmedData = event.data.trim();
                if (trimmedData.startsWith('<svg') && trimmedData.endsWith('</svg>')) {
                    return trimmedData;
                }
            }
            if (mime !== 'text/html') {
                return false;
            }
            // text/html is sometimes handlable SVG data. Use a hueristic
            // to determine if this is the case:
            // We use [^] and not . so that newlines are included.
            const match = event.data.match(/^[^]{0,200}<svg.*/i); // [^]{0,200} <- Allow for metadata near start
            if (!match) {
                return false;
            }
            // Extract the SVG element from the pasted data
            let svgEnd = event.data.toLowerCase().lastIndexOf('</svg>');
            if (svgEnd === -1)
                svgEnd = event.data.length;
            return event.data.substring(event.data.search(/<svg/i), svgEnd);
        })();
        if (svgData) {
            void this.doSVGPaste(svgData).then(onComplete);
            return true;
        }
        else if (mime === 'text/plain') {
            void this.doTextPaste(event.data).then(onComplete);
            return true;
        }
        else if (mime === 'image/png' || mime === 'image/jpeg') {
            void this.doImagePaste(event.data).then(onComplete);
            return true;
        }
        return false;
    }
    async addComponentsFromPaste(components) {
        await this.editor.addAndCenterComponents(components, true, this.editor.localization.pasted(components.length));
    }
    async doSVGPaste(data) {
        this.editor.showLoadingWarning(0);
        try {
            const loader = _SVGLoader_SVGLoader_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].fromString(data, true);
            const components = [];
            await loader.start((component) => {
                components.push(component);
            }, (_countProcessed, _totalToProcess) => null);
            await this.addComponentsFromPaste(components);
        }
        finally {
            this.editor.hideLoadingWarning();
        }
    }
    async doTextPaste(text) {
        const textTools = this.editor.toolController.getMatchingTools(_TextTool_mjs__WEBPACK_IMPORTED_MODULE_4__["default"]);
        textTools.sort((a, b) => {
            if (!a.isEnabled() && b.isEnabled()) {
                return -1;
            }
            if (!b.isEnabled() && a.isEnabled()) {
                return 1;
            }
            return 0;
        });
        const defaultTextStyle = {
            size: 12,
            fontFamily: 'sans',
            renderingStyle: { fill: _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Color4.red },
        };
        const pastedTextStyle = textTools[0]?.getTextStyle() ?? defaultTextStyle;
        // Don't paste text that would be invisible.
        if (text.trim() === '') {
            return;
        }
        const lines = text.split('\n');
        await this.addComponentsFromPaste([
            _components_TextComponent_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].fromLines(lines, _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Mat33.identity, pastedTextStyle),
        ]);
    }
    async doImagePaste(dataURL) {
        const image = new Image();
        image.src = dataURL;
        const component = await _components_ImageComponent_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].fromImage(image, _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Mat33.identity);
        await this.addComponentsFromPaste([component]);
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/Pen.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/Pen.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Pen)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../image/EditorImage.mjs */ "./node_modules/js-draw/dist/mjs/image/EditorImage.mjs");
/* harmony import */ var _Pointer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Pointer.mjs */ "./node_modules/js-draw/dist/mjs/Pointer.mjs");
/* harmony import */ var _components_builders_FreehandLineBuilder_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/builders/FreehandLineBuilder.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/FreehandLineBuilder.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../types.mjs */ "./node_modules/js-draw/dist/mjs/types.mjs");
/* harmony import */ var _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./BaseTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/BaseTool.mjs");
/* harmony import */ var _keybindings_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./keybindings.mjs */ "./node_modules/js-draw/dist/mjs/tools/keybindings.mjs");
/* harmony import */ var _InputFilter_InputStabilizer_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./InputFilter/InputStabilizer.mjs */ "./node_modules/js-draw/dist/mjs/tools/InputFilter/InputStabilizer.mjs");
/* harmony import */ var _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/ReactiveValue.mjs */ "./node_modules/js-draw/dist/mjs/util/ReactiveValue.mjs");
/* harmony import */ var _util_StationaryPenDetector_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./util/StationaryPenDetector.mjs */ "./node_modules/js-draw/dist/mjs/tools/util/StationaryPenDetector.mjs");











/**
 * A tool that allows drawing shapes and freehand lines.
 *
 * To change the type of shape drawn by the pen (e.g. to switch to the rectangle
 * pen type), see {@link setStrokeFactory}.
 */
class Pen extends _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_5__["default"] {
    constructor(editor, description, style) {
        super(editor.notifier, description);
        this.editor = editor;
        this.builder = null;
        this.lastPoint = null;
        this.startPoint = null;
        this.currentDeviceType = null;
        this.currentPointerId = null;
        this.shapeAutocompletionEnabled = false;
        this.autocorrectedShape = null;
        this.lastAutocorrectedShape = null;
        this.removedAutocorrectedShapeTime = 0;
        this.stationaryDetector = null;
        this.styleValue = _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_8__.ReactiveValue.fromInitialValue({
            factory: _components_builders_FreehandLineBuilder_mjs__WEBPACK_IMPORTED_MODULE_3__.makeFreehandLineBuilder,
            color: _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.blue,
            thickness: 4,
            ...style,
        });
        this.styleValue.onUpdateAndNow((newValue) => {
            this.style = newValue;
            this.noteUpdated();
        });
    }
    getPressureMultiplier() {
        const thickness = this.style.thickness;
        return (1 / this.editor.viewport.getScaleFactor()) * thickness;
    }
    // Converts a `pointer` to a `StrokeDataPoint`.
    toStrokePoint(pointer) {
        const minPressure = 0.3;
        let pressure = Math.max(pointer.pressure ?? 1.0, minPressure);
        if (!isFinite(pressure)) {
            console.warn('Non-finite pressure!', pointer);
            pressure = minPressure;
        }
        console.assert(isFinite(pointer.canvasPos.length()), 'Non-finite canvas position!');
        console.assert(isFinite(pointer.screenPos.length()), 'Non-finite screen position!');
        console.assert(isFinite(pointer.timeStamp), 'Non-finite timeStamp on pointer!');
        const pos = pointer.canvasPos;
        return {
            pos,
            width: pressure * this.getPressureMultiplier(),
            color: this.style.color,
            time: pointer.timeStamp,
        };
    }
    // Displays the stroke that is currently being built with the display's `wetInkRenderer`.
    previewStroke() {
        this.editor.clearWetInk();
        const wetInkRenderer = this.editor.display.getWetInkRenderer();
        if (this.autocorrectedShape) {
            const visibleRect = this.editor.viewport.visibleRect;
            this.autocorrectedShape.render(wetInkRenderer, visibleRect);
        }
        else {
            this.builder?.preview(wetInkRenderer);
        }
    }
    // Throws if no stroke builder exists.
    addPointToStroke(point) {
        if (!this.builder) {
            throw new Error('No stroke is currently being generated.');
        }
        this.builder.addPoint(point);
        this.lastPoint = point;
        this.previewStroke();
    }
    onPointerDown(event) {
        // Avoid canceling an existing stroke
        if (this.builder && !this.eventCanCancelStroke(event)) {
            return true;
        }
        const { current, allPointers } = event;
        const isEraser = current.device === _Pointer_mjs__WEBPACK_IMPORTED_MODULE_2__.PointerDevice.Eraser;
        const isPen = current.device === _Pointer_mjs__WEBPACK_IMPORTED_MODULE_2__.PointerDevice.Pen;
        // Always start strokes if the current device is a pen. This is useful in the case
        // where an accidental touch gesture from a user's hand is ongoing. This gesture
        // should not prevent the user from drawing.
        if ((allPointers.length === 1 && !isEraser) || isPen) {
            this.startPoint = this.toStrokePoint(current);
            this.builder = this.style.factory(this.startPoint, this.editor.viewport);
            this.currentDeviceType = current.device;
            this.currentPointerId = current.id;
            if (this.shapeAutocompletionEnabled) {
                this.stationaryDetector = new _util_StationaryPenDetector_mjs__WEBPACK_IMPORTED_MODULE_9__["default"](current, _util_StationaryPenDetector_mjs__WEBPACK_IMPORTED_MODULE_9__.defaultStationaryDetectionConfig, (pointer) => this.autocorrectShape(pointer));
            }
            else {
                this.stationaryDetector = null;
            }
            this.lastAutocorrectedShape = null;
            this.removedAutocorrectedShapeTime = 0;
            return true;
        }
        return false;
    }
    eventCanCancelStroke(event) {
        // If there has been a delay since the last input event,
        // it's always okay to cancel
        const lastInputTime = this.lastPoint?.time ?? 0;
        if (event.current.timeStamp - lastInputTime > 1000) {
            return true;
        }
        const isPenStroke = this.currentDeviceType === _Pointer_mjs__WEBPACK_IMPORTED_MODULE_2__.PointerDevice.Pen;
        const isTouchEvent = event.current.device === _Pointer_mjs__WEBPACK_IMPORTED_MODULE_2__.PointerDevice.Touch;
        // Don't allow pen strokes to be cancelled by touch events.
        if (isPenStroke && isTouchEvent) {
            return false;
        }
        return true;
    }
    eventCanBeDeliveredToNonActiveTool(event) {
        return this.eventCanCancelStroke(event);
    }
    onPointerMove({ current }) {
        if (!this.builder)
            return;
        if (current.device !== this.currentDeviceType)
            return;
        if (current.id !== this.currentPointerId)
            return;
        const isStationary = this.stationaryDetector?.onPointerMove(current);
        if (!isStationary) {
            this.addPointToStroke(this.toStrokePoint(current));
            if (this.autocorrectedShape) {
                this.removedAutocorrectedShapeTime = performance.now();
                this.autocorrectedShape = null;
                this.editor.announceForAccessibility(this.editor.localization.autocorrectionCanceled);
            }
        }
    }
    onPointerUp({ current }) {
        if (!this.builder)
            return false;
        if (current.id !== this.currentPointerId) {
            // this.builder still exists, so we're handling events from another
            // device type.
            return true;
        }
        this.stationaryDetector?.onPointerUp(current);
        // onPointerUp events can have zero pressure. Use the last pressure instead.
        const currentPoint = this.toStrokePoint(current);
        const strokePoint = {
            ...currentPoint,
            width: this.lastPoint?.width ?? currentPoint.width,
        };
        this.addPointToStroke(strokePoint);
        this.finalizeStroke();
        return false;
    }
    onGestureCancel() {
        this.builder = null;
        this.editor.clearWetInk();
        this.stationaryDetector?.destroy();
        this.stationaryDetector = null;
    }
    removedAutocorrectedShapeRecently() {
        return this.removedAutocorrectedShapeTime > performance.now() - 320;
    }
    async autocorrectShape(_lastPointer) {
        if (!this.builder || !this.builder.autocorrectShape)
            return;
        if (!this.shapeAutocompletionEnabled)
            return;
        // If already corrected, do nothing
        if (this.autocorrectedShape)
            return;
        // Activate stroke fitting
        const correctedShape = await this.builder.autocorrectShape();
        if (!this.builder || !correctedShape) {
            return;
        }
        // Don't complete to empty shapes.
        const bboxArea = correctedShape.getBBox().area;
        if (bboxArea === 0 || !isFinite(bboxArea)) {
            return;
        }
        const shapeDescription = correctedShape.description(this.editor.localization);
        this.editor.announceForAccessibility(this.editor.localization.autocorrectedTo(shapeDescription));
        this.autocorrectedShape = correctedShape;
        this.lastAutocorrectedShape = correctedShape;
        this.previewStroke();
    }
    finalizeStroke() {
        if (this.builder) {
            // If autocorrectedShape was cleared recently enough, it was
            // probably by mistake. Reset it.
            if (this.lastAutocorrectedShape && this.removedAutocorrectedShapeRecently()) {
                this.autocorrectedShape = this.lastAutocorrectedShape;
            }
            const stroke = this.autocorrectedShape ?? this.builder.build();
            this.previewStroke();
            if (stroke.getBBox().area > 0) {
                if (stroke === this.autocorrectedShape) {
                    this.editor.announceForAccessibility(this.editor.localization.autocorrectedTo(stroke.description(this.editor.localization)));
                }
                const canFlatten = true;
                const action = _image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].addElement(stroke, canFlatten);
                this.editor.dispatch(action);
            }
            else {
                console.warn('Pen: Not adding empty stroke', stroke, 'to the canvas.');
            }
        }
        this.builder = null;
        this.lastPoint = null;
        this.autocorrectedShape = null;
        this.lastAutocorrectedShape = null;
        this.editor.clearWetInk();
        this.stationaryDetector?.destroy();
        this.stationaryDetector = null;
    }
    noteUpdated() {
        this.editor.notifier.dispatch(_types_mjs__WEBPACK_IMPORTED_MODULE_4__.EditorEventType.ToolUpdated, {
            kind: _types_mjs__WEBPACK_IMPORTED_MODULE_4__.EditorEventType.ToolUpdated,
            tool: this,
        });
    }
    setColor(color) {
        if (color.toHexString() !== this.style.color.toHexString()) {
            this.styleValue.set({
                ...this.style,
                color,
            });
        }
    }
    setThickness(thickness) {
        if (thickness !== this.style.thickness) {
            this.styleValue.set({
                ...this.style,
                thickness,
            });
        }
    }
    /**
     * Changes the type of stroke created by the pen. The given `factory` can be one of the built-in
     * stroke factories (e.g. {@link makeFreehandLineBuilder}) or a custom stroke factory.
     *
     * Example:
     * [[include:doc-pages/inline-examples/changing-pen-types.md]]
     */
    setStrokeFactory(factory) {
        if (factory !== this.style.factory) {
            this.styleValue.set({
                ...this.style,
                factory,
            });
        }
    }
    setHasStabilization(hasStabilization) {
        const hasInputMapper = !!this.getInputMapper();
        // TODO: Currently, this assumes that there is no other input mapper.
        if (hasStabilization === hasInputMapper) {
            return;
        }
        if (hasInputMapper) {
            this.setInputMapper(null);
        }
        else {
            this.setInputMapper(new _InputFilter_InputStabilizer_mjs__WEBPACK_IMPORTED_MODULE_7__["default"](this.editor.viewport));
        }
        this.noteUpdated();
    }
    setStrokeAutocorrectEnabled(enabled) {
        if (enabled !== this.shapeAutocompletionEnabled) {
            this.shapeAutocompletionEnabled = enabled;
            this.noteUpdated();
        }
    }
    getStrokeAutocorrectionEnabled() {
        return this.shapeAutocompletionEnabled;
    }
    getThickness() {
        return this.style.thickness;
    }
    getColor() {
        return this.style.color;
    }
    getStrokeFactory() {
        return this.style.factory;
    }
    getStyleValue() {
        return this.styleValue;
    }
    onKeyPress(event) {
        const shortcuts = this.editor.shortcuts;
        // Ctrl+Z: End the stroke so that it can be undone/redone.
        const isCtrlZ = shortcuts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_6__.undoKeyboardShortcutId, event);
        if (this.builder && isCtrlZ) {
            this.finalizeStroke();
            // Return false: Allow other listeners to handle the event (e.g.
            // undo/redo).
            return false;
        }
        let newThickness;
        if (shortcuts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_6__.decreaseSizeKeyboardShortcutId, event)) {
            newThickness = (this.getThickness() * 2) / 3;
        }
        else if (shortcuts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_6__.increaseSizeKeyboardShortcutId, event)) {
            newThickness = (this.getThickness() * 3) / 2;
        }
        if (newThickness !== undefined) {
            newThickness = Math.min(Math.max(1, newThickness), 256);
            this.setThickness(newThickness);
            return true;
        }
        return false;
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/PipetteTool.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/PipetteTool.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PipetteTool)
/* harmony export */ });
/* harmony import */ var _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/BaseTool.mjs");
// @internal @packageDocumentation

/**
 * A tool used internally to pick colors from the canvas.
 *
 * When color selection is in progress, the `pipette--color-selection-in-progress` class
 * is added to the root element. This can be used by themes.
 *
 * @internal
 */
class PipetteTool extends _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(editor, description) {
        super(editor.notifier, description);
        this.editor = editor;
        this.colorPreviewListener = null;
        this.colorSelectListener = null;
        this.enabledValue().onUpdateAndNow(() => {
            this.updateSelectingStatus();
        });
    }
    canReceiveInputInReadOnlyEditor() {
        return true;
    }
    // Ensures that the root editor element correctly reflects whether color selection
    // is in progress.
    updateSelectingStatus() {
        const className = 'pipette--color-selection-in-progress';
        if (this.isEnabled() && this.colorSelectListener && this.colorPreviewListener) {
            this.editor.getRootElement().classList.add(className);
        }
        else {
            this.editor.getRootElement().classList.remove(className);
        }
    }
    setColorListener(colorPreviewListener, 
    // Called when the gesture ends -- when the user has selected a color.
    colorSelectListener) {
        this.colorPreviewListener = colorPreviewListener;
        this.colorSelectListener = colorSelectListener;
        this.updateSelectingStatus();
    }
    clearColorListener() {
        this.colorPreviewListener = null;
        this.colorSelectListener = null;
        this.updateSelectingStatus();
    }
    onPointerDown({ current, allPointers }) {
        if (this.colorPreviewListener && allPointers.length === 1) {
            this.colorPreviewListener(this.editor.display.getColorAt(current.screenPos));
            return true;
        }
        return false;
    }
    onPointerMove({ current }) {
        this.colorPreviewListener?.(this.editor.display.getColorAt(current.screenPos));
    }
    onPointerUp({ current }) {
        this.colorSelectListener?.(this.editor.display.getColorAt(current.screenPos));
    }
    onGestureCancel() {
        this.colorSelectListener?.(null);
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/ScrollbarTool.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/ScrollbarTool.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ScrollbarTool)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types.mjs */ "./node_modules/js-draw/dist/mjs/types.mjs");
/* harmony import */ var _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/BaseTool.mjs");



/**
 * This tool, when enabled, renders scrollbars reflecting the current position
 * of the view relative to the import/export area of the image.
 *
 * **Note**: These scrollbars are currently not draggable. This may change in
 * a future release.
 */
class ScrollbarTool extends _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(editor) {
        super(editor.notifier, 'scrollbar');
        this.editor = editor;
        this.fadeOutTimeout = null;
        this.scrollbarOverlay = document.createElement('div');
        this.scrollbarOverlay.classList.add('ScrollbarTool-overlay');
        this.verticalScrollbar = document.createElement('div');
        this.verticalScrollbar.classList.add('vertical-scrollbar');
        this.horizontalScrollbar = document.createElement('div');
        this.horizontalScrollbar.classList.add('horizontal-scrollbar');
        this.scrollbarOverlay.replaceChildren(this.verticalScrollbar, this.horizontalScrollbar);
        let overlay = null;
        let viewportListener = null;
        this.enabledValue().onUpdateAndNow((enabled) => {
            overlay?.remove();
            viewportListener?.remove();
            viewportListener = null;
            overlay = null;
            if (enabled) {
                viewportListener = editor.notifier.on(_types_mjs__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.ViewportChanged, (_event) => {
                    this.updateScrollbars();
                });
                this.updateScrollbars();
                overlay = editor.createHTMLOverlay(this.scrollbarOverlay);
            }
        });
    }
    updateScrollbars() {
        const viewport = this.editor.viewport;
        const screenSize = viewport.getScreenRectSize();
        const screenRect = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2(0, 0, screenSize.x, screenSize.y);
        const imageRect = this.editor
            .getImportExportRect()
            // The scrollbars are positioned in screen coordinates, so the exportRect also needs
            // to be in screen coordinates
            .transformedBoundingBox(viewport.canvasToScreenTransform)
            // If the screenRect is outside of the exportRect, expand the image rectangle
            .union(screenRect);
        const scrollbarWidth = (screenRect.width / imageRect.width) * screenSize.x;
        const scrollbarHeight = (screenRect.height / imageRect.height) * screenSize.y;
        const scrollbarX = ((screenRect.x - imageRect.x) / imageRect.width) * screenSize.x;
        const scrollbarY = ((screenRect.y - imageRect.y) / imageRect.height) * screenSize.y;
        this.horizontalScrollbar.style.width = `${scrollbarWidth}px`;
        this.verticalScrollbar.style.height = `${scrollbarHeight}px`;
        this.horizontalScrollbar.style.marginLeft = `${scrollbarX}px`;
        this.verticalScrollbar.style.marginTop = `${scrollbarY}px`;
        // Style the scrollbars differently when there's no scroll (all content visible)
        const handleNoScrollStyling = (scrollbar, size, fillSize) => {
            const fillsWindowClass = 'represents-no-scroll';
            if (Math.abs(size - fillSize) < 1e-8) {
                scrollbar.classList.add(fillsWindowClass);
            }
            else {
                scrollbar.classList.remove(fillsWindowClass);
            }
        };
        handleNoScrollStyling(this.horizontalScrollbar, scrollbarWidth, screenSize.x);
        handleNoScrollStyling(this.verticalScrollbar, scrollbarHeight, screenSize.y);
        // Fade out after a delay.
        if (this.fadeOutTimeout !== null) {
            clearTimeout(this.fadeOutTimeout);
        }
        const fadeOutDelay = 3000;
        this.fadeOutTimeout = setTimeout(() => {
            this.scrollbarOverlay.classList.remove('just-updated');
        }, fadeOutDelay);
        this.scrollbarOverlay.classList.add('just-updated');
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectAllShortcutHandler.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectAllShortcutHandler.mjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SelectAllShortcutHandler)
/* harmony export */ });
/* harmony import */ var _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../BaseTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/BaseTool.mjs");
/* harmony import */ var _keybindings_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../keybindings.mjs */ "./node_modules/js-draw/dist/mjs/tools/keybindings.mjs");
/* harmony import */ var _SelectionTool_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SelectionTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionTool.mjs");



// Handles ctrl+a: Select all
class SelectAllShortcutHandler extends _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(editor) {
        super(editor.notifier, editor.localization.selectAllTool);
        this.editor = editor;
    }
    canReceiveInputInReadOnlyEditor() {
        return true;
    }
    // @internal
    onKeyPress(event) {
        if (this.editor.shortcuts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_1__.selectAllKeyboardShortcut, event)) {
            const selectionTools = this.editor.toolController.getMatchingTools(_SelectionTool_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]);
            if (selectionTools.length > 0) {
                const selectionTool = selectionTools[0];
                selectionTool.setEnabled(true);
                selectionTool.setSelection(this.editor.image.getAllElements());
                return true;
            }
        }
        return false;
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/Selection.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/SelectionTool/Selection.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _commands_SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../commands/SerializableCommand.mjs */ "./node_modules/js-draw/dist/mjs/commands/SerializableCommand.mjs");
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _SelectionHandle_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SelectionHandle.mjs */ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionHandle.mjs");
/* harmony import */ var _SelectionTool_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SelectionTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionTool.mjs");
/* harmony import */ var _Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Viewport.mjs */ "./node_modules/js-draw/dist/mjs/Viewport.mjs");
/* harmony import */ var _commands_Erase_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../commands/Erase.mjs */ "./node_modules/js-draw/dist/mjs/commands/Erase.mjs");
/* harmony import */ var _commands_Duplicate_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../commands/Duplicate.mjs */ "./node_modules/js-draw/dist/mjs/commands/Duplicate.mjs");
/* harmony import */ var _TransformMode_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./TransformMode.mjs */ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/TransformMode.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./types.mjs */ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/types.mjs");
/* harmony import */ var _image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../image/EditorImage.mjs */ "./node_modules/js-draw/dist/mjs/image/EditorImage.mjs");
/* harmony import */ var _commands_uniteCommands_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../commands/uniteCommands.mjs */ "./node_modules/js-draw/dist/mjs/commands/uniteCommands.mjs");
/* harmony import */ var _SelectionMenuShortcut_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./SelectionMenuShortcut.mjs */ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionMenuShortcut.mjs");
/**
 * @internal
 * @packageDocumentation
 */
var _a;












const updateChunkSize = 100;
const maxPreviewElemCount = 500;
// @internal
class Selection {
    constructor(startPoint, editor, showContextMenu) {
        this.editor = editor;
        // The last-computed bounding box of selected content
        // @see getTightBoundingBox
        this.selectionTightBoundingBox = null;
        this.transform = _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Mat33.identity;
        // invariant: sorted by increasing z-index
        this.selectedElems = [];
        this.hasParent = true;
        // Maps IDs to whether we removed the component from the image
        this.removedFromImage = {};
        this.activeHandle = null;
        this.backgroundDragging = false;
        this.selectionDuplicatedAnimationTimeout = null;
        this.originalRegion = new _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Rect2(startPoint.x, startPoint.y, 0, 0);
        this.transformers = {
            drag: new _TransformMode_mjs__WEBPACK_IMPORTED_MODULE_7__.DragTransformer(editor, this),
            resize: new _TransformMode_mjs__WEBPACK_IMPORTED_MODULE_7__.ResizeTransformer(editor, this),
            rotate: new _TransformMode_mjs__WEBPACK_IMPORTED_MODULE_7__.RotateTransformer(editor, this),
        };
        // We need two containers for some CSS to apply (the outer container
        // needs zero height, the inner needs to prevent the selection background
        // from being visible outside of the editor).
        this.outerContainer = document.createElement('div');
        this.outerContainer.classList.add(`${_SelectionTool_mjs__WEBPACK_IMPORTED_MODULE_3__.cssPrefix}selection-outer-container`);
        this.innerContainer = document.createElement('div');
        this.innerContainer.classList.add(`${_SelectionTool_mjs__WEBPACK_IMPORTED_MODULE_3__.cssPrefix}selection-inner-container`);
        this.backgroundElem = document.createElement('div');
        this.backgroundElem.classList.add(`${_SelectionTool_mjs__WEBPACK_IMPORTED_MODULE_3__.cssPrefix}selection-background`);
        this.innerContainer.appendChild(this.backgroundElem);
        this.outerContainer.appendChild(this.innerContainer);
        const makeResizeHandle = (mode, side) => {
            const modeToAction = {
                [_types_mjs__WEBPACK_IMPORTED_MODULE_8__.ResizeMode.Both]: _SelectionHandle_mjs__WEBPACK_IMPORTED_MODULE_2__.HandleAction.ResizeXY,
                [_types_mjs__WEBPACK_IMPORTED_MODULE_8__.ResizeMode.HorizontalOnly]: _SelectionHandle_mjs__WEBPACK_IMPORTED_MODULE_2__.HandleAction.ResizeX,
                [_types_mjs__WEBPACK_IMPORTED_MODULE_8__.ResizeMode.VerticalOnly]: _SelectionHandle_mjs__WEBPACK_IMPORTED_MODULE_2__.HandleAction.ResizeY,
            };
            return new _SelectionHandle_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]({
                action: modeToAction[mode],
                side,
            }, this, this.editor.viewport, (startPoint) => this.transformers.resize.onDragStart(startPoint, mode), (currentPoint) => this.transformers.resize.onDragUpdate(currentPoint), () => this.transformers.resize.onDragEnd());
        };
        const resizeHorizontalHandles = [
            makeResizeHandle(_types_mjs__WEBPACK_IMPORTED_MODULE_8__.ResizeMode.HorizontalOnly, _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(0, 0.5)),
            makeResizeHandle(_types_mjs__WEBPACK_IMPORTED_MODULE_8__.ResizeMode.HorizontalOnly, _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(1, 0.5)),
        ];
        const resizeVerticalHandle = makeResizeHandle(_types_mjs__WEBPACK_IMPORTED_MODULE_8__.ResizeMode.VerticalOnly, _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(0.5, 1));
        const resizeBothHandle = makeResizeHandle(_types_mjs__WEBPACK_IMPORTED_MODULE_8__.ResizeMode.Both, _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(1, 1));
        const rotationHandle = new _SelectionHandle_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]({
            action: _SelectionHandle_mjs__WEBPACK_IMPORTED_MODULE_2__.HandleAction.Rotate,
            side: _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(0.5, 0),
            icon: this.editor.icons.makeRotateIcon(),
        }, this, this.editor.viewport, (startPoint) => this.transformers.rotate.onDragStart(startPoint), (currentPoint) => this.transformers.rotate.onDragUpdate(currentPoint), () => this.transformers.rotate.onDragEnd());
        const menuToggleButton = new _SelectionMenuShortcut_mjs__WEBPACK_IMPORTED_MODULE_11__["default"](this, this.editor.viewport, this.editor.icons.makeOverflowIcon(), showContextMenu, this.editor.localization);
        this.childwidgets = [
            menuToggleButton,
            resizeBothHandle,
            ...resizeHorizontalHandles,
            resizeVerticalHandle,
            rotationHandle,
        ];
        for (const widget of this.childwidgets) {
            widget.addTo(this.backgroundElem);
        }
        this.updateUI();
    }
    // @internal Intended for unit tests
    getBackgroundElem() {
        return this.backgroundElem;
    }
    getTransform() {
        return this.transform;
    }
    get preTransformRegion() {
        return this.originalRegion;
    }
    // The **canvas** region.
    get region() {
        // TODO: This currently assumes that the region rotates about its center.
        // This may not be true.
        const rotationMatrix = _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Mat33.zRotation(this.regionRotation, this.originalRegion.center);
        const scaleAndTranslateMat = this.transform.rightMul(rotationMatrix.inverse());
        return this.originalRegion.transformedBoundingBox(scaleAndTranslateMat);
    }
    /**
     * Computes and returns the bounding box of the selection without
     * any additional padding. Computes directly from the elements that are selected.
     * @internal
     */
    computeTightBoundingBox() {
        const bbox = this.selectedElems.reduce((accumulator, elem) => {
            return (accumulator ?? elem.getBBox()).union(elem.getBBox());
        }, null);
        return bbox ?? _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Rect2.empty;
    }
    get regionRotation() {
        return this.transform.transformVec3(_js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Vec2.unitX).angle();
    }
    get preTransformedScreenRegion() {
        const toScreen = (vec) => this.editor.viewport.canvasToScreen(vec);
        return _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Rect2.fromCorners(toScreen(this.preTransformRegion.topLeft), toScreen(this.preTransformRegion.bottomRight));
    }
    get preTransformedScreenRegionRotation() {
        return this.editor.viewport.getRotationAngle();
    }
    getScreenRegion() {
        const toScreen = this.editor.viewport.canvasToScreenTransform;
        const scaleFactor = this.editor.viewport.getScaleFactor();
        const screenCenter = toScreen.transformVec2(this.region.center);
        return new _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Rect2(screenCenter.x, screenCenter.y, scaleFactor * this.region.width, scaleFactor * this.region.height).translatedBy(this.region.size.times(-scaleFactor / 2));
    }
    get screenRegionRotation() {
        return this.regionRotation + this.editor.viewport.getRotationAngle();
    }
    // Applies, previews, but doesn't finalize the given transformation.
    setTransform(transform, preview = true) {
        this.transform = transform;
        if (preview && this.hasParent) {
            this.previewTransformCmds();
        }
    }
    getDeltaZIndexToMoveSelectionToTop() {
        if (this.selectedElems.length === 0) {
            return 0;
        }
        const selectedBottommostZIndex = this.selectedElems[0].getZIndex();
        const visibleObjects = this.editor.image.getElementsIntersectingRegion(this.region);
        const topMostVisibleZIndex = visibleObjects[visibleObjects.length - 1]?.getZIndex() ?? selectedBottommostZIndex;
        const deltaZIndex = topMostVisibleZIndex + 1 - selectedBottommostZIndex;
        return deltaZIndex;
    }
    // Applies the current transformation to the selection
    finalizeTransform() {
        const fullTransform = this.transform;
        const selectedElems = this.selectedElems;
        // Reset for the next drag
        this.originalRegion = this.originalRegion.transformedBoundingBox(this.transform);
        this.transform = _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Mat33.identity;
        this.scrollTo();
        let transformPromise = undefined;
        // Make the commands undo-able.
        // Don't check for non-empty transforms because this breaks changing the
        // z-index of the just-transformed commands.
        if (this.selectedElems.length > 0) {
            const deltaZIndex = this.getDeltaZIndexToMoveSelectionToTop();
            transformPromise = this.editor.dispatch(new _a.ApplyTransformationCommand(this, selectedElems, fullTransform, deltaZIndex));
        }
        return transformPromise;
    }
    /** Sends all selected elements to the bottom of the visible image. */
    sendToBack() {
        const visibleObjects = this.editor.image.getElementsIntersectingRegion(this.editor.viewport.visibleRect);
        // VisibleObjects and selectedElems should both be sorted by z-index
        const lowestVisibleZIndex = visibleObjects[0]?.getZIndex() ?? 0;
        const highestSelectedZIndex = this.selectedElems[this.selectedElems.length - 1]?.getZIndex() ?? 0;
        const targetHighestZIndex = lowestVisibleZIndex - 1;
        const deltaZIndex = targetHighestZIndex - highestSelectedZIndex;
        if (deltaZIndex !== 0) {
            const commands = this.selectedElems.map((elem) => {
                return elem.setZIndex(elem.getZIndex() + deltaZIndex);
            });
            return (0,_commands_uniteCommands_mjs__WEBPACK_IMPORTED_MODULE_10__["default"])(commands, updateChunkSize);
        }
        return null;
    }
    // Preview the effects of the current transformation on the selection
    previewTransformCmds() {
        if (this.selectedElems.length === 0) {
            return;
        }
        // Don't render what we're moving if it's likely to be slow.
        if (this.selectedElems.length > maxPreviewElemCount) {
            this.updateUI();
            return;
        }
        const wetInkRenderer = this.editor.display.getWetInkRenderer();
        wetInkRenderer.clear();
        wetInkRenderer.pushTransform(this.transform);
        const viewportVisibleRect = this.editor.viewport.visibleRect.union(this.region);
        const visibleRect = viewportVisibleRect.transformedBoundingBox(this.transform.inverse());
        for (const elem of this.selectedElems) {
            elem.render(wetInkRenderer, visibleRect);
        }
        wetInkRenderer.popTransform();
        this.updateUI();
    }
    // Find the objects corresponding to this in the document,
    // select them.
    // Returns false iff nothing was selected.
    resolveToObjects() {
        let singleItemSelectionMode = false;
        this.transform = _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Mat33.identity;
        // Grow the rectangle, if necessary
        if (this.region.w === 0 || this.region.h === 0) {
            const padding = this.editor.viewport.visibleRect.maxDimension / 200;
            this.originalRegion = _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Rect2.bboxOf(this.region.corners, padding);
            // Only select one item if the rectangle was very small.
            singleItemSelectionMode = true;
        }
        this.selectedElems = this.editor.image
            .getElementsIntersectingRegion(this.region)
            .filter((elem) => {
            return elem.intersectsRect(this.region) && elem.isSelectable();
        });
        if (singleItemSelectionMode && this.selectedElems.length > 0) {
            this.selectedElems = [this.selectedElems[this.selectedElems.length - 1]];
        }
        // Find the bounding box of all selected elements.
        if (!this.recomputeRegion()) {
            return false;
        }
        this.updateUI();
        return true;
    }
    // Recompute this' region from the selected elements.
    // Returns false if the selection is empty.
    recomputeRegion() {
        const newRegion = this.computeTightBoundingBox();
        this.selectionTightBoundingBox = newRegion;
        if (!newRegion) {
            this.cancelSelection();
            return false;
        }
        this.originalRegion = newRegion;
        this.padRegion();
        return true;
    }
    // Applies padding to the current region if it is too small.
    // @internal
    padRegion() {
        const sourceRegion = this.selectionTightBoundingBox ?? this.originalRegion;
        const minSize = this.getMinCanvasSize();
        if (sourceRegion.w < minSize || sourceRegion.h < minSize) {
            // Add padding
            const padding = minSize / 2;
            this.originalRegion = _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Rect2.bboxOf(sourceRegion.corners, padding);
            this.updateUI();
        }
    }
    getMinCanvasSize() {
        const canvasHandleSize = _SelectionHandle_mjs__WEBPACK_IMPORTED_MODULE_2__.handleSize / this.editor.viewport.getScaleFactor();
        return canvasHandleSize * 2;
    }
    getSelectedItemCount() {
        return this.selectedElems.length;
    }
    // @internal
    updateUI() {
        // Don't update old selections.
        if (!this.hasParent) {
            return;
        }
        const screenRegion = this.getScreenRegion();
        // marginLeft, marginTop: Display relative to the top left of the selection overlay.
        // left, top don't work for this.
        this.backgroundElem.style.marginLeft = `${screenRegion.topLeft.x}px`;
        this.backgroundElem.style.marginTop = `${screenRegion.topLeft.y}px`;
        this.backgroundElem.style.width = `${screenRegion.width}px`;
        this.backgroundElem.style.height = `${screenRegion.height}px`;
        const rotationDeg = (this.screenRegionRotation * 180) / Math.PI;
        this.backgroundElem.style.transform = `rotate(${rotationDeg}deg)`;
        this.backgroundElem.style.transformOrigin = 'center';
        // If closer to perpendicular, apply different CSS
        const perpendicularClassName = `${_SelectionTool_mjs__WEBPACK_IMPORTED_MODULE_3__.cssPrefix}rotated-near-perpendicular`;
        if (Math.abs(Math.sin(this.screenRegionRotation)) > 0.5) {
            this.innerContainer.classList.add(perpendicularClassName);
        }
        else {
            this.innerContainer.classList.remove(perpendicularClassName);
        }
        // Hide handles when empty
        if (screenRegion.width === 0 && screenRegion.height === 0) {
            this.innerContainer.classList.add('-empty');
        }
        else {
            this.innerContainer.classList.remove('-empty');
        }
        for (const widget of this.childwidgets) {
            widget.updatePosition(this.getScreenRegion());
        }
    }
    // Add/remove the contents of this seleciton from the editor.
    // Used to prevent previewed content from looking like duplicate content
    // while dragging.
    //
    // Does nothing if a large number of elements are selected (and so modifying
    // the editor image is likely to be slow.)
    //
    // If removed from the image, selected elements are drawn as wet ink.
    //
    // [inImage] should be `true` if the selected elements should be added to the
    // main image, `false` if they should be removed.
    addRemoveSelectionFromImage(inImage) {
        // Don't hide elements if doing so will be slow.
        if (!inImage && this.selectedElems.length > maxPreviewElemCount) {
            return;
        }
        for (const elem of this.selectedElems) {
            const parent = this.editor.image.findParent(elem);
            if (!inImage && parent) {
                this.removedFromImage[elem.getId()] = true;
                parent.remove();
            }
            // If we're making things visible and the selected object wasn't previously
            // visible,
            else if (!parent && this.removedFromImage[elem.getId()]) {
                _image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_9__["default"].addElement(elem).apply(this.editor);
                this.removedFromImage[elem.getId()] = false;
                delete this.removedFromImage[elem.getId()];
            }
        }
        // Don't await queueRerender. If we're running in a test, the re-render might never
        // happen.
        this.editor.queueRerender().then(() => {
            if (!inImage) {
                this.previewTransformCmds();
            }
            else {
                // Clear renderings of any in-progress transformations
                const wetInkRenderer = this.editor.display.getWetInkRenderer();
                wetInkRenderer.clear();
            }
        });
    }
    removeDeletedElemsFromSelection() {
        // Remove any deleted elements from the selection.
        this.selectedElems = this.selectedElems.filter((elem) => {
            const hasParent = !!this.editor.image.findParent(elem);
            // If we removed the element and haven't added it back yet, don't remove it
            // from the selection.
            const weRemoved = this.removedFromImage[elem.getId()];
            return hasParent || weRemoved;
        });
    }
    onDragStart(pointer) {
        // Clear the HTML selection (prevent HTML drag and drop being triggered by this drag)
        document.getSelection()?.removeAllRanges();
        this.activeHandle = null;
        let result = false;
        this.backgroundDragging = false;
        if (this.region.containsPoint(pointer.canvasPos)) {
            this.backgroundDragging = true;
            result = true;
        }
        for (const widget of this.childwidgets) {
            if (widget.containsPoint(pointer.canvasPos)) {
                this.activeHandle = widget;
                this.backgroundDragging = false;
                result = true;
            }
        }
        if (result) {
            this.removeDeletedElemsFromSelection();
            this.addRemoveSelectionFromImage(false);
        }
        if (this.activeHandle) {
            this.activeHandle.handleDragStart(pointer);
        }
        if (this.backgroundDragging) {
            this.transformers.drag.onDragStart(pointer.canvasPos);
        }
        return result;
    }
    onDragUpdate(pointer) {
        if (this.backgroundDragging) {
            this.transformers.drag.onDragUpdate(pointer.canvasPos);
        }
        if (this.activeHandle) {
            this.activeHandle.handleDragUpdate(pointer);
        }
    }
    onDragEnd() {
        if (this.backgroundDragging) {
            this.transformers.drag.onDragEnd();
        }
        else if (this.activeHandle) {
            this.activeHandle.handleDragEnd();
        }
        this.addRemoveSelectionFromImage(true);
        this.backgroundDragging = false;
        this.activeHandle = null;
        this.updateUI();
    }
    onDragCancel() {
        this.backgroundDragging = false;
        this.activeHandle = null;
        this.setTransform(_js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Mat33.identity);
        this.addRemoveSelectionFromImage(true);
        this.updateUI();
    }
    // Scroll the viewport to this. Does not zoom
    scrollTo() {
        if (this.selectedElems.length === 0) {
            return false;
        }
        const screenSize = this.editor.viewport.getScreenRectSize();
        const screenRect = new _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Rect2(0, 0, screenSize.x, screenSize.y);
        const selectionScreenRegion = this.getScreenRegion();
        if (!screenRect.containsPoint(selectionScreenRegion.center)) {
            const targetPointScreen = selectionScreenRegion.center;
            const closestPointScreen = screenRect.getClosestPointOnBoundaryTo(targetPointScreen);
            const closestPointCanvas = this.editor.viewport.screenToCanvas(closestPointScreen);
            const targetPointCanvas = this.region.center;
            const delta = closestPointCanvas.minus(targetPointCanvas);
            this.editor.dispatchNoAnnounce(_Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].transformBy(_js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Mat33.translation(delta.times(0.5))), false);
            this.editor.queueRerender().then(() => {
                this.previewTransformCmds();
            });
            return true;
        }
        return false;
    }
    deleteSelectedObjects() {
        if (this.backgroundDragging || this.activeHandle) {
            this.onDragEnd();
        }
        return new _commands_Erase_mjs__WEBPACK_IMPORTED_MODULE_5__["default"](this.selectedElems);
    }
    runSelectionDuplicatedAnimation() {
        if (this.selectionDuplicatedAnimationTimeout) {
            clearTimeout(this.selectionDuplicatedAnimationTimeout);
        }
        const animationDuration = 400; // ms
        this.backgroundElem.style.animation = `${animationDuration}ms ease selection-duplicated-animation`;
        this.selectionDuplicatedAnimationTimeout = setTimeout(() => {
            this.backgroundElem.style.animation = '';
            this.selectionDuplicatedAnimationTimeout = null;
        }, animationDuration);
    }
    async duplicateSelectedObjects() {
        const wasTransforming = this.backgroundDragging || this.activeHandle;
        let tmpApplyCommand = null;
        if (!wasTransforming) {
            this.runSelectionDuplicatedAnimation();
        }
        let command;
        if (wasTransforming) {
            // Don't update the selection's focus when redoing/undoing
            const selectionToUpdate = null;
            const deltaZIndex = this.getDeltaZIndexToMoveSelectionToTop();
            tmpApplyCommand = new _a.ApplyTransformationCommand(selectionToUpdate, this.selectedElems, this.transform, deltaZIndex);
            // Transform to ensure that the duplicates are in the correct location
            await tmpApplyCommand.apply(this.editor);
            // Show items again
            this.addRemoveSelectionFromImage(true);
            // With the transformation applied, create the duplicates
            command = (0,_commands_uniteCommands_mjs__WEBPACK_IMPORTED_MODULE_10__["default"])(this.selectedElems.map((elem) => {
                return _image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_9__["default"].addElement(elem.clone());
            }));
            // Move the selected objects back to the correct location.
            await tmpApplyCommand?.unapply(this.editor);
            this.addRemoveSelectionFromImage(false);
            this.previewTransformCmds();
            this.updateUI();
        }
        else {
            command = new _commands_Duplicate_mjs__WEBPACK_IMPORTED_MODULE_6__["default"](this.selectedElems);
        }
        return command;
    }
    setHandlesVisible(showHandles) {
        if (!showHandles) {
            this.innerContainer.classList.add('-hide-handles');
        }
        else {
            this.innerContainer.classList.remove('-hide-handles');
        }
    }
    addTo(elem) {
        if (this.outerContainer.parentElement) {
            this.outerContainer.remove();
        }
        elem.appendChild(this.outerContainer);
        this.hasParent = true;
    }
    setToPoint(point) {
        this.originalRegion = this.originalRegion.grownToPoint(point);
        this.selectionTightBoundingBox = null;
        this.updateUI();
    }
    cancelSelection() {
        if (this.outerContainer.parentElement) {
            this.outerContainer.remove();
        }
        this.originalRegion = _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Rect2.empty;
        this.selectionTightBoundingBox = null;
        this.hasParent = false;
    }
    setSelectedObjects(objects, bbox) {
        this.addRemoveSelectionFromImage(true);
        this.originalRegion = bbox;
        this.selectionTightBoundingBox = bbox;
        this.selectedElems = objects.filter((object) => object.isSelectable());
        // Enforce increasing z-index invariant
        this.selectedElems.sort((a, b) => a.getZIndex() - b.getZIndex());
        this.padRegion();
        this.updateUI();
    }
    getSelectedObjects() {
        return [...this.selectedElems];
    }
}
_a = Selection;
(() => {
    _commands_SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].register('selection-tool-transform', (json, _editor) => {
        // The selection box is lost when serializing/deserializing. No need to store box rotation
        const fullTransform = new _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Mat33(...json.transform);
        const elemIds = json.elems ?? [];
        const deltaZIndex = parseInt(json.deltaZIndex ?? 0);
        return new _a.ApplyTransformationCommand(null, elemIds, fullTransform, deltaZIndex);
    });
})();
Selection.ApplyTransformationCommand = class extends _commands_SerializableCommand_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(selection, 
    // If a `string[]`, selectedElems is a list of element IDs.
    selectedElems, 
    // Full transformation used to transform elements.
    fullTransform, deltaZIndex) {
        super('selection-tool-transform');
        this.selection = selection;
        this.fullTransform = fullTransform;
        this.deltaZIndex = deltaZIndex;
        const isIDList = (arr) => {
            return typeof arr[0] === 'string';
        };
        // If a list of element IDs,
        if (isIDList(selectedElems)) {
            this.selectedElemIds = selectedElems;
        }
        else {
            this.selectedElemIds = selectedElems.map((elem) => elem.getId());
            this.transformCommands = selectedElems.map((elem) => {
                return elem.setZIndexAndTransformBy(this.fullTransform, elem.getZIndex() + deltaZIndex);
            });
        }
    }
    resolveToElems(editor, isUndoing) {
        if (this.transformCommands) {
            return;
        }
        this.transformCommands = this.selectedElemIds
            .map((id) => {
            const elem = editor.image.lookupElement(id);
            if (!elem) {
                // There may be valid reasons for an element lookup to fail:
                // For example, if the element was deleted remotely and the remote deletion
                // hasn't been undone.
                console.warn(`Unable to find element with ID, ${id}.`);
                return null;
            }
            let originalZIndex = elem.getZIndex();
            let targetZIndex = elem.getZIndex() + this.deltaZIndex;
            // If the command has already been applied, the element should currently
            // have the target z-index.
            if (isUndoing) {
                targetZIndex = elem.getZIndex();
                originalZIndex = elem.getZIndex() - this.deltaZIndex;
            }
            return elem.setZIndexAndTransformBy(this.fullTransform, targetZIndex, originalZIndex);
        })
            .filter(
        // Remove all null commands
        (command) => command !== null);
    }
    async apply(editor) {
        this.resolveToElems(editor, false);
        this.selection?.setTransform(this.fullTransform, false);
        this.selection?.updateUI();
        await editor.asyncApplyCommands(this.transformCommands, updateChunkSize);
        this.selection?.setTransform(_js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Mat33.identity, false);
        this.selection?.recomputeRegion();
        this.selection?.updateUI();
    }
    async unapply(editor) {
        this.resolveToElems(editor, true);
        this.selection?.setTransform(this.fullTransform.inverse(), false);
        this.selection?.updateUI();
        await editor.asyncUnapplyCommands(this.transformCommands, updateChunkSize, true);
        this.selection?.setTransform(_js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Mat33.identity, false);
        this.selection?.recomputeRegion();
        this.selection?.updateUI();
    }
    serializeToJSON() {
        return {
            elems: this.selectedElemIds,
            transform: this.fullTransform.toArray(),
            deltaZIndex: this.deltaZIndex,
        };
    }
    description(_editor, localizationTable) {
        return localizationTable.transformedElements(this.selectedElemIds.length);
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Selection);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionHandle.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionHandle.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HandleAction: () => (/* binding */ HandleAction),
/* harmony export */   "default": () => (/* binding */ SelectionHandle),
/* harmony export */   handleSize: () => (/* binding */ handleSize)
/* harmony export */ });
/* harmony import */ var _util_assertions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/assertions.mjs */ "./node_modules/js-draw/dist/mjs/util/assertions.mjs");
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _SelectionTool_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SelectionTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionTool.mjs");



var HandleShape;
(function (HandleShape) {
    HandleShape[HandleShape["Circle"] = 0] = "Circle";
    HandleShape[HandleShape["Square"] = 1] = "Square";
})(HandleShape || (HandleShape = {}));
var HandleAction;
(function (HandleAction) {
    HandleAction["ResizeXY"] = "resize-xy";
    HandleAction["Rotate"] = "rotate";
    HandleAction["ResizeX"] = "resize-x";
    HandleAction["ResizeY"] = "resize-y";
})(HandleAction || (HandleAction = {}));
// The *interactable* handle size. The visual size will be slightly smaller.
const handleSize = 30;
class SelectionHandle {
    constructor(presentation, parent, viewport, onDragStart, onDragUpdate, onDragEnd) {
        this.presentation = presentation;
        this.parent = parent;
        this.viewport = viewport;
        this.onDragStart = onDragStart;
        this.onDragUpdate = onDragUpdate;
        this.onDragEnd = onDragEnd;
        this.dragLastPos = null;
        this.element = document.createElement('div');
        this.element.classList.add(`${_SelectionTool_mjs__WEBPACK_IMPORTED_MODULE_2__.cssPrefix}handle`, `${_SelectionTool_mjs__WEBPACK_IMPORTED_MODULE_2__.cssPrefix}${presentation.action}`);
        // Create a slightly smaller content/background element.
        const visibleContent = document.createElement('div');
        visibleContent.classList.add(`${_SelectionTool_mjs__WEBPACK_IMPORTED_MODULE_2__.cssPrefix}content`);
        this.element.appendChild(visibleContent);
        this.parentSide = presentation.side;
        const icon = presentation.icon;
        if (icon) {
            visibleContent.appendChild(icon);
            icon.classList.add('icon');
        }
        if (presentation.action === HandleAction.Rotate) {
            this.shape = HandleShape.Circle;
        }
        else {
            this.shape = HandleShape.Square;
        }
        switch (this.shape) {
            case HandleShape.Circle:
                this.element.classList.add(`${_SelectionTool_mjs__WEBPACK_IMPORTED_MODULE_2__.cssPrefix}circle`);
                break;
            case HandleShape.Square:
                this.element.classList.add(`${_SelectionTool_mjs__WEBPACK_IMPORTED_MODULE_2__.cssPrefix}square`);
                break;
            default:
                (0,_util_assertions_mjs__WEBPACK_IMPORTED_MODULE_0__.assertUnreachable)(this.shape);
        }
        this.updatePosition();
    }
    /**
     * Adds this to `container`, where `conatiner` should be the background/selection
     * element visible on the screen.
     */
    addTo(container) {
        container.appendChild(this.element);
    }
    /**
     * Removes this element from its container. Should only be called
     * after {@link addTo}.
     */
    remove() {
        this.element.remove();
    }
    /**
     * Returns this handle's bounding box relative to the top left of the
     * selection box.
     */
    getBBoxParentCoords() {
        const parentRect = this.parent.getScreenRegion();
        const size = _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(handleSize, handleSize);
        const topLeft = parentRect.size
            .scale(this.parentSide)
            // Center
            .minus(size.times(1 / 2));
        return new _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Rect2(topLeft.x, topLeft.y, size.x, size.y);
    }
    /** @returns this handle's bounding box relative to the canvas. */
    getBBoxCanvasCoords() {
        const parentRect = this.parent.region;
        const size = _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(handleSize, handleSize).times(1 / this.viewport.getScaleFactor());
        const topLeftFromParent = parentRect.size.scale(this.parentSide).minus(size.times(0.5));
        return new _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Rect2(topLeftFromParent.x, topLeftFromParent.y, size.x, size.y).translatedBy(parentRect.topLeft);
    }
    /**
     * Moves the HTML representation of this to the location matching its internal representation.
     */
    updatePosition() {
        const bbox = this.getBBoxParentCoords();
        // Position within the selection box.
        this.element.style.marginLeft = `${bbox.topLeft.x}px`;
        this.element.style.marginTop = `${bbox.topLeft.y}px`;
        this.element.style.width = `${bbox.w}px`;
        this.element.style.height = `${bbox.h}px`;
    }
    /** @returns true iff `point` (in editor **canvas** coordinates) is in this. */
    containsPoint(point) {
        const bbox = this.getBBoxCanvasCoords();
        const delta = point.minus(bbox.center);
        // Should have same x and y radius
        const radius = bbox.size.x / 2;
        let result;
        if (this.shape === HandleShape.Circle) {
            result = delta.magnitude() <= radius;
        }
        else {
            result = Math.abs(delta.x) <= radius && Math.abs(delta.y) <= radius;
        }
        return result;
    }
    handleDragStart(pointer) {
        this.onDragStart(pointer.canvasPos);
        this.dragLastPos = pointer.canvasPos;
        return true;
    }
    handleDragUpdate(pointer) {
        if (!this.dragLastPos) {
            return;
        }
        this.onDragUpdate(pointer.canvasPos);
    }
    handleDragEnd() {
        if (!this.dragLastPos) {
            return;
        }
        return this.onDragEnd();
    }
    setSnapToGrid(snap) {
        this.snapToGrid = snap;
    }
    isSnappingToGrid() {
        return this.snapToGrid;
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionMenuShortcut.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionMenuShortcut.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SelectionMenuShortcut)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _SelectionTool_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SelectionTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionTool.mjs");


const verticalOffset = 40;
class SelectionMenuShortcut {
    constructor(parent, viewport, icon, showContextMenu, localization) {
        this.parent = parent;
        this.viewport = viewport;
        this.icon = icon;
        this.localization = localization;
        this.lastDragPointer = null;
        this.element = document.createElement('div');
        this.element.classList.add(`${_SelectionTool_mjs__WEBPACK_IMPORTED_MODULE_1__.cssPrefix}handle`, `${_SelectionTool_mjs__WEBPACK_IMPORTED_MODULE_1__.cssPrefix}selection-menu`);
        this.element.style.setProperty('--vertical-offset', `${verticalOffset}px`);
        this.onClick = () => {
            this.button?.focus({ preventScroll: true });
            const anchor = this.getBBoxCanvasCoords().center;
            showContextMenu(anchor);
        };
        this.initUI();
        this.updatePosition();
    }
    initUI() {
        const button = document.createElement('button');
        this.icon.classList.add('icon');
        button.replaceChildren(this.icon);
        button.ariaLabel = this.localization.selectionMenu__show;
        button.title = button.ariaLabel;
        this.button = button;
        // To prevent editor event handlers from conflicting with those for the button,
        // don't register a [click] handler. An onclick handler can be fired incorrectly
        // in this case (in Chrome) after onClick is fired in onDragEnd, leading to a double
        // on-click action.
        button.onkeydown = (event) => {
            if (event.key === 'Enter') {
                // .preventDefault prevents [Enter] from activating the first item in the
                // selection menu.
                event.preventDefault();
                this.onClick();
            }
        };
        this.element.appendChild(button);
        // Update the bounding box of this in response to the new button.
        requestAnimationFrame(() => {
            this.updatePosition();
        });
    }
    addTo(container) {
        container.appendChild(this.element);
    }
    remove() {
        this.element.remove();
    }
    getElementScreenSize() {
        return _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(this.element.clientWidth, this.element.clientHeight);
    }
    /** Gets this menu's bounding box relative to the top left of its parent. */
    getBBoxParentCoords() {
        const topLeft = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(0, -verticalOffset);
        const screenSize = this.getElementScreenSize();
        return new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2(topLeft.x, topLeft.y, screenSize.x, screenSize.y);
    }
    getBBoxCanvasCoords() {
        const parentCanvasRect = this.parent.region;
        const toCanvasScale = this.viewport.getSizeOfPixelOnCanvas();
        // Don't apply rotation -- rotation is handled by the selection container
        const contentCanvasSize = this.getElementScreenSize().times(toCanvasScale);
        const handleSizeCanvas = verticalOffset / this.viewport.getScaleFactor();
        const topLeft = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(parentCanvasRect.x, parentCanvasRect.y - handleSizeCanvas);
        const minSize = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(48, 48).times(toCanvasScale);
        return new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2(topLeft.x, topLeft.y, contentCanvasSize.x, contentCanvasSize.y).grownToSize(minSize);
    }
    updatePosition() {
        const bbox = this.getBBoxParentCoords();
        // Position within the selection box.
        this.element.style.marginLeft = `${bbox.topLeft.x}px`;
        this.element.style.marginTop = `${bbox.topLeft.y}px`;
    }
    containsPoint(canvasPoint) {
        return this.getBBoxCanvasCoords().containsPoint(canvasPoint);
    }
    handleDragStart(pointer) {
        this.lastDragPointer = pointer;
        return true;
    }
    handleDragUpdate(pointer) {
        this.lastDragPointer = pointer;
    }
    handleDragEnd() {
        if (this.lastDragPointer && this.containsPoint(this.lastDragPointer.canvasPos)) {
            this.onClick();
        }
        this.lastDragPointer = null;
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionTool.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionTool.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cssPrefix: () => (/* binding */ cssPrefix),
/* harmony export */   "default": () => (/* binding */ SelectionTool)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../types.mjs */ "./node_modules/js-draw/dist/mjs/types.mjs");
/* harmony import */ var _Viewport_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Viewport.mjs */ "./node_modules/js-draw/dist/mjs/Viewport.mjs");
/* harmony import */ var _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../BaseTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/BaseTool.mjs");
/* harmony import */ var _rendering_renderers_CanvasRenderer_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../rendering/renderers/CanvasRenderer.mjs */ "./node_modules/js-draw/dist/mjs/rendering/renderers/CanvasRenderer.mjs");
/* harmony import */ var _rendering_renderers_SVGRenderer_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../rendering/renderers/SVGRenderer.mjs */ "./node_modules/js-draw/dist/mjs/rendering/renderers/SVGRenderer.mjs");
/* harmony import */ var _Selection_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Selection.mjs */ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/Selection.mjs");
/* harmony import */ var _components_TextComponent_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../components/TextComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/TextComponent.mjs");
/* harmony import */ var _keybindings_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../keybindings.mjs */ "./node_modules/js-draw/dist/mjs/tools/keybindings.mjs");
/* harmony import */ var _ToPointerAutoscroller_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ToPointerAutoscroller.mjs */ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/ToPointerAutoscroller.mjs");
/* harmony import */ var _util_showSelectionContextMenu_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./util/showSelectionContextMenu.mjs */ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/util/showSelectionContextMenu.mjs");











const cssPrefix = 'selection-tool-';
// Allows users to select/transform portions of the `EditorImage`.
// With respect to `extend`ing, `SelectionTool` is not stable.
class SelectionTool extends _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(editor, description) {
        super(editor.notifier, description);
        this.editor = editor;
        // True if clearing and recreating the selectionBox has been deferred. This is used to prevent the selection
        // from vanishing on pointerdown events that are intended to form other gestures (e.g. long press) that would
        // ultimately restore the selection.
        this.rebuildSelectionScheduled = false;
        this.startPoint = null; // canvas position
        this.expandingSelectionBox = false;
        this.shiftKeyPressed = false;
        this.snapToGrid = false;
        this.lastPointer = null;
        this.showContextMenu = async (canvasAnchor, preferSelectionMenu = true) => {
            await (0,_util_showSelectionContextMenu_mjs__WEBPACK_IMPORTED_MODULE_10__["default"])(this.selectionBox, this.editor, canvasAnchor, preferSelectionMenu, () => this.clearSelection());
        };
        this.selectionBoxHandlingEvt = false;
        this.lastSelectedObjects = [];
        // Whether the last keypress corresponded to an action that didn't transform the
        // selection (and thus does not need to be finalized on onKeyUp).
        this.hasUnfinalizedTransformFromKeyPress = false;
        this.autoscroller = new _ToPointerAutoscroller_mjs__WEBPACK_IMPORTED_MODULE_9__["default"](editor.viewport, (scrollBy) => {
            editor.dispatch(_Viewport_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].transformBy(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.translation(scrollBy)), false);
            // Update the selection box/content to match the new viewport.
            if (this.lastPointer) {
                // The viewport has changed -- ensure that the screen and canvas positions
                // of the pointer are both correct
                const updatedPointer = this.lastPointer.withScreenPosition(this.lastPointer.screenPos, editor.viewport);
                this.onMainPointerUpdated(updatedPointer);
            }
        });
        this.handleOverlay = document.createElement('div');
        editor.createHTMLOverlay(this.handleOverlay);
        this.handleOverlay.style.display = 'none';
        this.handleOverlay.classList.add('handleOverlay');
        editor.notifier.on(_types_mjs__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.ViewportChanged, (_data) => {
            // The selection box could be using the wet ink display if its transformation
            // hasn't been finalized yet. Clear before updating the UI.
            this.editor.clearWetInk();
            // If not currently selecting, ensure that the selection box
            // is large enough.
            if (!this.expandingSelectionBox) {
                this.selectionBox?.padRegion();
            }
            this.selectionBox?.updateUI();
        });
        this.editor.handleKeyEventsFrom(this.handleOverlay);
        this.editor.handlePointerEventsFrom(this.handleOverlay);
    }
    makeSelectionBox(selectionStartPos) {
        this.prevSelectionBox = this.selectionBox;
        this.selectionBox = new _Selection_mjs__WEBPACK_IMPORTED_MODULE_6__["default"](selectionStartPos, this.editor, this.showContextMenu);
        if (!this.expandingSelectionBox) {
            // Remove any previous selection rects
            this.prevSelectionBox?.cancelSelection();
        }
        this.selectionBox.addTo(this.handleOverlay);
    }
    snapSelectionToGrid() {
        if (!this.selectionBox)
            throw new Error('No selection to snap!');
        // Snap the top left corner of what we have selected.
        const topLeftOfBBox = this.selectionBox.computeTightBoundingBox().topLeft;
        const snappedTopLeft = this.editor.viewport.snapToGrid(topLeftOfBBox);
        const snapDelta = snappedTopLeft.minus(topLeftOfBBox);
        const oldTransform = this.selectionBox.getTransform();
        this.selectionBox.setTransform(oldTransform.rightMul(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.translation(snapDelta)));
        this.selectionBox.finalizeTransform();
    }
    onContextMenu(event) {
        const canShowSelectionMenu = this.selectionBox
            ?.getScreenRegion()
            ?.containsPoint(event.screenPos);
        void this.showContextMenu(event.canvasPos, canShowSelectionMenu);
        return true;
    }
    onPointerDown({ allPointers, current }) {
        const snapToGrid = this.snapToGrid;
        if (snapToGrid) {
            current = current.snappedToGrid(this.editor.viewport);
        }
        // Don't rely on .isPrimary -- it's buggy in Firefox. See https://github.com/personalizedrefrigerator/js-draw/issues/71
        if (allPointers.length === 1) {
            this.startPoint = current.canvasPos;
            let transforming = false;
            if (this.selectionBox) {
                if (snapToGrid) {
                    this.snapSelectionToGrid();
                }
                const dragStartResult = this.selectionBox.onDragStart(current);
                if (dragStartResult) {
                    transforming = true;
                    this.selectionBoxHandlingEvt = true;
                    this.expandingSelectionBox = false;
                }
            }
            if (!transforming) {
                // Shift key: Combine the new and old selection boxes at the end of the gesture.
                this.expandingSelectionBox = this.shiftKeyPressed;
                this.rebuildSelectionScheduled = true;
            }
            else {
                // Only autoscroll if we're transforming an existing selection
                this.autoscroller.start();
            }
            return true;
        }
        return false;
    }
    onPointerMove(event) {
        this.onMainPointerUpdated(event.current);
    }
    onMainPointerUpdated(currentPointer) {
        this.lastPointer = currentPointer;
        if (this.rebuildSelectionScheduled) {
            this.rebuildSelectionScheduled = false;
            this.makeSelectionBox(this.startPoint ?? currentPointer.canvasPos);
            this.selectionBox?.setHandlesVisible(false);
        }
        if (!this.selectionBox)
            return;
        this.autoscroller.onPointerMove(currentPointer.screenPos);
        if (!this.expandingSelectionBox && this.shiftKeyPressed && this.startPoint) {
            const screenPos = this.editor.viewport.canvasToScreen(this.startPoint);
            currentPointer = currentPointer.lockedToXYAxesScreen(screenPos, this.editor.viewport);
        }
        if (this.snapToGrid) {
            currentPointer = currentPointer.snappedToGrid(this.editor.viewport);
        }
        if (this.selectionBoxHandlingEvt) {
            this.selectionBox.onDragUpdate(currentPointer);
        }
        else {
            this.selectionBox.setToPoint(currentPointer.canvasPos);
        }
    }
    onPointerUp(event) {
        this.onMainPointerUpdated(event.current);
        this.autoscroller.stop();
        if (!this.selectionBox)
            return;
        this.selectionBox.setHandlesVisible(true);
        // Were we expanding the previous selection?
        if (this.expandingSelectionBox && this.prevSelectionBox) {
            // If so, finish expanding.
            this.expandingSelectionBox = false;
            this.selectionBox.resolveToObjects();
            this.setSelection([
                ...this.selectionBox.getSelectedObjects(),
                ...this.prevSelectionBox.getSelectedObjects(),
            ]);
        }
        else {
            if (!this.selectionBoxHandlingEvt) {
                // Expand/shrink the selection rectangle, if applicable
                this.selectionBox.resolveToObjects();
                this.onSelectionUpdated();
            }
            else {
                this.selectionBox.onDragEnd();
            }
            this.selectionBoxHandlingEvt = false;
            this.lastPointer = null;
        }
    }
    onGestureCancel() {
        this.autoscroller.stop();
        if (this.selectionBoxHandlingEvt) {
            this.selectionBox?.onDragCancel();
        }
        else if (!this.rebuildSelectionScheduled) {
            // Revert to the previous selection, if any.
            this.selectionBox?.cancelSelection();
            this.selectionBox = this.prevSelectionBox;
            this.selectionBox?.addTo(this.handleOverlay);
            this.selectionBox?.recomputeRegion();
            this.prevSelectionBox = null;
        }
        this.rebuildSelectionScheduled = false;
        this.expandingSelectionBox = false;
        this.lastPointer = null;
        this.selectionBoxHandlingEvt = false;
    }
    onSelectionUpdated() {
        const selectedItemCount = this.selectionBox?.getSelectedItemCount() ?? 0;
        const selectedObjects = this.selectionBox?.getSelectedObjects() ?? [];
        const hasDifferentSelection = this.lastSelectedObjects.length !== selectedItemCount ||
            selectedObjects.some((obj, i) => this.lastSelectedObjects[i] !== obj);
        if (hasDifferentSelection) {
            this.lastSelectedObjects = selectedObjects;
            // Note that the selection has changed
            this.editor.notifier.dispatch(_types_mjs__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.ToolUpdated, {
                kind: _types_mjs__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.ToolUpdated,
                tool: this,
            });
            // Only fire the SelectionUpdated event if the selection really updated.
            this.editor.notifier.dispatch(_types_mjs__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.SelectionUpdated, {
                kind: _types_mjs__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.SelectionUpdated,
                selectedComponents: selectedObjects,
                tool: this,
            });
            if (selectedItemCount > 0) {
                this.editor.announceForAccessibility(this.editor.localization.selectedElements(selectedItemCount));
                this.zoomToSelection();
            }
        }
        if (selectedItemCount === 0 && this.selectionBox) {
            this.selectionBox.cancelSelection();
            this.prevSelectionBox = this.selectionBox;
            this.selectionBox = null;
        }
    }
    zoomToSelection() {
        if (this.selectionBox) {
            const selectionRect = this.selectionBox.region;
            this.editor.dispatchNoAnnounce(this.editor.viewport.zoomTo(selectionRect, false), false);
        }
    }
    onKeyPress(event) {
        const shortcucts = this.editor.shortcuts;
        if (shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_8__.snapToGridKeyboardShortcutId, event)) {
            this.snapToGrid = true;
            return true;
        }
        if (this.selectionBox &&
            (shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_8__.duplicateSelectionShortcut, event) ||
                shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_8__.sendToBackSelectionShortcut, event))) {
            // Handle duplication on key up — we don't want to accidentally duplicate
            // many times.
            return true;
        }
        else if (shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_8__.selectAllKeyboardShortcut, event)) {
            this.setSelection(this.editor.image.getAllElements());
            return true;
        }
        else if (event.ctrlKey) {
            // Don't transform the selection with, for example, ctrl+i.
            // Pass it to another tool, if apliccable.
            return false;
        }
        else if (event.shiftKey || event.key === 'Shift') {
            this.shiftKeyPressed = true;
            if (event.key === 'Shift') {
                return true;
            }
        }
        let rotationSteps = 0;
        let xTranslateSteps = 0;
        let yTranslateSteps = 0;
        let xScaleSteps = 0;
        let yScaleSteps = 0;
        if (shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_8__.translateLeftSelectionShortcutId, event)) {
            xTranslateSteps -= 1;
        }
        else if (shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_8__.translateRightSelectionShortcutId, event)) {
            xTranslateSteps += 1;
        }
        else if (shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_8__.translateUpSelectionShortcutId, event)) {
            yTranslateSteps -= 1;
        }
        else if (shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_8__.translateDownSelectionShortcutId, event)) {
            yTranslateSteps += 1;
        }
        else if (shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_8__.rotateClockwiseSelectionShortcutId, event)) {
            rotationSteps += 1;
        }
        else if (shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_8__.rotateCounterClockwiseSelectionShortcutId, event)) {
            rotationSteps -= 1;
        }
        else if (shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_8__.shrinkXSelectionShortcutId, event)) {
            xScaleSteps -= 1;
        }
        else if (shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_8__.stretchXSelectionShortcutId, event)) {
            xScaleSteps += 1;
        }
        else if (shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_8__.shrinkYSelectionShortcutId, event)) {
            yScaleSteps -= 1;
        }
        else if (shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_8__.stretchYSelectionShortcutId, event)) {
            yScaleSteps += 1;
        }
        else if (shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_8__.shrinkXYSelectionShortcutId, event)) {
            xScaleSteps -= 1;
            yScaleSteps -= 1;
        }
        else if (shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_8__.stretchXYSelectionShortcutId, event)) {
            xScaleSteps += 1;
            yScaleSteps += 1;
        }
        let handled = xTranslateSteps !== 0 ||
            yTranslateSteps !== 0 ||
            rotationSteps !== 0 ||
            xScaleSteps !== 0 ||
            yScaleSteps !== 0;
        if (!this.selectionBox) {
            handled = false;
        }
        else if (handled) {
            const translateStepSize = 10 * this.editor.viewport.getSizeOfPixelOnCanvas();
            const rotateStepSize = Math.PI / 8;
            const scaleStepSize = 5 / 4;
            const region = this.selectionBox.region;
            const scaleFactor = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(scaleStepSize ** xScaleSteps, scaleStepSize ** yScaleSteps);
            const rotationMat = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.zRotation(rotationSteps * rotateStepSize);
            const roundedRotationMatrix = rotationMat.mapEntries((component) => _Viewport_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].roundScaleRatio(component));
            const regionCenter = this.editor.viewport.roundPoint(region.center);
            const transform = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.scaling2D(scaleFactor, this.editor.viewport.roundPoint(region.topLeft))
                .rightMul(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.translation(regionCenter)
                .rightMul(roundedRotationMatrix)
                .rightMul(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.translation(regionCenter.times(-1))))
                .rightMul(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.translation(this.editor.viewport.roundPoint(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(xTranslateSteps, yTranslateSteps).times(translateStepSize))));
            const oldTransform = this.selectionBox.getTransform();
            this.selectionBox.setTransform(oldTransform.rightMul(transform));
            this.selectionBox.scrollTo();
            // The transformation needs to be finalized at some point (on key up)
            this.hasUnfinalizedTransformFromKeyPress = true;
        }
        if (this.selectionBox && !handled && (event.key === 'Delete' || event.key === 'Backspace')) {
            this.editor.dispatch(this.selectionBox.deleteSelectedObjects());
            this.clearSelection();
            handled = true;
        }
        return handled;
    }
    onKeyUp(evt) {
        const shortcucts = this.editor.shortcuts;
        if (shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_8__.snapToGridKeyboardShortcutId, evt)) {
            this.snapToGrid = false;
            return true;
        }
        if (shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_8__.selectAllKeyboardShortcut, evt)) {
            // Selected all in onKeyDown. Don't finalizeTransform.
            return true;
        }
        if (this.selectionBox && shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_8__.duplicateSelectionShortcut, evt)) {
            // Finalize duplicating the selection
            this.selectionBox.duplicateSelectedObjects().then((command) => {
                this.editor.dispatch(command);
            });
            return true;
        }
        if (this.selectionBox && shortcucts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_8__.sendToBackSelectionShortcut, evt)) {
            const sendToBackCommand = this.selectionBox.sendToBack();
            if (sendToBackCommand) {
                this.editor.dispatch(sendToBackCommand);
            }
            return true;
        }
        // Here, we check if shiftKey === false because, as of this writing,
        // evt.shiftKey is an optional property. Being falsey could just mean
        // that it wasn't set.
        if (evt.shiftKey === false) {
            this.shiftKeyPressed = false;
            // Don't return immediately -- event may be otherwise handled
        }
        // Also check for key === 'Shift' (for the case where shiftKey is undefined)
        if (evt.key === 'Shift') {
            this.shiftKeyPressed = false;
            return true;
        }
        // If we don't need to finalize the transform
        if (!this.hasUnfinalizedTransformFromKeyPress) {
            return true;
        }
        if (this.selectionBox) {
            this.selectionBox.finalizeTransform();
            this.hasUnfinalizedTransformFromKeyPress = false;
            return true;
        }
        return false;
    }
    onCopy(event) {
        if (!this.selectionBox) {
            return false;
        }
        const selectedElems = this.selectionBox.getSelectedObjects();
        const bbox = this.selectionBox.region;
        if (selectedElems.length === 0) {
            return false;
        }
        const exportViewport = new _Viewport_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](() => { });
        const selectionScreenSize = this.selectionBox
            .getScreenRegion()
            .size.times(this.editor.display.getDevicePixelRatio());
        // Update the viewport to have screen size roughly equal to the size of the selection box
        let scaleFactor = selectionScreenSize.maximumEntryMagnitude() / (bbox.size.maximumEntryMagnitude() || 1);
        // Round to a nearby power of two
        scaleFactor = Math.pow(2, Math.ceil(Math.log2(scaleFactor)));
        exportViewport.updateScreenSize(bbox.size.times(scaleFactor));
        exportViewport.resetTransform(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.scaling2D(scaleFactor)
            // Move the selection onto the screen
            .rightMul(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.translation(bbox.topLeft.times(-1))));
        const { element: svgExportElem, renderer: svgRenderer } = _rendering_renderers_SVGRenderer_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].fromViewport(exportViewport, { sanitize: true, useViewBoxForPositioning: true });
        const { element: canvas, renderer: canvasRenderer } = _rendering_renderers_CanvasRenderer_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].fromViewport(exportViewport, { maxCanvasDimen: 4096 });
        const text = [];
        for (const elem of selectedElems) {
            elem.render(svgRenderer);
            elem.render(canvasRenderer);
            if (elem instanceof _components_TextComponent_mjs__WEBPACK_IMPORTED_MODULE_7__["default"]) {
                text.push(elem.getText());
            }
        }
        event.setData('image/svg+xml', svgExportElem.outerHTML);
        event.setData('text/html', svgExportElem.outerHTML);
        event.setData('image/png', new Promise((resolve, reject) => {
            canvas.toBlob((blob) => {
                if (blob) {
                    resolve(blob);
                }
                else {
                    reject(new Error('Failed to convert canvas to blob.'));
                }
            }, 'image/png');
        }));
        if (text.length > 0) {
            event.setData('text/plain', text.join('\n'));
        }
        return true;
    }
    setEnabled(enabled) {
        const wasEnabled = this.isEnabled();
        super.setEnabled(enabled);
        if (wasEnabled === enabled) {
            return;
        }
        // Clear the selection
        this.selectionBox?.cancelSelection();
        this.onSelectionUpdated();
        this.handleOverlay.replaceChildren();
        this.selectionBox = null;
        this.shiftKeyPressed = false;
        this.snapToGrid = false;
        this.handleOverlay.style.display = enabled ? 'block' : 'none';
        if (enabled) {
            this.handleOverlay.tabIndex = 0;
            this.handleOverlay.setAttribute('aria-label', this.editor.localization.selectionToolKeyboardShortcuts);
        }
        else {
            this.handleOverlay.tabIndex = -1;
        }
    }
    // Get the object responsible for displaying this' selection.
    // @internal
    getSelection() {
        return this.selectionBox;
    }
    getSelectedObjects() {
        return this.selectionBox?.getSelectedObjects() ?? [];
    }
    // Select the given `objects`. Any non-selectable objects in `objects` are ignored.
    setSelection(objects) {
        // Only select selectable objects.
        objects = objects.filter((obj) => obj.isSelectable());
        // Sort by z-index
        objects.sort((a, b) => a.getZIndex() - b.getZIndex());
        // Remove duplicates
        objects = objects.filter((current, idx) => {
            if (idx > 0) {
                return current !== objects[idx - 1];
            }
            return true;
        });
        let bbox = null;
        for (const object of objects) {
            if (bbox) {
                bbox = bbox.union(object.getBBox());
            }
            else {
                bbox = object.getBBox();
            }
        }
        if (!bbox) {
            return;
        }
        this.clearSelection();
        if (!this.selectionBox) {
            this.makeSelectionBox(bbox.topLeft);
        }
        this.selectionBox.setSelectedObjects(objects, bbox);
        this.onSelectionUpdated();
    }
    clearSelection() {
        this.handleOverlay.replaceChildren();
        this.prevSelectionBox = this.selectionBox;
        this.selectionBox = null;
        this.onSelectionUpdated();
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/ToPointerAutoscroller.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/SelectionTool/ToPointerAutoscroller.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ToPointerAutoscroller)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _util_untilNextAnimationFrame_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/untilNextAnimationFrame.mjs */ "./node_modules/js-draw/dist/mjs/util/untilNextAnimationFrame.mjs");


/**
 * Automatically scrolls the viewport such that the user's pointer is visible.
 */
class ToPointerAutoscroller {
    constructor(viewport, scrollByCanvasDelta) {
        this.viewport = viewport;
        this.scrollByCanvasDelta = scrollByCanvasDelta;
        this.started = false;
        this.updateLoopId = 0;
        this.updateLoopRunning = false;
        this.targetPoint = null;
        this.scrollRate = 1000; // px/s
    }
    getScrollForPoint(screenPoint) {
        const screenSize = this.viewport.getScreenRectSize();
        const screenRect = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Rect2(0, 0, screenSize.x, screenSize.y);
        // Starts autoscrolling when the cursor is **outside of** this region
        const marginSize = 44;
        const autoscrollBoundary = screenRect.grownBy(-marginSize);
        if (autoscrollBoundary.containsPoint(screenPoint)) {
            return _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.zero;
        }
        const closestEdgePoint = autoscrollBoundary.getClosestPointOnBoundaryTo(screenPoint);
        const distToEdge = closestEdgePoint.distanceTo(screenPoint);
        const toEdge = closestEdgePoint.minus(screenPoint);
        // Go faster for points further away from the boundary.
        const maximumScaleFactor = 1.25;
        const scaleFactor = Math.min(distToEdge / marginSize, maximumScaleFactor);
        return toEdge.normalizedOrZero().times(scaleFactor);
    }
    start() {
        this.started = true;
    }
    onPointerMove(pointerScreenPosition) {
        if (!this.started) {
            return;
        }
        if (this.getScrollForPoint(pointerScreenPosition) === _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.zero) {
            this.stopUpdateLoop();
        }
        else {
            this.targetPoint = pointerScreenPosition;
            this.startUpdateLoop();
        }
    }
    stop() {
        this.targetPoint = null;
        this.started = false;
        this.stopUpdateLoop();
    }
    startUpdateLoop() {
        if (this.updateLoopRunning) {
            return;
        }
        (async () => {
            this.updateLoopId++;
            const currentUpdateLoopId = this.updateLoopId;
            let lastUpdateTime = performance.now();
            while (this.updateLoopId === currentUpdateLoopId && this.targetPoint) {
                this.updateLoopRunning = true;
                const currentTime = performance.now();
                const deltaTimeMs = currentTime - lastUpdateTime;
                const scrollDirection = this.getScrollForPoint(this.targetPoint);
                const screenScrollAmount = scrollDirection.times((this.scrollRate * deltaTimeMs) / 1000);
                this.scrollByCanvasDelta(this.viewport.screenToCanvasTransform.transformVec3(screenScrollAmount));
                lastUpdateTime = currentTime;
                await (0,_util_untilNextAnimationFrame_mjs__WEBPACK_IMPORTED_MODULE_1__["default"])();
            }
            this.updateLoopRunning = false;
        })();
    }
    stopUpdateLoop() {
        this.updateLoopId++;
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/TransformMode.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/SelectionTool/TransformMode.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DragTransformer: () => (/* binding */ DragTransformer),
/* harmony export */   ResizeTransformer: () => (/* binding */ ResizeTransformer),
/* harmony export */   RotateTransformer: () => (/* binding */ RotateTransformer)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _Viewport_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Viewport.mjs */ "./node_modules/js-draw/dist/mjs/Viewport.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.mjs */ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/types.mjs");



class DragTransformer {
    constructor(editor, selection) {
        this.editor = editor;
        this.selection = selection;
    }
    onDragStart(startPoint) {
        this.selection.setTransform(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.identity);
        this.dragStartPoint = startPoint;
    }
    onDragUpdate(canvasPos) {
        const delta = this.editor.viewport.roundPoint(canvasPos.minus(this.dragStartPoint));
        this.selection.setTransform(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.translation(delta));
    }
    onDragEnd() {
        return this.selection.finalizeTransform();
    }
}
class ResizeTransformer {
    constructor(editor, selection) {
        this.editor = editor;
        this.selection = selection;
        this.mode = _types_mjs__WEBPACK_IMPORTED_MODULE_2__.ResizeMode.Both;
    }
    onDragStart(startPoint, mode) {
        this.selection.setTransform(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.identity);
        this.mode = mode;
        this.dragStartPoint = startPoint;
        this.computeOriginAndScaleRate();
    }
    computeOriginAndScaleRate() {
        // Store the index of the furthest corner from startPoint. We'll use that
        // to determine where the transform considers (0, 0) (where we scale from).
        const selectionRect = this.selection.preTransformRegion;
        const selectionBoxCorners = selectionRect.corners;
        let largestDistSquared = 0;
        for (let i = 0; i < selectionBoxCorners.length; i++) {
            const currentCorner = selectionBoxCorners[i];
            const distSquaredToCurrent = this.dragStartPoint.minus(currentCorner).magnitudeSquared();
            if (distSquaredToCurrent > largestDistSquared) {
                largestDistSquared = distSquaredToCurrent;
                this.transformOrigin = currentCorner;
            }
        }
        // Determine whether moving the mouse to the right increases or decreases the width.
        let widthScaleRate = 1;
        let heightScaleRate = 1;
        if (this.transformOrigin.x > selectionRect.center.x) {
            widthScaleRate = -1;
        }
        if (this.transformOrigin.y > selectionRect.center.y) {
            heightScaleRate = -1;
        }
        this.scaleRate = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(widthScaleRate, heightScaleRate);
    }
    onDragUpdate(canvasPos) {
        const canvasDelta = canvasPos.minus(this.dragStartPoint);
        const origWidth = this.selection.preTransformRegion.width;
        const origHeight = this.selection.preTransformRegion.height;
        let scale = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(1, 1);
        if (this.mode === _types_mjs__WEBPACK_IMPORTED_MODULE_2__.ResizeMode.HorizontalOnly) {
            const newWidth = origWidth + canvasDelta.x * this.scaleRate.x;
            scale = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(newWidth / origWidth, scale.y);
        }
        if (this.mode === _types_mjs__WEBPACK_IMPORTED_MODULE_2__.ResizeMode.VerticalOnly) {
            const newHeight = origHeight + canvasDelta.y * this.scaleRate.y;
            scale = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(scale.x, newHeight / origHeight);
        }
        if (this.mode === _types_mjs__WEBPACK_IMPORTED_MODULE_2__.ResizeMode.Both) {
            const delta = Math.abs(canvasDelta.x) > Math.abs(canvasDelta.y) ? canvasDelta.x : canvasDelta.y;
            const newWidth = origWidth + delta;
            scale = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(newWidth / origWidth, newWidth / origWidth);
        }
        // Round: If this isn't done, scaling can create numbers with long decimal representations.
        //    long decimal representations => large file sizes.
        scale = scale.map((component) => _Viewport_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].roundScaleRatio(component, 2));
        if (scale.x !== 0 && scale.y !== 0) {
            const origin = this.editor.viewport.roundPoint(this.transformOrigin);
            this.selection.setTransform(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.scaling2D(scale, origin));
        }
    }
    onDragEnd() {
        return this.selection.finalizeTransform();
    }
}
class RotateTransformer {
    constructor(editor, selection) {
        this.editor = editor;
        this.selection = selection;
        this.startAngle = 0;
        this.targetRotation = 0;
        this.maximumDistFromStart = 0;
    }
    getAngle(canvasPoint) {
        const selectionCenter = this.selection.preTransformRegion.center;
        const offset = canvasPoint.minus(selectionCenter);
        return offset.angle();
    }
    roundAngle(angle) {
        // Round angles to the nearest 16th of a turn
        const roundingFactor = 16 / 2 / Math.PI;
        return Math.round(angle * roundingFactor) / roundingFactor;
    }
    onDragStart(startPoint) {
        this.startPoint = startPoint;
        this.selection.setTransform(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.identity);
        this.startAngle = this.getAngle(startPoint);
        this.targetRotation = 0;
        // Used to determine whether the user clicked or not.
        this.maximumDistFromStart = 0;
        this.startTime = performance.now();
    }
    setRotationTo(angle) {
        // Transform in canvas space
        const canvasSelCenter = this.editor.viewport.roundPoint(this.selection.preTransformRegion.center);
        const unrounded = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.zRotation(angle);
        const roundedRotationTransform = unrounded.mapEntries((entry) => _Viewport_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].roundScaleRatio(entry));
        const fullRoundedTransform = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.translation(canvasSelCenter)
            .rightMul(roundedRotationTransform)
            .rightMul(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Mat33.translation(canvasSelCenter.times(-1)));
        this.selection.setTransform(fullRoundedTransform);
    }
    onDragUpdate(canvasPos) {
        this.targetRotation = this.roundAngle(this.getAngle(canvasPos) - this.startAngle);
        this.setRotationTo(this.targetRotation);
        const distFromStart = canvasPos.minus(this.startPoint).magnitude();
        if (distFromStart > this.maximumDistFromStart) {
            this.maximumDistFromStart = distFromStart;
        }
    }
    onDragEnd() {
        // Anything with motion less than this is considered a click
        const clickThresholdDist = 10;
        const clickThresholdTime = 0.4; // s
        const dragTimeSeconds = (performance.now() - this.startTime) / 1000;
        if (dragTimeSeconds < clickThresholdTime &&
            this.maximumDistFromStart < clickThresholdDist &&
            this.targetRotation === 0) {
            this.setRotationTo(-Math.PI / 2);
        }
        return this.selection.finalizeTransform();
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/keybindings.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/SelectionTool/keybindings.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   duplicateSelectionShortcut: () => (/* binding */ duplicateSelectionShortcut),
/* harmony export */   rotateClockwiseSelectionShortcutId: () => (/* binding */ rotateClockwiseSelectionShortcutId),
/* harmony export */   rotateCounterClockwiseSelectionShortcutId: () => (/* binding */ rotateCounterClockwiseSelectionShortcutId),
/* harmony export */   selectAllKeyboardShortcut: () => (/* binding */ selectAllKeyboardShortcut),
/* harmony export */   sendToBackSelectionShortcut: () => (/* binding */ sendToBackSelectionShortcut),
/* harmony export */   shrinkXSelectionShortcutId: () => (/* binding */ shrinkXSelectionShortcutId),
/* harmony export */   shrinkXYSelectionShortcutId: () => (/* binding */ shrinkXYSelectionShortcutId),
/* harmony export */   shrinkYSelectionShortcutId: () => (/* binding */ shrinkYSelectionShortcutId),
/* harmony export */   stretchXSelectionShortcutId: () => (/* binding */ stretchXSelectionShortcutId),
/* harmony export */   stretchXYSelectionShortcutId: () => (/* binding */ stretchXYSelectionShortcutId),
/* harmony export */   stretchYSelectionShortcutId: () => (/* binding */ stretchYSelectionShortcutId),
/* harmony export */   translateDownSelectionShortcutId: () => (/* binding */ translateDownSelectionShortcutId),
/* harmony export */   translateLeftSelectionShortcutId: () => (/* binding */ translateLeftSelectionShortcutId),
/* harmony export */   translateRightSelectionShortcutId: () => (/* binding */ translateRightSelectionShortcutId),
/* harmony export */   translateUpSelectionShortcutId: () => (/* binding */ translateUpSelectionShortcutId)
/* harmony export */ });
/* harmony import */ var _shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shortcuts/KeyboardShortcutManager.mjs */ "./node_modules/js-draw/dist/mjs/shortcuts/KeyboardShortcutManager.mjs");

// Selection
const selectAllKeyboardShortcut = 'jsdraw.tools.SelectionTool.selectAll';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(selectAllKeyboardShortcut, ['CtrlOrMeta+KeyA'], 'Select all');
const duplicateSelectionShortcut = 'jsdraw.tools.SelectionTool.duplicateSelection';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(duplicateSelectionShortcut, ['CtrlOrMeta+KeyD'], 'Duplicate selection');
const sendToBackSelectionShortcut = 'jsdraw.tools.SelectionTool.sendToBack';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(sendToBackSelectionShortcut, ['End'], 'Send to back');
const translateLeftSelectionShortcutId = 'jsdraw.tools.SelectionTool.translateLeft';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(translateLeftSelectionShortcutId, ['KeyA', 'KeyH', 'ArrowLeft'], 'Move selection left');
const translateRightSelectionShortcutId = 'jsdraw.tools.SelectionTool.translateRight';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(translateRightSelectionShortcutId, ['KeyD', 'KeyL', 'ArrowRight'], 'Move selection right');
const translateUpSelectionShortcutId = 'jsdraw.tools.SelectionTool.translateUp';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(translateUpSelectionShortcutId, ['KeyQ', 'KeyK', 'ArrowUp'], 'Move selection up');
const translateDownSelectionShortcutId = 'jsdraw.tools.SelectionTool.translateDown';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(translateDownSelectionShortcutId, ['KeyE', 'KeyJ', 'ArrowDown'], 'Move selection down');
const rotateCounterClockwiseSelectionShortcutId = 'jsdraw.tools.SelectionTool.rotateCCW';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(rotateCounterClockwiseSelectionShortcutId, ['Shift+KeyR'], 'Rotate selection counter clockwise');
const rotateClockwiseSelectionShortcutId = 'jsdraw.tools.SelectionTool.rotateCW';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(rotateClockwiseSelectionShortcutId, ['KeyR'], 'Rotate selection clockwise');
const shrinkXSelectionShortcutId = 'jsdraw.tools.SelectionTool.shrink.x';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(shrinkXSelectionShortcutId, ['KeyI'], 'Decrease width');
const stretchXSelectionShortcutId = 'jsdraw.tools.SelectionTool.stretch.x';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(stretchXSelectionShortcutId, ['Shift+KeyI'], 'Increase width');
const shrinkYSelectionShortcutId = 'jsdraw.tools.SelectionTool.shrink.y';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(shrinkYSelectionShortcutId, ['KeyO'], 'Decrease height');
const stretchYSelectionShortcutId = 'jsdraw.tools.SelectionTool.stretch.y';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(stretchYSelectionShortcutId, ['Shift+KeyO'], 'Increase height');
const shrinkXYSelectionShortcutId = 'jsdraw.tools.SelectionTool.shrink.xy';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(shrinkXYSelectionShortcutId, ['Comma'], 'Decrease selection size');
const stretchXYSelectionShortcutId = 'jsdraw.tools.SelectionTool.stretch.xy';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(stretchXYSelectionShortcutId, ['Period'], 'Increase selection size');


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/types.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/SelectionTool/types.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ResizeMode: () => (/* binding */ ResizeMode),
/* harmony export */   TransformMode: () => (/* binding */ TransformMode)
/* harmony export */ });
var ResizeMode;
(function (ResizeMode) {
    ResizeMode[ResizeMode["Both"] = 0] = "Both";
    ResizeMode[ResizeMode["HorizontalOnly"] = 1] = "HorizontalOnly";
    ResizeMode[ResizeMode["VerticalOnly"] = 2] = "VerticalOnly";
})(ResizeMode || (ResizeMode = {}));
var TransformMode;
(function (TransformMode) {
    TransformMode[TransformMode["Snap"] = 0] = "Snap";
    TransformMode[TransformMode["NoSnap"] = 1] = "NoSnap";
})(TransformMode || (TransformMode = {}));


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/util/makeClipboardErrorHandlers.mjs":
/*!***********************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/SelectionTool/util/makeClipboardErrorHandlers.mjs ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dialogs_makeMessageDialog_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../dialogs/makeMessageDialog.mjs */ "./node_modules/js-draw/dist/mjs/dialogs/makeMessageDialog.mjs");
/* harmony import */ var _util_ClipboardHandler_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/ClipboardHandler.mjs */ "./node_modules/js-draw/dist/mjs/util/ClipboardHandler.mjs");


const makeClipboardErrorHandlers = (editor) => {
    const makeErrorDialog = (error) => {
        const dialog = (0,_dialogs_makeMessageDialog_mjs__WEBPACK_IMPORTED_MODULE_0__["default"])(editor, {
            title: editor.localization.copyPasteError__heading,
            classNames: ['clipboard-error-dialog'],
        });
        dialog.appendChild(document.createTextNode(editor.localization.copyPasteError__description));
        const errorDetailsElement = document.createElement('details');
        const errorDetailsSummary = document.createElement('summary');
        errorDetailsSummary.textContent = editor.localization.copyPasteError__errorDetails;
        errorDetailsElement.appendChild(errorDetailsSummary);
        errorDetailsElement.appendChild(document.createTextNode(`Error: ${error}`));
        dialog.appendChild(errorDetailsElement);
        return dialog;
    };
    return {
        onCopyError(error) {
            const dialog = makeErrorDialog(error);
            const textboxLabel = document.createElement('label');
            textboxLabel.textContent = editor.localization.copyPasteError__copyRetry;
            const copyTextbox = document.createElement('textarea');
            textboxLabel.appendChild(copyTextbox);
            const retryHandler = new _util_ClipboardHandler_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](editor);
            const handleCopy = (event) => {
                event.preventDefault();
                // Use .then to ensure that .copy runs within the event handler.
                // Copy can fail if certain logic is run async.
                return retryHandler.copy(event).then(() => {
                    dialog.close();
                });
            };
            copyTextbox.oncopy = handleCopy;
            copyTextbox.ondragstart = handleCopy;
            copyTextbox.value = editor.localization.copyPasteError__copyMe;
            dialog.appendChild(textboxLabel);
            copyTextbox.select();
            document.execCommand('copy');
        },
        onPasteError(error) {
            const dialog = makeErrorDialog(error);
            const textboxLabel = document.createElement('label');
            textboxLabel.textContent = editor.localization.copyPasteError__pasteRetry;
            const pasteTextbox = document.createElement('textarea');
            textboxLabel.appendChild(pasteTextbox);
            const retryHandler = new _util_ClipboardHandler_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](editor);
            const handlePaste = (event) => {
                event.preventDefault();
                // Use .then to ensure that .paste runs within the event handler.
                // Paste can fail if certain logic is run async.
                return retryHandler.paste(event).then((pasted) => {
                    if (pasted) {
                        dialog.close();
                    }
                });
            };
            pasteTextbox.onpaste = handlePaste;
            pasteTextbox.ondrop = handlePaste;
            dialog.appendChild(textboxLabel);
            pasteTextbox.focus();
            document.execCommand('paste');
        },
    };
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (makeClipboardErrorHandlers);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/util/showSelectionContextMenu.mjs":
/*!*********************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/SelectionTool/util/showSelectionContextMenu.mjs ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_createMenuOverlay_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/createMenuOverlay.mjs */ "./node_modules/js-draw/dist/mjs/tools/util/createMenuOverlay.mjs");
/* harmony import */ var _util_ClipboardHandler_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/ClipboardHandler.mjs */ "./node_modules/js-draw/dist/mjs/util/ClipboardHandler.mjs");
/* harmony import */ var _makeClipboardErrorHandlers_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./makeClipboardErrorHandlers.mjs */ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/util/makeClipboardErrorHandlers.mjs");



const showSelectionContextMenu = async (selectionBox, editor, canvasAnchor, preferSelectionMenu, clearSelection) => {
    const localization = editor.localization;
    const showSelectionMenu = selectionBox?.getSelectedItemCount() && preferSelectionMenu;
    const noSelectionMenu = [
        {
            text: localization.selectionMenu__paste,
            icon: () => editor.icons.makePasteIcon(),
            key: () => {
                const clipboardHandler = new _util_ClipboardHandler_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](editor, (0,_makeClipboardErrorHandlers_mjs__WEBPACK_IMPORTED_MODULE_2__["default"])(editor));
                void clipboardHandler.paste();
            },
        },
    ];
    const onActivated = await (0,_util_createMenuOverlay_mjs__WEBPACK_IMPORTED_MODULE_0__["default"])(editor, canvasAnchor, showSelectionMenu
        ? [
            {
                text: localization.selectionMenu__duplicate,
                icon: () => editor.icons.makeDuplicateSelectionIcon(),
                key: async () => {
                    await editor.dispatch(await selectionBox.duplicateSelectedObjects());
                },
            },
            {
                text: localization.selectionMenu__delete,
                icon: () => editor.icons.makeDeleteSelectionIcon(),
                key: async () => {
                    await editor.dispatch(selectionBox.deleteSelectedObjects());
                    clearSelection();
                },
            },
            {
                text: localization.selectionMenu__copyToClipboard,
                icon: () => editor.icons.makeCopyIcon(),
                key: () => {
                    const clipboardHandler = new _util_ClipboardHandler_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](editor, (0,_makeClipboardErrorHandlers_mjs__WEBPACK_IMPORTED_MODULE_2__["default"])(editor));
                    void clipboardHandler.copy();
                },
            },
            ...noSelectionMenu,
        ]
        : noSelectionMenu);
    onActivated?.();
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (showSelectionContextMenu);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/SoundUITool.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/SoundUITool.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SoundUITool)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/BaseTool.mjs");


class SoundFeedback {
    constructor() {
        this.closed = false;
        // No AudioContext? Exit!
        if (!window.AudioContext) {
            console.warn('Accessibility sound UI: Unable to open AudioContext.');
            this.closed = true;
            return;
        }
        this.ctx = new AudioContext();
        // Color oscillator and gain
        this.colorOscHue = this.ctx.createOscillator();
        this.colorOscValue = this.ctx.createOscillator();
        this.colorOscSaturation = this.ctx.createOscillator();
        this.colorOscHue.type = 'triangle';
        this.colorOscSaturation.type = 'sine';
        this.colorOscValue.type = 'sawtooth';
        this.valueGain = this.ctx.createGain();
        this.colorOscValue.connect(this.valueGain);
        this.valueGain.gain.setValueAtTime(0.18, this.ctx.currentTime);
        this.colorGain = this.ctx.createGain();
        this.colorOscHue.connect(this.colorGain);
        this.valueGain.connect(this.colorGain);
        this.colorOscSaturation.connect(this.colorGain);
        this.colorGain.connect(this.ctx.destination);
        // Boundary oscillator and gain
        this.boundaryGain = this.ctx.createGain();
        this.boundaryOsc = this.ctx.createOscillator();
        this.boundaryOsc.type = 'sawtooth';
        this.boundaryGain.gain.setValueAtTime(0, this.ctx.currentTime);
        this.boundaryOsc.connect(this.boundaryGain);
        this.boundaryGain.connect(this.ctx.destination);
        // Prepare for the first announcement/feedback.
        this.colorOscHue.start();
        this.colorOscSaturation.start();
        this.colorOscValue.start();
        this.boundaryOsc.start();
        this.pause();
    }
    pause() {
        if (this.closed)
            return;
        this.colorGain.gain.setValueAtTime(0, this.ctx.currentTime);
        void this.ctx.suspend();
    }
    play() {
        if (this.closed)
            return;
        void this.ctx.resume();
    }
    setColor(color) {
        const hsv = color.asHSV();
        // Choose frequencies that roughly correspond to hue, saturation, and value.
        const hueFrequency = -Math.cos(hsv.x / 2) * 220 + 440;
        const saturationFrequency = hsv.y * 440 + 220;
        const valueFrequency = (hsv.z + 0.1) * 440;
        // Sigmoid with maximum 0.25 * alpha.
        // Louder for greater value.
        const gain = (0.25 * Math.min(1, color.a)) / (1 + Math.exp(-(hsv.z - 0.5) * 3));
        this.colorOscHue.frequency.setValueAtTime(hueFrequency, this.ctx.currentTime);
        this.colorOscSaturation.frequency.setValueAtTime(saturationFrequency, this.ctx.currentTime);
        this.colorOscValue.frequency.setValueAtTime(valueFrequency, this.ctx.currentTime);
        this.valueGain.gain.setValueAtTime((1 - hsv.z) * 0.4, this.ctx.currentTime);
        this.colorGain.gain.setValueAtTime(gain, this.ctx.currentTime);
    }
    announceBoundaryCross(boundaryCrossCount) {
        this.boundaryGain.gain.cancelScheduledValues(this.ctx.currentTime);
        this.boundaryGain.gain.setValueAtTime(0, this.ctx.currentTime);
        this.boundaryGain.gain.linearRampToValueAtTime(0.018, this.ctx.currentTime + 0.1);
        this.boundaryOsc.frequency.setValueAtTime(440 + Math.atan(boundaryCrossCount / 2) * 100, this.ctx.currentTime);
        this.boundaryGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.25);
    }
    close() {
        void this.ctx.close();
        this.closed = true;
    }
}
/**
 * This tool, when enabled, plays a sound representing the color of the portion of the display
 * currently under the cursor. This tool adds a button that can be navigated to with the tab key
 * that enables/disables the tool.
 *
 * This allows the user to explore the content of the display without a working screen.
 */
class SoundUITool extends _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(editor, description) {
        super(editor.notifier, description);
        this.editor = editor;
        this.soundFeedback = null;
        // Create a screen-reader-usable method of toggling the tool:
        this.toggleButtonContainer = document.createElement('div');
        this.toggleButtonContainer.classList.add('js-draw-sound-ui-toggle');
        this.toggleButton = document.createElement('button');
        this.toggleButton.onclick = () => {
            this.setEnabled(!this.isEnabled());
        };
        this.toggleButtonContainer.appendChild(this.toggleButton);
        this.updateToggleButtonText();
        editor.createHTMLOverlay(this.toggleButtonContainer);
    }
    canReceiveInputInReadOnlyEditor() {
        return true;
    }
    updateToggleButtonText() {
        const containerEnabledClass = 'sound-ui-tool-enabled';
        if (this.isEnabled()) {
            this.toggleButton.innerText = this.editor.localization.disableAccessibilityExploreTool;
            this.toggleButtonContainer.classList.add(containerEnabledClass);
        }
        else {
            this.toggleButton.innerText = this.editor.localization.enableAccessibilityExploreTool;
            this.toggleButtonContainer.classList.remove(containerEnabledClass);
        }
    }
    setEnabled(enabled) {
        super.setEnabled(enabled);
        if (!this.isEnabled()) {
            this.soundFeedback?.close();
            this.soundFeedback = null;
        }
        else {
            this.editor.announceForAccessibility(this.editor.localization.soundExplorerUsageAnnouncement);
        }
        this.updateToggleButtonText();
    }
    onKeyPress(event) {
        if (event.code === 'Escape') {
            this.setEnabled(false);
            return true;
        }
        return false;
    }
    onPointerDown({ current, allPointers }) {
        if (!this.soundFeedback) {
            this.soundFeedback = new SoundFeedback();
        }
        // Allow two-finger gestures to move the screen.
        if (allPointers.length >= 2) {
            return false;
        }
        // Accept multiple cursors -- some screen readers require multiple (touch) pointers to interact with
        // an image instead of using the built-in navigation features.
        this.soundFeedback?.play();
        this.soundFeedback?.setColor(this.editor.display.getColorAt(current.screenPos) ?? _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.black);
        this.lastPointerPos = current.canvasPos;
        return true;
    }
    onPointerMove({ current }) {
        this.soundFeedback?.setColor(this.editor.display.getColorAt(current.screenPos) ?? _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.black);
        const pointerMotionLine = new _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.LineSegment2(this.lastPointerPos, current.canvasPos);
        const collisions = this.editor.image
            .getElementsIntersectingRegion(pointerMotionLine.bbox)
            .filter((component) => component.intersects(pointerMotionLine));
        this.lastPointerPos = current.canvasPos;
        if (collisions.length > 0) {
            this.soundFeedback?.announceBoundaryCross(collisions.length);
        }
    }
    onPointerUp(_event) {
        this.soundFeedback?.pause();
    }
    onGestureCancel() {
        this.soundFeedback?.pause();
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/TextTool.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/TextTool.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextTool)
/* harmony export */ });
/* harmony import */ var _components_TextComponent_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/TextComponent.mjs */ "./node_modules/js-draw/dist/mjs/components/TextComponent.mjs");
/* harmony import */ var _image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../image/EditorImage.mjs */ "./node_modules/js-draw/dist/mjs/image/EditorImage.mjs");
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _Pointer_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Pointer.mjs */ "./node_modules/js-draw/dist/mjs/Pointer.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../types.mjs */ "./node_modules/js-draw/dist/mjs/types.mjs");
/* harmony import */ var _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./BaseTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/BaseTool.mjs");
/* harmony import */ var _commands_Erase_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../commands/Erase.mjs */ "./node_modules/js-draw/dist/mjs/commands/Erase.mjs");
/* harmony import */ var _commands_uniteCommands_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../commands/uniteCommands.mjs */ "./node_modules/js-draw/dist/mjs/commands/uniteCommands.mjs");
/* harmony import */ var _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/ReactiveValue.mjs */ "./node_modules/js-draw/dist/mjs/util/ReactiveValue.mjs");









const overlayCSSClass = 'textEditorOverlay';
/** A tool that allows users to enter and edit text. */
class TextTool extends _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_5__["default"] {
    constructor(editor, description, localizationTable) {
        super(editor.notifier, description);
        this.editor = editor;
        this.localizationTable = localizationTable;
        this.textInputElem = null;
        this.textMeasuringCtx = null;
        this.removeExistingCommand = null;
        const editorFonts = editor.getCurrentSettings().text?.fonts ?? [];
        this.textStyleValue = _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_8__.ReactiveValue.fromInitialValue({
            size: 32,
            fontFamily: editorFonts.length > 0 ? editorFonts[0] : 'sans-serif',
            renderingStyle: {
                fill: _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Color4.purple,
            },
        });
        this.textStyleValue.onUpdateAndNow(() => {
            this.textStyle = this.textStyleValue.get();
            this.updateTextInput();
            this.editor.notifier.dispatch(_types_mjs__WEBPACK_IMPORTED_MODULE_4__.EditorEventType.ToolUpdated, {
                kind: _types_mjs__WEBPACK_IMPORTED_MODULE_4__.EditorEventType.ToolUpdated,
                tool: this,
            });
        });
        this.contentTransform = _util_ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_8__.ReactiveValue.fromInitialValue(_js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Mat33.identity);
        this.textEditOverlay = document.createElement('div');
        this.textEditOverlay.classList.add(overlayCSSClass);
        this.editor.addStyleSheet(`
			.${overlayCSSClass} textarea {
				background-color: rgba(0, 0, 0, 0);

				white-space: pre;
				overflow: hidden;

				padding: 0;
				margin: 0;
				border: none;
				padding: 0;

				min-width: 100px;
				min-height: 1.1em;
			}
		`);
        this.anchorControl = this.editor.anchorElementToCanvas(this.textEditOverlay, this.contentTransform);
    }
    initTextMeasuringCanvas() {
        this.textMeasuringCtx ??= document.createElement('canvas').getContext('2d');
    }
    getTextAscent(text, style) {
        this.initTextMeasuringCanvas();
        if (this.textMeasuringCtx) {
            this.textMeasuringCtx.textBaseline = 'alphabetic';
            _components_TextComponent_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].applyTextStyles(this.textMeasuringCtx, style);
            const measurement = this.textMeasuringCtx.measureText(text);
            return measurement.fontBoundingBoxAscent ?? measurement.actualBoundingBoxAscent;
        }
        // Estimate
        return (style.size * 2) / 3;
    }
    // Take input from this' textInputElem and add it to the EditorImage.
    // If [removeInput], the HTML input element is removed. Otherwise, its value
    // is cleared.
    flushInput(removeInput = true) {
        if (!this.textInputElem)
            return;
        // Determine the scroll first -- removing the input (and other DOM changes)
        // also change the scroll.
        const scrollingRegion = this.textEditOverlay.parentElement;
        const containerScroll = _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Vec2.of(scrollingRegion?.scrollLeft ?? 0, scrollingRegion?.scrollTop ?? 0);
        const content = this.textInputElem.value.trimEnd();
        this.textInputElem.value = '';
        if (removeInput) {
            // In some browsers, .remove() triggers a .blur event (synchronously).
            // Clear this.textInputElem before removal
            const input = this.textInputElem;
            this.textInputElem = null;
            input.remove();
        }
        if (content !== '') {
            // When the text is long, it can cause its container to scroll so that the
            // editing caret is in view.
            // So that the text added to the document is in the same position as the text
            // shown in the editor, account for this scroll when computing the transform:
            const scrollCorrectionScreen = containerScroll.times(-1);
            // Uses .transformVec3 to avoid also translating the scroll correction (treating
            // it as a point):
            const scrollCorrectionCanvas = this.editor.viewport.screenToCanvasTransform.transformVec3(scrollCorrectionScreen);
            const scrollTransform = _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Mat33.translation(scrollCorrectionCanvas);
            const textComponent = _components_TextComponent_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].fromLines(content.split('\n'), scrollTransform.rightMul(this.contentTransform.get()), this.textStyle);
            const action = _image_EditorImage_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].addElement(textComponent);
            if (this.removeExistingCommand) {
                // Unapply so that `removeExistingCommand` can be added to the undo stack.
                this.removeExistingCommand.unapply(this.editor);
                this.editor.dispatch((0,_commands_uniteCommands_mjs__WEBPACK_IMPORTED_MODULE_7__["default"])([this.removeExistingCommand, action]));
                this.removeExistingCommand = null;
            }
            else {
                this.editor.dispatch(action);
            }
        }
    }
    updateTextInput() {
        if (!this.textInputElem) {
            return;
        }
        this.textInputElem.placeholder = this.localizationTable.enterTextToInsert;
        this.textInputElem.style.fontFamily = this.textStyle.fontFamily;
        this.textInputElem.style.fontStyle = this.textStyle.fontStyle ?? '';
        this.textInputElem.style.fontVariant = this.textStyle.fontVariant ?? '';
        this.textInputElem.style.fontWeight = this.textStyle.fontWeight ?? '';
        this.textInputElem.style.fontSize = `${this.textStyle.size}px`;
        this.textInputElem.style.color = this.textStyle.renderingStyle.fill.toHexString();
        this.textInputElem.style.margin = '0';
        this.textInputElem.style.width = `${this.textInputElem.scrollWidth}px`;
        this.textInputElem.style.height = `${this.textInputElem.scrollHeight}px`;
        // Get the ascent based on the font, using a string of characters
        // that is tall in most fonts.
        const tallText = 'Testing!';
        const ascent = this.getTextAscent(tallText, this.textStyle);
        const vertAdjust = ascent;
        this.textInputElem.style.transform = `translate(0, ${-vertAdjust}px)`;
        this.textInputElem.style.transformOrigin = 'top left';
        // Match the line height of default rendered text.
        const lineHeight = Math.floor(this.textStyle.size);
        this.textInputElem.style.lineHeight = `${lineHeight}px`;
    }
    startTextInput(textCanvasPos, initialText) {
        this.flushInput();
        this.textInputElem = document.createElement('textarea');
        this.textInputElem.value = initialText;
        this.textInputElem.style.display = 'inline-block';
        const textTargetPosition = this.editor.viewport.roundPoint(textCanvasPos);
        const textRotation = -this.editor.viewport.getRotationAngle();
        const textScale = _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Vec2.of(1, 1).times(this.editor.viewport.getSizeOfPixelOnCanvas());
        this.contentTransform.set(
        // Scale, then rotate, then translate:
        _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Mat33.translation(textTargetPosition)
            .rightMul(_js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Mat33.zRotation(textRotation))
            .rightMul(_js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Mat33.scaling2D(textScale)));
        this.updateTextInput();
        // Update the input size/position/etc. after the placeHolder has had time to appear.
        setTimeout(() => this.updateTextInput(), 0);
        this.textInputElem.oninput = () => {
            if (this.textInputElem) {
                this.textInputElem.style.width = `${this.textInputElem.scrollWidth}px`;
                this.textInputElem.style.height = `${this.textInputElem.scrollHeight}px`;
            }
        };
        this.textInputElem.onblur = () => {
            const input = this.textInputElem;
            // Delay removing the input -- flushInput may be called within a blur()
            // event handler
            const removeInput = false;
            this.flushInput(removeInput);
            this.textInputElem = null;
            if (input) {
                input.classList.add('-hiding');
            }
            setTimeout(() => {
                input?.remove();
            }, 0);
        };
        this.textInputElem.onkeyup = (evt) => {
            // In certain input modes, the <enter> key is used to select characters.
            // When in this mode, prevent <enter> from submitting:
            if (evt.isComposing)
                return;
            if (evt.key === 'Enter' && !evt.shiftKey) {
                this.flushInput();
                this.editor.focus();
            }
            else if (evt.key === 'Escape') {
                // Cancel input.
                this.textInputElem?.remove();
                this.textInputElem = null;
                this.editor.focus();
                this.removeExistingCommand?.unapply(this.editor);
                this.removeExistingCommand = null;
            }
        };
        this.textEditOverlay.replaceChildren(this.textInputElem);
        setTimeout(() => this.textInputElem?.focus(), 0);
    }
    setEnabled(enabled) {
        super.setEnabled(enabled);
        if (!this.isEnabled()) {
            this.flushInput();
        }
        this.textEditOverlay.style.display = enabled ? 'block' : 'none';
    }
    onPointerDown({ current, allPointers }) {
        if (current.device === _Pointer_mjs__WEBPACK_IMPORTED_MODULE_3__.PointerDevice.Eraser) {
            return false;
        }
        if (allPointers.length === 1) {
            // Are we clicking on a text node?
            const canvasPos = current.canvasPos;
            const halfTestRegionSize = _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Vec2.of(4, 4).times(this.editor.viewport.getSizeOfPixelOnCanvas());
            const testRegion = _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Rect2.fromCorners(canvasPos.minus(halfTestRegionSize), canvasPos.plus(halfTestRegionSize));
            const targetNodes = this.editor.image.getElementsIntersectingRegion(testRegion);
            let targetTextNodes = targetNodes.filter((node) => node instanceof _components_TextComponent_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]);
            // Don't try to edit text nodes that contain the viewport (this allows us
            // to zoom in on text nodes and add text on top of them.)
            const visibleRect = this.editor.viewport.visibleRect;
            targetTextNodes = targetTextNodes.filter((node) => !node.getBBox().containsRect(visibleRect));
            // End any TextNodes we're currently editing.
            this.flushInput();
            if (targetTextNodes.length > 0) {
                const targetNode = targetTextNodes[targetTextNodes.length - 1];
                this.setTextStyle(targetNode.getTextStyle());
                // Create and temporarily apply removeExistingCommand.
                this.removeExistingCommand = new _commands_Erase_mjs__WEBPACK_IMPORTED_MODULE_6__["default"]([targetNode]);
                this.removeExistingCommand.apply(this.editor);
                this.startTextInput(targetNode.getBaselinePos(), targetNode.getText());
                this.contentTransform.set(targetNode.getTransform());
                this.updateTextInput();
            }
            else {
                this.removeExistingCommand = null;
                this.startTextInput(current.canvasPos, '');
            }
            return true;
        }
        return false;
    }
    onGestureCancel() {
        this.flushInput();
        this.editor.focus();
    }
    setFontFamily(fontFamily) {
        if (fontFamily !== this.textStyle.fontFamily) {
            this.textStyleValue.set({
                ...this.textStyle,
                fontFamily: fontFamily,
            });
        }
    }
    setColor(color) {
        if (!color.eq(this.textStyle.renderingStyle.fill)) {
            this.textStyleValue.set({
                ...this.textStyle,
                renderingStyle: {
                    ...this.textStyle.renderingStyle,
                    fill: color,
                },
            });
        }
    }
    setFontSize(size) {
        if (size !== this.textStyle.size) {
            this.textStyleValue.set({
                ...this.textStyle,
                size,
            });
        }
    }
    getTextStyle() {
        return this.textStyle;
    }
    getStyleValue() {
        return this.textStyleValue;
    }
    setTextStyle(style) {
        this.textStyleValue.set(style);
    }
    // @internal
    onDestroy() {
        super.onDestroy();
        this.anchorControl.remove();
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/ToolController.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/ToolController.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ToolController)
/* harmony export */ });
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types.mjs */ "./node_modules/js-draw/dist/mjs/types.mjs");
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _PanZoom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PanZoom.mjs */ "./node_modules/js-draw/dist/mjs/tools/PanZoom.mjs");
/* harmony import */ var _Pen_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Pen.mjs */ "./node_modules/js-draw/dist/mjs/tools/Pen.mjs");
/* harmony import */ var _ToolEnabledGroup_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ToolEnabledGroup.mjs */ "./node_modules/js-draw/dist/mjs/tools/ToolEnabledGroup.mjs");
/* harmony import */ var _Eraser_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Eraser.mjs */ "./node_modules/js-draw/dist/mjs/tools/Eraser.mjs");
/* harmony import */ var _SelectionTool_SelectionTool_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./SelectionTool/SelectionTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionTool.mjs");
/* harmony import */ var _UndoRedoShortcut_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./UndoRedoShortcut.mjs */ "./node_modules/js-draw/dist/mjs/tools/UndoRedoShortcut.mjs");
/* harmony import */ var _TextTool_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./TextTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/TextTool.mjs");
/* harmony import */ var _PipetteTool_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./PipetteTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/PipetteTool.mjs");
/* harmony import */ var _ToolSwitcherShortcut_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ToolSwitcherShortcut.mjs */ "./node_modules/js-draw/dist/mjs/tools/ToolSwitcherShortcut.mjs");
/* harmony import */ var _PasteHandler_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./PasteHandler.mjs */ "./node_modules/js-draw/dist/mjs/tools/PasteHandler.mjs");
/* harmony import */ var _ToolbarShortcutHandler_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ToolbarShortcutHandler.mjs */ "./node_modules/js-draw/dist/mjs/tools/ToolbarShortcutHandler.mjs");
/* harmony import */ var _components_builders_PressureSensitiveFreehandLineBuilder_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../components/builders/PressureSensitiveFreehandLineBuilder.mjs */ "./node_modules/js-draw/dist/mjs/components/builders/PressureSensitiveFreehandLineBuilder.mjs");
/* harmony import */ var _FindTool_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./FindTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/FindTool.mjs");
/* harmony import */ var _SelectionTool_SelectAllShortcutHandler_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./SelectionTool/SelectAllShortcutHandler.mjs */ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectAllShortcutHandler.mjs");
/* harmony import */ var _SoundUITool_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./SoundUITool.mjs */ "./node_modules/js-draw/dist/mjs/tools/SoundUITool.mjs");
/* harmony import */ var _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../inputEvents.mjs */ "./node_modules/js-draw/dist/mjs/inputEvents.mjs");
/* harmony import */ var _InputFilter_InputPipeline_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./InputFilter/InputPipeline.mjs */ "./node_modules/js-draw/dist/mjs/tools/InputFilter/InputPipeline.mjs");
/* harmony import */ var _InputFilter_InputStabilizer_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./InputFilter/InputStabilizer.mjs */ "./node_modules/js-draw/dist/mjs/tools/InputFilter/InputStabilizer.mjs");
/* harmony import */ var _ScrollbarTool_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./ScrollbarTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/ScrollbarTool.mjs");





















class ToolController {
    /** @internal */
    constructor(editor, localization) {
        this.activeTool = null;
        this.isEditorReadOnly = editor.isReadOnlyReactiveValue();
        this.inputPipeline = new _InputFilter_InputPipeline_mjs__WEBPACK_IMPORTED_MODULE_18__["default"]();
        this.inputPipeline.setEmitListener((event) => this.onEventInternal(event));
        const primaryToolGroup = new _ToolEnabledGroup_mjs__WEBPACK_IMPORTED_MODULE_4__["default"]();
        this.primaryToolGroup = primaryToolGroup;
        const panZoomTool = new _PanZoom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](editor, _PanZoom_mjs__WEBPACK_IMPORTED_MODULE_2__.PanZoomMode.TwoFingerTouchGestures | _PanZoom_mjs__WEBPACK_IMPORTED_MODULE_2__.PanZoomMode.RightClickDrags, localization.touchPanTool);
        const keyboardPanZoomTool = new _PanZoom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](editor, _PanZoom_mjs__WEBPACK_IMPORTED_MODULE_2__.PanZoomMode.Keyboard, localization.keyboardPanZoom);
        const primaryPenTool = new _Pen_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](editor, localization.penTool(1), {
            color: _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Color4.purple,
            thickness: 8,
        });
        const secondaryPenTool = new _Pen_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](editor, localization.penTool(2), {
            color: _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Color4.clay,
            thickness: 4,
        });
        // Stabilize the secondary pen tool.
        secondaryPenTool.setInputMapper(new _InputFilter_InputStabilizer_mjs__WEBPACK_IMPORTED_MODULE_19__["default"](editor.viewport));
        const eraser = new _Eraser_mjs__WEBPACK_IMPORTED_MODULE_5__["default"](editor, localization.eraserTool);
        const primaryTools = [
            // Three pens
            primaryPenTool,
            secondaryPenTool,
            // Highlighter-like pen with width=40
            new _Pen_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](editor, localization.penTool(3), {
                color: _js_draw_math__WEBPACK_IMPORTED_MODULE_1__.Color4.ofRGBA(1, 1, 0, 0.5),
                thickness: 40,
                factory: _components_builders_PressureSensitiveFreehandLineBuilder_mjs__WEBPACK_IMPORTED_MODULE_13__.makePressureSensitiveFreehandLineBuilder,
            }),
            eraser,
            new _SelectionTool_SelectionTool_mjs__WEBPACK_IMPORTED_MODULE_6__["default"](editor, localization.selectionTool),
            new _TextTool_mjs__WEBPACK_IMPORTED_MODULE_8__["default"](editor, localization.textTool, localization),
            new _PanZoom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](editor, _PanZoom_mjs__WEBPACK_IMPORTED_MODULE_2__.PanZoomMode.SinglePointerGestures, localization.anyDevicePanning),
        ];
        // Accessibility tools
        const soundExplorer = new _SoundUITool_mjs__WEBPACK_IMPORTED_MODULE_16__["default"](editor, localization.soundExplorer);
        soundExplorer.setEnabled(false);
        this.tools = [
            new _ScrollbarTool_mjs__WEBPACK_IMPORTED_MODULE_20__["default"](editor),
            new _PipetteTool_mjs__WEBPACK_IMPORTED_MODULE_9__["default"](editor, localization.pipetteTool),
            soundExplorer,
            panZoomTool,
            ...primaryTools,
            keyboardPanZoomTool,
            new _UndoRedoShortcut_mjs__WEBPACK_IMPORTED_MODULE_7__["default"](editor),
            new _ToolbarShortcutHandler_mjs__WEBPACK_IMPORTED_MODULE_12__["default"](editor),
            new _ToolSwitcherShortcut_mjs__WEBPACK_IMPORTED_MODULE_10__["default"](editor),
            eraser.makeEraserSwitcherTool(),
            new _FindTool_mjs__WEBPACK_IMPORTED_MODULE_14__["default"](editor),
            new _PasteHandler_mjs__WEBPACK_IMPORTED_MODULE_11__["default"](editor),
            new _SelectionTool_SelectAllShortcutHandler_mjs__WEBPACK_IMPORTED_MODULE_15__["default"](editor),
        ];
        primaryTools.forEach((tool) => tool.setToolGroup(primaryToolGroup));
        panZoomTool.setEnabled(true);
        primaryPenTool.setEnabled(true);
        editor.notifier.on(_types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ToolEnabled, (event) => {
            if (event.kind === _types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ToolEnabled) {
                editor.announceForAccessibility(localization.toolEnabledAnnouncement(event.tool.description));
            }
        });
        editor.notifier.on(_types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ToolDisabled, (event) => {
            if (event.kind === _types_mjs__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ToolDisabled) {
                editor.announceForAccessibility(localization.toolDisabledAnnouncement(event.tool.description));
            }
        });
        this.activeTool = null;
    }
    /**
     * Replaces the current set of tools with `tools`. This should only be done before
     * the creation of the app's toolbar (if using `AbstractToolbar`).
     *
     * If no `primaryToolGroup` is given, an empty one will be created.
     */
    setTools(tools, primaryToolGroup) {
        this.tools = tools;
        this.primaryToolGroup = primaryToolGroup ?? new _ToolEnabledGroup_mjs__WEBPACK_IMPORTED_MODULE_4__["default"]();
    }
    /**
     * Add a tool that acts like one of the primary tools (only one primary tool can be enabled at a time).
     *
     * If the tool is already added to this, the tool is converted to a primary tool.
     *
     * This should be called before creating the app's toolbar.
     */
    addPrimaryTool(tool) {
        tool.setToolGroup(this.primaryToolGroup);
        if (tool.isEnabled()) {
            this.primaryToolGroup.notifyEnabled(tool);
        }
        if (!this.tools.includes(tool)) {
            this.addTool(tool);
        }
    }
    getPrimaryTools() {
        return this.tools.filter((tool) => {
            return tool.getToolGroup() === this.primaryToolGroup;
        });
    }
    /**
     * Add a tool to the end of this' tool list (the added tool receives events after tools already added to this).
     * This should be called before creating the app's toolbar.
     *
     * If `options.addToFront`, the tool is added to the beginning of this' tool list.
     *
     * Does nothing if the tool is already present.
     */
    addTool(tool, options) {
        // Only add if not already present.
        if (!this.tools.includes(tool)) {
            if (options?.addToFront) {
                this.tools.splice(0, 0, tool);
            }
            else {
                this.tools.push(tool);
            }
        }
    }
    /**
     * Removes **and destroys** all tools in `tools` from this.
     */
    removeAndDestroyTools(tools) {
        const newTools = [];
        for (const tool of this.tools) {
            if (tools.includes(tool)) {
                if (this.activeTool === tool) {
                    this.activeTool = null;
                }
                tool.onDestroy();
            }
            else {
                newTools.push(tool);
            }
        }
        this.tools = newTools;
    }
    insertTools(insertNear, toolsToInsert, mode) {
        this.tools = this.tools.filter((tool) => !toolsToInsert.includes(tool));
        const newTools = [];
        for (const tool of this.tools) {
            if (mode === 'after') {
                newTools.push(tool);
            }
            if (tool === insertNear) {
                newTools.push(...toolsToInsert);
            }
            if (mode === 'before') {
                newTools.push(tool);
            }
        }
        this.tools = newTools;
    }
    /**
     * Removes a tool from this' tool list and replaces it with `replaceWith`.
     *
     * If any of `toolsToInsert` have already been added to this, the tools are
     * moved.
     *
     * This should be called before creating the editor's toolbar.
     */
    insertToolsAfter(insertAfter, toolsToInsert) {
        this.insertTools(insertAfter, toolsToInsert, 'after');
    }
    /** @see {@link insertToolsAfter} */
    insertToolsBefore(insertBefore, toolsToInsert) {
        this.insertTools(insertBefore, toolsToInsert, 'before');
    }
    // @internal use `dispatchEvent` rather than calling `onEvent` directly.
    onEventInternal(event) {
        const isEditorReadOnly = this.isEditorReadOnly.get();
        const canToolReceiveInput = (tool) => {
            return tool.isEnabled() && (!isEditorReadOnly || tool.canReceiveInputInReadOnlyEditor());
        };
        let handled = false;
        if (event.kind === _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_17__.InputEvtType.PointerDownEvt) {
            let canOnlySendToActiveTool = false;
            if (this.activeTool && !this.activeTool.eventCanBeDeliveredToNonActiveTool(event)) {
                canOnlySendToActiveTool = true;
            }
            for (const tool of this.tools) {
                if (canOnlySendToActiveTool && tool !== this.activeTool) {
                    continue;
                }
                if (canToolReceiveInput(tool) && tool.onEvent(event)) {
                    if (this.activeTool !== tool) {
                        this.activeTool?.onEvent({ kind: _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_17__.InputEvtType.GestureCancelEvt });
                    }
                    this.activeTool = tool;
                    handled = true;
                    break;
                }
            }
        }
        else if (event.kind === _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_17__.InputEvtType.PointerUpEvt) {
            const upResult = this.activeTool?.onEvent(event);
            const continueHandlingEvents = upResult && event.allPointers.length > 1;
            // Should the active tool continue handling events (without an additional pointer down?)
            if (!continueHandlingEvents) {
                // No -- Remove the current tool
                this.activeTool = null;
            }
            handled = true;
        }
        else if (event.kind === _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_17__.InputEvtType.PointerMoveEvt) {
            if (this.activeTool !== null) {
                this.activeTool.onEvent(event);
                handled = true;
            }
        }
        else if (event.kind === _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_17__.InputEvtType.GestureCancelEvt) {
            if (this.activeTool !== null) {
                this.activeTool.onEvent(event);
                this.activeTool = null;
            }
        }
        else {
            for (const tool of this.tools) {
                if (!canToolReceiveInput(tool)) {
                    continue;
                }
                handled = tool.onEvent(event);
                if (handled) {
                    break;
                }
            }
        }
        return handled;
    }
    /** Alias for {@link dispatchInputEvent}. */
    onEvent(event) {
        return this.dispatchInputEvent(event);
    }
    // Returns true if the event was handled.
    dispatchInputEvent(event) {
        // Feed the event through the input pipeline
        return this.inputPipeline.onEvent(event);
    }
    /**
     * Adds a new `InputMapper` to this' input pipeline.
     *
     * A `mapper` is really a relation that maps each event to no, one,
     * or many other events.
     *
     * @see {@link InputMapper}.
     */
    addInputMapper(mapper) {
        this.inputPipeline.addToTail(mapper);
    }
    getMatchingTools(type) {
        return this.tools.filter((tool) => tool instanceof type);
    }
    // @internal
    onEditorDestroyed() {
        for (const tool of this.tools) {
            tool.onDestroy();
        }
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/ToolEnabledGroup.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/ToolEnabledGroup.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ToolEnabledGroup)
/* harmony export */ });
// Connects a group of tools -- at most one tool in the group can be enabled.
class ToolEnabledGroup {
    constructor() { }
    notifyEnabled(tool) {
        if (tool !== this.activeTool) {
            this.activeTool?.setEnabled(false);
            this.activeTool = tool;
        }
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/ToolSwitcherShortcut.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/ToolSwitcherShortcut.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ToolSwitcherShortcut)
/* harmony export */ });
/* harmony import */ var _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/BaseTool.mjs");

/**
 * Handles keyboard events used, by default, to select tools. By default,
 * 1 maps to the first primary tool, 2 to the second primary tool, ... .
 *
 * This is in the default set of {@link ToolController} tools.
 *
 */
class ToolSwitcherShortcut extends _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(editor) {
        super(editor.notifier, editor.localization.changeTool);
        this.editor = editor;
    }
    canReceiveInputInReadOnlyEditor() {
        return true;
    }
    // @internal
    onKeyPress({ key }) {
        const toolController = this.editor.toolController;
        const primaryTools = toolController.getPrimaryTools();
        // Map keys 0-9 to primary tools.
        const keyMatch = /^[0-9]$/.exec(key);
        let targetTool;
        if (keyMatch) {
            const targetIdx = parseInt(keyMatch[0], 10) - 1;
            targetTool = primaryTools[targetIdx];
        }
        if (targetTool) {
            targetTool.setEnabled(true);
            return true;
        }
        return false;
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/ToolbarShortcutHandler.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/ToolbarShortcutHandler.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ToolbarShortcutHandler)
/* harmony export */ });
/* harmony import */ var _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/BaseTool.mjs");
// Allows the toolbar to register keyboard events.
// @packageDocumentation

class ToolbarShortcutHandler extends _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(editor) {
        super(editor.notifier, editor.localization.changeTool);
        this.listeners = new Set([]);
    }
    registerListener(listener) {
        this.listeners.add(listener);
    }
    removeListener(listener) {
        this.listeners.delete(listener);
    }
    onKeyPress(event) {
        // TypeScript seems to automatically convert for of loops into for(init;check;update)
        // loops (even with target set to es6). Thus, we cannot iterate directly through the
        // set here.
        // See https://stackoverflow.com/q/48886500
        const listeners = Array.from(this.listeners.values());
        for (const listener of listeners) {
            if (listener(event)) {
                return true;
            }
        }
        return false;
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/UndoRedoShortcut.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/UndoRedoShortcut.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ UndoRedoShortcut)
/* harmony export */ });
/* harmony import */ var _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/BaseTool.mjs");
/* harmony import */ var _keybindings_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keybindings.mjs */ "./node_modules/js-draw/dist/mjs/tools/keybindings.mjs");


// Handles ctrl+Z, ctrl+Shift+Z keyboard shortcuts.
class UndoRedoShortcut extends _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(editor) {
        super(editor.notifier, editor.localization.undoRedoTool);
        this.editor = editor;
    }
    // @internal
    onKeyPress(event) {
        if (this.editor.shortcuts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_1__.undoKeyboardShortcutId, event)) {
            void this.editor.history.undo();
            return true;
        }
        else if (this.editor.shortcuts.matchesShortcut(_keybindings_mjs__WEBPACK_IMPORTED_MODULE_1__.redoKeyboardShortcutId, event)) {
            void this.editor.history.redo();
            return true;
        }
        return false;
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/keybindings.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/keybindings.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decreaseSizeKeyboardShortcutId: () => (/* binding */ decreaseSizeKeyboardShortcutId),
/* harmony export */   duplicateSelectionShortcut: () => (/* reexport safe */ _SelectionTool_keybindings_mjs__WEBPACK_IMPORTED_MODULE_1__.duplicateSelectionShortcut),
/* harmony export */   increaseSizeKeyboardShortcutId: () => (/* binding */ increaseSizeKeyboardShortcutId),
/* harmony export */   lineLockKeyboardShortcutId: () => (/* binding */ lineLockKeyboardShortcutId),
/* harmony export */   moveDownKeyboardShortcutId: () => (/* binding */ moveDownKeyboardShortcutId),
/* harmony export */   moveLeftKeyboardShortcutId: () => (/* binding */ moveLeftKeyboardShortcutId),
/* harmony export */   moveRightKeyboardShortcutId: () => (/* binding */ moveRightKeyboardShortcutId),
/* harmony export */   moveUpKeyboardShortcutId: () => (/* binding */ moveUpKeyboardShortcutId),
/* harmony export */   redoKeyboardShortcutId: () => (/* binding */ redoKeyboardShortcutId),
/* harmony export */   rotateClockwiseKeyboardShortcutId: () => (/* binding */ rotateClockwiseKeyboardShortcutId),
/* harmony export */   rotateClockwiseSelectionShortcutId: () => (/* reexport safe */ _SelectionTool_keybindings_mjs__WEBPACK_IMPORTED_MODULE_1__.rotateClockwiseSelectionShortcutId),
/* harmony export */   rotateCounterClockwiseKeyboardShortcutId: () => (/* binding */ rotateCounterClockwiseKeyboardShortcutId),
/* harmony export */   rotateCounterClockwiseSelectionShortcutId: () => (/* reexport safe */ _SelectionTool_keybindings_mjs__WEBPACK_IMPORTED_MODULE_1__.rotateCounterClockwiseSelectionShortcutId),
/* harmony export */   selectAllKeyboardShortcut: () => (/* reexport safe */ _SelectionTool_keybindings_mjs__WEBPACK_IMPORTED_MODULE_1__.selectAllKeyboardShortcut),
/* harmony export */   sendToBackSelectionShortcut: () => (/* reexport safe */ _SelectionTool_keybindings_mjs__WEBPACK_IMPORTED_MODULE_1__.sendToBackSelectionShortcut),
/* harmony export */   shrinkXSelectionShortcutId: () => (/* reexport safe */ _SelectionTool_keybindings_mjs__WEBPACK_IMPORTED_MODULE_1__.shrinkXSelectionShortcutId),
/* harmony export */   shrinkXYSelectionShortcutId: () => (/* reexport safe */ _SelectionTool_keybindings_mjs__WEBPACK_IMPORTED_MODULE_1__.shrinkXYSelectionShortcutId),
/* harmony export */   shrinkYSelectionShortcutId: () => (/* reexport safe */ _SelectionTool_keybindings_mjs__WEBPACK_IMPORTED_MODULE_1__.shrinkYSelectionShortcutId),
/* harmony export */   snapToGridKeyboardShortcutId: () => (/* binding */ snapToGridKeyboardShortcutId),
/* harmony export */   stretchXSelectionShortcutId: () => (/* reexport safe */ _SelectionTool_keybindings_mjs__WEBPACK_IMPORTED_MODULE_1__.stretchXSelectionShortcutId),
/* harmony export */   stretchXYSelectionShortcutId: () => (/* reexport safe */ _SelectionTool_keybindings_mjs__WEBPACK_IMPORTED_MODULE_1__.stretchXYSelectionShortcutId),
/* harmony export */   stretchYSelectionShortcutId: () => (/* reexport safe */ _SelectionTool_keybindings_mjs__WEBPACK_IMPORTED_MODULE_1__.stretchYSelectionShortcutId),
/* harmony export */   toggleFindVisibleShortcutId: () => (/* binding */ toggleFindVisibleShortcutId),
/* harmony export */   translateDownSelectionShortcutId: () => (/* reexport safe */ _SelectionTool_keybindings_mjs__WEBPACK_IMPORTED_MODULE_1__.translateDownSelectionShortcutId),
/* harmony export */   translateLeftSelectionShortcutId: () => (/* reexport safe */ _SelectionTool_keybindings_mjs__WEBPACK_IMPORTED_MODULE_1__.translateLeftSelectionShortcutId),
/* harmony export */   translateRightSelectionShortcutId: () => (/* reexport safe */ _SelectionTool_keybindings_mjs__WEBPACK_IMPORTED_MODULE_1__.translateRightSelectionShortcutId),
/* harmony export */   translateUpSelectionShortcutId: () => (/* reexport safe */ _SelectionTool_keybindings_mjs__WEBPACK_IMPORTED_MODULE_1__.translateUpSelectionShortcutId),
/* harmony export */   undoKeyboardShortcutId: () => (/* binding */ undoKeyboardShortcutId),
/* harmony export */   zoomInKeyboardShortcutId: () => (/* binding */ zoomInKeyboardShortcutId),
/* harmony export */   zoomOutKeyboardShortcutId: () => (/* binding */ zoomOutKeyboardShortcutId)
/* harmony export */ });
/* harmony import */ var _shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shortcuts/KeyboardShortcutManager.mjs */ "./node_modules/js-draw/dist/mjs/shortcuts/KeyboardShortcutManager.mjs");
/* harmony import */ var _SelectionTool_keybindings_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SelectionTool/keybindings.mjs */ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/keybindings.mjs");

// This file contains user-overridable tool-realted keybindings.
// Undo/redo
const undoKeyboardShortcutId = 'jsdraw.tools.undo';
const redoKeyboardShortcutId = 'jsdaw.tools.redo';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(undoKeyboardShortcutId, ['CtrlOrMeta+KeyZ'], 'Undo');
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(redoKeyboardShortcutId, ['CtrlOrMeta+Shift+KeyZ', 'CtrlOrMeta+KeyY'], 'Redo');
// Pen/eraser/selection keybindings
const increaseSizeKeyboardShortcutId = 'jsdraw.tools.increaseSize';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(increaseSizeKeyboardShortcutId, ['Equal', 'Shift+Equal'], 'Increase pen/eraser size');
const decreaseSizeKeyboardShortcutId = 'jsdraw.tools.decreaseSize';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(decreaseSizeKeyboardShortcutId, ['Minus', 'Shift+Minus'], 'Decrease pen/eraser size');
const snapToGridKeyboardShortcutId = 'jsdraw.tools.snapToGrid';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(snapToGridKeyboardShortcutId, ['Control', 'Meta'], 'Snap to grid (press and hold)');
const lineLockKeyboardShortcutId = 'jsdraw.tools.lockToLine';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(lineLockKeyboardShortcutId, ['Shift'], 'Snap to XY axes (press and hold)');
// Find tool
const toggleFindVisibleShortcutId = 'js-draw.tools.FindTool.toggleVisible';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(toggleFindVisibleShortcutId, ['CtrlOrMeta+KeyF'], 'Shows/hides the find tool');
// Pan/zoom
const moveLeftKeyboardShortcutId = 'jsdraw.tools.PanZoom.moveLeft';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(moveLeftKeyboardShortcutId, ['ArrowLeft', 'KeyH', 'KeyA'], 'Pan left');
const moveRightKeyboardShortcutId = 'jsdraw.tools.PanZoom.moveRight';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(moveRightKeyboardShortcutId, ['ArrowRight', 'KeyL', 'KeyD'], 'Pan right');
const moveUpKeyboardShortcutId = 'jsdraw.tools.PanZoom.moveUp';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(moveUpKeyboardShortcutId, ['ArrowUp', 'KeyK', 'KeyQ'], 'Pan up');
const moveDownKeyboardShortcutId = 'jsdraw.tools.PanZoom.moveDown';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(moveDownKeyboardShortcutId, ['ArrowDown', 'KeyJ', 'KeyE'], 'Pan down');
const rotateClockwiseKeyboardShortcutId = 'jsdraw.tools.PanZoom.rotateViewClockwise';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(rotateClockwiseKeyboardShortcutId, ['Shift+KeyR'], 'Rotate viewport clockwise');
const rotateCounterClockwiseKeyboardShortcutId = 'jsdraw.tools.PanZoom.rotateViewCounterClockwise';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(rotateCounterClockwiseKeyboardShortcutId, ['KeyR'], 'Rotate viewport counter-clockwise');
const zoomInKeyboardShortcutId = 'jsdraw.tools.PanZoom.zoomIn';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(zoomInKeyboardShortcutId, ['KeyW'], 'Zoom in');
const zoomOutKeyboardShortcutId = 'jsdraw.tools.PanZoom.zoomOut';
_shortcuts_KeyboardShortcutManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].registerDefaultKeyboardShortcut(zoomOutKeyboardShortcutId, ['KeyS'], 'Zoom out');
// Selection tool



/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/lib.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/lib.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseTool: () => (/* reexport safe */ _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   EraserMode: () => (/* reexport safe */ _Eraser_mjs__WEBPACK_IMPORTED_MODULE_11__.EraserMode),
/* harmony export */   EraserTool: () => (/* reexport safe */ _Eraser_mjs__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   InputMapper: () => (/* reexport safe */ _InputFilter_InputMapper_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   PanZoomMode: () => (/* reexport safe */ _PanZoom_mjs__WEBPACK_IMPORTED_MODULE_6__.PanZoomMode),
/* harmony export */   PanZoomTool: () => (/* reexport safe */ _PanZoom_mjs__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   PasteHandler: () => (/* reexport safe */ _PasteHandler_mjs__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   PenTool: () => (/* reexport safe */ _Pen_mjs__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   SelectAllShortcutHandler: () => (/* reexport safe */ _SelectionTool_SelectAllShortcutHandler_mjs__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   SelectionTool: () => (/* reexport safe */ _SelectionTool_SelectionTool_mjs__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   SoundUITool: () => (/* reexport safe */ _SoundUITool_mjs__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   TextTool: () => (/* reexport safe */ _TextTool_mjs__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   ToolController: () => (/* reexport safe */ _ToolController_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   ToolEnabledGroup: () => (/* reexport safe */ _ToolEnabledGroup_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   ToolSwitcherShortcut: () => (/* reexport safe */ _ToolSwitcherShortcut_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   ToolbarShortcutHandler: () => (/* reexport safe */ _ToolbarShortcutHandler_mjs__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   UndoRedoShortcut: () => (/* reexport safe */ _UndoRedoShortcut_mjs__WEBPACK_IMPORTED_MODULE_4__["default"])
/* harmony export */ });
/* harmony import */ var _InputFilter_InputMapper_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./InputFilter/InputMapper.mjs */ "./node_modules/js-draw/dist/mjs/tools/InputFilter/InputMapper.mjs");
/* harmony import */ var _BaseTool_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/BaseTool.mjs");
/* harmony import */ var _ToolController_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ToolController.mjs */ "./node_modules/js-draw/dist/mjs/tools/ToolController.mjs");
/* harmony import */ var _ToolEnabledGroup_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ToolEnabledGroup.mjs */ "./node_modules/js-draw/dist/mjs/tools/ToolEnabledGroup.mjs");
/* harmony import */ var _UndoRedoShortcut_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./UndoRedoShortcut.mjs */ "./node_modules/js-draw/dist/mjs/tools/UndoRedoShortcut.mjs");
/* harmony import */ var _ToolSwitcherShortcut_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ToolSwitcherShortcut.mjs */ "./node_modules/js-draw/dist/mjs/tools/ToolSwitcherShortcut.mjs");
/* harmony import */ var _PanZoom_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PanZoom.mjs */ "./node_modules/js-draw/dist/mjs/tools/PanZoom.mjs");
/* harmony import */ var _Pen_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Pen.mjs */ "./node_modules/js-draw/dist/mjs/tools/Pen.mjs");
/* harmony import */ var _TextTool_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./TextTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/TextTool.mjs");
/* harmony import */ var _SelectionTool_SelectionTool_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./SelectionTool/SelectionTool.mjs */ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionTool.mjs");
/* harmony import */ var _SelectionTool_SelectAllShortcutHandler_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./SelectionTool/SelectAllShortcutHandler.mjs */ "./node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectAllShortcutHandler.mjs");
/* harmony import */ var _Eraser_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Eraser.mjs */ "./node_modules/js-draw/dist/mjs/tools/Eraser.mjs");
/* harmony import */ var _PasteHandler_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./PasteHandler.mjs */ "./node_modules/js-draw/dist/mjs/tools/PasteHandler.mjs");
/* harmony import */ var _SoundUITool_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./SoundUITool.mjs */ "./node_modules/js-draw/dist/mjs/tools/SoundUITool.mjs");
/* harmony import */ var _ToolbarShortcutHandler_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./ToolbarShortcutHandler.mjs */ "./node_modules/js-draw/dist/mjs/tools/ToolbarShortcutHandler.mjs");

















/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/localization.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/localization.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultToolLocalization: () => (/* binding */ defaultToolLocalization)
/* harmony export */ });
const defaultToolLocalization = {
    penTool: (penId) => `Pen ${penId}`,
    selectionTool: 'Selection',
    selectAllTool: 'Select all shortcut',
    eraserTool: 'Eraser',
    touchPanTool: 'Touch panning',
    twoFingerPanZoomTool: 'Panning and zooming',
    undoRedoTool: 'Undo/Redo',
    rightClickDragPanTool: 'Right-click drag',
    pipetteTool: 'Pick color from screen',
    keyboardPanZoom: 'Keyboard pan/zoom shortcuts',
    selectionMenu__show: 'Show selection menu',
    selectionMenu__copyToClipboard: 'Copy to clipboard',
    selectionMenu__duplicate: 'Duplicate',
    selectionMenu__delete: 'Delete',
    selectionMenu__paste: 'Paste',
    copyPasteError__heading: 'Copy/paste',
    copyPasteError__description: 'Something went wrong — this tool may not have clipboard access.',
    copyPasteError__errorDetails: 'Show error',
    copyPasteError__pasteRetry: 'To retry, please paste into the input box below:',
    copyPasteError__copyRetry: 'To retry, please copy the text in the input box below:',
    copyPasteError__copyMe: 'Copy me!',
    autocorrectedTo: (strokeDescription) => `Autocorrected to ${strokeDescription}`,
    autocorrectionCanceled: 'Autocorrect cancelled',
    textTool: 'Text',
    enterTextToInsert: 'Text to insert',
    changeTool: 'Change tool',
    pasteHandler: 'Copy paste handler',
    soundExplorer: 'Sound-based image exploration',
    disableAccessibilityExploreTool: 'Disable sound-based exploration',
    enableAccessibilityExploreTool: 'Enable sound-based exploration',
    soundExplorerUsageAnnouncement: 'Sound-based image exploration enabled: Click/drag the screen to play a sound representation of different parts of the image.',
    findLabel: 'Find',
    toNextMatch: 'Next',
    closeDialog: 'Close',
    findDialogShown: 'Find dialog shown',
    findDialogHidden: 'Find dialog hidden',
    focusedFoundText: (matchIdx, totalMatches) => `Viewing match ${matchIdx} of ${totalMatches}`,
    anyDevicePanning: 'Any device panning',
    copied: (count) => `Copied ${count} item(s)`,
    pasted: (count) => `Pasted ${count} item(s)`,
    toolEnabledAnnouncement: (toolName) => `${toolName} enabled`,
    toolDisabledAnnouncement: (toolName) => `${toolName} disabled`,
};


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/util/StationaryPenDetector.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/util/StationaryPenDetector.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ StationaryPenDetector),
/* harmony export */   defaultStationaryDetectionConfig: () => (/* binding */ defaultStationaryDetectionConfig)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");

const defaultStationaryDetectionConfig = {
    maxSpeed: 8.5, // screenPx/s
    maxRadius: 11, // screenPx
    minTimeSeconds: 0.5, // s
};
class StationaryPenDetector {
    // Only handles one pen. As such, `startPointer` should be the same device/finger
    // as `updatedPointer` in `onPointerMove`.
    //
    // A new `StationaryPenDetector` should be created for each gesture.
    constructor(startPointer, config, onStationary) {
        this.config = config;
        this.onStationary = onStationary;
        this.timeout = null;
        this.stationaryStartPointer = startPointer;
        this.lastPointer = startPointer;
        this.averageVelocity = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec2.zero;
        this.setStationaryTimeout(this.config.minTimeSeconds * 1000);
    }
    // Returns true if stationary
    onPointerMove(currentPointer) {
        if (!this.stationaryStartPointer) {
            // Destoroyed
            return;
        }
        if (currentPointer.id !== this.stationaryStartPointer.id) {
            return false;
        }
        // dx: "Δx" Displacement from last.
        const dxFromLast = currentPointer.screenPos.minus(this.lastPointer.screenPos);
        const dxFromStationaryStart = currentPointer.screenPos.minus(this.stationaryStartPointer.screenPos);
        // dt: Delta time:
        // /1000: Convert to s.
        let dtFromLast = (currentPointer.timeStamp - this.lastPointer.timeStamp) / 1000; // s
        // Don't divide by zero
        if (dtFromLast === 0) {
            dtFromLast = 1;
        }
        const currentVelocity = dxFromLast.times(1 / dtFromLast); // px/s
        // Slight smoothing of the velocity to prevent input jitter from affecting the
        // velocity too significantly.
        this.averageVelocity = this.averageVelocity.lerp(currentVelocity, 0.5); // px/s
        const dtFromStart = currentPointer.timeStamp - this.stationaryStartPointer.timeStamp; // ms
        const movedOutOfRadius = dxFromStationaryStart.length() > this.config.maxRadius;
        this.hasMovedOutOfRadius ||= movedOutOfRadius;
        // If not stationary
        if (movedOutOfRadius ||
            this.averageVelocity.length() > this.config.maxSpeed ||
            dtFromStart < this.config.minTimeSeconds) {
            this.stationaryStartPointer = currentPointer;
            this.lastPointer = currentPointer;
            this.setStationaryTimeout(this.config.minTimeSeconds * 1000);
            return false;
        }
        const stationaryTimeoutMs = this.config.minTimeSeconds * 1000 - dtFromStart;
        this.lastPointer = currentPointer;
        return stationaryTimeoutMs <= 0;
    }
    onPointerUp(pointer) {
        if (pointer.id !== this.stationaryStartPointer?.id) {
            this.cancelStationaryTimeout();
        }
    }
    destroy() {
        this.cancelStationaryTimeout();
        this.stationaryStartPointer = null;
    }
    getHasMovedOutOfRadius() {
        return this.hasMovedOutOfRadius;
    }
    cancelStationaryTimeout() {
        if (this.timeout !== null) {
            clearTimeout(this.timeout);
            this.timeout = null;
        }
    }
    setStationaryTimeout(timeoutMs) {
        if (this.timeout !== null) {
            return;
        }
        if (timeoutMs <= 0) {
            this.onStationary(this.lastPointer);
        }
        else {
            this.timeout = setTimeout(() => {
                this.timeout = null;
                if (!this.stationaryStartPointer) {
                    // Destroyed
                    return;
                }
                const timeSinceStationaryStart = performance.now() - this.stationaryStartPointer.timeStamp;
                const timeRemaining = this.config.minTimeSeconds * 1000 - timeSinceStationaryStart;
                if (timeRemaining <= 0) {
                    this.onStationary(this.lastPointer);
                }
                else {
                    this.setStationaryTimeout(timeRemaining);
                }
            }, timeoutMs);
        }
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/tools/util/createMenuOverlay.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/tools/util/createMenuOverlay.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_waitForTimeout_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/waitForTimeout.mjs */ "./node_modules/js-draw/dist/mjs/util/waitForTimeout.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../types.mjs */ "./node_modules/js-draw/dist/mjs/types.mjs");


let idCounter = 0;
const createMenuOverlay = async (editor, canvasAnchor, options) => {
    const overlay = document.createElement('div');
    const { remove: removeOverlay } = editor.createHTMLOverlay(overlay);
    const menuModal = document.createElement('dialog');
    menuModal.classList.add('editor-popup-menu');
    const hideMenuTimeout = 240;
    menuModal.style.setProperty('--hide-menu-animation-timeout', `${hideMenuTimeout}ms`);
    const updateMenuLocation = () => {
        const overlayRect = editor.getOutputBBoxInDOM();
        const anchor = editor.viewport.canvasToScreen(canvasAnchor).plus(overlayRect.topLeft);
        menuModal.style.setProperty('--anchor-x', `${anchor.x}px`);
        menuModal.style.setProperty('--anchor-y', `${anchor.y}px`);
    };
    updateMenuLocation();
    const viewportChangeListener = editor.notifier.on(_types_mjs__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.ViewportChanged, updateMenuLocation);
    overlay.appendChild(menuModal);
    let dismissing = false;
    const dismissMenu = async () => {
        if (dismissing)
            return;
        dismissing = true;
        viewportChangeListener.remove();
        menuModal.classList.add('-hide');
        await (0,_util_waitForTimeout_mjs__WEBPACK_IMPORTED_MODULE_0__["default"])(hideMenuTimeout);
        menuModal.close();
    };
    return new Promise((resolve) => {
        let resolved = false;
        let result = null;
        const resolveWithSelectedResult = () => {
            if (!resolved) {
                resolve(result);
                resolved = true;
            }
        };
        menuModal.onclose = () => {
            removeOverlay();
            resolveWithSelectedResult();
        };
        const onOptionSelected = (key) => {
            result = key;
            void dismissMenu();
            // To properly handle clipboard events, this needs to be called synchronously
            // and not after a delay:
            resolveWithSelectedResult();
        };
        editor.handlePointerEventsExceptClicksFrom(menuModal, (eventName, event) => {
            if (event.target === menuModal && eventName === 'pointerdown') {
                void dismissMenu();
                return true;
            }
            else if (dismissing) {
                // Send pointer events to the editor if the dialog is in the process of being
                // dismissed (e.g. pointermove events just after a pointerdown outside of the
                // editor).
                return true;
            }
            return false;
        }, (_eventName, event) => {
            return event.target === menuModal;
        });
        const contentElement = document.createElement('div');
        contentElement.classList.add('content');
        contentElement.role = 'menu';
        const optionElements = [];
        // Keyboard focus handling as described in
        // - https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/menu_role and
        // - https://www.w3.org/WAI/ARIA/apg/patterns/disclosure/examples/disclosure-navigation/
        contentElement.addEventListener('keydown', (event) => {
            const focusedIndex = optionElements.findIndex((item) => item === document.activeElement);
            if (focusedIndex === -1)
                return;
            let newFocusedIndex = focusedIndex;
            if (event.key === 'ArrowDown') {
                newFocusedIndex++;
            }
            else if (event.key === 'ArrowUp') {
                newFocusedIndex--;
            }
            else if (event.key === 'End') {
                newFocusedIndex = optionElements.length - 1;
            }
            else if (event.key === 'Home') {
                newFocusedIndex = 0;
            }
            if (newFocusedIndex < 0) {
                newFocusedIndex += optionElements.length;
            }
            newFocusedIndex %= optionElements.length;
            if (newFocusedIndex !== focusedIndex) {
                event.preventDefault();
                optionElements[newFocusedIndex].focus();
            }
        });
        for (const option of options) {
            const optionElement = document.createElement('button');
            optionElement.id = `menu-overlay-option-${idCounter++}`;
            optionElement.role = 'menuitem';
            optionElement.classList.add('option', 'editor-popup-menu-option');
            optionElement.replaceChildren(option.icon(), document.createTextNode(option.text));
            optionElement.onclick = (event) => {
                if (event.defaultPrevented)
                    return;
                onOptionSelected(option.key);
            };
            contentElement.appendChild(optionElement);
            if (optionElements.length === 0) {
                optionElement.autofocus = true;
            }
            optionElements.push(optionElement);
        }
        menuModal.appendChild(contentElement);
        menuModal.showModal();
        // Ensures that the menu is visible even if triggered near the edge of the screen.
        contentElement.scrollIntoView({ block: 'nearest' });
    });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createMenuOverlay);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/types.mjs":
/*!*************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/types.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EditorEventType: () => (/* binding */ EditorEventType),
/* harmony export */   UndoEventType: () => (/* binding */ UndoEventType)
/* harmony export */ });
// Types related to the image editor
/** @see {@link EditorNotifier} */
var EditorEventType;
(function (EditorEventType) {
    EditorEventType[EditorEventType["ToolEnabled"] = 0] = "ToolEnabled";
    EditorEventType[EditorEventType["ToolDisabled"] = 1] = "ToolDisabled";
    EditorEventType[EditorEventType["ToolUpdated"] = 2] = "ToolUpdated";
    EditorEventType[EditorEventType["UndoRedoStackUpdated"] = 3] = "UndoRedoStackUpdated";
    EditorEventType[EditorEventType["CommandDone"] = 4] = "CommandDone";
    EditorEventType[EditorEventType["CommandUndone"] = 5] = "CommandUndone";
    EditorEventType[EditorEventType["ObjectAdded"] = 6] = "ObjectAdded";
    EditorEventType[EditorEventType["ViewportChanged"] = 7] = "ViewportChanged";
    EditorEventType[EditorEventType["DisplayResized"] = 8] = "DisplayResized";
    EditorEventType[EditorEventType["SelectionUpdated"] = 9] = "SelectionUpdated";
    EditorEventType[EditorEventType["ReadOnlyModeToggled"] = 10] = "ReadOnlyModeToggled";
    /** @internal */
    EditorEventType[EditorEventType["ColorPickerToggled"] = 11] = "ColorPickerToggled";
    /** @internal */
    EditorEventType[EditorEventType["ColorPickerColorSelected"] = 12] = "ColorPickerColorSelected";
    /** @deprecated @internal */
    EditorEventType[EditorEventType["ToolbarDropdownShown"] = 13] = "ToolbarDropdownShown";
})(EditorEventType || (EditorEventType = {}));
// Types of `EditorUndoStackUpdated` events.
var UndoEventType;
(function (UndoEventType) {
    UndoEventType[UndoEventType["CommandDone"] = 0] = "CommandDone";
    UndoEventType[UndoEventType["CommandUndone"] = 1] = "CommandUndone";
    UndoEventType[UndoEventType["CommandRedone"] = 2] = "CommandRedone";
})(UndoEventType || (UndoEventType = {}));


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/util/ClipboardHandler.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/util/ClipboardHandler.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../inputEvents.mjs */ "./node_modules/js-draw/dist/mjs/inputEvents.mjs");
/* harmony import */ var _fileToBase64Url_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fileToBase64Url.mjs */ "./node_modules/js-draw/dist/mjs/util/fileToBase64Url.mjs");
/* eslint-disable @typescript-eslint/no-redundant-type-constituents -- Used for clarity */
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _ClipboardHandler_preferClipboardEvents;


const isTextMimeType = (mime) => 
// +xml: Handles image/svg+xml
mime.endsWith('+xml') || mime.startsWith('text/');
/**
 * Handles conversion between the browser clipboard APIs and internal
 * js-draw clipboard events.
 */
class ClipboardHandler {
    constructor(editor, callbacks) {
        this.editor = editor;
        this.callbacks = callbacks;
        _ClipboardHandler_preferClipboardEvents.set(this, false);
    }
    /**
     * Pastes data from the clipboard into the editor associated with
     * this handler.
     *
     * @param event Optional -- a clipboard/drag event. If not provided,
     * 				`navigator.clipboard` will be used instead.
     * @returns true if the paste event was handled by the editor.
     */
    paste(event) {
        const onError = (error) => {
            if (this.callbacks?.onPasteError) {
                this.callbacks.onPasteError(error);
                return Promise.resolve(false);
            }
            else {
                throw error;
            }
        };
        try {
            // Use .catch rather than `async` to prevent future modifications from
            // moving clipboard handling logic out of user event handlers.
            // In the past, `await`s have caused permissions issues in some browsers.
            return this.pasteInternal(event).catch(onError);
        }
        catch (error) {
            return onError(error);
        }
    }
    async pasteInternal(event) {
        const editor = this.editor;
        const clipboardData = event?.dataTransfer ?? event?.clipboardData ?? null;
        const hasEvent = !!clipboardData;
        const sendPasteEvent = (mime, data) => {
            return (data &&
                editor.toolController.dispatchInputEvent({
                    kind: _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.PasteEvent,
                    mime,
                    data,
                }));
        };
        // Listed in order of precedence
        const supportedMIMEs = ['image/svg+xml', 'text/html', 'image/png', 'image/jpeg', 'text/plain'];
        let files = [];
        const textData = new Map();
        const editorSettings = editor.getCurrentSettings();
        if (hasEvent) {
            // NOTE: On some browsers, .getData and .files must be used before any async operations.
            files = [...clipboardData.files];
            for (const mime of supportedMIMEs) {
                const data = clipboardData.getData(mime);
                if (data) {
                    textData.set(mime, data);
                }
            }
        }
        else if (editorSettings.clipboardApi) {
            const clipboardData = await editorSettings.clipboardApi.read();
            for (const [type, data] of clipboardData.entries()) {
                if (typeof data === 'string') {
                    textData.set(type, data);
                }
                else {
                    let blob = data;
                    if (blob.type !== type) {
                        blob = new Blob([blob], { type });
                    }
                    files.push(blob);
                }
            }
        }
        else {
            const clipboardData = await navigator.clipboard.read();
            for (const item of clipboardData) {
                for (const mime of item.types) {
                    if (supportedMIMEs.includes(mime)) {
                        files.push(await item.getType(mime));
                    }
                }
            }
        }
        // Returns true if handled
        const handleMIME = async (mime) => {
            const isTextFormat = isTextMimeType(mime);
            if (isTextFormat) {
                const data = textData.get(mime);
                if (sendPasteEvent(mime, data)) {
                    event?.preventDefault();
                    return true;
                }
            }
            for (const file of files) {
                const fileType = file?.type?.toLowerCase();
                if (fileType !== mime) {
                    continue;
                }
                if (isTextFormat) {
                    const text = await file.text();
                    if (sendPasteEvent(mime, text)) {
                        event?.preventDefault();
                        return true;
                    }
                }
                else {
                    editor.showLoadingWarning(0);
                    const onprogress = (evt) => {
                        editor.showLoadingWarning(evt.loaded / evt.total);
                    };
                    try {
                        const data = await (0,_fileToBase64Url_mjs__WEBPACK_IMPORTED_MODULE_1__["default"])(file, { onprogress });
                        if (sendPasteEvent(mime, data)) {
                            event?.preventDefault();
                            editor.hideLoadingWarning();
                            return true;
                        }
                    }
                    catch (e) {
                        console.error('Error reading image:', e);
                    }
                    editor.hideLoadingWarning();
                }
            }
            return false;
        };
        for (const mime of supportedMIMEs) {
            if (await handleMIME(mime)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Copies text from the editor associated with this.
     *
     * Even if `event` is provided, the `navigator.clipboard` API may be used if image data
     * is to be copied. This is done because `ClipboardEvent`s seem to not support attaching
     * images.
     */
    copy(event) {
        const onError = (error) => {
            if (this.callbacks?.onCopyError) {
                this.callbacks.onCopyError(error);
                return Promise.resolve();
            }
            else {
                throw error;
            }
        };
        try {
            // As above, use `.catch` to be certain that certain copyInternal
            // is run now, before returning.
            return this.copyInternal(event).catch(onError);
        }
        catch (error) {
            return onError(error);
        }
    }
    copyInternal(event) {
        const mimeToData = new Map();
        if (this.editor.toolController.dispatchInputEvent({
            kind: _inputEvents_mjs__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.CopyEvent,
            setData: (mime, data) => {
                mimeToData.set(mime, data);
            },
        })) {
            event?.preventDefault();
        }
        const mimeTypes = [...mimeToData.keys()];
        const hasNonTextMimeTypes = mimeTypes.some((mime) => !isTextMimeType(mime));
        const copyToEvent = (reason) => {
            if (!event) {
                throw new Error(`Unable to copy -- no event provided${reason ? `. Original error: ${reason}` : ''}`);
            }
            for (const [key, value] of mimeToData.entries()) {
                if (typeof value === 'string') {
                    if ('clipboardData' in event) {
                        event.clipboardData?.setData(key, value);
                    }
                    else {
                        event.dataTransfer?.setData(key, value);
                    }
                }
            }
        };
        const copyToClipboardApi = () => {
            const mapInternalDataToBrowserData = (originalMimeToData) => {
                const mappedMimeToData = Object.create(null);
                for (const [key, data] of originalMimeToData.entries()) {
                    if (typeof data === 'string') {
                        const loadedData = new Blob([new TextEncoder().encode(data)], { type: key });
                        mappedMimeToData[key] = loadedData;
                    }
                    else {
                        mappedMimeToData[key] = data;
                    }
                    // Different platforms have varying support for different clipboard MIME types:
                    // - As of September 2024, image/svg+xml is unsupported on iOS
                    // - text/html is unsupported on Chrome/Android (and perhaps Chrome on other platforms).
                    //    - See https://issues.chromium.org/issues/40851502
                    if (key === 'image/svg+xml') {
                        mappedMimeToData['text/html'] ??= mappedMimeToData[key];
                    }
                }
                return mappedMimeToData;
            };
            const removeUnsupportedMime = (originalMimeToData) => {
                const filteredMimeToData = Object.create(null);
                for (const [key, data] of Object.entries(originalMimeToData)) {
                    // Browser support for ClipboardItem.supports is limited as of mid 2024. However, some browsers
                    // that do support `.supports` throw an exception when attempting to copy an unsupported MIME type
                    // (e.g. Firefox).
                    const unsupported = 'supports' in ClipboardItem &&
                        typeof ClipboardItem.supports === 'function' &&
                        !ClipboardItem.supports(key);
                    if (!unsupported) {
                        filteredMimeToData[key] = data;
                    }
                }
                return filteredMimeToData;
            };
            const browserMimeToData = removeUnsupportedMime(mapInternalDataToBrowserData(mimeToData));
            return navigator.clipboard.write([new ClipboardItem(browserMimeToData)]);
        };
        const supportsClipboardApi = typeof ClipboardItem !== 'undefined' && typeof navigator?.clipboard?.write !== 'undefined';
        const prefersClipboardApi = !__classPrivateFieldGet(this, _ClipboardHandler_preferClipboardEvents, "f") && supportsClipboardApi && (hasNonTextMimeTypes || !event);
        const editorSettings = this.editor.getCurrentSettings();
        if (prefersClipboardApi && editorSettings.clipboardApi) {
            const writeResult = editorSettings.clipboardApi.write(mimeToData);
            return writeResult ?? Promise.resolve();
        }
        else if (prefersClipboardApi) {
            let clipboardApiPromise = null;
            const fallBackToCopyEvent = (reason) => {
                console.warn('Unable to copy to the clipboard API. Future calls to .copy will use ClipboardEvents if possible.', reason);
                __classPrivateFieldSet(this, _ClipboardHandler_preferClipboardEvents, true, "f");
                copyToEvent(reason);
            };
            try {
                clipboardApiPromise = copyToClipboardApi();
            }
            catch (error) {
                fallBackToCopyEvent(error);
            }
            if (clipboardApiPromise) {
                return clipboardApiPromise.catch(fallBackToCopyEvent);
            }
        }
        else {
            copyToEvent();
        }
        return Promise.resolve();
    }
}
_ClipboardHandler_preferClipboardEvents = new WeakMap();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ClipboardHandler);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/util/ReactiveValue.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/util/ReactiveValue.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MutableReactiveValue: () => (/* binding */ MutableReactiveValue),
/* harmony export */   ReactiveValue: () => (/* binding */ ReactiveValue),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ReactiveValueImpl_value, _ReactiveValueImpl_onUpdateListeners;
const noOpUpdateListenerResult = {
    remove() { },
};
/**
 * An update listener that does nothing. Useful for reactive values
 * that will never change.
 */
const noOpSetUpdateListener = () => {
    return noOpUpdateListenerResult;
};
/**
 * A `ReactiveValue` is a value that
 * - updates periodically,
 * - can fire listeners when it updates,
 * - and can be chanined together with other `ReactiveValue`s.
 *
 * A `ReactiveValue` is a read-only view. See {@link MutableReactiveValue} for a
 * read-write view.
 *
 * Static methods in the `ReactiveValue` and `MutableReactiveValue` classes are
 * constructors (e.g. `fromImmutable`).
 *
 * Avoid extending this class from an external library, as that may not be stable.
 */
class ReactiveValue {
    /** Returns a promise that resolves when this value is next changed. */
    waitForNextUpdate() {
        return new Promise((resolve) => {
            const listener = this.onUpdate((value) => {
                listener.remove();
                resolve(value);
            });
        });
    }
    /** Creates a `ReactiveValue` with an initial value, `initialValue`. */
    static fromInitialValue(initialValue) {
        return new ReactiveValueImpl(initialValue);
    }
    /** Returns a `ReactiveValue` that is **known** will never change. */
    static fromImmutable(value) {
        return {
            get: () => value,
            onUpdate: noOpSetUpdateListener,
            onUpdateAndNow: (callback) => {
                callback(value);
                return noOpUpdateListenerResult;
            },
            // Never resolves -- immutable.
            waitForNextUpdate: () => new Promise(() => { }),
        };
    }
    /**
     * Creates a `ReactiveValue` whose values come from `callback`.
     *
     * `callback` is called whenever any of `sourceValues` are updated and initially to
     * set the initial value of the result.
     */
    static fromCallback(callback, sourceValues) {
        const result = new ReactiveValueImpl(callback());
        const resultRef =  false
            ? 0
            : { deref: () => result };
        for (const value of sourceValues) {
            const listener = value.onUpdate(() => {
                // Use resultRef to allow `result` to be garbage collected
                // despite this listener.
                const value = resultRef.deref();
                if (value) {
                    value.set(callback());
                }
                else {
                    listener.remove();
                }
            });
        }
        return result;
    }
    static map(source, map, inverseMap) {
        const result = ReactiveValue.fromInitialValue(map(source.get()));
        let expectedResultValue = result.get();
        source.onUpdate((newValue) => {
            expectedResultValue = map(newValue);
            result.set(expectedResultValue);
        });
        if (inverseMap) {
            result.onUpdate((newValue) => {
                // Prevent infinite loops if inverseMap is not a true
                // inverse.
                if (newValue !== expectedResultValue) {
                    source.set(inverseMap(newValue));
                }
            });
        }
        return result;
    }
    static union(values) {
        return ReactiveValue.fromCallback(() => {
            return values.map((value) => value.get());
        }, values);
    }
}
class MutableReactiveValue extends ReactiveValue {
    static fromProperty(sourceValue, propertyName) {
        const child = ReactiveValue.fromInitialValue(sourceValue.get()[propertyName]);
        const childRef = window.WeakRef
            ? new window.WeakRef(child)
            : { deref: () => child };
        // When the source is updated...
        const sourceListener = sourceValue.onUpdate((newValue) => {
            const childValue = childRef.deref();
            if (childValue) {
                childValue.set(newValue[propertyName]);
            }
            else {
                // TODO: What if `sourceValue` would be dropped before
                // the child value?
                sourceListener.remove();
            }
        });
        // When the child is updated, also apply the update to the
        // parent.
        child.onUpdate((newValue) => {
            sourceValue.set({
                ...sourceValue.get(),
                [propertyName]: newValue,
            });
        });
        return child;
    }
}
// @internal
class ReactiveValueImpl extends MutableReactiveValue {
    constructor(initialValue) {
        super();
        _ReactiveValueImpl_value.set(this, void 0);
        _ReactiveValueImpl_onUpdateListeners.set(this, void 0);
        __classPrivateFieldSet(this, _ReactiveValueImpl_value, initialValue, "f");
        __classPrivateFieldSet(this, _ReactiveValueImpl_onUpdateListeners, [], "f");
    }
    set(newValue) {
        if (__classPrivateFieldGet(this, _ReactiveValueImpl_value, "f") === newValue) {
            return;
        }
        __classPrivateFieldSet(this, _ReactiveValueImpl_value, newValue, "f");
        for (const listener of __classPrivateFieldGet(this, _ReactiveValueImpl_onUpdateListeners, "f")) {
            listener(newValue);
        }
    }
    get() {
        return __classPrivateFieldGet(this, _ReactiveValueImpl_value, "f");
    }
    onUpdate(listener) {
        // **Note**: If memory is a concern, listeners should avoid referencing this
        // reactive value directly. Doing so allows the value to be garbage collected when
        // no longer referenced.
        __classPrivateFieldGet(this, _ReactiveValueImpl_onUpdateListeners, "f").push(listener);
        return {
            remove: () => {
                __classPrivateFieldSet(this, _ReactiveValueImpl_onUpdateListeners, __classPrivateFieldGet(this, _ReactiveValueImpl_onUpdateListeners, "f").filter((otherListener) => {
                    return otherListener !== listener;
                }), "f");
            },
        };
    }
    onUpdateAndNow(callback) {
        callback(this.get());
        return this.onUpdate(callback);
    }
}
_ReactiveValueImpl_value = new WeakMap(), _ReactiveValueImpl_onUpdateListeners = new WeakMap();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ReactiveValue);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/util/addLongPressOrHoverCssClasses.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/util/addLongPressOrHoverCssClasses.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _listenForLongPressOrHover_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./listenForLongPressOrHover.mjs */ "./node_modules/js-draw/dist/mjs/util/listenForLongPressOrHover.mjs");

/**
 * When a pointer is inside `element`, after a delay, adds the `has-long-press-or-hover`
 * CSS class to `element`.
 *
 * When no pointers are inside `element`, adds the CSS class `no-long-press-or-hover`.
 */
const addLongPressOrHoverCssClasses = (element, options) => {
    const hasLongPressClass = 'has-long-press-or-hover';
    const noLongPressClass = 'no-long-press-or-hover';
    element.classList.add('no-long-press-or-hover');
    const { removeListeners } = (0,_listenForLongPressOrHover_mjs__WEBPACK_IMPORTED_MODULE_0__["default"])(element, {
        onStart() {
            element.classList.remove(noLongPressClass);
            element.classList.add(hasLongPressClass);
        },
        onEnd() {
            element.classList.add(noLongPressClass);
            element.classList.remove(hasLongPressClass);
        },
        longPressTimeout: options?.timeout,
    });
    return {
        removeEventListeners: () => {
            element.classList.remove(noLongPressClass);
            removeListeners();
        },
    };
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (addLongPressOrHoverCssClasses);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/util/adjustEditorThemeForContrast.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/util/adjustEditorThemeForContrast.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");

/**
 * Adjusts the current editor theme such that colors have appropriate contrast.
 *
 * As this method overrides CSS variables using the `.style` property,
 * **assumes** all original theme variables are set using CSS and not the `.style` property.
 *
 * If the editor changes theme in response to the system theme, this method should be
 * called whenever the system theme changes (e.g. by using [the `matchMedia`](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia)
 * method).
 *
 * @example
 * ```ts,runnable
 * import { Editor, adjustEditorThemeForContrast } from 'js-draw';
 *
 * const editor = new Editor(document.body);
 * editor.addToolbar();
 *
 * const css = `
 *   :root .imageEditorContainer {
 *     --background-color-1: #ffff77;
 *     --foreground-color-1: #fff;
 *     --background-color-2: #ffff99;
 *     --foreground-color-2: #ffff88;
 *     --background-color-3: #ddffff;
 *     --foreground-color-3: #eeffff;
 *     --selection-background-color: #9f7;
 *     --selection-foreground-color: #98f;
 *   }
 *
 *   @media screen and (prefers-color-scheme: dark) {
 *     :root .imageEditorContainer {
 *       --background-color-1: black;
 *     }
 *   }
 * `;
 * editor.addStyleSheet(css);
 *
 * adjustEditorThemeForContrast(editor);
 *
 * // Because adjustEditorThemeForContrast overrides the current theme, it should be called again
 * // to allow the editor to switch between light/dark themes.
 * window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
 *   adjustEditorThemeForContrast(editor);
 * });
 *
 * window.matchMedia('print').addEventListener('change', () => {
 *   adjustEditorThemeForContrast(editor);
 * });
 * ```
 */
const adjustEditorThemeForContrast = (editor, options) => {
    const editorElem = editor.getRootElement();
    // Each set of entries in colorPairs should resolve to colors with sufficient
    // contrast.
    const colorPairs = [
        ['--background-color-1', '--foreground-color-1', true, true],
        ['--background-color-2', '--foreground-color-2', true, true],
        ['--background-color-3', '--foreground-color-3', true, true],
        ['--background-color-2', '--primary-action-foreground-color', false, true],
        ['--selection-background-color', '--selection-foreground-color', false, true],
    ];
    if (!options?.dontClearOverrides) {
        // Clear any overrides
        for (const [backgroundVar, foregroundVar] of colorPairs) {
            editorElem.style.setProperty(backgroundVar, null);
            editorElem.style.setProperty(foregroundVar, null);
        }
    }
    const styles = getComputedStyle(editorElem);
    const updatedColors = Object.create(null);
    const adjustVariablesForContrast = (var1, var2, minContrast, 
    // true if the variable can be updated
    updateVar1, updateVar2) => {
        // Fetch from updatedColors if available -- styles isn't updated dynamically.
        let color1 = updatedColors[var1]
            ? updatedColors[var1]
            : _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.fromString(styles.getPropertyValue(var1));
        let color2 = updatedColors[var2]
            ? updatedColors[var2]
            : _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.fromString(styles.getPropertyValue(var2));
        // Ensure that color1 has the lesser luminance
        if (color1.relativeLuminance() < color2.relativeLuminance()) {
            const tmp = color1;
            color1 = color2;
            color2 = tmp;
            const oldVar2 = var2;
            var2 = var1;
            var1 = oldVar2;
            const oldUpdateVar1 = updateVar1;
            updateVar1 = updateVar2;
            updateVar2 = oldUpdateVar1;
        }
        let colorsUpdated = false;
        let currentContrast = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.contrastRatio(color1, color2);
        let iterations = 0;
        // Step the brightness of color1 and color2 in different directions while necessary
        while (currentContrast < minContrast && iterations < 8) {
            const step = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Vec3.of(0.1, 0.1, 0.1);
            if (updateVar1) {
                if (color2.eq(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.white) && !updateVar2) {
                    color2 = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.black;
                }
                color1 = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.fromRGBVector(color1.rgb.plus(step));
            }
            if (updateVar2) {
                if (color2.eq(_js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.black) && !updateVar1) {
                    color2 = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.white;
                }
                color2 = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.fromRGBVector(color2.rgb.minus(step));
            }
            currentContrast = _js_draw_math__WEBPACK_IMPORTED_MODULE_0__.Color4.contrastRatio(color1, color2);
            colorsUpdated = true;
            iterations++;
        }
        // Update the CSS variables if necessary
        if (colorsUpdated) {
            editorElem.style.setProperty(var1, color1.toHexString());
            editorElem.style.setProperty(var2, color2.toHexString());
            updatedColors[var1] = color1;
            updatedColors[var2] = color2;
        }
    };
    // Also adjust the selection background
    adjustVariablesForContrast('--selection-background-color', '--background-color-2', 1.29, true, false);
    for (const [backgroundVar, foregroundVar, updateBackground, updateForeground] of colorPairs) {
        const minContrast = 4.5;
        adjustVariablesForContrast(backgroundVar, foregroundVar, minContrast, updateBackground, updateForeground);
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (adjustEditorThemeForContrast);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/util/assertions.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/util/assertions.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assertIsArray: () => (/* binding */ assertIsArray),
/* harmony export */   assertIsBoolean: () => (/* binding */ assertIsBoolean),
/* harmony export */   assertIsNumber: () => (/* binding */ assertIsNumber),
/* harmony export */   assertIsNumberArray: () => (/* binding */ assertIsNumberArray),
/* harmony export */   assertIsObject: () => (/* binding */ assertIsObject),
/* harmony export */   assertTruthy: () => (/* binding */ assertTruthy),
/* harmony export */   assertUnreachable: () => (/* binding */ assertUnreachable)
/* harmony export */ });
// Note: Arrow functions cannot be used for type assertions. See
// https://github.com/microsoft/TypeScript/issues/34523
/**
 * Compile-time assertion that a branch of code is unreachable.
 * @internal
 */
function assertUnreachable(key) {
    // See https://stackoverflow.com/a/39419171/17055750
    throw new Error(`Should be unreachable. Key: ${key}.`);
}
/**
 * Throws an exception if the typeof given value is not a number or `value` is NaN.
 *
 * @example
 * ```ts
 * const foo: unknown = 3;
 * assertIsNumber(foo);
 *
 * assertIsNumber('hello, world'); // throws an Error.
 * ```
 */
function assertIsNumber(value, allowNaN = false) {
    if (typeof value !== 'number' || (!allowNaN && isNaN(value))) {
        throw new Error('Given value is not a number');
    }
}
function assertIsArray(values) {
    if (!Array.isArray(values)) {
        throw new Error('Asserting isArray: Given entity is not an array');
    }
}
/**
 * Throws if any of `values` is not of type number.
 */
function assertIsNumberArray(values, allowNaN = false) {
    assertIsArray(values);
    assertIsNumber(values.length);
    for (const value of values) {
        assertIsNumber(value, allowNaN);
    }
}
/**
 * Throws an exception if `typeof value` is not a boolean.
 */
function assertIsBoolean(value) {
    if (typeof value !== 'boolean') {
        throw new Error('Given value is not a boolean');
    }
}
function assertTruthy(value) {
    if (!value) {
        throw new Error(`${JSON.stringify(value)} is not truthy`);
    }
}
function assertIsObject(value) {
    if (typeof value !== 'object') {
        throw new Error(`AssertIsObject: Given entity is not an object (type = ${typeof value})`);
    }
}


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/util/bytesToSizeString.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/util/bytesToSizeString.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Returns a size in bytes, KiB, or MiB with units suffix.
 */
const bytesToSizeString = (sizeBytes) => {
    const sizeInKiB = sizeBytes / 1024;
    const sizeInMiB = sizeInKiB / 1024;
    const sizeInGiB = sizeInMiB / 1024;
    let units = 'B';
    let size = sizeBytes;
    if (sizeInGiB >= 1) {
        size = sizeInGiB;
        units = 'GiB';
    }
    else if (sizeInMiB >= 1) {
        size = sizeInMiB;
        units = 'MiB';
    }
    else if (sizeInKiB >= 1) {
        size = sizeInKiB;
        units = 'KiB';
    }
    return { size, units };
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (bytesToSizeString);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/util/cloneElementWithStyles.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/util/cloneElementWithStyles.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Makes a clone of `element` and recursively applies styles from the original to the
 * clone's children.
 */
const cloneElementWithStyles = (element) => {
    const restyle = (originalElement, clonedElement) => {
        const originalComputedStyle = getComputedStyle(originalElement);
        // jsdom doesn't support iterators in CSSStyleDeclarations. Iterate with
        // an index.
        for (let index = 0; index < originalComputedStyle.length; index++) {
            const propertyName = originalComputedStyle.item(index);
            const propertyValue = originalComputedStyle.getPropertyValue(propertyName);
            clonedElement.style?.setProperty(propertyName, propertyValue);
        }
        for (let i = 0; i < originalElement.children.length; i++) {
            const originalChild = originalElement.children.item(i);
            const clonedChild = clonedElement.children.item(i);
            if (originalChild && clonedChild) {
                restyle(originalChild, clonedChild);
            }
            else {
                console.warn('CloneElement: Missing child');
            }
        }
    };
    const elementClone = element.cloneNode(true);
    restyle(element, elementClone);
    return elementClone;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cloneElementWithStyles);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/util/createElement.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/util/createElement.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ElementNamespace: () => (/* binding */ ElementNamespace),
/* harmony export */   createSvgElement: () => (/* binding */ createSvgElement),
/* harmony export */   createSvgElements: () => (/* binding */ createSvgElements),
/* harmony export */   createSvgPaths: () => (/* binding */ createSvgPaths),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var ElementNamespace;
(function (ElementNamespace) {
    ElementNamespace["Html"] = "html";
    ElementNamespace["Svg"] = "svg";
})(ElementNamespace || (ElementNamespace = {}));
/**
 * Shorthand for creating an element with `document.createElement`, then assigning properties.
 *
 * Non-HTML elements (e.g. `svg` elements) should use the `elementType` parameter to select
 * the element namespace.
 */
const createElement = (tag, props, elementType = ElementNamespace.Html) => {
    let elem;
    if (elementType === ElementNamespace.Html) {
        elem = document.createElement(tag);
    }
    else if (elementType === ElementNamespace.Svg) {
        elem = document.createElementNS('http://www.w3.org/2000/svg', tag);
    }
    else {
        throw new Error(`Unknown element type ${elementType}`);
    }
    for (const [key, value] of Object.entries(props)) {
        if (key === 'children')
            continue;
        if (typeof value !== 'string' && typeof value !== 'number') {
            throw new Error(`Unsupported value type ${typeof value}`);
        }
        elem.setAttribute(key, value.toString());
    }
    if (props.children) {
        for (const item of props.children) {
            elem.appendChild(item);
        }
    }
    return elem;
};
const createSvgElement = (tag, props) => {
    return createElement(tag, props, ElementNamespace.Svg);
};
const createSvgElements = (tag, elements) => {
    return elements.map((props) => createSvgElement(tag, props));
};
const createSvgPaths = (...paths) => {
    return createSvgElements('path', paths);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createElement);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/util/fileToBase64Url.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/util/fileToBase64Url.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Converts `file` to a base64 data URL.
 */
const fileToBase64Url = async (file, options = {}) => {
    try {
        const reader = new FileReader();
        return await new Promise((resolve, reject) => {
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.onabort = reject;
            reader.onprogress = (evt) => {
                options.onprogress?.(evt);
            };
            reader.readAsDataURL(file);
        });
    }
    catch (error) {
        // Files can fail to load with a FileReader in some cases. For example,
        // in iOS Lockdown mode, where FileReader is unavailable.
        (options.onWarning ?? console.warn)('Unable to convert file to base64 with a FileReader: ', error);
        const arrayBuffer = await file.arrayBuffer();
        const array = new Uint8Array(arrayBuffer);
        // step: must be divisible by 3 (3 bytes = 4 base64 numerals)
        //       If too large, this will fail (String.fromCharCode accepts a limited
        //       number of arguments).
        const step = 30;
        const result = [];
        for (let i = 0; i < array.length; i += step) {
            // btoa accepts only characters with byte value 0-255 (which can be created
            // with String.fromCharCode)
            const stringByteArray = String.fromCharCode(...array.slice(i, i + step));
            result.push(btoa(stringByteArray));
        }
        return `data:${file.type ?? 'image/*'};base64,${result.join('')}`;
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (fileToBase64Url);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/util/guessKeyCodeFromKey.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/util/guessKeyCodeFromKey.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// See https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_code_values for
// more
const keyToKeyCode = {
    Control: 'ControlLeft',
    '=': 'Equal',
    '-': 'Minus',
    ';': 'Semicolon',
    ' ': 'Space',
};
/**
 * Attempts to guess the .code value corresponding to the given key.
 *
 * Use this to facilitate testing.
 *
 * If no matching keycode is found, returns `key`.
 */
const guessKeyCodeFromKey = (key) => {
    const upperKey = key.toUpperCase();
    if ('A' <= upperKey && upperKey <= 'Z') {
        return `Key${upperKey}`;
    }
    if ('0' <= key && key <= '9') {
        return `Digit${key}`;
    }
    if (key in keyToKeyCode) {
        return keyToKeyCode[key];
    }
    return key;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (guessKeyCodeFromKey);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/util/lib.mjs":
/*!****************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/util/lib.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MutableReactiveValue: () => (/* reexport safe */ _ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_1__.MutableReactiveValue),
/* harmony export */   ReactiveValue: () => (/* reexport safe */ _ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_1__.ReactiveValue),
/* harmony export */   adjustEditorThemeForContrast: () => (/* reexport safe */ _adjustEditorThemeForContrast_mjs__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _adjustEditorThemeForContrast_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adjustEditorThemeForContrast.mjs */ "./node_modules/js-draw/dist/mjs/util/adjustEditorThemeForContrast.mjs");
/* harmony import */ var _ReactiveValue_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ReactiveValue.mjs */ "./node_modules/js-draw/dist/mjs/util/ReactiveValue.mjs");




/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/util/listPrefixMatch.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/util/listPrefixMatch.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Returns true iff all elements in the shorter list equal (===) the elements
 * in the longer list.
 */
const listPrefixMatch = (a, b) => {
    const shorter = a.length < b.length ? a : b;
    const longer = shorter === a ? b : a;
    for (let i = 0; i < shorter.length; i++) {
        if (shorter[i] !== longer[i]) {
            return false;
        }
    }
    return true;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (listPrefixMatch);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/util/listenForKeyboardEventsFrom.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/util/listenForKeyboardEventsFrom.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Calls `callbacks` when different keys are known to be pressed.
 *
 * `filter` can be used to ignore events.
 *
 * This includes keys that didn't trigger a keydown or keyup event, but did cause
 * shiftKey/altKey/metaKey/etc. properties to change on other events (e.g. mousemove
 * events). Artifical events are created for these changes and sent to `callbacks`.
 */
const listenForKeyboardEventsFrom = (elem, callbacks) => {
    // Track which keys are down so we can release them when the element
    // loses focus. This is particularly important for keys like Control
    // that can trigger shortcuts that cause the editor to lose focus before
    // the keyup event is triggered.
    let keysDown = [];
    // Return whether two objects that are similar to keyboard events represent the
    // same key.
    const keyEventsMatch = (a, b) => {
        return a.key === b.key && a.code === b.code;
    };
    const isKeyDown = (keyEvent) => {
        return keysDown.some((other) => keyEventsMatch(other, keyEvent));
    };
    const keyEventToRecord = (event) => {
        return {
            code: event.code,
            key: event.key,
            ctrlKey: event.ctrlKey,
            altKey: event.altKey,
            shiftKey: event.shiftKey,
            metaKey: event.metaKey,
        };
    };
    const handleKeyEvent = (htmlEvent) => {
        if (htmlEvent.type === 'keydown') {
            // Add event to the list of keys that are down (so long as it
            // isn't a duplicate).
            if (!isKeyDown(htmlEvent)) {
                // Destructructring, then pushing seems to cause
                // data loss. Copy properties individually:
                keysDown.push(keyEventToRecord(htmlEvent));
            }
            if (!callbacks.filter(htmlEvent)) {
                return;
            }
            callbacks.handleKeyDown(htmlEvent);
        }
        else {
            // keyup
            console.assert(htmlEvent.type === 'keyup');
            // Remove the key from keysDown -- it's no longer down.
            keysDown = keysDown.filter((event) => {
                const matches = keyEventsMatch(event, htmlEvent);
                return !matches;
            });
            if (!callbacks.filter(htmlEvent)) {
                return;
            }
            callbacks.handleKeyUp(htmlEvent);
        }
    };
    elem.addEventListener('keydown', (htmlEvent) => {
        handleKeyEvent(htmlEvent);
    });
    elem.addEventListener('keyup', (htmlEvent) => {
        handleKeyEvent(htmlEvent);
    });
    elem.addEventListener('focusout', (focusEvent) => {
        let stillHasFocus = false;
        if (focusEvent.relatedTarget) {
            const relatedTarget = focusEvent.relatedTarget;
            stillHasFocus =
                elem.contains(relatedTarget) || callbacks.getHandlesKeyEventsFrom(relatedTarget);
        }
        if (!stillHasFocus) {
            for (const event of keysDown) {
                callbacks.handleKeyUp(new KeyboardEvent('keyup', {
                    ...event,
                }));
            }
            keysDown = [];
        }
    });
    const fireArtificalEventsBasedOn = (htmlEvent) => {
        let wasShiftDown = false;
        let wasCtrlDown = false;
        let wasAltDown = false;
        let wasMetaDown = false;
        for (const otherEvent of keysDown) {
            const code = otherEvent.code;
            wasShiftDown ||= !!code.match(/^Shift(Left|Right)$/);
            wasCtrlDown ||= !!code.match(/^Control(Left|Right)$/);
            wasAltDown ||= !!code.match(/^Alt(Left|Right)$/);
            wasMetaDown ||= !!code.match(/^Meta(Left|Right)$/);
        }
        const eventName = (isDown) => {
            if (isDown) {
                return 'keydown';
            }
            else {
                return 'keyup';
            }
        };
        const eventInitDefaults = {
            shiftKey: htmlEvent.shiftKey,
            altKey: htmlEvent.altKey,
            metaKey: htmlEvent.metaKey,
            ctrlKey: htmlEvent.ctrlKey,
        };
        if (htmlEvent.shiftKey !== wasShiftDown) {
            handleKeyEvent(new KeyboardEvent(eventName(htmlEvent.shiftKey), {
                ...eventInitDefaults,
                key: 'Shift',
                code: 'ShiftLeft',
            }));
        }
        if (htmlEvent.altKey !== wasAltDown) {
            handleKeyEvent(new KeyboardEvent(eventName(htmlEvent.altKey), {
                ...eventInitDefaults,
                key: 'Alt',
                code: 'AltLeft',
            }));
        }
        if (htmlEvent.ctrlKey !== wasCtrlDown) {
            handleKeyEvent(new KeyboardEvent(eventName(htmlEvent.ctrlKey), {
                ...eventInitDefaults,
                key: 'Control',
                code: 'ControlLeft',
            }));
        }
        if (htmlEvent.metaKey !== wasMetaDown) {
            handleKeyEvent(new KeyboardEvent(eventName(htmlEvent.metaKey), {
                ...eventInitDefaults,
                key: 'Meta',
                code: 'MetaLeft',
            }));
        }
    };
    elem.addEventListener('mousedown', (htmlEvent) => {
        fireArtificalEventsBasedOn(htmlEvent);
    });
    elem.addEventListener('mousemove', (htmlEvent) => {
        fireArtificalEventsBasedOn(htmlEvent);
    });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (listenForKeyboardEventsFrom);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/util/listenForLongPressOrHover.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/util/listenForLongPressOrHover.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Calls `options.onStart` at the start of a long press or hover.
 * Calls `options.onEnd` when no pointers are within the container.
 */
const listenForLongPressOrHover = (target, options) => {
    const pointersInside = new Map();
    let timeoutId = null;
    let isLongPressInProgress = false;
    const updateTimeout = () => {
        if (pointersInside.size === 0) {
            if (isLongPressInProgress) {
                isLongPressInProgress = false;
                options.onEnd();
            }
            else if (timeoutId !== null) {
                clearTimeout(timeoutId);
                timeoutId = null;
            }
        }
        else {
            const nowTime = Date.now();
            let timeSinceFirstPointer = 0; // ms
            for (const record of pointersInside.values()) {
                const timeSince = nowTime - record.timeEnter;
                timeSinceFirstPointer = Math.max(timeSince, timeSinceFirstPointer);
            }
            const longPressTimeout = options.longPressTimeout ?? 700; // ms
            if (timeoutId !== null) {
                clearTimeout(timeoutId);
                timeoutId = null;
            }
            const timeLeft = longPressTimeout - timeSinceFirstPointer;
            if (timeLeft <= 0) {
                options.onStart();
                isLongPressInProgress = true;
            }
            else {
                timeoutId = setTimeout(() => {
                    timeoutId = null;
                    updateTimeout();
                }, timeLeft);
            }
        }
    };
    // Detects long press
    const pointerEventListener = (event) => {
        const eventRecord = {
            timeEnter: Date.now(),
        };
        if (event.type === 'pointerenter') {
            pointersInside.set(event.pointerId, eventRecord);
        }
        else if (event.type === 'pointerleave' || event.type === 'pointercancel') {
            // In some cases (for example, a click with a stylus on Android/Chrome), moving the pen
            // over the target, clicking, then moving the pen out of the target produces input
            // similar to this:
            // - pointerenter (pointerId: 4)
            // - pointerleave (pointerId: 4)
            // - pointerenter (pointerId: 6)
            // - pointerenter (pointerId: 1)
            // - pointerleave (pointerId: 6)
            // Observe that no pointerleave event was fired for the pointer with ID 1.
            pointersInside.clear();
        }
        updateTimeout();
    };
    target.addEventListener('pointerenter', pointerEventListener);
    target.addEventListener('pointerleave', pointerEventListener);
    target.addEventListener('pointercancel', pointerEventListener);
    return {
        removeListeners: () => {
            target.removeEventListener('pointerenter', pointerEventListener);
            target.removeEventListener('pointerleave', pointerEventListener);
            target.removeEventListener('pointercancel', pointerEventListener);
        },
    };
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (listenForLongPressOrHover);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/util/mitLicenseAttribution.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/util/mitLicenseAttribution.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const mitLicenseAttribution = (copyright) => {
    const removeSingleLineBreaks = (text) => text.replace(/([^\n])[\n]([^\n])/g, '$1 $2');
    return removeSingleLineBreaks(`
MIT License

Copyright (c) ${copyright}

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.`);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mitLicenseAttribution);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/util/stopPropagationOfScrollingWheelEvents.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/util/stopPropagationOfScrollingWheelEvents.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const stopPropagationOfScrollingWheelEvents = (scrollingContainer) => {
    const scrollsAxis = (delta, clientSize, scrollOffset, scrollSize) => {
        const hasScroll = clientSize !== scrollSize && delta !== 0;
        const eventScrollsPastStart = scrollOffset + delta <= 0;
        const scrollEnd = scrollOffset + clientSize;
        const eventScrollsPastEnd = scrollEnd + delta > scrollSize;
        return hasScroll && !eventScrollsPastStart && !eventScrollsPastEnd;
    };
    scrollingContainer.onwheel = (event) => {
        const scrollsX = scrollsAxis(event.deltaX, scrollingContainer.clientWidth, scrollingContainer.scrollLeft, scrollingContainer.scrollWidth);
        const scrollsY = scrollsAxis(event.deltaY, scrollingContainer.clientHeight, scrollingContainer.scrollTop, scrollingContainer.scrollHeight);
        // Stop the editor from receiving the event if it will scroll the pen type selector
        // instead.
        if (scrollsX || scrollsY) {
            event.stopPropagation();
        }
    };
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stopPropagationOfScrollingWheelEvents);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/util/untilNextAnimationFrame.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/util/untilNextAnimationFrame.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** @internal */
const untilNextAnimationFrame = () => {
    return new Promise((resolve) => {
        requestAnimationFrame(() => resolve());
    });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (untilNextAnimationFrame);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/util/waitForAll.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/util/waitForAll.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Resolves when all given promises have resolved. If no promises are given,
 * does not return a Promise.
 *
 * If all elements of `results` are known to be `Promise`s, use `Promise.all`.
 */
const waitForAll = (results) => {
    // If any are Promises...
    if (results.some((command) => command && command['then'])) {
        // Wait for all commands to finish.
        return (Promise.all(results)
            // Ensure we return a Promise<void> and not a Promise<void[]>
            .then(() => { }));
    }
    return;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (waitForAll);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/util/waitForImageLoaded.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/util/waitForImageLoaded.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const waitForImageLoad = async (image) => {
    if (!image.complete) {
        await new Promise((resolve, reject) => {
            image.onload = (event) => resolve(event);
            // TODO(v2): Return a `new Error(event.message)`
            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors -- Forwarding an error-like object.
            image.onerror = (event) => reject(event);
            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors -- Forwarding an error-like object.
            image.onabort = (event) => reject(event);
        });
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (waitForImageLoad);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/util/waitForTimeout.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/util/waitForTimeout.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Returns a promise that resolves after `timeout` milliseconds. */
const waitForTimeout = (timeout) => {
    return new Promise((resolve) => {
        setTimeout(() => resolve(), timeout);
    });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (waitForTimeout);


/***/ }),

/***/ "./node_modules/js-draw/dist/mjs/version.mjs":
/*!***************************************************!*\
  !*** ./node_modules/js-draw/dist/mjs/version.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Contains the current version of the library -- used
 * internaly (e.g. for documentation).
 * @internal
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    number: '1.26.0',
});


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!*****************************!*\
  !*** ./src/firefox-draw.ts ***!
  \*****************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var js_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! js-draw */ "./node_modules/js-draw/dist/mjs/lib.mjs");
/* harmony import */ var js_draw_bundledStyles__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! js-draw/bundledStyles */ "./node_modules/js-draw/dist/bundledStyles.js");
/* harmony import */ var js_draw_bundledStyles__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(js_draw_bundledStyles__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _js_draw_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @js-draw/math */ "./node_modules/@js-draw/math/dist/mjs/lib.mjs");
/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./db */ "./src/db.ts");
/* harmony import */ var _update__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./update */ "./src/update.ts");
/* harmony import */ var _toolbar_toolbar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./toolbar/toolbar */ "./src/toolbar/toolbar.ts");






const initializeEditor = () => {
    const editor = new js_draw__WEBPACK_IMPORTED_MODULE_0__.Editor(document.body, {
        wheelEventsEnabled: false,
        maxZoom: 1,
        minZoom: 1,
    });
    const toolbar = (0,_toolbar_toolbar__WEBPACK_IMPORTED_MODULE_5__.initToolbar)(editor);
    editor.dispatch(editor.setBackgroundStyle({
        color: _js_draw_math__WEBPACK_IMPORTED_MODULE_2__.Color4.transparent,
        autoresize: true,
        type: js_draw__WEBPACK_IMPORTED_MODULE_0__.BackgroundComponentBackgroundType.Grid,
    }));
    editor.notifier.on(js_draw__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.CommandDone, (event) => {
        (0,_db__WEBPACK_IMPORTED_MODULE_3__.queueSave)(editor);
    });
    editor.notifier.on(js_draw__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.CommandUndone, (event) => {
        (0,_db__WEBPACK_IMPORTED_MODULE_3__.queueSave)(editor);
    });
    (0,_db__WEBPACK_IMPORTED_MODULE_3__.getSVG)(document.location.href).then((svg) => {
        if (svg && typeof svg === "string") {
            editor.loadFromSVG(svg);
        }
    });
    return { editor, toolbar };
};
let editor;
let toolbar;
document.addEventListener("scroll", () => {
    (0,_update__WEBPACK_IMPORTED_MODULE_4__.update)(editor, window);
});
browser.runtime.onMessage.addListener((message) => {
    if (message.command === "show-toolbar") {
        if (!toolbar || !editor) {
            ({ editor, toolbar } = initializeEditor());
        }
        document.querySelector(".js-draw")?.classList.remove("display-none");
    }
});

})();

/******/ })()
;
//# sourceMappingURL=firefox-draw.bundle.js.map